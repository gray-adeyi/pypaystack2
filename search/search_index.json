{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"A developer friendly wrapper for Paystack API Documentation: https://github.com/gray-adeyi/pypaystack2 Source Code: https://gray-adeyi.github.io/pypaystack2/ PyPaystack2 is a python wrapper over the Paystack API . It aims at being developer friendly and easy to use. The key features are: Type hints : All methods provided by PyPaystack2 are type annotated, so you can easily infer. This improves the development experience. Async support : PyPaystack2 allow you to also make calls to Paystack API using async/await which is super great, for example, if your project is in FastAPI where every chance of a performance improvement adds up. Requirements Python 3.9+ PyPaystack2 now uses httpx under the hood to make API calls to Paystack. Compared to previous version 1.1.3 and down which use requests . This switch has made it possible to support async/await based wrappers. Installation $ pip install pypaystack2 Example Python 3.9.15 ( main , Dec 12 2022 , 21 : 54 : 43 ) [ GCC 12.2.0 ] on linux Type \"help\" , \"copyright\" , \"credits\" or \"license\" for more information . >>> from pypaystack2 import Paystack >>> paystack = Paystack () # assumes the environmental variable `PAYSTACK_AUTHORIZATION_KEY=paystack integration secret key` is set. if not, you can alternatively pass it into the `Paystack` instantiation like so Paystack(auth_key='paystack integration secret key') >>> response = paystack . customers . get_customer ( email_or_code = \"CUS_8x2byd6x3dk5hp0\" ) >>> print ( response ) Response ( status_code = 200 , status = True , message = 'Customer retrieved' , data = { 'transactions' : [], 'subscriptions' : [], 'authorizations' : [{ 'authorization_code' : 'AUTH_ohnpjcd7z9' , 'bin' : '408408' , 'last4' : '4081' , 'exp_month' : '12' , 'exp_year' : '2030' , 'channel' : 'card' , 'card_type' : 'visa ' , 'bank' : 'TEST BANK' , 'country_code' : 'NG' , 'brand' : 'visa' , 'reusable' : True , 'signature' : 'SIG_JOdryeujwrsZryg0Lkrg' , 'account_name' : None }], 'first_name' : 'john' , 'last_name' : 'doe' , 'email' : 'johndoe@example.com' , 'phone' : None , 'metadata' : None , 'domain' : 'test' , 'customer_code' : 'CUS_8x2byd6x3dk5hp0' , 'risk_action' : 'default' , 'id' : 87934333 , 'integration' : 630606 , 'createdAt' : '2022-07-25T03:46:01.000Z' , 'updatedAt' : '2022-07-25T03:46:01.000Z' , 'created_at' : '2022-07-25T03:46:01.000Z' , 'updated_at' : '2022-07-25T03:46:01.000Z' , 'total_transactions' : 0 , 'total_transaction_value' : [], 'dedicated_account' : None , 'identified' : False , 'identifications' : None }) >>> print ( response . status_code ) 200 >>> print ( response . message ) Customer retrieved >>> All you need to interact with Paystack's API in your python project is the Paystack class it has attributes bounded to it that provides methods you can call in your code to make API calls to Paystack. Every method call on the wrapper has the same return type, which is a Response . A namedtuple containing the data from making the actual call to Paystack servers Async Now! PyPaystack2 now supports asynchronous wrappers to Paystack's API. AsyncPaystack is an asynchronous mirror equivalent of the Paystack wrapper. i.e. AsyncPaystack provides the same functionality as the Paystack wrapper but is more useful in the context of async\\await code. All the bindings on the AsyncPaystack are the same as on the Paystack wrapper except that the methods on the AsyncPaystack are awaitable asyncio REPL 3.9.15 ( main , Dec 12 2022 , 21 : 54 : 43 ) [ GCC 12.2.0 ] on linux Use \"await\" directly instead of \"asyncio.run()\" . Type \"help\" , \"copyright\" , \"credits\" or \"license\" for more information . >>> import asyncio >>> from pypaystack2 import AsyncPaystack >>> paystack = AsyncPaystack () # assumes the environmental variable `PAYSTACK_AUTHORIZATION_KEY=paystack integration secret key` is set. if not, you can alternatively pass it into the `AsyncPaystack` instantiation like so AsyncPaystack(auth_key='paystack integration secret key') >>> response = await paystack . customers . get_customer ( email_or_code = \"CUS_8x2byd6x3dk5hp0\" ) >>> print ( response ) Response ( status_code = 200 , status = True , message = 'Customer retrieved' , data = { 'transactions' : [], 'subscriptions' : [], 'authorizations' : [{ 'authorization_code' : 'AUTH_ohnpjcd7z9' , 'bin' : '408408' , 'last4' : '4081' , 'exp_month' : '12' , 'exp_year' : '2030' , 'channel' : 'card' , 'card_type' : 'visa ' , 'bank' : 'TEST BANK' , 'country_code' : 'NG' , 'brand' : 'visa' , 'reusable' : True , 'signature' : 'SIG_JOdryeujwrsZryg0Lkrg' , 'account_name' : None }], 'first_name' : 'john' , 'last_name' : 'doe' , 'email' : 'johndoe@example.com' , 'phone' : None , 'metadata' : None , 'domain' : 'test' , 'customer_code' : 'CUS_8x2byd6x3dk5hp0' , 'risk_action' : 'default' , 'id' : 87934333 , 'integration' : 630606 , 'createdAt' : '2022-07-25T03:46:01.000Z' , 'updatedAt' : '2022-07-25T03:46:01.000Z' , 'created_at' : '2022-07-25T03:46:01.000Z' , 'updated_at' : '2022-07-25T03:46:01.000Z' , 'total_transactions' : 0 , 'total_transaction_value' : [], 'dedicated_account' : None , 'identified' : False , 'identifications' : None }) >>> print ( response . status_code ) 200 >>> print ( response . message ) Customer retrieved >>> License This project is licensed under the terms of the MIT license. Notice This project is a third party open source project and is in no way directly related to Paystack. It's made out of love \u2665\ufe0f for the services offered by Paystack. You can help make it better. If you find typos while reading this documentation or you find any part of it that's out of date, also if you find any bugs while using it or have ideas to make it better, please create an issue at the projects github repo . Contributors gray-adeyi Buy me a coffee account_information = { \"account_name\" : \"Gbenga Adeyi\" , \"account_number\" : \"3000606742\" , \"bank\" : \"Kuda\" , }","title":"PyPaystack2"},{"location":"#requirements","text":"Python 3.9+ PyPaystack2 now uses httpx under the hood to make API calls to Paystack. Compared to previous version 1.1.3 and down which use requests . This switch has made it possible to support async/await based wrappers.","title":"Requirements"},{"location":"#installation","text":"$ pip install pypaystack2","title":"Installation"},{"location":"#example","text":"Python 3.9.15 ( main , Dec 12 2022 , 21 : 54 : 43 ) [ GCC 12.2.0 ] on linux Type \"help\" , \"copyright\" , \"credits\" or \"license\" for more information . >>> from pypaystack2 import Paystack >>> paystack = Paystack () # assumes the environmental variable `PAYSTACK_AUTHORIZATION_KEY=paystack integration secret key` is set. if not, you can alternatively pass it into the `Paystack` instantiation like so Paystack(auth_key='paystack integration secret key') >>> response = paystack . customers . get_customer ( email_or_code = \"CUS_8x2byd6x3dk5hp0\" ) >>> print ( response ) Response ( status_code = 200 , status = True , message = 'Customer retrieved' , data = { 'transactions' : [], 'subscriptions' : [], 'authorizations' : [{ 'authorization_code' : 'AUTH_ohnpjcd7z9' , 'bin' : '408408' , 'last4' : '4081' , 'exp_month' : '12' , 'exp_year' : '2030' , 'channel' : 'card' , 'card_type' : 'visa ' , 'bank' : 'TEST BANK' , 'country_code' : 'NG' , 'brand' : 'visa' , 'reusable' : True , 'signature' : 'SIG_JOdryeujwrsZryg0Lkrg' , 'account_name' : None }], 'first_name' : 'john' , 'last_name' : 'doe' , 'email' : 'johndoe@example.com' , 'phone' : None , 'metadata' : None , 'domain' : 'test' , 'customer_code' : 'CUS_8x2byd6x3dk5hp0' , 'risk_action' : 'default' , 'id' : 87934333 , 'integration' : 630606 , 'createdAt' : '2022-07-25T03:46:01.000Z' , 'updatedAt' : '2022-07-25T03:46:01.000Z' , 'created_at' : '2022-07-25T03:46:01.000Z' , 'updated_at' : '2022-07-25T03:46:01.000Z' , 'total_transactions' : 0 , 'total_transaction_value' : [], 'dedicated_account' : None , 'identified' : False , 'identifications' : None }) >>> print ( response . status_code ) 200 >>> print ( response . message ) Customer retrieved >>> All you need to interact with Paystack's API in your python project is the Paystack class it has attributes bounded to it that provides methods you can call in your code to make API calls to Paystack. Every method call on the wrapper has the same return type, which is a Response . A namedtuple containing the data from making the actual call to Paystack servers","title":"Example"},{"location":"#async-now","text":"PyPaystack2 now supports asynchronous wrappers to Paystack's API. AsyncPaystack is an asynchronous mirror equivalent of the Paystack wrapper. i.e. AsyncPaystack provides the same functionality as the Paystack wrapper but is more useful in the context of async\\await code. All the bindings on the AsyncPaystack are the same as on the Paystack wrapper except that the methods on the AsyncPaystack are awaitable asyncio REPL 3.9.15 ( main , Dec 12 2022 , 21 : 54 : 43 ) [ GCC 12.2.0 ] on linux Use \"await\" directly instead of \"asyncio.run()\" . Type \"help\" , \"copyright\" , \"credits\" or \"license\" for more information . >>> import asyncio >>> from pypaystack2 import AsyncPaystack >>> paystack = AsyncPaystack () # assumes the environmental variable `PAYSTACK_AUTHORIZATION_KEY=paystack integration secret key` is set. if not, you can alternatively pass it into the `AsyncPaystack` instantiation like so AsyncPaystack(auth_key='paystack integration secret key') >>> response = await paystack . customers . get_customer ( email_or_code = \"CUS_8x2byd6x3dk5hp0\" ) >>> print ( response ) Response ( status_code = 200 , status = True , message = 'Customer retrieved' , data = { 'transactions' : [], 'subscriptions' : [], 'authorizations' : [{ 'authorization_code' : 'AUTH_ohnpjcd7z9' , 'bin' : '408408' , 'last4' : '4081' , 'exp_month' : '12' , 'exp_year' : '2030' , 'channel' : 'card' , 'card_type' : 'visa ' , 'bank' : 'TEST BANK' , 'country_code' : 'NG' , 'brand' : 'visa' , 'reusable' : True , 'signature' : 'SIG_JOdryeujwrsZryg0Lkrg' , 'account_name' : None }], 'first_name' : 'john' , 'last_name' : 'doe' , 'email' : 'johndoe@example.com' , 'phone' : None , 'metadata' : None , 'domain' : 'test' , 'customer_code' : 'CUS_8x2byd6x3dk5hp0' , 'risk_action' : 'default' , 'id' : 87934333 , 'integration' : 630606 , 'createdAt' : '2022-07-25T03:46:01.000Z' , 'updatedAt' : '2022-07-25T03:46:01.000Z' , 'created_at' : '2022-07-25T03:46:01.000Z' , 'updated_at' : '2022-07-25T03:46:01.000Z' , 'total_transactions' : 0 , 'total_transaction_value' : [], 'dedicated_account' : None , 'identified' : False , 'identifications' : None }) >>> print ( response . status_code ) 200 >>> print ( response . message ) Customer retrieved >>>","title":"Async Now!"},{"location":"#license","text":"This project is licensed under the terms of the MIT license.","title":"License"},{"location":"#notice","text":"This project is a third party open source project and is in no way directly related to Paystack. It's made out of love \u2665\ufe0f for the services offered by Paystack. You can help make it better. If you find typos while reading this documentation or you find any part of it that's out of date, also if you find any bugs while using it or have ideas to make it better, please create an issue at the projects github repo .","title":"Notice"},{"location":"#contributors","text":"gray-adeyi","title":"Contributors"},{"location":"#buy-me-a-coffee","text":"account_information = { \"account_name\" : \"Gbenga Adeyi\" , \"account_number\" : \"3000606742\" , \"bank\" : \"Kuda\" , }","title":"Buy me a coffee"},{"location":"explanation/","text":"Coming soon!","title":"Explanation"},{"location":"how-to-guides/","text":"How to use the new Paystack class In previous versions of pypaystack2 , it is required to import all the various API wrappers required to achieve a goal. e.g. say you want to work with the transactions API wrapper and the customer API wrapper, the code below demonstrates how it's achieved from pypaystack2.api import Transaction , Customer Besides having to import these different wrappers, you'll also have to instantiate them, individually. While this kind of import will continue to be supported, I've added a new Paystack class which has all the wrappers bound to it. So now the preferred way to use pypaystack2 is demonstrated below from pypaystack2 import Paystack Here's a comparison of how a goal is achieved using the old API and the new API Old API from pypaystack2.api import PaymentRequest , Transaction , Customer invoice_api_wrapper = PaymentRequest () # assumes your PAYSTACK_AUTHORIZATION_KEY is set invoice_api_response = invoice_api_wrapper . create ( customer = \"CUS_xwaj0txjryg393b\" , amount = 1000 ) # Creates an invoice with a charge of \u20a6100 transaction_api_wrapper = Transaction () transaction_api_response = transaction_api_wrapper . get_transactions () customer_api_wrapper = Customer () customer_api_response = customer_api_wrapper . get_customers () New API from pypaystack2 import Paystack paystack_api = Paystack () # assumes your PAYSTACK_AUTHORIZATION_KEY is set payment_requests_api_response = paystack_api . payment_requests . create ( customer = \"CUS_xwaj0txjryg393b\" , amount = 1000 ) # Creates an invoice with a charge of \u20a6100 transaction_api_response = paystack_api . transactions . get_transactions () customer_api_response = paystack_api . transactions . get_transactions () For async/await from pypaystack2 import AsyncPaystack paystack_api = AsyncPaystack () # assumes your PAYSTACK_AUTHORIZATION_KEY is set payment_requests_api_response = await paystack_api . payment_requests . create ( customer = \"CUS_xwaj0txjryg393b\" , amount = 1000 ) # Creates an invoice with a charge of \u20a6100 transaction_api_response = await paystack_api . transactions . get_transactions () customer_api_response = await paystack_api . transactions . get_transactions () Note For the async equivalent to work start your interpreter in async mode with python -m asyncio You should get a prompt similar to this. asyncio REPL 3.9.15 ( main , May 14 2023 , 15 : 13 : 34 ) [ GCC 12.2.1 20230201 ] on linux Use \"await\" directly instead of \"asyncio.run()\" . Type \"help\" , \"copyright\" , \"credits\" or \"license\" for more information . >>> import asyncio >>> Bindings on the Paystack object API wrapper binding name on Paystack class ApplePay apple_pay BulkCharge bulk_charges Charge charge Integration integration Customer customer DedicatedAccount dedicated_account Dispute disputes PaymentRequest payment_requests Miscellaneous miscellaneous Page payment_pages Product products Refund refunds Settlement settlements Split split SubAccount subaccount Subscription subscriptions Terminal terminals Transaction transactions TransferRecipient transfer_recipients Transfer transfers TransferControl transfer_control Verification verification Bindings on the AsyncPaystack object API wrapper binding name on Paystack class AsyncApplePay apple_pay AsyncBulkCharge bulk_charges AsyncCharge charge AsyncIntegration integration AsyncCustomer customer AsyncDedicatedAccount dedicated_account AsyncDispute disputes AsyncPaymentRequest payment_requests AsyncMiscellaneous miscellaneous AsyncPage payment_pages AsyncProduct products AsyncRefund refunds AsyncSettlement settlements AsyncSplit split AsyncSubAccount subaccount AsyncSubscription subscriptions AsyncTerminal terminals AsyncTransaction transactions AsyncTransferRecipient transfer_recipients AsyncTransfer transfers AsyncTransferControl transfer_control AsyncVerification verification","title":"How-To Guides"},{"location":"how-to-guides/#how-to-use-the-new-paystack-class","text":"In previous versions of pypaystack2 , it is required to import all the various API wrappers required to achieve a goal. e.g. say you want to work with the transactions API wrapper and the customer API wrapper, the code below demonstrates how it's achieved from pypaystack2.api import Transaction , Customer Besides having to import these different wrappers, you'll also have to instantiate them, individually. While this kind of import will continue to be supported, I've added a new Paystack class which has all the wrappers bound to it. So now the preferred way to use pypaystack2 is demonstrated below from pypaystack2 import Paystack Here's a comparison of how a goal is achieved using the old API and the new API","title":"How to use the new Paystack class"},{"location":"how-to-guides/#old-api","text":"from pypaystack2.api import PaymentRequest , Transaction , Customer invoice_api_wrapper = PaymentRequest () # assumes your PAYSTACK_AUTHORIZATION_KEY is set invoice_api_response = invoice_api_wrapper . create ( customer = \"CUS_xwaj0txjryg393b\" , amount = 1000 ) # Creates an invoice with a charge of \u20a6100 transaction_api_wrapper = Transaction () transaction_api_response = transaction_api_wrapper . get_transactions () customer_api_wrapper = Customer () customer_api_response = customer_api_wrapper . get_customers ()","title":"Old API"},{"location":"how-to-guides/#new-api","text":"from pypaystack2 import Paystack paystack_api = Paystack () # assumes your PAYSTACK_AUTHORIZATION_KEY is set payment_requests_api_response = paystack_api . payment_requests . create ( customer = \"CUS_xwaj0txjryg393b\" , amount = 1000 ) # Creates an invoice with a charge of \u20a6100 transaction_api_response = paystack_api . transactions . get_transactions () customer_api_response = paystack_api . transactions . get_transactions () For async/await from pypaystack2 import AsyncPaystack paystack_api = AsyncPaystack () # assumes your PAYSTACK_AUTHORIZATION_KEY is set payment_requests_api_response = await paystack_api . payment_requests . create ( customer = \"CUS_xwaj0txjryg393b\" , amount = 1000 ) # Creates an invoice with a charge of \u20a6100 transaction_api_response = await paystack_api . transactions . get_transactions () customer_api_response = await paystack_api . transactions . get_transactions () Note For the async equivalent to work start your interpreter in async mode with python -m asyncio You should get a prompt similar to this. asyncio REPL 3.9.15 ( main , May 14 2023 , 15 : 13 : 34 ) [ GCC 12.2.1 20230201 ] on linux Use \"await\" directly instead of \"asyncio.run()\" . Type \"help\" , \"copyright\" , \"credits\" or \"license\" for more information . >>> import asyncio >>>","title":"New API"},{"location":"how-to-guides/#bindings-on-the-paystack-object","text":"API wrapper binding name on Paystack class ApplePay apple_pay BulkCharge bulk_charges Charge charge Integration integration Customer customer DedicatedAccount dedicated_account Dispute disputes PaymentRequest payment_requests Miscellaneous miscellaneous Page payment_pages Product products Refund refunds Settlement settlements Split split SubAccount subaccount Subscription subscriptions Terminal terminals Transaction transactions TransferRecipient transfer_recipients Transfer transfers TransferControl transfer_control Verification verification","title":"Bindings on the Paystack object"},{"location":"how-to-guides/#bindings-on-the-asyncpaystack-object","text":"API wrapper binding name on Paystack class AsyncApplePay apple_pay AsyncBulkCharge bulk_charges AsyncCharge charge AsyncIntegration integration AsyncCustomer customer AsyncDedicatedAccount dedicated_account AsyncDispute disputes AsyncPaymentRequest payment_requests AsyncMiscellaneous miscellaneous AsyncPage payment_pages AsyncProduct products AsyncRefund refunds AsyncSettlement settlements AsyncSplit split AsyncSubAccount subaccount AsyncSubscription subscriptions AsyncTerminal terminals AsyncTransaction transactions AsyncTransferRecipient transfer_recipients AsyncTransfer transfers AsyncTransferControl transfer_control AsyncVerification verification","title":"Bindings on the AsyncPaystack object"},{"location":"reference/","text":"Pypaystack2 Package Reference Pypaystack2 is a simple python wrapper for Paystack API. it is a fork of the original project Pypaystack Modules and packages exported by this package api : A package containing several wrappers for Paystack API, like apple pay api, bulk charges api e.t.c. utils : A module containing useful utilities and enums errors : A module containing error types for pypaystack2 pypaystack2.paytack AsyncPaystack Bases: BaseAsyncAPI An asynchronous Paystack API wrapper class with all the wrappers supported by pypaystack2. This class has all the individual api wrapper classes like ApplePay , BulkCharge bound to it. its intent is to reduce the number of imports by exposing all the api wrappers bound to it via an instance of this class. Source code in pypaystack2/paystack.py 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 class AsyncPaystack ( BaseAsyncAPI ): \"\"\"An asynchronous Paystack API wrapper class with all the wrappers supported by pypaystack2. This class has all the individual api wrapper classes like `ApplePay`, `BulkCharge` bound to it. its intent is to reduce the number of imports by exposing all the api wrappers bound to it via an instance of this class. \"\"\" def __init__ ( self , auth_key : str = None ): super () . __init__ ( auth_key = auth_key ) self . apple_pay = AsyncApplePay ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . bulk_charges = AsyncBulkCharge ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . charge = AsyncCharge ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . integration = AsyncIntegration ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . customers = AsyncCustomer ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . dedicated_accounts = AsyncDedicatedAccount ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . disputes = AsyncDispute ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . payment_requests = AsyncPaymentRequest ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . miscellaneous = AsyncMiscellaneous ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . payment_pages = AsyncPaymentPage ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . plans = AsyncPlan ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . products = AsyncProduct ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . refunds = AsyncRefund ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . settlements = AsyncSettlement ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . splits = AsyncTransactionSplit ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . subaccounts = AsyncSubAccount ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . subscriptions = AsyncSubscription ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . terminals = AsyncTerminal ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . transactions = AsyncTransaction ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . transfer_recipients = AsyncTransferRecipient ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . transfers = AsyncTransfer ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . transfer_control = AsyncTransferControl ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . verification = AsyncVerification ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) Paystack Bases: BaseAPI A Paystack API wrapper class with all the wrappers supported by pypaystack2. This class has all the individual api wrapper classes like ApplePay , BulkCharge bound to it. its intent is to reduce the number of imports by exposing all the api wrappers bound to it via an instance of this class. Source code in pypaystack2/paystack.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 class Paystack ( BaseAPI ): \"\"\"A Paystack API wrapper class with all the wrappers supported by pypaystack2. This class has all the individual api wrapper classes like `ApplePay`, `BulkCharge` bound to it. its intent is to reduce the number of imports by exposing all the api wrappers bound to it via an instance of this class. \"\"\" def __init__ ( self , auth_key : str = None ): super () . __init__ ( auth_key = auth_key ) self . apple_pay = ApplePay ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . bulk_charges = BulkCharge ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . charge = Charge ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . integration = Integration ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . customers = Customer ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . dedicated_accounts = DedicatedAccount ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . disputes = Dispute ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . payment_requests = PaymentRequest ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . miscellaneous = Miscellaneous ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . payment_pages = PaymentPage ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . plans = Plan ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . products = Product ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . refunds = Refund ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . settlements = Settlement ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . splits = TransactionSplit ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . subaccounts = SubAccount ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . subscriptions = Subscription ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . terminals = Terminal ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . transactions = Transaction ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . transfer_recipients = TransferRecipient ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . transfers = Transfer ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . transfer_control = TransferControl ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . verification = Verification ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) pypaystack2.api A package containing several wrappers for interfacing Paystack API, like apple pay api, bulk charges api e.t.c. Modules exported by this package apple_pay : A module containing implementations for interfacing with Paystack's Apple Pay API bulk_charges : A module containing implementations for interfacing with Paystack's Bulk Charges API charge : A module containing implementations for interfacing with Paystack's Charge API control_panel : A module containing implementations for interfacing with Paystack's Control Panel API customer : A module containing implementations for interfacing with Paystack's Customer API dedicated_accounts : A module containing implementations for interfacing with Paystack's Dedicated Accounts API disputes : A module containing implementations for interfacing with Paystack's Disputes API invoices : A module containing implementations for interfacing with Paystack's Invoices API miscellaneous : A module containing implementations for interfacing with Paystack's Miscellaneous API payment_pages : A module containing implementations for interfacing with Paystack's Payment Page API plans : A module containing implementations for interfacing with Paystack's Plans API products : A module containing implementations for interfacing with Paystack's Products API refunds : A module containing implementations for interfacing with Paystack's Refunds API settlements : A module containing implementations for interfacing with Paystack's Settlements API splits : A module containing implementations for interfacing with Paystack's Splits API subaccounts : A module containing implementations for interfacing with Paystack's Sub Account API subscriptions : A module containing implementations for interfacing with Paystack's Subscriptions API transactions : A module containing implementations for interfacing with Paystack's Transactions API transfer_recipients : A module containing implementations for interfacing with Paystack's Transfer Recipients API transfers : A module containing implementations for interfacing with Paystack's Transfers API transfers_control : A module containing implementations for interfacing with Paystack's Transfers Control API verification : A module containing implementations for interfacing with Paystack's Verification API wrappers within pypaystack2.api ApplePay & AsyncApplePay BulkCharge & AsyncBulkCharge Charge & AsyncCharge Integration & AsyncIntegration Customer & AsyncCustomer DedicatedAccount & AsyncDedicatedAccount Dispute & AsyncDispute PaymentRequest & AsyncPaymentRequest Miscellaneous & AsyncMiscellaneous PaymentPage & AsyncPaymentPage Plan & AsyncPlan Product & AsyncProduct Refund & AsyncRefund Settlement & AsyncSettlement Split & AsyncSplit SubAccount & AsyncSubAccount Subscription & AsyncSubscription Terminal & AsyncTerminal Transaction & AsyncTransaction TransferRecipient & AsyncTransferRecipient Transfer & AsyncTransfer TransferControl & AsyncTransferControl Verification & AsyncVerification pypaystack2.utils AccountType Bases: str , Enum Enum of Account types supported by paystack Source code in pypaystack2/utils.py 382 383 384 385 386 class AccountType ( str , Enum ): \"\"\"Enum of Account types supported by paystack\"\"\" PERSONAL = \"personal\" BUSINESS = \"business\" BankType Bases: str , Enum Enum of bank types Source code in pypaystack2/utils.py 396 397 398 399 400 class BankType ( str , Enum ): \"\"\"Enum of bank types\"\"\" GHIPPS = \"ghipps\" MOBILE_MONEY = \"mobile_money\" Bearer Bases: str , Enum Enum for who bears paystack charges Source code in pypaystack2/utils.py 269 270 271 272 273 274 275 class Bearer ( str , Enum ): \"\"\"Enum for who bears paystack charges\"\"\" ACCOUNT = \"account\" SUB_ACCOUNT = \"subaccount\" ALL_PROPORTIONAL = \"all-proportional\" ALL = \"all\" Channel Bases: str , Enum Enum of payment channels supported by paystack Source code in pypaystack2/utils.py 258 259 260 261 262 263 264 265 266 class Channel ( str , Enum ): \"\"\"Enum of payment channels supported by paystack\"\"\" CARD = \"card\" BANK = \"bank\" USSD = \"ussd\" QR = \"qr\" MOBILE_MONEY = \"mobile_money\" BANK_TRANSFER = \"bank_transfer\" Country Bases: str , Enum Enum of countries supported by paystack Source code in pypaystack2/utils.py 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 class Country ( str , Enum ): \"\"\"Enum of countries supported by paystack\"\"\" NIGERIA = \"NG\" GHANA = \"GH\" SOUTH_AFRICA = \"ZA\" @staticmethod def get_full ( value : str ) -> Optional [ str ]: \"\"\"Returns paystack supported country name in full lowercase Args: value: The two-digit iso name of the country. Returns: The name of the country in lowercase if it is supported by paystack or none. \"\"\" value = value . lower () return { \"ng\" : \"nigeria\" , \"gh\" : \"ghana\" , \"za\" : \"south africa\" } . get ( value ) get_full ( value ) staticmethod Returns paystack supported country name in full lowercase Parameters: Name Type Description Default value str The two-digit iso name of the country. required Returns: Type Description Optional [ str ] The name of the country in lowercase if it is supported by Optional [ str ] paystack or none. Source code in pypaystack2/utils.py 300 301 302 303 304 305 306 307 308 309 310 311 312 @staticmethod def get_full ( value : str ) -> Optional [ str ]: \"\"\"Returns paystack supported country name in full lowercase Args: value: The two-digit iso name of the country. Returns: The name of the country in lowercase if it is supported by paystack or none. \"\"\" value = value . lower () return { \"ng\" : \"nigeria\" , \"gh\" : \"ghana\" , \"za\" : \"south africa\" } . get ( value ) Currency Bases: str , Enum Enum of currencies supported by paystack. Source code in pypaystack2/utils.py 239 240 241 242 243 244 245 class Currency ( str , Enum ): \"\"\"Enum of currencies supported by paystack.\"\"\" NGN = \"NGN\" GHS = \"GHS\" ZAR = \"ZAR\" USD = \"USD\" DisputeStatus Bases: str , Enum Enum of dispute status supported by paystack Source code in pypaystack2/utils.py 403 404 405 406 407 408 409 class DisputeStatus ( str , Enum ): \"\"\"Enum of dispute status supported by paystack\"\"\" PENDING = \"pending\" RESOLVED = \"resolved\" AWAITING_BANK_FEEDBACK = \"awaiting-bank-feedback\" AWAITING_MERCHANT_FEEDBACK = \"awaiting-merchant-feedback\" Document Bases: str , Enum Enum of Document types supported by paystack Source code in pypaystack2/utils.py 338 339 340 341 342 343 class Document ( str , Enum ): \"\"\"Enum of Document types supported by paystack\"\"\" IDENTITY_NUMBER = \"identityNumber\" PASSPORT_NUMBER = \"passportNumber\" BUSINESS_REGISTRATION_NUMBER = \"businessRegistrationNumber\" Gateway Bases: str , Enum Enum of bank gateways supported by paystack Source code in pypaystack2/utils.py 375 376 377 378 379 class Gateway ( str , Enum ): \"\"\"Enum of bank gateways supported by paystack\"\"\" EMANDATE = \"emandate\" DIGITALBANKMANDATE = \"digitalbankmandate\" HTTPMethod Bases: str , Enum An enum of supported http methods Source code in pypaystack2/utils.py 214 215 216 217 218 219 220 221 222 223 class HTTPMethod ( str , Enum ): \"\"\"An enum of supported http methods\"\"\" GET = \"GET\" POST = \"POST\" PUT = \"PUT\" PATCH = \"PATCH\" DELETE = \"DELETE\" OPTIONS = \"OPTIONS\" HEAD = \"HEAD\" Identification Bases: str , Enum Enum of Identification methods supported by paystack Source code in pypaystack2/utils.py 323 324 325 326 327 class Identification ( str , Enum ): \"\"\"Enum of Identification methods supported by paystack\"\"\" BVN = \"bvn\" BANK_ACCOUNT = \"bank_account\" Interval Bases: str , Enum Enum of intervals supported by paystack. Source code in pypaystack2/utils.py 248 249 250 251 252 253 254 255 class Interval ( str , Enum ): \"\"\"Enum of intervals supported by paystack.\"\"\" HOURLY = \"hourly\" DAILY = \"daily\" WEEKLY = \"weekly\" MONTHLY = \"monthly\" ANNUALLY = \"annually\" Reason Bases: str , Enum Enum of Reset OTP options Source code in pypaystack2/utils.py 367 368 369 370 371 372 class Reason ( str , Enum ): \"\"\"Enum of Reset OTP options\"\"\" RESEND_OTP = \"resend_otp\" TRANSFER = \"transfer\" DISABLE_OTP = \"disable_otp\" RecipientType Bases: str , Enum Enum of Transfer Recipient types Source code in pypaystack2/utils.py 330 331 332 333 334 335 class RecipientType ( str , Enum ): \"\"\"Enum of Transfer Recipient types\"\"\" NUBAN = \"nuban\" MOBILE_MONEY = \"mobile_money\" BASA = \"basa\" Resolution Bases: str , Enum Enum of Resolutions supported by paystack Source code in pypaystack2/utils.py 389 390 391 392 393 class Resolution ( str , Enum ): \"\"\"Enum of Resolutions supported by paystack\"\"\" MERCHANT_ACCEPTED = \"merchant-accepted\" DECLINED = \"declined\" Response Bases: NamedTuple A namedtuple containing the data gotten from making a request to paystack's API endpoints. All wrapper methods returns an instance of Response which can be used as a tuple following this format (status_code, status, message, data) . Accessing by attributes is also possible say for example response is an instance of Response , we can access the data in the response like so response.data Attributes: Name Type Description status_code int The response status code status bool A flag for the response status message str Paystack response message data Optional [ Union [ dict [ str , Any ], list [ dict [ str , Any ]]]] Data sent from paystack's server if any. Source code in pypaystack2/utils.py 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 class Response ( NamedTuple ): \"\"\" A namedtuple containing the data gotten from making a request to paystack's API endpoints. All wrapper methods returns an instance of `Response` which can be used as a tuple following this format `(status_code, status, message, data)`. Accessing by attributes is also possible say for example `response` is an instance of `Response`, we can access the data in the response like so `response.data` Attributes: status_code: The response status code status: A flag for the response status message: Paystack response message data: Data sent from paystack's server if any. \"\"\" status_code : int status : bool message : str data : Optional [ Union [ dict [ str , Any ], list [ dict [ str , Any ]]]] RiskAction Bases: str , Enum Enum of RiskActions supported by paystack Source code in pypaystack2/utils.py 315 316 317 318 319 320 class RiskAction ( str , Enum ): \"\"\"Enum of RiskActions supported by paystack\"\"\" DEFAULT = \"default\" WHITELIST = \"allow\" BLACKLIST = \"deny\" Schedule Bases: str , Enum Enum of settlement schedules supported by paystack Source code in pypaystack2/utils.py 358 359 360 361 362 363 364 class Schedule ( str , Enum ): \"\"\"Enum of settlement schedules supported by paystack\"\"\" AUTO = \"auto\" WEEKLY = \"weekly\" MONTHLY = \"monthly\" MANUAL = \"manual\" Split Bases: str , Enum Enum of split types Source code in pypaystack2/utils.py 286 287 288 289 290 class Split ( str , Enum ): \"\"\"Enum of split types\"\"\" PERCENTAGE = \"percentage\" FLAT = \"flat\" Status Bases: str , Enum Enum of statuses supported by paystack, used by Invoice, Charge & Plan Source code in pypaystack2/utils.py 350 351 352 353 354 355 class Status ( str , Enum ): \"\"\"Enum of statuses supported by paystack, used by Invoice, Charge & Plan\"\"\" PENDING = \"pending\" SUCCESS = \"success\" FAILED = \"failed\" TerminalEvent Bases: str , Enum Enum of the types of events supported by Terminal API Source code in pypaystack2/utils.py 226 227 228 229 230 class TerminalEvent ( str , Enum ): \"\"\"Enum of the types of events supported by Terminal API\"\"\" TRANSACTION = \"transaction\" INVOICE = \"invoice\" TransactionStatus Bases: str , Enum Enum of transaction status Source code in pypaystack2/utils.py 278 279 280 281 282 283 class TransactionStatus ( str , Enum ): \"\"\"Enum of transaction status\"\"\" FAILED = \"failed\" SUCCESS = \"success\" ABANDONED = \"abandoned\" add_to_payload ( optional_params , payload ) Adds more parameters to an existing payload. This is a utility is used in the generation of payloads for a request body. It helps to add more parameters to a payload if it is not None. e.g. say you want to send a payload which is currently {\"amount\": 20000} and you want to include an additional data such as currency if provided in the optional_params to send this {\"amount\": 20000,\"currency\":\"ngn\"} if only the currency is available otherwise send the initial payload. This functions takes a list of optional parameters which is added to the payload is they are available and returns the payload. Parameters: Name Type Description Default optional_params list [ tuple [ str , Any ]] A list of additional data to be added to the payload if it is available. It follows the format [(\"name-on-payload\",\"value\")]. e.g [(\"currency\",\"ngn\"),(\"amount\",2000)] required payload dict [ str , Any ] A dictionary containing the data to be sent in the request body. required Returns: Type Description dict [ str , Any ] A dictionary of the payload updated with additional data in the optional_params that are not None . Source code in pypaystack2/utils.py 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 def add_to_payload ( optional_params : list [ tuple [ str , Any ]], payload : dict [ str , Any ] ) -> dict [ str , Any ]: \"\"\"Adds more parameters to an existing payload. This is a utility is used in the generation of payloads for a request body. It helps to add more parameters to a payload if it is not None. e.g. say you want to send a payload which is currently ``{\"amount\": 20000}`` and you want to include an additional data such as ``currency`` if provided in the ``optional_params`` to send this ``{\"amount\": 20000,\"currency\":\"ngn\"}`` if only the currency is available otherwise send the initial payload. This functions takes a list of optional parameters which is added to the payload is they are available and returns the payload. Args: optional_params: A list of additional data to be added to the payload if it is available. It follows the format ``[(\"name-on-payload\",\"value\")].`` e.g ``[(\"currency\",\"ngn\"),(\"amount\",2000)]`` payload: A dictionary containing the data to be sent in the request body. Returns: A dictionary of the payload updated with additional data in the optional_params that are not `None`. \"\"\" [ payload . update ({ item [ 0 ]: item [ 1 ]}) for item in optional_params if item [ 1 ] is not None ] return payload append_query_params ( query_params , url ) Adds more queries to url that already have query parameters in its suffix This function should only be used with urls that already have a query parameter suffixed to it because it makes that assumption that the url supplied is of the state http://example-url.com?firstQuery=1 and it adds more query parameters delimited by & to the end of the provided url http://example-url.com?firstQuery=1&otherQuery=2&... Parameters: Name Type Description Default query_params list [ tuple [ str , Any ]] A list of other query parameters that should be appended to the url if it is not None. e.g [(\"page\",2),(\"pagination\",50),(\"currency\",None)] -> url&page=2&pagination=50 required url str The url to which additional query parameters are added. required Returns: Type Description str The new url with padded query parameters. Source code in pypaystack2/utils.py 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 def append_query_params ( query_params : list [ tuple [ str , Any ]], url : str ) -> str : \"\"\"Adds more queries to url that already have query parameters in its suffix This function should only be used with urls that already have a query parameter suffixed to it because it makes that assumption that the url supplied is of the state ``http://example-url.com?firstQuery=1`` and it adds more query parameters delimited by & to the end of the provided url ``http://example-url.com?firstQuery=1&otherQuery=2&...`` Args: query_params: A list of other query parameters that should be appended to the url if it is not None. e.g ``[(\"page\",2),(\"pagination\",50),(\"currency\",None)]`` -> ``url&page=2&pagination=50`` url: The url to which additional query parameters are added. Returns: The new url with padded query parameters. \"\"\" params = [ f \"& { param [ 0 ] } = { param [ 1 ] } \" for param in query_params if param [ 1 ] is not None ] if len ( params ) == 0 : return url return url + reduce ( add , params ) validate_amount ( amount ) Helps to validate money amount. Helps to ensure that a valid amount of money is supplied as an input, to prevent cases where negative or zero value is provided as an amount. Parameters: Name Type Description Default amount Union [ int , float ] The money to be validated. required Returns: Type Description Union [ int , float ] The money supplied if it is valid. Raises: Type Description InvalidDataError With the cause of the validation error Source code in pypaystack2/utils.py 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 def validate_amount ( amount : Union [ int , float ]) -> Union [ int , float ]: \"\"\"Helps to validate money amount. Helps to ensure that a valid amount of money is supplied as an input, to prevent cases where negative or zero value is provided as an amount. Args: amount: The money to be validated. Returns: The money supplied if it is valid. Raises: InvalidDataError: With the cause of the validation error \"\"\" if not amount : raise InvalidDataError ( \"Amount to be charged is required\" ) if isinstance ( amount , int ) or isinstance ( amount , float ): # Save the sever some headaches if amount < 0 : raise InvalidDataError ( \"Negative amount is not allowed\" ) return amount else : raise InvalidDataError ( \"Amount should be a number\" ) validate_interval ( interval ) Validates that the interval supplied is supported by paystack Parameters: Name Type Description Default interval str any of the intervals supported by paystack i.e. hourly, daily weekly,monthly,annually required Returns: Type Description str The interval if it is a valid paystack interval Raises: Type Description InvalidDataError to provide feedback that an invalid interval was provided. Source code in pypaystack2/utils.py 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 def validate_interval ( interval : str ) -> str : \"\"\"Validates that the interval supplied is supported by paystack Args: interval: any of the intervals supported by paystack i.e. hourly, daily weekly,monthly,annually Returns: The interval if it is a valid paystack interval Raises: InvalidDataError: to provide feedback that an invalid interval was provided. \"\"\" interval = ( interval if interval . lower () in [ \"hourly\" , \"daily\" , \"weekly\" , \"monthly\" , \"annually\" ] else None ) if not interval : raise InvalidDataError ( \"Please provide a valid plan interval\" ) return interval pypaystack2.errors InvalidDataError Bases: PyPaystackError Invalid input recognised. Saves unnecessary request to the server Source code in pypaystack2/errors.py 25 26 27 28 29 30 class InvalidDataError ( PyPaystackError ): \"\"\" Invalid input recognised. Saves unnecessary request to the server \"\"\" pass InvalidMethodError Bases: PyPaystackError Invalid or unrecognized/unimplemented HTTP request method Source code in pypaystack2/errors.py 17 18 19 20 21 22 class InvalidMethodError ( PyPaystackError ): \"\"\" Invalid or unrecognized/unimplemented HTTP request method \"\"\" pass MissingAuthKeyError Bases: PyPaystackError We can't find the authentication key Source code in pypaystack2/errors.py 9 10 11 12 13 14 class MissingAuthKeyError ( PyPaystackError ): \"\"\" We can't find the authentication key \"\"\" pass PyPaystackError Bases: Exception Python Paystack Error Source code in pypaystack2/errors.py 1 2 3 4 5 6 class PyPaystackError ( Exception ): \"\"\" Python Paystack Error \"\"\" pass","title":"Introduction"},{"location":"reference/#pypaystack2-package-reference","text":"Pypaystack2 is a simple python wrapper for Paystack API. it is a fork of the original project Pypaystack Modules and packages exported by this package api : A package containing several wrappers for Paystack API, like apple pay api, bulk charges api e.t.c. utils : A module containing useful utilities and enums errors : A module containing error types for pypaystack2","title":"Pypaystack2 Package Reference"},{"location":"reference/#pypaystack2paytack","text":"","title":"pypaystack2.paytack"},{"location":"reference/#pypaystack2.paystack.AsyncPaystack","text":"Bases: BaseAsyncAPI An asynchronous Paystack API wrapper class with all the wrappers supported by pypaystack2. This class has all the individual api wrapper classes like ApplePay , BulkCharge bound to it. its intent is to reduce the number of imports by exposing all the api wrappers bound to it via an instance of this class. Source code in pypaystack2/paystack.py 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 class AsyncPaystack ( BaseAsyncAPI ): \"\"\"An asynchronous Paystack API wrapper class with all the wrappers supported by pypaystack2. This class has all the individual api wrapper classes like `ApplePay`, `BulkCharge` bound to it. its intent is to reduce the number of imports by exposing all the api wrappers bound to it via an instance of this class. \"\"\" def __init__ ( self , auth_key : str = None ): super () . __init__ ( auth_key = auth_key ) self . apple_pay = AsyncApplePay ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . bulk_charges = AsyncBulkCharge ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . charge = AsyncCharge ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . integration = AsyncIntegration ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . customers = AsyncCustomer ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . dedicated_accounts = AsyncDedicatedAccount ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . disputes = AsyncDispute ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . payment_requests = AsyncPaymentRequest ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . miscellaneous = AsyncMiscellaneous ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . payment_pages = AsyncPaymentPage ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . plans = AsyncPlan ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . products = AsyncProduct ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . refunds = AsyncRefund ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . settlements = AsyncSettlement ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . splits = AsyncTransactionSplit ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . subaccounts = AsyncSubAccount ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . subscriptions = AsyncSubscription ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . terminals = AsyncTerminal ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . transactions = AsyncTransaction ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . transfer_recipients = AsyncTransferRecipient ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . transfers = AsyncTransfer ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . transfer_control = AsyncTransferControl ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . verification = AsyncVerification ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY )","title":"AsyncPaystack"},{"location":"reference/#pypaystack2.paystack.Paystack","text":"Bases: BaseAPI A Paystack API wrapper class with all the wrappers supported by pypaystack2. This class has all the individual api wrapper classes like ApplePay , BulkCharge bound to it. its intent is to reduce the number of imports by exposing all the api wrappers bound to it via an instance of this class. Source code in pypaystack2/paystack.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 class Paystack ( BaseAPI ): \"\"\"A Paystack API wrapper class with all the wrappers supported by pypaystack2. This class has all the individual api wrapper classes like `ApplePay`, `BulkCharge` bound to it. its intent is to reduce the number of imports by exposing all the api wrappers bound to it via an instance of this class. \"\"\" def __init__ ( self , auth_key : str = None ): super () . __init__ ( auth_key = auth_key ) self . apple_pay = ApplePay ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . bulk_charges = BulkCharge ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . charge = Charge ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . integration = Integration ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . customers = Customer ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . dedicated_accounts = DedicatedAccount ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . disputes = Dispute ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . payment_requests = PaymentRequest ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . miscellaneous = Miscellaneous ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . payment_pages = PaymentPage ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . plans = Plan ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . products = Product ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . refunds = Refund ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . settlements = Settlement ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . splits = TransactionSplit ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . subaccounts = SubAccount ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . subscriptions = Subscription ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . terminals = Terminal ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . transactions = Transaction ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . transfer_recipients = TransferRecipient ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . transfers = Transfer ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . transfer_control = TransferControl ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY ) self . verification = Verification ( auth_key = self . _PAYSTACK_AUTHORIZATION_KEY )","title":"Paystack"},{"location":"reference/#pypaystack2api","text":"A package containing several wrappers for interfacing Paystack API, like apple pay api, bulk charges api e.t.c. Modules exported by this package apple_pay : A module containing implementations for interfacing with Paystack's Apple Pay API bulk_charges : A module containing implementations for interfacing with Paystack's Bulk Charges API charge : A module containing implementations for interfacing with Paystack's Charge API control_panel : A module containing implementations for interfacing with Paystack's Control Panel API customer : A module containing implementations for interfacing with Paystack's Customer API dedicated_accounts : A module containing implementations for interfacing with Paystack's Dedicated Accounts API disputes : A module containing implementations for interfacing with Paystack's Disputes API invoices : A module containing implementations for interfacing with Paystack's Invoices API miscellaneous : A module containing implementations for interfacing with Paystack's Miscellaneous API payment_pages : A module containing implementations for interfacing with Paystack's Payment Page API plans : A module containing implementations for interfacing with Paystack's Plans API products : A module containing implementations for interfacing with Paystack's Products API refunds : A module containing implementations for interfacing with Paystack's Refunds API settlements : A module containing implementations for interfacing with Paystack's Settlements API splits : A module containing implementations for interfacing with Paystack's Splits API subaccounts : A module containing implementations for interfacing with Paystack's Sub Account API subscriptions : A module containing implementations for interfacing with Paystack's Subscriptions API transactions : A module containing implementations for interfacing with Paystack's Transactions API transfer_recipients : A module containing implementations for interfacing with Paystack's Transfer Recipients API transfers : A module containing implementations for interfacing with Paystack's Transfers API transfers_control : A module containing implementations for interfacing with Paystack's Transfers Control API verification : A module containing implementations for interfacing with Paystack's Verification API","title":"pypaystack2.api"},{"location":"reference/#wrappers-within-pypaystack2api","text":"ApplePay & AsyncApplePay BulkCharge & AsyncBulkCharge Charge & AsyncCharge Integration & AsyncIntegration Customer & AsyncCustomer DedicatedAccount & AsyncDedicatedAccount Dispute & AsyncDispute PaymentRequest & AsyncPaymentRequest Miscellaneous & AsyncMiscellaneous PaymentPage & AsyncPaymentPage Plan & AsyncPlan Product & AsyncProduct Refund & AsyncRefund Settlement & AsyncSettlement Split & AsyncSplit SubAccount & AsyncSubAccount Subscription & AsyncSubscription Terminal & AsyncTerminal Transaction & AsyncTransaction TransferRecipient & AsyncTransferRecipient Transfer & AsyncTransfer TransferControl & AsyncTransferControl Verification & AsyncVerification","title":"wrappers within pypaystack2.api"},{"location":"reference/#pypaystack2utils","text":"","title":"pypaystack2.utils"},{"location":"reference/#pypaystack2.utils.AccountType","text":"Bases: str , Enum Enum of Account types supported by paystack Source code in pypaystack2/utils.py 382 383 384 385 386 class AccountType ( str , Enum ): \"\"\"Enum of Account types supported by paystack\"\"\" PERSONAL = \"personal\" BUSINESS = \"business\"","title":"AccountType"},{"location":"reference/#pypaystack2.utils.BankType","text":"Bases: str , Enum Enum of bank types Source code in pypaystack2/utils.py 396 397 398 399 400 class BankType ( str , Enum ): \"\"\"Enum of bank types\"\"\" GHIPPS = \"ghipps\" MOBILE_MONEY = \"mobile_money\"","title":"BankType"},{"location":"reference/#pypaystack2.utils.Bearer","text":"Bases: str , Enum Enum for who bears paystack charges Source code in pypaystack2/utils.py 269 270 271 272 273 274 275 class Bearer ( str , Enum ): \"\"\"Enum for who bears paystack charges\"\"\" ACCOUNT = \"account\" SUB_ACCOUNT = \"subaccount\" ALL_PROPORTIONAL = \"all-proportional\" ALL = \"all\"","title":"Bearer"},{"location":"reference/#pypaystack2.utils.Channel","text":"Bases: str , Enum Enum of payment channels supported by paystack Source code in pypaystack2/utils.py 258 259 260 261 262 263 264 265 266 class Channel ( str , Enum ): \"\"\"Enum of payment channels supported by paystack\"\"\" CARD = \"card\" BANK = \"bank\" USSD = \"ussd\" QR = \"qr\" MOBILE_MONEY = \"mobile_money\" BANK_TRANSFER = \"bank_transfer\"","title":"Channel"},{"location":"reference/#pypaystack2.utils.Country","text":"Bases: str , Enum Enum of countries supported by paystack Source code in pypaystack2/utils.py 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 class Country ( str , Enum ): \"\"\"Enum of countries supported by paystack\"\"\" NIGERIA = \"NG\" GHANA = \"GH\" SOUTH_AFRICA = \"ZA\" @staticmethod def get_full ( value : str ) -> Optional [ str ]: \"\"\"Returns paystack supported country name in full lowercase Args: value: The two-digit iso name of the country. Returns: The name of the country in lowercase if it is supported by paystack or none. \"\"\" value = value . lower () return { \"ng\" : \"nigeria\" , \"gh\" : \"ghana\" , \"za\" : \"south africa\" } . get ( value )","title":"Country"},{"location":"reference/#pypaystack2.utils.Country.get_full","text":"Returns paystack supported country name in full lowercase Parameters: Name Type Description Default value str The two-digit iso name of the country. required Returns: Type Description Optional [ str ] The name of the country in lowercase if it is supported by Optional [ str ] paystack or none. Source code in pypaystack2/utils.py 300 301 302 303 304 305 306 307 308 309 310 311 312 @staticmethod def get_full ( value : str ) -> Optional [ str ]: \"\"\"Returns paystack supported country name in full lowercase Args: value: The two-digit iso name of the country. Returns: The name of the country in lowercase if it is supported by paystack or none. \"\"\" value = value . lower () return { \"ng\" : \"nigeria\" , \"gh\" : \"ghana\" , \"za\" : \"south africa\" } . get ( value )","title":"get_full()"},{"location":"reference/#pypaystack2.utils.Currency","text":"Bases: str , Enum Enum of currencies supported by paystack. Source code in pypaystack2/utils.py 239 240 241 242 243 244 245 class Currency ( str , Enum ): \"\"\"Enum of currencies supported by paystack.\"\"\" NGN = \"NGN\" GHS = \"GHS\" ZAR = \"ZAR\" USD = \"USD\"","title":"Currency"},{"location":"reference/#pypaystack2.utils.DisputeStatus","text":"Bases: str , Enum Enum of dispute status supported by paystack Source code in pypaystack2/utils.py 403 404 405 406 407 408 409 class DisputeStatus ( str , Enum ): \"\"\"Enum of dispute status supported by paystack\"\"\" PENDING = \"pending\" RESOLVED = \"resolved\" AWAITING_BANK_FEEDBACK = \"awaiting-bank-feedback\" AWAITING_MERCHANT_FEEDBACK = \"awaiting-merchant-feedback\"","title":"DisputeStatus"},{"location":"reference/#pypaystack2.utils.Document","text":"Bases: str , Enum Enum of Document types supported by paystack Source code in pypaystack2/utils.py 338 339 340 341 342 343 class Document ( str , Enum ): \"\"\"Enum of Document types supported by paystack\"\"\" IDENTITY_NUMBER = \"identityNumber\" PASSPORT_NUMBER = \"passportNumber\" BUSINESS_REGISTRATION_NUMBER = \"businessRegistrationNumber\"","title":"Document"},{"location":"reference/#pypaystack2.utils.Gateway","text":"Bases: str , Enum Enum of bank gateways supported by paystack Source code in pypaystack2/utils.py 375 376 377 378 379 class Gateway ( str , Enum ): \"\"\"Enum of bank gateways supported by paystack\"\"\" EMANDATE = \"emandate\" DIGITALBANKMANDATE = \"digitalbankmandate\"","title":"Gateway"},{"location":"reference/#pypaystack2.utils.HTTPMethod","text":"Bases: str , Enum An enum of supported http methods Source code in pypaystack2/utils.py 214 215 216 217 218 219 220 221 222 223 class HTTPMethod ( str , Enum ): \"\"\"An enum of supported http methods\"\"\" GET = \"GET\" POST = \"POST\" PUT = \"PUT\" PATCH = \"PATCH\" DELETE = \"DELETE\" OPTIONS = \"OPTIONS\" HEAD = \"HEAD\"","title":"HTTPMethod"},{"location":"reference/#pypaystack2.utils.Identification","text":"Bases: str , Enum Enum of Identification methods supported by paystack Source code in pypaystack2/utils.py 323 324 325 326 327 class Identification ( str , Enum ): \"\"\"Enum of Identification methods supported by paystack\"\"\" BVN = \"bvn\" BANK_ACCOUNT = \"bank_account\"","title":"Identification"},{"location":"reference/#pypaystack2.utils.Interval","text":"Bases: str , Enum Enum of intervals supported by paystack. Source code in pypaystack2/utils.py 248 249 250 251 252 253 254 255 class Interval ( str , Enum ): \"\"\"Enum of intervals supported by paystack.\"\"\" HOURLY = \"hourly\" DAILY = \"daily\" WEEKLY = \"weekly\" MONTHLY = \"monthly\" ANNUALLY = \"annually\"","title":"Interval"},{"location":"reference/#pypaystack2.utils.Reason","text":"Bases: str , Enum Enum of Reset OTP options Source code in pypaystack2/utils.py 367 368 369 370 371 372 class Reason ( str , Enum ): \"\"\"Enum of Reset OTP options\"\"\" RESEND_OTP = \"resend_otp\" TRANSFER = \"transfer\" DISABLE_OTP = \"disable_otp\"","title":"Reason"},{"location":"reference/#pypaystack2.utils.RecipientType","text":"Bases: str , Enum Enum of Transfer Recipient types Source code in pypaystack2/utils.py 330 331 332 333 334 335 class RecipientType ( str , Enum ): \"\"\"Enum of Transfer Recipient types\"\"\" NUBAN = \"nuban\" MOBILE_MONEY = \"mobile_money\" BASA = \"basa\"","title":"RecipientType"},{"location":"reference/#pypaystack2.utils.Resolution","text":"Bases: str , Enum Enum of Resolutions supported by paystack Source code in pypaystack2/utils.py 389 390 391 392 393 class Resolution ( str , Enum ): \"\"\"Enum of Resolutions supported by paystack\"\"\" MERCHANT_ACCEPTED = \"merchant-accepted\" DECLINED = \"declined\"","title":"Resolution"},{"location":"reference/#pypaystack2.utils.Response","text":"Bases: NamedTuple A namedtuple containing the data gotten from making a request to paystack's API endpoints. All wrapper methods returns an instance of Response which can be used as a tuple following this format (status_code, status, message, data) . Accessing by attributes is also possible say for example response is an instance of Response , we can access the data in the response like so response.data Attributes: Name Type Description status_code int The response status code status bool A flag for the response status message str Paystack response message data Optional [ Union [ dict [ str , Any ], list [ dict [ str , Any ]]]] Data sent from paystack's server if any. Source code in pypaystack2/utils.py 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 class Response ( NamedTuple ): \"\"\" A namedtuple containing the data gotten from making a request to paystack's API endpoints. All wrapper methods returns an instance of `Response` which can be used as a tuple following this format `(status_code, status, message, data)`. Accessing by attributes is also possible say for example `response` is an instance of `Response`, we can access the data in the response like so `response.data` Attributes: status_code: The response status code status: A flag for the response status message: Paystack response message data: Data sent from paystack's server if any. \"\"\" status_code : int status : bool message : str data : Optional [ Union [ dict [ str , Any ], list [ dict [ str , Any ]]]]","title":"Response"},{"location":"reference/#pypaystack2.utils.RiskAction","text":"Bases: str , Enum Enum of RiskActions supported by paystack Source code in pypaystack2/utils.py 315 316 317 318 319 320 class RiskAction ( str , Enum ): \"\"\"Enum of RiskActions supported by paystack\"\"\" DEFAULT = \"default\" WHITELIST = \"allow\" BLACKLIST = \"deny\"","title":"RiskAction"},{"location":"reference/#pypaystack2.utils.Schedule","text":"Bases: str , Enum Enum of settlement schedules supported by paystack Source code in pypaystack2/utils.py 358 359 360 361 362 363 364 class Schedule ( str , Enum ): \"\"\"Enum of settlement schedules supported by paystack\"\"\" AUTO = \"auto\" WEEKLY = \"weekly\" MONTHLY = \"monthly\" MANUAL = \"manual\"","title":"Schedule"},{"location":"reference/#pypaystack2.utils.Split","text":"Bases: str , Enum Enum of split types Source code in pypaystack2/utils.py 286 287 288 289 290 class Split ( str , Enum ): \"\"\"Enum of split types\"\"\" PERCENTAGE = \"percentage\" FLAT = \"flat\"","title":"Split"},{"location":"reference/#pypaystack2.utils.Status","text":"Bases: str , Enum Enum of statuses supported by paystack, used by Invoice, Charge & Plan Source code in pypaystack2/utils.py 350 351 352 353 354 355 class Status ( str , Enum ): \"\"\"Enum of statuses supported by paystack, used by Invoice, Charge & Plan\"\"\" PENDING = \"pending\" SUCCESS = \"success\" FAILED = \"failed\"","title":"Status"},{"location":"reference/#pypaystack2.utils.TerminalEvent","text":"Bases: str , Enum Enum of the types of events supported by Terminal API Source code in pypaystack2/utils.py 226 227 228 229 230 class TerminalEvent ( str , Enum ): \"\"\"Enum of the types of events supported by Terminal API\"\"\" TRANSACTION = \"transaction\" INVOICE = \"invoice\"","title":"TerminalEvent"},{"location":"reference/#pypaystack2.utils.TransactionStatus","text":"Bases: str , Enum Enum of transaction status Source code in pypaystack2/utils.py 278 279 280 281 282 283 class TransactionStatus ( str , Enum ): \"\"\"Enum of transaction status\"\"\" FAILED = \"failed\" SUCCESS = \"success\" ABANDONED = \"abandoned\"","title":"TransactionStatus"},{"location":"reference/#pypaystack2.utils.add_to_payload","text":"Adds more parameters to an existing payload. This is a utility is used in the generation of payloads for a request body. It helps to add more parameters to a payload if it is not None. e.g. say you want to send a payload which is currently {\"amount\": 20000} and you want to include an additional data such as currency if provided in the optional_params to send this {\"amount\": 20000,\"currency\":\"ngn\"} if only the currency is available otherwise send the initial payload. This functions takes a list of optional parameters which is added to the payload is they are available and returns the payload. Parameters: Name Type Description Default optional_params list [ tuple [ str , Any ]] A list of additional data to be added to the payload if it is available. It follows the format [(\"name-on-payload\",\"value\")]. e.g [(\"currency\",\"ngn\"),(\"amount\",2000)] required payload dict [ str , Any ] A dictionary containing the data to be sent in the request body. required Returns: Type Description dict [ str , Any ] A dictionary of the payload updated with additional data in the optional_params that are not None . Source code in pypaystack2/utils.py 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 def add_to_payload ( optional_params : list [ tuple [ str , Any ]], payload : dict [ str , Any ] ) -> dict [ str , Any ]: \"\"\"Adds more parameters to an existing payload. This is a utility is used in the generation of payloads for a request body. It helps to add more parameters to a payload if it is not None. e.g. say you want to send a payload which is currently ``{\"amount\": 20000}`` and you want to include an additional data such as ``currency`` if provided in the ``optional_params`` to send this ``{\"amount\": 20000,\"currency\":\"ngn\"}`` if only the currency is available otherwise send the initial payload. This functions takes a list of optional parameters which is added to the payload is they are available and returns the payload. Args: optional_params: A list of additional data to be added to the payload if it is available. It follows the format ``[(\"name-on-payload\",\"value\")].`` e.g ``[(\"currency\",\"ngn\"),(\"amount\",2000)]`` payload: A dictionary containing the data to be sent in the request body. Returns: A dictionary of the payload updated with additional data in the optional_params that are not `None`. \"\"\" [ payload . update ({ item [ 0 ]: item [ 1 ]}) for item in optional_params if item [ 1 ] is not None ] return payload","title":"add_to_payload()"},{"location":"reference/#pypaystack2.utils.append_query_params","text":"Adds more queries to url that already have query parameters in its suffix This function should only be used with urls that already have a query parameter suffixed to it because it makes that assumption that the url supplied is of the state http://example-url.com?firstQuery=1 and it adds more query parameters delimited by & to the end of the provided url http://example-url.com?firstQuery=1&otherQuery=2&... Parameters: Name Type Description Default query_params list [ tuple [ str , Any ]] A list of other query parameters that should be appended to the url if it is not None. e.g [(\"page\",2),(\"pagination\",50),(\"currency\",None)] -> url&page=2&pagination=50 required url str The url to which additional query parameters are added. required Returns: Type Description str The new url with padded query parameters. Source code in pypaystack2/utils.py 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 def append_query_params ( query_params : list [ tuple [ str , Any ]], url : str ) -> str : \"\"\"Adds more queries to url that already have query parameters in its suffix This function should only be used with urls that already have a query parameter suffixed to it because it makes that assumption that the url supplied is of the state ``http://example-url.com?firstQuery=1`` and it adds more query parameters delimited by & to the end of the provided url ``http://example-url.com?firstQuery=1&otherQuery=2&...`` Args: query_params: A list of other query parameters that should be appended to the url if it is not None. e.g ``[(\"page\",2),(\"pagination\",50),(\"currency\",None)]`` -> ``url&page=2&pagination=50`` url: The url to which additional query parameters are added. Returns: The new url with padded query parameters. \"\"\" params = [ f \"& { param [ 0 ] } = { param [ 1 ] } \" for param in query_params if param [ 1 ] is not None ] if len ( params ) == 0 : return url return url + reduce ( add , params )","title":"append_query_params()"},{"location":"reference/#pypaystack2.utils.validate_amount","text":"Helps to validate money amount. Helps to ensure that a valid amount of money is supplied as an input, to prevent cases where negative or zero value is provided as an amount. Parameters: Name Type Description Default amount Union [ int , float ] The money to be validated. required Returns: Type Description Union [ int , float ] The money supplied if it is valid. Raises: Type Description InvalidDataError With the cause of the validation error Source code in pypaystack2/utils.py 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 def validate_amount ( amount : Union [ int , float ]) -> Union [ int , float ]: \"\"\"Helps to validate money amount. Helps to ensure that a valid amount of money is supplied as an input, to prevent cases where negative or zero value is provided as an amount. Args: amount: The money to be validated. Returns: The money supplied if it is valid. Raises: InvalidDataError: With the cause of the validation error \"\"\" if not amount : raise InvalidDataError ( \"Amount to be charged is required\" ) if isinstance ( amount , int ) or isinstance ( amount , float ): # Save the sever some headaches if amount < 0 : raise InvalidDataError ( \"Negative amount is not allowed\" ) return amount else : raise InvalidDataError ( \"Amount should be a number\" )","title":"validate_amount()"},{"location":"reference/#pypaystack2.utils.validate_interval","text":"Validates that the interval supplied is supported by paystack Parameters: Name Type Description Default interval str any of the intervals supported by paystack i.e. hourly, daily weekly,monthly,annually required Returns: Type Description str The interval if it is a valid paystack interval Raises: Type Description InvalidDataError to provide feedback that an invalid interval was provided. Source code in pypaystack2/utils.py 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 def validate_interval ( interval : str ) -> str : \"\"\"Validates that the interval supplied is supported by paystack Args: interval: any of the intervals supported by paystack i.e. hourly, daily weekly,monthly,annually Returns: The interval if it is a valid paystack interval Raises: InvalidDataError: to provide feedback that an invalid interval was provided. \"\"\" interval = ( interval if interval . lower () in [ \"hourly\" , \"daily\" , \"weekly\" , \"monthly\" , \"annually\" ] else None ) if not interval : raise InvalidDataError ( \"Please provide a valid plan interval\" ) return interval","title":"validate_interval()"},{"location":"reference/#pypaystack2errors","text":"","title":"pypaystack2.errors"},{"location":"reference/#pypaystack2.errors.InvalidDataError","text":"Bases: PyPaystackError Invalid input recognised. Saves unnecessary request to the server Source code in pypaystack2/errors.py 25 26 27 28 29 30 class InvalidDataError ( PyPaystackError ): \"\"\" Invalid input recognised. Saves unnecessary request to the server \"\"\" pass","title":"InvalidDataError"},{"location":"reference/#pypaystack2.errors.InvalidMethodError","text":"Bases: PyPaystackError Invalid or unrecognized/unimplemented HTTP request method Source code in pypaystack2/errors.py 17 18 19 20 21 22 class InvalidMethodError ( PyPaystackError ): \"\"\" Invalid or unrecognized/unimplemented HTTP request method \"\"\" pass","title":"InvalidMethodError"},{"location":"reference/#pypaystack2.errors.MissingAuthKeyError","text":"Bases: PyPaystackError We can't find the authentication key Source code in pypaystack2/errors.py 9 10 11 12 13 14 class MissingAuthKeyError ( PyPaystackError ): \"\"\" We can't find the authentication key \"\"\" pass","title":"MissingAuthKeyError"},{"location":"reference/#pypaystack2.errors.PyPaystackError","text":"Bases: Exception Python Paystack Error Source code in pypaystack2/errors.py 1 2 3 4 5 6 class PyPaystackError ( Exception ): \"\"\" Python Paystack Error \"\"\" pass","title":"PyPaystackError"},{"location":"reference/apple_pay/","text":"ApplePay Bases: BaseAPI Provides a wrapper for paystack Apple Pay API The Apple Pay API allows you register your application's top-level domain or subdomain. Visit paystack api doc Source code in pypaystack2/api/apple_pay.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 class ApplePay ( BaseAPI ): \"\"\"Provides a wrapper for paystack Apple Pay API The Apple Pay API allows you register your application's top-level domain or subdomain. [Visit paystack api doc](https://paystack.com/docs/api/apple-pay/) \"\"\" def register_domain ( self , domain_name : str ) -> Response : \"\"\"Register a top-level domain or subdomain for your Apple Pay integration. This method can only be called with one domain or subdomain at a time. Args: domain_name: Domain name to be registered. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/apple-pay/domain\" ) payload = { \"domainName\" : domain_name , } return self . _handle_request ( HTTPMethod . POST , url , payload ) def get_domains ( self ) -> Response : \"\"\"Fetches all registered domains on your integration. Returns an empty array if no domains have been added. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/apple-pay/domain\" ) return self . _handle_request ( HTTPMethod . GET , url ) def unregister_domain ( self , domain_name : str ) -> Response : \"\"\"Unregister a top-level domain or subdomain previously used for your Apple Pay integration. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/apple-pay/domain\" ) payload = { \"domainName\" : domain_name , } # return self._handle_request(HTTPMethod.DELETE, url, payload) raise NotImplementedError ( \"The package `httpx` which PyPaystack uses to make REST \" \"API calls does not allow HTTPMethod.DELETE have a body\" ) get_domains () Fetches all registered domains on your integration. Returns an empty array if no domains have been added. Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/apple_pay.py 31 32 33 34 35 36 37 38 39 40 41 def get_domains ( self ) -> Response : \"\"\"Fetches all registered domains on your integration. Returns an empty array if no domains have been added. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/apple-pay/domain\" ) return self . _handle_request ( HTTPMethod . GET , url ) register_domain ( domain_name ) Register a top-level domain or subdomain for your Apple Pay integration. This method can only be called with one domain or subdomain at a time. Parameters: Name Type Description Default domain_name str Domain name to be registered. required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/apple_pay.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 def register_domain ( self , domain_name : str ) -> Response : \"\"\"Register a top-level domain or subdomain for your Apple Pay integration. This method can only be called with one domain or subdomain at a time. Args: domain_name: Domain name to be registered. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/apple-pay/domain\" ) payload = { \"domainName\" : domain_name , } return self . _handle_request ( HTTPMethod . POST , url , payload ) unregister_domain ( domain_name ) Unregister a top-level domain or subdomain previously used for your Apple Pay integration. Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/apple_pay.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 def unregister_domain ( self , domain_name : str ) -> Response : \"\"\"Unregister a top-level domain or subdomain previously used for your Apple Pay integration. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/apple-pay/domain\" ) payload = { \"domainName\" : domain_name , } # return self._handle_request(HTTPMethod.DELETE, url, payload) raise NotImplementedError ( \"The package `httpx` which PyPaystack uses to make REST \" \"API calls does not allow HTTPMethod.DELETE have a body\" ) AsyncApplePay Bases: BaseAsyncAPI Provides a wrapper for paystack Apple Pay API The Apple Pay API allows you register your application's top-level domain or subdomain. Visit paystack api doc Source code in pypaystack2/api/apple_pay.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 class AsyncApplePay ( BaseAsyncAPI ): \"\"\"Provides a wrapper for paystack Apple Pay API The Apple Pay API allows you register your application's top-level domain or subdomain. [Visit paystack api doc](https://paystack.com/docs/api/apple-pay/) \"\"\" async def register_domain ( self , domain_name : str ) -> Response : \"\"\"Register a top-level domain or subdomain for your Apple Pay integration. This method can only be called with one domain or subdomain at a time. Args: domain_name: Domain name to be registered. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/apple-pay/domain\" ) payload = { \"domainName\" : domain_name , } return await self . _handle_request ( HTTPMethod . POST , url , payload ) async def get_domains ( self ) -> Response : \"\"\"Fetches all registered domains on your integration. Returns an empty array if no domains have been added. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/apple-pay/domain\" ) return await self . _handle_request ( HTTPMethod . GET , url ) async def unregister_domain ( self , domain_name : str ) -> Response : \"\"\"Unregister a top-level domain or subdomain previously used for your Apple Pay integration. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/apple-pay/domain\" ) payload = { \"domainName\" : domain_name , } # return await self._handle_request(HTTPMethod.DELETE, url, payload) raise NotImplementedError ( \"The package `httpx` which PyPaystack uses to make REST \" \"API calls does not allow HTTPMethod.DELETE have a body\" ) get_domains () async Fetches all registered domains on your integration. Returns an empty array if no domains have been added. Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/apple_pay.py 86 87 88 89 90 91 92 93 94 95 96 async def get_domains ( self ) -> Response : \"\"\"Fetches all registered domains on your integration. Returns an empty array if no domains have been added. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/apple-pay/domain\" ) return await self . _handle_request ( HTTPMethod . GET , url ) register_domain ( domain_name ) async Register a top-level domain or subdomain for your Apple Pay integration. This method can only be called with one domain or subdomain at a time. Parameters: Name Type Description Default domain_name str Domain name to be registered. required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/apple_pay.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 async def register_domain ( self , domain_name : str ) -> Response : \"\"\"Register a top-level domain or subdomain for your Apple Pay integration. This method can only be called with one domain or subdomain at a time. Args: domain_name: Domain name to be registered. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/apple-pay/domain\" ) payload = { \"domainName\" : domain_name , } return await self . _handle_request ( HTTPMethod . POST , url , payload ) unregister_domain ( domain_name ) async Unregister a top-level domain or subdomain previously used for your Apple Pay integration. Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/apple_pay.py 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 async def unregister_domain ( self , domain_name : str ) -> Response : \"\"\"Unregister a top-level domain or subdomain previously used for your Apple Pay integration. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/apple-pay/domain\" ) payload = { \"domainName\" : domain_name , } # return await self._handle_request(HTTPMethod.DELETE, url, payload) raise NotImplementedError ( \"The package `httpx` which PyPaystack uses to make REST \" \"API calls does not allow HTTPMethod.DELETE have a body\" )","title":"Apple pay"},{"location":"reference/apple_pay/#pypaystack2.api.apple_pay.ApplePay","text":"Bases: BaseAPI Provides a wrapper for paystack Apple Pay API The Apple Pay API allows you register your application's top-level domain or subdomain. Visit paystack api doc Source code in pypaystack2/api/apple_pay.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 class ApplePay ( BaseAPI ): \"\"\"Provides a wrapper for paystack Apple Pay API The Apple Pay API allows you register your application's top-level domain or subdomain. [Visit paystack api doc](https://paystack.com/docs/api/apple-pay/) \"\"\" def register_domain ( self , domain_name : str ) -> Response : \"\"\"Register a top-level domain or subdomain for your Apple Pay integration. This method can only be called with one domain or subdomain at a time. Args: domain_name: Domain name to be registered. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/apple-pay/domain\" ) payload = { \"domainName\" : domain_name , } return self . _handle_request ( HTTPMethod . POST , url , payload ) def get_domains ( self ) -> Response : \"\"\"Fetches all registered domains on your integration. Returns an empty array if no domains have been added. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/apple-pay/domain\" ) return self . _handle_request ( HTTPMethod . GET , url ) def unregister_domain ( self , domain_name : str ) -> Response : \"\"\"Unregister a top-level domain or subdomain previously used for your Apple Pay integration. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/apple-pay/domain\" ) payload = { \"domainName\" : domain_name , } # return self._handle_request(HTTPMethod.DELETE, url, payload) raise NotImplementedError ( \"The package `httpx` which PyPaystack uses to make REST \" \"API calls does not allow HTTPMethod.DELETE have a body\" )","title":"ApplePay"},{"location":"reference/apple_pay/#pypaystack2.api.apple_pay.ApplePay.get_domains","text":"Fetches all registered domains on your integration. Returns an empty array if no domains have been added. Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/apple_pay.py 31 32 33 34 35 36 37 38 39 40 41 def get_domains ( self ) -> Response : \"\"\"Fetches all registered domains on your integration. Returns an empty array if no domains have been added. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/apple-pay/domain\" ) return self . _handle_request ( HTTPMethod . GET , url )","title":"get_domains()"},{"location":"reference/apple_pay/#pypaystack2.api.apple_pay.ApplePay.register_domain","text":"Register a top-level domain or subdomain for your Apple Pay integration. This method can only be called with one domain or subdomain at a time. Parameters: Name Type Description Default domain_name str Domain name to be registered. required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/apple_pay.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 def register_domain ( self , domain_name : str ) -> Response : \"\"\"Register a top-level domain or subdomain for your Apple Pay integration. This method can only be called with one domain or subdomain at a time. Args: domain_name: Domain name to be registered. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/apple-pay/domain\" ) payload = { \"domainName\" : domain_name , } return self . _handle_request ( HTTPMethod . POST , url , payload )","title":"register_domain()"},{"location":"reference/apple_pay/#pypaystack2.api.apple_pay.ApplePay.unregister_domain","text":"Unregister a top-level domain or subdomain previously used for your Apple Pay integration. Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/apple_pay.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 def unregister_domain ( self , domain_name : str ) -> Response : \"\"\"Unregister a top-level domain or subdomain previously used for your Apple Pay integration. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/apple-pay/domain\" ) payload = { \"domainName\" : domain_name , } # return self._handle_request(HTTPMethod.DELETE, url, payload) raise NotImplementedError ( \"The package `httpx` which PyPaystack uses to make REST \" \"API calls does not allow HTTPMethod.DELETE have a body\" )","title":"unregister_domain()"},{"location":"reference/apple_pay/#pypaystack2.api.apple_pay.AsyncApplePay","text":"Bases: BaseAsyncAPI Provides a wrapper for paystack Apple Pay API The Apple Pay API allows you register your application's top-level domain or subdomain. Visit paystack api doc Source code in pypaystack2/api/apple_pay.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 class AsyncApplePay ( BaseAsyncAPI ): \"\"\"Provides a wrapper for paystack Apple Pay API The Apple Pay API allows you register your application's top-level domain or subdomain. [Visit paystack api doc](https://paystack.com/docs/api/apple-pay/) \"\"\" async def register_domain ( self , domain_name : str ) -> Response : \"\"\"Register a top-level domain or subdomain for your Apple Pay integration. This method can only be called with one domain or subdomain at a time. Args: domain_name: Domain name to be registered. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/apple-pay/domain\" ) payload = { \"domainName\" : domain_name , } return await self . _handle_request ( HTTPMethod . POST , url , payload ) async def get_domains ( self ) -> Response : \"\"\"Fetches all registered domains on your integration. Returns an empty array if no domains have been added. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/apple-pay/domain\" ) return await self . _handle_request ( HTTPMethod . GET , url ) async def unregister_domain ( self , domain_name : str ) -> Response : \"\"\"Unregister a top-level domain or subdomain previously used for your Apple Pay integration. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/apple-pay/domain\" ) payload = { \"domainName\" : domain_name , } # return await self._handle_request(HTTPMethod.DELETE, url, payload) raise NotImplementedError ( \"The package `httpx` which PyPaystack uses to make REST \" \"API calls does not allow HTTPMethod.DELETE have a body\" )","title":"AsyncApplePay"},{"location":"reference/apple_pay/#pypaystack2.api.apple_pay.AsyncApplePay.get_domains","text":"Fetches all registered domains on your integration. Returns an empty array if no domains have been added. Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/apple_pay.py 86 87 88 89 90 91 92 93 94 95 96 async def get_domains ( self ) -> Response : \"\"\"Fetches all registered domains on your integration. Returns an empty array if no domains have been added. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/apple-pay/domain\" ) return await self . _handle_request ( HTTPMethod . GET , url )","title":"get_domains()"},{"location":"reference/apple_pay/#pypaystack2.api.apple_pay.AsyncApplePay.register_domain","text":"Register a top-level domain or subdomain for your Apple Pay integration. This method can only be called with one domain or subdomain at a time. Parameters: Name Type Description Default domain_name str Domain name to be registered. required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/apple_pay.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 async def register_domain ( self , domain_name : str ) -> Response : \"\"\"Register a top-level domain or subdomain for your Apple Pay integration. This method can only be called with one domain or subdomain at a time. Args: domain_name: Domain name to be registered. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/apple-pay/domain\" ) payload = { \"domainName\" : domain_name , } return await self . _handle_request ( HTTPMethod . POST , url , payload )","title":"register_domain()"},{"location":"reference/apple_pay/#pypaystack2.api.apple_pay.AsyncApplePay.unregister_domain","text":"Unregister a top-level domain or subdomain previously used for your Apple Pay integration. Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/apple_pay.py 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 async def unregister_domain ( self , domain_name : str ) -> Response : \"\"\"Unregister a top-level domain or subdomain previously used for your Apple Pay integration. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/apple-pay/domain\" ) payload = { \"domainName\" : domain_name , } # return await self._handle_request(HTTPMethod.DELETE, url, payload) raise NotImplementedError ( \"The package `httpx` which PyPaystack uses to make REST \" \"API calls does not allow HTTPMethod.DELETE have a body\" )","title":"unregister_domain()"},{"location":"reference/bulk_charges/","text":"AsyncBulkCharge Bases: BaseAsyncAPI Provides a wrapper for paystack Bulk Charge API The Bulk Charges API allows you to create and manage multiple recurring payments from your customers. https://paystack.com/docs/api/bulk-charge/ Source code in pypaystack2/api/bulk_charges.py 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 class AsyncBulkCharge ( BaseAsyncAPI ): \"\"\"Provides a wrapper for paystack Bulk Charge API The Bulk Charges API allows you to create and manage multiple recurring payments from your customers. [https://paystack.com/docs/api/bulk-charge/](https://paystack.com/docs/api/bulk-charge/) \"\"\" async def initiate ( self , body : list [ BulkChargeInstruction ]) -> Response : \"\"\" Send a list of dictionaries with authorization ``codes`` and ``amount`` (in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR ) so paystack can process transactions as a batch. Args: body: A list of BulkChargeInstruction. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/bulkcharge\" ) payload = [ item . dict for item in body ] return await self . _handle_request ( HTTPMethod . POST , url , payload ) async def get_batches ( self , page : int = 1 , pagination : int = 50 , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , ) -> Response : \"\"\"This gets all bulk charge batches created by the integration. Args: page: Specify exactly what transfer you want to page. If not specified, we use a default value of 1. pagination: Specify how many records you want to retrieve per page. If not specified we use a default value of 50. start_date: A timestamp from which to start listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/bulkcharge?perPage= { pagination } \" ) query_params = [ ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url ) async def get_batch ( self , id_or_code : str ) -> Response : \"\"\" This method retrieves a specific batch code. It also returns useful information on its progress by way of the total_charges and pending_charges attributes in the Response. Args: id_or_code: An ID or code for the charge whose batches you want to retrieve. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/bulkcharge/ { id_or_code } \" ) return await self . _handle_request ( HTTPMethod . GET , url ) async def get_charges_in_batch ( self , id_or_code : str , status : Status , pagination : int = 50 , page : int = 1 , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , ) -> Response : \"\"\" This method retrieves the charges associated with a specified batch code. Pagination parameters are available. You can also filter by status. Charge statuses can be `Status.PENDING`, `Status.SUCCESS` or `Status.FAILED`. Args: id_or_code: An ID or code for the batch whose charges you want to retrieve. status: Any of the values from the Status enum. pagination: Specify how many records you want to retrieve per page. If not specified we use a default value of 50. page: Specify exactly what transfer you want to page. If not specified we use a default value of 1. start_date: A timestamp from which to start listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/bulkcharge/ { id_or_code } /charges?perPage= { pagination } \" ) query_params = [ ( \"status\" , status ), ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url ) async def pause_batch ( self , batch_code : str ) -> Response : \"\"\"Use this method to pause processing a batch. Args: batch_code: The batch code for the bulk charge you want to pause. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/bulkcharge/pause/ { batch_code } \" ) return await self . _handle_request ( HTTPMethod . GET , url ) async def resume_batch ( self , batch_code : str ) -> Response : \"\"\"Use this method to resume processing a batch Args: batch_code: The batch code for the bulk charge you want to resume. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/bulkcharge/resume/ { batch_code } \" ) return await self . _handle_request ( HTTPMethod . GET , url ) get_batch ( id_or_code ) async This method retrieves a specific batch code. It also returns useful information on its progress by way of the total_charges and pending_charges attributes in the Response. Parameters: Name Type Description Default id_or_code str An ID or code for the charge whose batches you want to retrieve. required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/bulk_charges.py 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 async def get_batch ( self , id_or_code : str ) -> Response : \"\"\" This method retrieves a specific batch code. It also returns useful information on its progress by way of the total_charges and pending_charges attributes in the Response. Args: id_or_code: An ID or code for the charge whose batches you want to retrieve. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/bulkcharge/ { id_or_code } \" ) return await self . _handle_request ( HTTPMethod . GET , url ) get_batches ( page = 1 , pagination = 50 , start_date = None , end_date = None ) async This gets all bulk charge batches created by the integration. Parameters: Name Type Description Default page int Specify exactly what transfer you want to page. If not specified, we use a default value of 1. 1 pagination int Specify how many records you want to retrieve per page. If not specified we use a default value of 50. 50 start_date Optional [ str ] A timestamp from which to start listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None end_date Optional [ str ] A timestamp at which to stop listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/bulk_charges.py 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 async def get_batches ( self , page : int = 1 , pagination : int = 50 , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , ) -> Response : \"\"\"This gets all bulk charge batches created by the integration. Args: page: Specify exactly what transfer you want to page. If not specified, we use a default value of 1. pagination: Specify how many records you want to retrieve per page. If not specified we use a default value of 50. start_date: A timestamp from which to start listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/bulkcharge?perPage= { pagination } \" ) query_params = [ ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url ) get_charges_in_batch ( id_or_code , status , pagination = 50 , page = 1 , start_date = None , end_date = None ) async This method retrieves the charges associated with a specified batch code. Pagination parameters are available. You can also filter by status. Charge statuses can be Status.PENDING , Status.SUCCESS or Status.FAILED . Parameters: Name Type Description Default id_or_code str An ID or code for the batch whose charges you want to retrieve. required status Status Any of the values from the Status enum. required pagination int Specify how many records you want to retrieve per page. If not specified we use a default value of 50. 50 page int Specify exactly what transfer you want to page. If not specified we use a default value of 1. 1 start_date Optional [ str ] A timestamp from which to start listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None end_date Optional [ str ] A timestamp at which to stop listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/bulk_charges.py 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 async def get_charges_in_batch ( self , id_or_code : str , status : Status , pagination : int = 50 , page : int = 1 , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , ) -> Response : \"\"\" This method retrieves the charges associated with a specified batch code. Pagination parameters are available. You can also filter by status. Charge statuses can be `Status.PENDING`, `Status.SUCCESS` or `Status.FAILED`. Args: id_or_code: An ID or code for the batch whose charges you want to retrieve. status: Any of the values from the Status enum. pagination: Specify how many records you want to retrieve per page. If not specified we use a default value of 50. page: Specify exactly what transfer you want to page. If not specified we use a default value of 1. start_date: A timestamp from which to start listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/bulkcharge/ { id_or_code } /charges?perPage= { pagination } \" ) query_params = [ ( \"status\" , status ), ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url ) initiate ( body ) async Send a list of dictionaries with authorization codes and amount (in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR ) so paystack can process transactions as a batch. Parameters: Name Type Description Default body list [ BulkChargeInstruction ] A list of BulkChargeInstruction. required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/bulk_charges.py 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 async def initiate ( self , body : list [ BulkChargeInstruction ]) -> Response : \"\"\" Send a list of dictionaries with authorization ``codes`` and ``amount`` (in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR ) so paystack can process transactions as a batch. Args: body: A list of BulkChargeInstruction. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/bulkcharge\" ) payload = [ item . dict for item in body ] return await self . _handle_request ( HTTPMethod . POST , url , payload ) pause_batch ( batch_code ) async Use this method to pause processing a batch. Parameters: Name Type Description Default batch_code str The batch code for the bulk charge you want to pause. required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/bulk_charges.py 254 255 256 257 258 259 260 261 262 263 264 265 async def pause_batch ( self , batch_code : str ) -> Response : \"\"\"Use this method to pause processing a batch. Args: batch_code: The batch code for the bulk charge you want to pause. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/bulkcharge/pause/ { batch_code } \" ) return await self . _handle_request ( HTTPMethod . GET , url ) resume_batch ( batch_code ) async Use this method to resume processing a batch Parameters: Name Type Description Default batch_code str The batch code for the bulk charge you want to resume. required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/bulk_charges.py 267 268 269 270 271 272 273 274 275 276 277 278 async def resume_batch ( self , batch_code : str ) -> Response : \"\"\"Use this method to resume processing a batch Args: batch_code: The batch code for the bulk charge you want to resume. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/bulkcharge/resume/ { batch_code } \" ) return await self . _handle_request ( HTTPMethod . GET , url ) BulkCharge Bases: BaseAPI Provides a wrapper for paystack Bulk Charge API The Bulk Charges API allows you to create and manage multiple recurring payments from your customers. https://paystack.com/docs/api/bulk-charge/ Source code in pypaystack2/api/bulk_charges.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 class BulkCharge ( BaseAPI ): \"\"\"Provides a wrapper for paystack Bulk Charge API The Bulk Charges API allows you to create and manage multiple recurring payments from your customers. [https://paystack.com/docs/api/bulk-charge/](https://paystack.com/docs/api/bulk-charge/) \"\"\" def initiate ( self , body : list [ BulkChargeInstruction ]) -> Response : \"\"\" Send a list of dictionaries with authorization ``codes`` and ``amount`` (in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR ) so paystack can process transactions as a batch. Args: body: A list of BulkChargeInstruction. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/bulkcharge\" ) payload = [ item . dict for item in body ] return self . _handle_request ( HTTPMethod . POST , url , payload ) def get_batches ( self , page : int = 1 , pagination : int = 50 , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , ) -> Response : \"\"\"This gets all bulk charge batches created by the integration. Args: page: Specify exactly what transfer you want to page. If not specified, we use a default value of 1. pagination: Specify how many records you want to retrieve per page. If not specified we use a default value of 50. start_date: A timestamp from which to start listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/bulkcharge?perPage= { pagination } \" ) query_params = [ ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url ) def get_batch ( self , id_or_code : str ) -> Response : \"\"\" This method retrieves a specific batch code. It also returns useful information on its progress by way of the total_charges and pending_charges attributes in the Response. Args: id_or_code: An ID or code for the charge whose batches you want to retrieve. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/bulkcharge/ { id_or_code } \" ) return self . _handle_request ( HTTPMethod . GET , url ) def get_charges_in_batch ( self , id_or_code : str , status : Status , pagination : int = 50 , page : int = 1 , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , ) -> Response : \"\"\" This method retrieves the charges associated with a specified batch code. Pagination parameters are available. You can also filter by status. Charge statuses can be `Status.PENDING`, `Status.SUCCESS` or `Status.FAILED`. Args: id_or_code: An ID or code for the batch whose charges you want to retrieve. status: Any of the values from the Status enum. pagination: Specify how many records you want to retrieve per page. If not specified we use a default value of 50. page: Specify exactly what transfer you want to page. If not specified we use a default value of 1. start_date: A timestamp from which to start listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/bulkcharge/ { id_or_code } /charges?perPage= { pagination } \" ) query_params = [ ( \"status\" , status ), ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url ) def pause_batch ( self , batch_code : str ) -> Response : \"\"\"Use this method to pause processing a batch. Args: batch_code: The batch code for the bulk charge you want to pause. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/bulkcharge/pause/ { batch_code } \" ) return self . _handle_request ( HTTPMethod . GET , url ) def resume_batch ( self , batch_code : str ) -> Response : \"\"\"Use this method to resume processing a batch Args: batch_code: The batch code for the bulk charge you want to resume. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/bulkcharge/resume/ { batch_code } \" ) return self . _handle_request ( HTTPMethod . GET , url ) get_batch ( id_or_code ) This method retrieves a specific batch code. It also returns useful information on its progress by way of the total_charges and pending_charges attributes in the Response. Parameters: Name Type Description Default id_or_code str An ID or code for the charge whose batches you want to retrieve. required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/bulk_charges.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 def get_batch ( self , id_or_code : str ) -> Response : \"\"\" This method retrieves a specific batch code. It also returns useful information on its progress by way of the total_charges and pending_charges attributes in the Response. Args: id_or_code: An ID or code for the charge whose batches you want to retrieve. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/bulkcharge/ { id_or_code } \" ) return self . _handle_request ( HTTPMethod . GET , url ) get_batches ( page = 1 , pagination = 50 , start_date = None , end_date = None ) This gets all bulk charge batches created by the integration. Parameters: Name Type Description Default page int Specify exactly what transfer you want to page. If not specified, we use a default value of 1. 1 pagination int Specify how many records you want to retrieve per page. If not specified we use a default value of 50. 50 start_date Optional [ str ] A timestamp from which to start listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None end_date Optional [ str ] A timestamp at which to stop listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/bulk_charges.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 def get_batches ( self , page : int = 1 , pagination : int = 50 , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , ) -> Response : \"\"\"This gets all bulk charge batches created by the integration. Args: page: Specify exactly what transfer you want to page. If not specified, we use a default value of 1. pagination: Specify how many records you want to retrieve per page. If not specified we use a default value of 50. start_date: A timestamp from which to start listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/bulkcharge?perPage= { pagination } \" ) query_params = [ ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url ) get_charges_in_batch ( id_or_code , status , pagination = 50 , page = 1 , start_date = None , end_date = None ) This method retrieves the charges associated with a specified batch code. Pagination parameters are available. You can also filter by status. Charge statuses can be Status.PENDING , Status.SUCCESS or Status.FAILED . Parameters: Name Type Description Default id_or_code str An ID or code for the batch whose charges you want to retrieve. required status Status Any of the values from the Status enum. required pagination int Specify how many records you want to retrieve per page. If not specified we use a default value of 50. 50 page int Specify exactly what transfer you want to page. If not specified we use a default value of 1. 1 start_date Optional [ str ] A timestamp from which to start listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None end_date Optional [ str ] A timestamp at which to stop listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/bulk_charges.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 def get_charges_in_batch ( self , id_or_code : str , status : Status , pagination : int = 50 , page : int = 1 , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , ) -> Response : \"\"\" This method retrieves the charges associated with a specified batch code. Pagination parameters are available. You can also filter by status. Charge statuses can be `Status.PENDING`, `Status.SUCCESS` or `Status.FAILED`. Args: id_or_code: An ID or code for the batch whose charges you want to retrieve. status: Any of the values from the Status enum. pagination: Specify how many records you want to retrieve per page. If not specified we use a default value of 50. page: Specify exactly what transfer you want to page. If not specified we use a default value of 1. start_date: A timestamp from which to start listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/bulkcharge/ { id_or_code } /charges?perPage= { pagination } \" ) query_params = [ ( \"status\" , status ), ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url ) initiate ( body ) Send a list of dictionaries with authorization codes and amount (in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR ) so paystack can process transactions as a batch. Parameters: Name Type Description Default body list [ BulkChargeInstruction ] A list of BulkChargeInstruction. required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/bulk_charges.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 def initiate ( self , body : list [ BulkChargeInstruction ]) -> Response : \"\"\" Send a list of dictionaries with authorization ``codes`` and ``amount`` (in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR ) so paystack can process transactions as a batch. Args: body: A list of BulkChargeInstruction. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/bulkcharge\" ) payload = [ item . dict for item in body ] return self . _handle_request ( HTTPMethod . POST , url , payload ) pause_batch ( batch_code ) Use this method to pause processing a batch. Parameters: Name Type Description Default batch_code str The batch code for the bulk charge you want to pause. required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/bulk_charges.py 120 121 122 123 124 125 126 127 128 129 130 131 def pause_batch ( self , batch_code : str ) -> Response : \"\"\"Use this method to pause processing a batch. Args: batch_code: The batch code for the bulk charge you want to pause. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/bulkcharge/pause/ { batch_code } \" ) return self . _handle_request ( HTTPMethod . GET , url ) resume_batch ( batch_code ) Use this method to resume processing a batch Parameters: Name Type Description Default batch_code str The batch code for the bulk charge you want to resume. required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/bulk_charges.py 133 134 135 136 137 138 139 140 141 142 143 144 def resume_batch ( self , batch_code : str ) -> Response : \"\"\"Use this method to resume processing a batch Args: batch_code: The batch code for the bulk charge you want to resume. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/bulkcharge/resume/ { batch_code } \" ) return self . _handle_request ( HTTPMethod . GET , url )","title":"Bulk charges"},{"location":"reference/bulk_charges/#pypaystack2.api.bulk_charges.AsyncBulkCharge","text":"Bases: BaseAsyncAPI Provides a wrapper for paystack Bulk Charge API The Bulk Charges API allows you to create and manage multiple recurring payments from your customers. https://paystack.com/docs/api/bulk-charge/ Source code in pypaystack2/api/bulk_charges.py 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 class AsyncBulkCharge ( BaseAsyncAPI ): \"\"\"Provides a wrapper for paystack Bulk Charge API The Bulk Charges API allows you to create and manage multiple recurring payments from your customers. [https://paystack.com/docs/api/bulk-charge/](https://paystack.com/docs/api/bulk-charge/) \"\"\" async def initiate ( self , body : list [ BulkChargeInstruction ]) -> Response : \"\"\" Send a list of dictionaries with authorization ``codes`` and ``amount`` (in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR ) so paystack can process transactions as a batch. Args: body: A list of BulkChargeInstruction. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/bulkcharge\" ) payload = [ item . dict for item in body ] return await self . _handle_request ( HTTPMethod . POST , url , payload ) async def get_batches ( self , page : int = 1 , pagination : int = 50 , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , ) -> Response : \"\"\"This gets all bulk charge batches created by the integration. Args: page: Specify exactly what transfer you want to page. If not specified, we use a default value of 1. pagination: Specify how many records you want to retrieve per page. If not specified we use a default value of 50. start_date: A timestamp from which to start listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/bulkcharge?perPage= { pagination } \" ) query_params = [ ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url ) async def get_batch ( self , id_or_code : str ) -> Response : \"\"\" This method retrieves a specific batch code. It also returns useful information on its progress by way of the total_charges and pending_charges attributes in the Response. Args: id_or_code: An ID or code for the charge whose batches you want to retrieve. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/bulkcharge/ { id_or_code } \" ) return await self . _handle_request ( HTTPMethod . GET , url ) async def get_charges_in_batch ( self , id_or_code : str , status : Status , pagination : int = 50 , page : int = 1 , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , ) -> Response : \"\"\" This method retrieves the charges associated with a specified batch code. Pagination parameters are available. You can also filter by status. Charge statuses can be `Status.PENDING`, `Status.SUCCESS` or `Status.FAILED`. Args: id_or_code: An ID or code for the batch whose charges you want to retrieve. status: Any of the values from the Status enum. pagination: Specify how many records you want to retrieve per page. If not specified we use a default value of 50. page: Specify exactly what transfer you want to page. If not specified we use a default value of 1. start_date: A timestamp from which to start listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/bulkcharge/ { id_or_code } /charges?perPage= { pagination } \" ) query_params = [ ( \"status\" , status ), ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url ) async def pause_batch ( self , batch_code : str ) -> Response : \"\"\"Use this method to pause processing a batch. Args: batch_code: The batch code for the bulk charge you want to pause. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/bulkcharge/pause/ { batch_code } \" ) return await self . _handle_request ( HTTPMethod . GET , url ) async def resume_batch ( self , batch_code : str ) -> Response : \"\"\"Use this method to resume processing a batch Args: batch_code: The batch code for the bulk charge you want to resume. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/bulkcharge/resume/ { batch_code } \" ) return await self . _handle_request ( HTTPMethod . GET , url )","title":"AsyncBulkCharge"},{"location":"reference/bulk_charges/#pypaystack2.api.bulk_charges.AsyncBulkCharge.get_batch","text":"This method retrieves a specific batch code. It also returns useful information on its progress by way of the total_charges and pending_charges attributes in the Response. Parameters: Name Type Description Default id_or_code str An ID or code for the charge whose batches you want to retrieve. required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/bulk_charges.py 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 async def get_batch ( self , id_or_code : str ) -> Response : \"\"\" This method retrieves a specific batch code. It also returns useful information on its progress by way of the total_charges and pending_charges attributes in the Response. Args: id_or_code: An ID or code for the charge whose batches you want to retrieve. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/bulkcharge/ { id_or_code } \" ) return await self . _handle_request ( HTTPMethod . GET , url )","title":"get_batch()"},{"location":"reference/bulk_charges/#pypaystack2.api.bulk_charges.AsyncBulkCharge.get_batches","text":"This gets all bulk charge batches created by the integration. Parameters: Name Type Description Default page int Specify exactly what transfer you want to page. If not specified, we use a default value of 1. 1 pagination int Specify how many records you want to retrieve per page. If not specified we use a default value of 50. 50 start_date Optional [ str ] A timestamp from which to start listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None end_date Optional [ str ] A timestamp at which to stop listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/bulk_charges.py 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 async def get_batches ( self , page : int = 1 , pagination : int = 50 , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , ) -> Response : \"\"\"This gets all bulk charge batches created by the integration. Args: page: Specify exactly what transfer you want to page. If not specified, we use a default value of 1. pagination: Specify how many records you want to retrieve per page. If not specified we use a default value of 50. start_date: A timestamp from which to start listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/bulkcharge?perPage= { pagination } \" ) query_params = [ ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url )","title":"get_batches()"},{"location":"reference/bulk_charges/#pypaystack2.api.bulk_charges.AsyncBulkCharge.get_charges_in_batch","text":"This method retrieves the charges associated with a specified batch code. Pagination parameters are available. You can also filter by status. Charge statuses can be Status.PENDING , Status.SUCCESS or Status.FAILED . Parameters: Name Type Description Default id_or_code str An ID or code for the batch whose charges you want to retrieve. required status Status Any of the values from the Status enum. required pagination int Specify how many records you want to retrieve per page. If not specified we use a default value of 50. 50 page int Specify exactly what transfer you want to page. If not specified we use a default value of 1. 1 start_date Optional [ str ] A timestamp from which to start listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None end_date Optional [ str ] A timestamp at which to stop listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/bulk_charges.py 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 async def get_charges_in_batch ( self , id_or_code : str , status : Status , pagination : int = 50 , page : int = 1 , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , ) -> Response : \"\"\" This method retrieves the charges associated with a specified batch code. Pagination parameters are available. You can also filter by status. Charge statuses can be `Status.PENDING`, `Status.SUCCESS` or `Status.FAILED`. Args: id_or_code: An ID or code for the batch whose charges you want to retrieve. status: Any of the values from the Status enum. pagination: Specify how many records you want to retrieve per page. If not specified we use a default value of 50. page: Specify exactly what transfer you want to page. If not specified we use a default value of 1. start_date: A timestamp from which to start listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/bulkcharge/ { id_or_code } /charges?perPage= { pagination } \" ) query_params = [ ( \"status\" , status ), ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url )","title":"get_charges_in_batch()"},{"location":"reference/bulk_charges/#pypaystack2.api.bulk_charges.AsyncBulkCharge.initiate","text":"Send a list of dictionaries with authorization codes and amount (in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR ) so paystack can process transactions as a batch. Parameters: Name Type Description Default body list [ BulkChargeInstruction ] A list of BulkChargeInstruction. required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/bulk_charges.py 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 async def initiate ( self , body : list [ BulkChargeInstruction ]) -> Response : \"\"\" Send a list of dictionaries with authorization ``codes`` and ``amount`` (in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR ) so paystack can process transactions as a batch. Args: body: A list of BulkChargeInstruction. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/bulkcharge\" ) payload = [ item . dict for item in body ] return await self . _handle_request ( HTTPMethod . POST , url , payload )","title":"initiate()"},{"location":"reference/bulk_charges/#pypaystack2.api.bulk_charges.AsyncBulkCharge.pause_batch","text":"Use this method to pause processing a batch. Parameters: Name Type Description Default batch_code str The batch code for the bulk charge you want to pause. required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/bulk_charges.py 254 255 256 257 258 259 260 261 262 263 264 265 async def pause_batch ( self , batch_code : str ) -> Response : \"\"\"Use this method to pause processing a batch. Args: batch_code: The batch code for the bulk charge you want to pause. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/bulkcharge/pause/ { batch_code } \" ) return await self . _handle_request ( HTTPMethod . GET , url )","title":"pause_batch()"},{"location":"reference/bulk_charges/#pypaystack2.api.bulk_charges.AsyncBulkCharge.resume_batch","text":"Use this method to resume processing a batch Parameters: Name Type Description Default batch_code str The batch code for the bulk charge you want to resume. required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/bulk_charges.py 267 268 269 270 271 272 273 274 275 276 277 278 async def resume_batch ( self , batch_code : str ) -> Response : \"\"\"Use this method to resume processing a batch Args: batch_code: The batch code for the bulk charge you want to resume. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/bulkcharge/resume/ { batch_code } \" ) return await self . _handle_request ( HTTPMethod . GET , url )","title":"resume_batch()"},{"location":"reference/bulk_charges/#pypaystack2.api.bulk_charges.BulkCharge","text":"Bases: BaseAPI Provides a wrapper for paystack Bulk Charge API The Bulk Charges API allows you to create and manage multiple recurring payments from your customers. https://paystack.com/docs/api/bulk-charge/ Source code in pypaystack2/api/bulk_charges.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 class BulkCharge ( BaseAPI ): \"\"\"Provides a wrapper for paystack Bulk Charge API The Bulk Charges API allows you to create and manage multiple recurring payments from your customers. [https://paystack.com/docs/api/bulk-charge/](https://paystack.com/docs/api/bulk-charge/) \"\"\" def initiate ( self , body : list [ BulkChargeInstruction ]) -> Response : \"\"\" Send a list of dictionaries with authorization ``codes`` and ``amount`` (in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR ) so paystack can process transactions as a batch. Args: body: A list of BulkChargeInstruction. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/bulkcharge\" ) payload = [ item . dict for item in body ] return self . _handle_request ( HTTPMethod . POST , url , payload ) def get_batches ( self , page : int = 1 , pagination : int = 50 , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , ) -> Response : \"\"\"This gets all bulk charge batches created by the integration. Args: page: Specify exactly what transfer you want to page. If not specified, we use a default value of 1. pagination: Specify how many records you want to retrieve per page. If not specified we use a default value of 50. start_date: A timestamp from which to start listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/bulkcharge?perPage= { pagination } \" ) query_params = [ ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url ) def get_batch ( self , id_or_code : str ) -> Response : \"\"\" This method retrieves a specific batch code. It also returns useful information on its progress by way of the total_charges and pending_charges attributes in the Response. Args: id_or_code: An ID or code for the charge whose batches you want to retrieve. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/bulkcharge/ { id_or_code } \" ) return self . _handle_request ( HTTPMethod . GET , url ) def get_charges_in_batch ( self , id_or_code : str , status : Status , pagination : int = 50 , page : int = 1 , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , ) -> Response : \"\"\" This method retrieves the charges associated with a specified batch code. Pagination parameters are available. You can also filter by status. Charge statuses can be `Status.PENDING`, `Status.SUCCESS` or `Status.FAILED`. Args: id_or_code: An ID or code for the batch whose charges you want to retrieve. status: Any of the values from the Status enum. pagination: Specify how many records you want to retrieve per page. If not specified we use a default value of 50. page: Specify exactly what transfer you want to page. If not specified we use a default value of 1. start_date: A timestamp from which to start listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/bulkcharge/ { id_or_code } /charges?perPage= { pagination } \" ) query_params = [ ( \"status\" , status ), ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url ) def pause_batch ( self , batch_code : str ) -> Response : \"\"\"Use this method to pause processing a batch. Args: batch_code: The batch code for the bulk charge you want to pause. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/bulkcharge/pause/ { batch_code } \" ) return self . _handle_request ( HTTPMethod . GET , url ) def resume_batch ( self , batch_code : str ) -> Response : \"\"\"Use this method to resume processing a batch Args: batch_code: The batch code for the bulk charge you want to resume. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/bulkcharge/resume/ { batch_code } \" ) return self . _handle_request ( HTTPMethod . GET , url )","title":"BulkCharge"},{"location":"reference/bulk_charges/#pypaystack2.api.bulk_charges.BulkCharge.get_batch","text":"This method retrieves a specific batch code. It also returns useful information on its progress by way of the total_charges and pending_charges attributes in the Response. Parameters: Name Type Description Default id_or_code str An ID or code for the charge whose batches you want to retrieve. required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/bulk_charges.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 def get_batch ( self , id_or_code : str ) -> Response : \"\"\" This method retrieves a specific batch code. It also returns useful information on its progress by way of the total_charges and pending_charges attributes in the Response. Args: id_or_code: An ID or code for the charge whose batches you want to retrieve. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/bulkcharge/ { id_or_code } \" ) return self . _handle_request ( HTTPMethod . GET , url )","title":"get_batch()"},{"location":"reference/bulk_charges/#pypaystack2.api.bulk_charges.BulkCharge.get_batches","text":"This gets all bulk charge batches created by the integration. Parameters: Name Type Description Default page int Specify exactly what transfer you want to page. If not specified, we use a default value of 1. 1 pagination int Specify how many records you want to retrieve per page. If not specified we use a default value of 50. 50 start_date Optional [ str ] A timestamp from which to start listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None end_date Optional [ str ] A timestamp at which to stop listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/bulk_charges.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 def get_batches ( self , page : int = 1 , pagination : int = 50 , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , ) -> Response : \"\"\"This gets all bulk charge batches created by the integration. Args: page: Specify exactly what transfer you want to page. If not specified, we use a default value of 1. pagination: Specify how many records you want to retrieve per page. If not specified we use a default value of 50. start_date: A timestamp from which to start listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/bulkcharge?perPage= { pagination } \" ) query_params = [ ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url )","title":"get_batches()"},{"location":"reference/bulk_charges/#pypaystack2.api.bulk_charges.BulkCharge.get_charges_in_batch","text":"This method retrieves the charges associated with a specified batch code. Pagination parameters are available. You can also filter by status. Charge statuses can be Status.PENDING , Status.SUCCESS or Status.FAILED . Parameters: Name Type Description Default id_or_code str An ID or code for the batch whose charges you want to retrieve. required status Status Any of the values from the Status enum. required pagination int Specify how many records you want to retrieve per page. If not specified we use a default value of 50. 50 page int Specify exactly what transfer you want to page. If not specified we use a default value of 1. 1 start_date Optional [ str ] A timestamp from which to start listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None end_date Optional [ str ] A timestamp at which to stop listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/bulk_charges.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 def get_charges_in_batch ( self , id_or_code : str , status : Status , pagination : int = 50 , page : int = 1 , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , ) -> Response : \"\"\" This method retrieves the charges associated with a specified batch code. Pagination parameters are available. You can also filter by status. Charge statuses can be `Status.PENDING`, `Status.SUCCESS` or `Status.FAILED`. Args: id_or_code: An ID or code for the batch whose charges you want to retrieve. status: Any of the values from the Status enum. pagination: Specify how many records you want to retrieve per page. If not specified we use a default value of 50. page: Specify exactly what transfer you want to page. If not specified we use a default value of 1. start_date: A timestamp from which to start listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/bulkcharge/ { id_or_code } /charges?perPage= { pagination } \" ) query_params = [ ( \"status\" , status ), ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url )","title":"get_charges_in_batch()"},{"location":"reference/bulk_charges/#pypaystack2.api.bulk_charges.BulkCharge.initiate","text":"Send a list of dictionaries with authorization codes and amount (in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR ) so paystack can process transactions as a batch. Parameters: Name Type Description Default body list [ BulkChargeInstruction ] A list of BulkChargeInstruction. required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/bulk_charges.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 def initiate ( self , body : list [ BulkChargeInstruction ]) -> Response : \"\"\" Send a list of dictionaries with authorization ``codes`` and ``amount`` (in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR ) so paystack can process transactions as a batch. Args: body: A list of BulkChargeInstruction. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/bulkcharge\" ) payload = [ item . dict for item in body ] return self . _handle_request ( HTTPMethod . POST , url , payload )","title":"initiate()"},{"location":"reference/bulk_charges/#pypaystack2.api.bulk_charges.BulkCharge.pause_batch","text":"Use this method to pause processing a batch. Parameters: Name Type Description Default batch_code str The batch code for the bulk charge you want to pause. required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/bulk_charges.py 120 121 122 123 124 125 126 127 128 129 130 131 def pause_batch ( self , batch_code : str ) -> Response : \"\"\"Use this method to pause processing a batch. Args: batch_code: The batch code for the bulk charge you want to pause. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/bulkcharge/pause/ { batch_code } \" ) return self . _handle_request ( HTTPMethod . GET , url )","title":"pause_batch()"},{"location":"reference/bulk_charges/#pypaystack2.api.bulk_charges.BulkCharge.resume_batch","text":"Use this method to resume processing a batch Parameters: Name Type Description Default batch_code str The batch code for the bulk charge you want to resume. required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/bulk_charges.py 133 134 135 136 137 138 139 140 141 142 143 144 def resume_batch ( self , batch_code : str ) -> Response : \"\"\"Use this method to resume processing a batch Args: batch_code: The batch code for the bulk charge you want to resume. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/bulkcharge/resume/ { batch_code } \" ) return self . _handle_request ( HTTPMethod . GET , url )","title":"resume_batch()"},{"location":"reference/charge/","text":"AsyncCharge Bases: BaseAsyncAPI Provides a wrapper for paystack Charge API The Charge API allows you to configure a payment channel of your choice when initiating a payment. https://paystack.com/docs/api/charge/ Source code in pypaystack2/api/charge.py 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 class AsyncCharge ( BaseAsyncAPI ): \"\"\"Provides a wrapper for paystack Charge API The Charge API allows you to configure a payment channel of your choice when initiating a payment. [https://paystack.com/docs/api/charge/](https://paystack.com/docs/api/charge/) \"\"\" async def charge ( self , email : str , amount : int , bank : Optional [ dict ] = None , auth_code : Optional [ str ] = None , pin : Optional [ str ] = None , metadata : Optional [ dict ] = None , reference : Optional [ str ] = None , ussd : Optional [ dict ] = None , mobile_money : Optional [ dict ] = None , device_id : Optional [ str ] = None , birthday : Optional [ str ] = None , ) -> Response : \"\"\"Initiate a payment by integrating the payment channel of your choice. Args: email: Customer's email address amount: Amount should be in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR bank: Bank account to charge (don't send if charging an authorization code) auth_code: An authorization code to charge (don't send if charging a bank account) pin: 4-digit PIN (send with a non-reusable authorization code) metadata: A dictionary of data. reference: Unique transaction reference. Only -, .\\\\`, = and alphanumeric characters allowed. ussd: USSD type to charge (don't send if charging an authorization code, bank or card) mobile_money: Mobile details (don't send if charging an authorization code, bank or card) device_id: This is the unique identifier of the device a user uses in making payment. Only -, .\\\\`, = and alphanumeric characters allowed. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" amount = validate_amount ( amount ) payload = { \"email\" : email , \"amount\" : amount } optional_params = [ ( \"bank\" , bank ), ( \"authorization_code\" , auth_code ), ( \"pin\" , pin ), ( \"metadata\" , metadata ), ( \"reference\" , reference ), ( \"ussd\" , ussd ), ( \"mobile_money\" , mobile_money ), ( \"device_id\" , device_id ), ( \"birthday\" , birthday ), ] payload = add_to_payload ( optional_params , payload ) url = self . _parse_url ( \"/charge\" ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) async def submit_pin ( self , pin : str , reference : str ) -> Response : \"\"\"Submit PIN to continue a charge Args: pin: PIN submitted by user reference: Reference for transaction that requested pin Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"pin\" : pin , \"reference\" : reference } url = self . _parse_url ( \"/charge/submit_pin\" ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) async def submit_otp ( self , otp : str , reference : str ) -> Response : \"\"\"Submit OTP to complete a charge Args: otp: OTP submitted by user reference: Reference for ongoing transaction Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"otp\" : otp , \"reference\" : reference } url = self . _parse_url ( \"/charge/submit_otp\" ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) async def submit_phone ( self , phone : str , reference : str ) -> Response : \"\"\"Submit Phone when requested Args: phone: Phone submitted by user reference: Reference for ongoing transaction Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"phone\" : phone , \"reference\" : reference } url = self . _parse_url ( \"/charge/submit_phone\" ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) async def submit_birthday ( self , birthday : str , reference : str ) -> Response : \"\"\"Submit Birthday when requested Args: birthday: Birthday submitted by user. ISO Format e.g. 2016-09-21 reference: Reference for ongoing transaction Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"birthday\" : birthday , \"reference\" : reference } url = self . _parse_url ( \"/charge/submit_birthday\" ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) async def set_address ( self , address : str , reference : str , city : str , state : str , zipcode : str , ) -> Response : \"\"\"Submit address to continue a charge Args: address: Address submitted by user reference: Reference for ongoing transaction city: City submitted by user state: State submitted by user zipcode: sZipcode submitted by user Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"address\" : address , \"reference\" : reference , \"city\" : city , \"state\" : state , \"zip_code\" : zipcode , } url = self . _parse_url ( \"/charge/submit_address\" ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) async def check_pending_charge ( self , reference : str ) -> Response : \"\"\" When you get \"pending\" as a charge status or if there was an exception when calling any of the /charge endpoints, wait 10 seconds or more, then make a check to see if its status has changed. Don't call too early as you may get a lot more pending than you should. Args: reference: The reference to check Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/charge/ { reference } \" ) return await self . _handle_request ( HTTPMethod . GET , url ) charge ( email , amount , bank = None , auth_code = None , pin = None , metadata = None , reference = None , ussd = None , mobile_money = None , device_id = None , birthday = None ) async Initiate a payment by integrating the payment channel of your choice. Parameters: Name Type Description Default email str Customer's email address required amount int Amount should be in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR required bank Optional [ dict ] Bank account to charge (don't send if charging an authorization code) None auth_code Optional [ str ] An authorization code to charge (don't send if charging a bank account) None pin Optional [ str ] 4-digit PIN (send with a non-reusable authorization code) None metadata Optional [ dict ] A dictionary of data. None reference Optional [ str ] Unique transaction reference. Only -, .`, = and alphanumeric characters allowed. None ussd Optional [ dict ] USSD type to charge (don't send if charging an authorization code, bank or card) None mobile_money Optional [ dict ] Mobile details (don't send if charging an authorization code, bank or card) None device_id Optional [ str ] This is the unique identifier of the device a user uses in making payment. Only -, .`, = and alphanumeric characters allowed. None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/charge.py 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 async def charge ( self , email : str , amount : int , bank : Optional [ dict ] = None , auth_code : Optional [ str ] = None , pin : Optional [ str ] = None , metadata : Optional [ dict ] = None , reference : Optional [ str ] = None , ussd : Optional [ dict ] = None , mobile_money : Optional [ dict ] = None , device_id : Optional [ str ] = None , birthday : Optional [ str ] = None , ) -> Response : \"\"\"Initiate a payment by integrating the payment channel of your choice. Args: email: Customer's email address amount: Amount should be in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR bank: Bank account to charge (don't send if charging an authorization code) auth_code: An authorization code to charge (don't send if charging a bank account) pin: 4-digit PIN (send with a non-reusable authorization code) metadata: A dictionary of data. reference: Unique transaction reference. Only -, .\\\\`, = and alphanumeric characters allowed. ussd: USSD type to charge (don't send if charging an authorization code, bank or card) mobile_money: Mobile details (don't send if charging an authorization code, bank or card) device_id: This is the unique identifier of the device a user uses in making payment. Only -, .\\\\`, = and alphanumeric characters allowed. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" amount = validate_amount ( amount ) payload = { \"email\" : email , \"amount\" : amount } optional_params = [ ( \"bank\" , bank ), ( \"authorization_code\" , auth_code ), ( \"pin\" , pin ), ( \"metadata\" , metadata ), ( \"reference\" , reference ), ( \"ussd\" , ussd ), ( \"mobile_money\" , mobile_money ), ( \"device_id\" , device_id ), ( \"birthday\" , birthday ), ] payload = add_to_payload ( optional_params , payload ) url = self . _parse_url ( \"/charge\" ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) check_pending_charge ( reference ) async When you get \"pending\" as a charge status or if there was an exception when calling any of the /charge endpoints, wait 10 seconds or more, then make a check to see if its status has changed. Don't call too early as you may get a lot more pending than you should. Parameters: Name Type Description Default reference str The reference to check required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/charge.py 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 async def check_pending_charge ( self , reference : str ) -> Response : \"\"\" When you get \"pending\" as a charge status or if there was an exception when calling any of the /charge endpoints, wait 10 seconds or more, then make a check to see if its status has changed. Don't call too early as you may get a lot more pending than you should. Args: reference: The reference to check Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/charge/ { reference } \" ) return await self . _handle_request ( HTTPMethod . GET , url ) set_address ( address , reference , city , state , zipcode ) async Submit address to continue a charge Parameters: Name Type Description Default address str Address submitted by user required reference str Reference for ongoing transaction required city str City submitted by user required state str State submitted by user required zipcode str sZipcode submitted by user required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/charge.py 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 async def set_address ( self , address : str , reference : str , city : str , state : str , zipcode : str , ) -> Response : \"\"\"Submit address to continue a charge Args: address: Address submitted by user reference: Reference for ongoing transaction city: City submitted by user state: State submitted by user zipcode: sZipcode submitted by user Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"address\" : address , \"reference\" : reference , \"city\" : city , \"state\" : state , \"zip_code\" : zipcode , } url = self . _parse_url ( \"/charge/submit_address\" ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) submit_birthday ( birthday , reference ) async Submit Birthday when requested Parameters: Name Type Description Default birthday str Birthday submitted by user. ISO Format e.g. 2016-09-21 required reference str Reference for ongoing transaction required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/charge.py 280 281 282 283 284 285 286 287 288 289 290 291 292 293 async def submit_birthday ( self , birthday : str , reference : str ) -> Response : \"\"\"Submit Birthday when requested Args: birthday: Birthday submitted by user. ISO Format e.g. 2016-09-21 reference: Reference for ongoing transaction Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"birthday\" : birthday , \"reference\" : reference } url = self . _parse_url ( \"/charge/submit_birthday\" ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) submit_otp ( otp , reference ) async Submit OTP to complete a charge Parameters: Name Type Description Default otp str OTP submitted by user required reference str Reference for ongoing transaction required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/charge.py 250 251 252 253 254 255 256 257 258 259 260 261 262 263 async def submit_otp ( self , otp : str , reference : str ) -> Response : \"\"\"Submit OTP to complete a charge Args: otp: OTP submitted by user reference: Reference for ongoing transaction Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"otp\" : otp , \"reference\" : reference } url = self . _parse_url ( \"/charge/submit_otp\" ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) submit_phone ( phone , reference ) async Submit Phone when requested Parameters: Name Type Description Default phone str Phone submitted by user required reference str Reference for ongoing transaction required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/charge.py 265 266 267 268 269 270 271 272 273 274 275 276 277 278 async def submit_phone ( self , phone : str , reference : str ) -> Response : \"\"\"Submit Phone when requested Args: phone: Phone submitted by user reference: Reference for ongoing transaction Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"phone\" : phone , \"reference\" : reference } url = self . _parse_url ( \"/charge/submit_phone\" ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) submit_pin ( pin , reference ) async Submit PIN to continue a charge Parameters: Name Type Description Default pin str PIN submitted by user required reference str Reference for transaction that requested pin required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/charge.py 235 236 237 238 239 240 241 242 243 244 245 246 247 248 async def submit_pin ( self , pin : str , reference : str ) -> Response : \"\"\"Submit PIN to continue a charge Args: pin: PIN submitted by user reference: Reference for transaction that requested pin Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"pin\" : pin , \"reference\" : reference } url = self . _parse_url ( \"/charge/submit_pin\" ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) Charge Bases: BaseAPI Provides a wrapper for paystack Charge API The Charge API allows you to configure a payment channel of your choice when initiating a payment. https://paystack.com/docs/api/charge/ Source code in pypaystack2/api/charge.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 class Charge ( BaseAPI ): \"\"\"Provides a wrapper for paystack Charge API The Charge API allows you to configure a payment channel of your choice when initiating a payment. [https://paystack.com/docs/api/charge/](https://paystack.com/docs/api/charge/) \"\"\" def charge ( self , email : str , amount : int , bank : Optional [ dict ] = None , auth_code : Optional [ str ] = None , pin : Optional [ str ] = None , metadata : Optional [ dict ] = None , reference : Optional [ str ] = None , ussd : Optional [ dict ] = None , mobile_money : Optional [ dict ] = None , device_id : Optional [ str ] = None , birthday : Optional [ str ] = None , ) -> Response : \"\"\"Initiate a payment by integrating the payment channel of your choice. Args: email: Customer's email address amount: Amount should be in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR bank: Bank account to charge (don't send if charging an authorization code) auth_code: An authorization code to charge (don't send if charging a bank account) pin: 4-digit PIN (send with a non-reusable authorization code) metadata: A dictionary of data. reference: Unique transaction reference. Only -, .\\\\`, = and alphanumeric characters allowed. ussd: USSD type to charge (don't send if charging an authorization code, bank or card) mobile_money: Mobile details (don't send if charging an authorization code, bank or card) device_id: This is the unique identifier of the device a user uses in making payment. Only -, .\\\\`, = and alphanumeric characters allowed. birthday: Date of birth. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" amount = validate_amount ( amount ) payload = { \"email\" : email , \"amount\" : amount } optional_params = [ ( \"bank\" , bank ), ( \"authorization_code\" , auth_code ), ( \"pin\" , pin ), ( \"metadata\" , metadata ), ( \"reference\" , reference ), ( \"ussd\" , ussd ), ( \"mobile_money\" , mobile_money ), ( \"device_id\" , device_id ), ( \"birthday\" , birthday ), ] payload = add_to_payload ( optional_params , payload ) url = self . _parse_url ( \"/charge\" ) return self . _handle_request ( HTTPMethod . POST , url , payload ) def submit_pin ( self , pin : str , reference : str ) -> Response : \"\"\"Submit PIN to continue a charge Args: pin: PIN submitted by user reference: Reference for transaction that requested pin Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"pin\" : pin , \"reference\" : reference } url = self . _parse_url ( \"/charge/submit_pin\" ) return self . _handle_request ( HTTPMethod . POST , url , payload ) def submit_otp ( self , otp : str , reference : str ) -> Response : \"\"\"Submit OTP to complete a charge Args: otp: OTP submitted by user reference: Reference for ongoing transaction Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"otp\" : otp , \"reference\" : reference } url = self . _parse_url ( \"/charge/submit_otp\" ) return self . _handle_request ( HTTPMethod . POST , url , payload ) def submit_phone ( self , phone : str , reference : str ) -> Response : \"\"\"Submit Phone when requested Args: phone: Phone submitted by user reference: Reference for ongoing transaction Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"phone\" : phone , \"reference\" : reference } url = self . _parse_url ( \"/charge/submit_phone\" ) return self . _handle_request ( HTTPMethod . POST , url , payload ) def submit_birthday ( self , birthday : str , reference : str ) -> Response : \"\"\"Submit Birthday when requested Args: birthday: Birthday submitted by user. ISO Format e.g. 2016-09-21 reference: Reference for ongoing transaction Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"birthday\" : birthday , \"reference\" : reference } url = self . _parse_url ( \"/charge/submit_birthday\" ) return self . _handle_request ( HTTPMethod . POST , url , payload ) def set_address ( self , address : str , reference : str , city : str , state : str , zipcode : str , ) -> Response : \"\"\"Submit address to continue a charge Args: address: Address submitted by user reference: Reference for ongoing transaction city: City submitted by user state: State submitted by user zipcode: sZipcode submitted by user Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"address\" : address , \"reference\" : reference , \"city\" : city , \"state\" : state , \"zip_code\" : zipcode , } url = self . _parse_url ( \"/charge/submit_address\" ) return self . _handle_request ( HTTPMethod . POST , url , payload ) def check_pending_charge ( self , reference : str ) -> Response : \"\"\" When you get \"pending\" as a charge status or if there was an exception when calling any of the /charge endpoints, wait 10 seconds or more, then make a check to see if its status has changed. Don't call too early as you may get a lot more pending than you should. Args: reference: The reference to check Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/charge/ { reference } \" ) return self . _handle_request ( HTTPMethod . GET , url ) charge ( email , amount , bank = None , auth_code = None , pin = None , metadata = None , reference = None , ussd = None , mobile_money = None , device_id = None , birthday = None ) Initiate a payment by integrating the payment channel of your choice. Parameters: Name Type Description Default email str Customer's email address required amount int Amount should be in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR required bank Optional [ dict ] Bank account to charge (don't send if charging an authorization code) None auth_code Optional [ str ] An authorization code to charge (don't send if charging a bank account) None pin Optional [ str ] 4-digit PIN (send with a non-reusable authorization code) None metadata Optional [ dict ] A dictionary of data. None reference Optional [ str ] Unique transaction reference. Only -, .`, = and alphanumeric characters allowed. None ussd Optional [ dict ] USSD type to charge (don't send if charging an authorization code, bank or card) None mobile_money Optional [ dict ] Mobile details (don't send if charging an authorization code, bank or card) None device_id Optional [ str ] This is the unique identifier of the device a user uses in making payment. Only -, .`, = and alphanumeric characters allowed. None birthday Optional [ str ] Date of birth. None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/charge.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 def charge ( self , email : str , amount : int , bank : Optional [ dict ] = None , auth_code : Optional [ str ] = None , pin : Optional [ str ] = None , metadata : Optional [ dict ] = None , reference : Optional [ str ] = None , ussd : Optional [ dict ] = None , mobile_money : Optional [ dict ] = None , device_id : Optional [ str ] = None , birthday : Optional [ str ] = None , ) -> Response : \"\"\"Initiate a payment by integrating the payment channel of your choice. Args: email: Customer's email address amount: Amount should be in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR bank: Bank account to charge (don't send if charging an authorization code) auth_code: An authorization code to charge (don't send if charging a bank account) pin: 4-digit PIN (send with a non-reusable authorization code) metadata: A dictionary of data. reference: Unique transaction reference. Only -, .\\\\`, = and alphanumeric characters allowed. ussd: USSD type to charge (don't send if charging an authorization code, bank or card) mobile_money: Mobile details (don't send if charging an authorization code, bank or card) device_id: This is the unique identifier of the device a user uses in making payment. Only -, .\\\\`, = and alphanumeric characters allowed. birthday: Date of birth. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" amount = validate_amount ( amount ) payload = { \"email\" : email , \"amount\" : amount } optional_params = [ ( \"bank\" , bank ), ( \"authorization_code\" , auth_code ), ( \"pin\" , pin ), ( \"metadata\" , metadata ), ( \"reference\" , reference ), ( \"ussd\" , ussd ), ( \"mobile_money\" , mobile_money ), ( \"device_id\" , device_id ), ( \"birthday\" , birthday ), ] payload = add_to_payload ( optional_params , payload ) url = self . _parse_url ( \"/charge\" ) return self . _handle_request ( HTTPMethod . POST , url , payload ) check_pending_charge ( reference ) When you get \"pending\" as a charge status or if there was an exception when calling any of the /charge endpoints, wait 10 seconds or more, then make a check to see if its status has changed. Don't call too early as you may get a lot more pending than you should. Parameters: Name Type Description Default reference str The reference to check required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/charge.py 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 def check_pending_charge ( self , reference : str ) -> Response : \"\"\" When you get \"pending\" as a charge status or if there was an exception when calling any of the /charge endpoints, wait 10 seconds or more, then make a check to see if its status has changed. Don't call too early as you may get a lot more pending than you should. Args: reference: The reference to check Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/charge/ { reference } \" ) return self . _handle_request ( HTTPMethod . GET , url ) set_address ( address , reference , city , state , zipcode ) Submit address to continue a charge Parameters: Name Type Description Default address str Address submitted by user required reference str Reference for ongoing transaction required city str City submitted by user required state str State submitted by user required zipcode str sZipcode submitted by user required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/charge.py 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 def set_address ( self , address : str , reference : str , city : str , state : str , zipcode : str , ) -> Response : \"\"\"Submit address to continue a charge Args: address: Address submitted by user reference: Reference for ongoing transaction city: City submitted by user state: State submitted by user zipcode: sZipcode submitted by user Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"address\" : address , \"reference\" : reference , \"city\" : city , \"state\" : state , \"zip_code\" : zipcode , } url = self . _parse_url ( \"/charge/submit_address\" ) return self . _handle_request ( HTTPMethod . POST , url , payload ) submit_birthday ( birthday , reference ) Submit Birthday when requested Parameters: Name Type Description Default birthday str Birthday submitted by user. ISO Format e.g. 2016-09-21 required reference str Reference for ongoing transaction required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/charge.py 112 113 114 115 116 117 118 119 120 121 122 123 124 125 def submit_birthday ( self , birthday : str , reference : str ) -> Response : \"\"\"Submit Birthday when requested Args: birthday: Birthday submitted by user. ISO Format e.g. 2016-09-21 reference: Reference for ongoing transaction Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"birthday\" : birthday , \"reference\" : reference } url = self . _parse_url ( \"/charge/submit_birthday\" ) return self . _handle_request ( HTTPMethod . POST , url , payload ) submit_otp ( otp , reference ) Submit OTP to complete a charge Parameters: Name Type Description Default otp str OTP submitted by user required reference str Reference for ongoing transaction required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/charge.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 def submit_otp ( self , otp : str , reference : str ) -> Response : \"\"\"Submit OTP to complete a charge Args: otp: OTP submitted by user reference: Reference for ongoing transaction Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"otp\" : otp , \"reference\" : reference } url = self . _parse_url ( \"/charge/submit_otp\" ) return self . _handle_request ( HTTPMethod . POST , url , payload ) submit_phone ( phone , reference ) Submit Phone when requested Parameters: Name Type Description Default phone str Phone submitted by user required reference str Reference for ongoing transaction required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/charge.py 97 98 99 100 101 102 103 104 105 106 107 108 109 110 def submit_phone ( self , phone : str , reference : str ) -> Response : \"\"\"Submit Phone when requested Args: phone: Phone submitted by user reference: Reference for ongoing transaction Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"phone\" : phone , \"reference\" : reference } url = self . _parse_url ( \"/charge/submit_phone\" ) return self . _handle_request ( HTTPMethod . POST , url , payload ) submit_pin ( pin , reference ) Submit PIN to continue a charge Parameters: Name Type Description Default pin str PIN submitted by user required reference str Reference for transaction that requested pin required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/charge.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 def submit_pin ( self , pin : str , reference : str ) -> Response : \"\"\"Submit PIN to continue a charge Args: pin: PIN submitted by user reference: Reference for transaction that requested pin Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"pin\" : pin , \"reference\" : reference } url = self . _parse_url ( \"/charge/submit_pin\" ) return self . _handle_request ( HTTPMethod . POST , url , payload )","title":"Charge"},{"location":"reference/charge/#pypaystack2.api.charge.AsyncCharge","text":"Bases: BaseAsyncAPI Provides a wrapper for paystack Charge API The Charge API allows you to configure a payment channel of your choice when initiating a payment. https://paystack.com/docs/api/charge/ Source code in pypaystack2/api/charge.py 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 class AsyncCharge ( BaseAsyncAPI ): \"\"\"Provides a wrapper for paystack Charge API The Charge API allows you to configure a payment channel of your choice when initiating a payment. [https://paystack.com/docs/api/charge/](https://paystack.com/docs/api/charge/) \"\"\" async def charge ( self , email : str , amount : int , bank : Optional [ dict ] = None , auth_code : Optional [ str ] = None , pin : Optional [ str ] = None , metadata : Optional [ dict ] = None , reference : Optional [ str ] = None , ussd : Optional [ dict ] = None , mobile_money : Optional [ dict ] = None , device_id : Optional [ str ] = None , birthday : Optional [ str ] = None , ) -> Response : \"\"\"Initiate a payment by integrating the payment channel of your choice. Args: email: Customer's email address amount: Amount should be in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR bank: Bank account to charge (don't send if charging an authorization code) auth_code: An authorization code to charge (don't send if charging a bank account) pin: 4-digit PIN (send with a non-reusable authorization code) metadata: A dictionary of data. reference: Unique transaction reference. Only -, .\\\\`, = and alphanumeric characters allowed. ussd: USSD type to charge (don't send if charging an authorization code, bank or card) mobile_money: Mobile details (don't send if charging an authorization code, bank or card) device_id: This is the unique identifier of the device a user uses in making payment. Only -, .\\\\`, = and alphanumeric characters allowed. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" amount = validate_amount ( amount ) payload = { \"email\" : email , \"amount\" : amount } optional_params = [ ( \"bank\" , bank ), ( \"authorization_code\" , auth_code ), ( \"pin\" , pin ), ( \"metadata\" , metadata ), ( \"reference\" , reference ), ( \"ussd\" , ussd ), ( \"mobile_money\" , mobile_money ), ( \"device_id\" , device_id ), ( \"birthday\" , birthday ), ] payload = add_to_payload ( optional_params , payload ) url = self . _parse_url ( \"/charge\" ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) async def submit_pin ( self , pin : str , reference : str ) -> Response : \"\"\"Submit PIN to continue a charge Args: pin: PIN submitted by user reference: Reference for transaction that requested pin Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"pin\" : pin , \"reference\" : reference } url = self . _parse_url ( \"/charge/submit_pin\" ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) async def submit_otp ( self , otp : str , reference : str ) -> Response : \"\"\"Submit OTP to complete a charge Args: otp: OTP submitted by user reference: Reference for ongoing transaction Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"otp\" : otp , \"reference\" : reference } url = self . _parse_url ( \"/charge/submit_otp\" ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) async def submit_phone ( self , phone : str , reference : str ) -> Response : \"\"\"Submit Phone when requested Args: phone: Phone submitted by user reference: Reference for ongoing transaction Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"phone\" : phone , \"reference\" : reference } url = self . _parse_url ( \"/charge/submit_phone\" ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) async def submit_birthday ( self , birthday : str , reference : str ) -> Response : \"\"\"Submit Birthday when requested Args: birthday: Birthday submitted by user. ISO Format e.g. 2016-09-21 reference: Reference for ongoing transaction Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"birthday\" : birthday , \"reference\" : reference } url = self . _parse_url ( \"/charge/submit_birthday\" ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) async def set_address ( self , address : str , reference : str , city : str , state : str , zipcode : str , ) -> Response : \"\"\"Submit address to continue a charge Args: address: Address submitted by user reference: Reference for ongoing transaction city: City submitted by user state: State submitted by user zipcode: sZipcode submitted by user Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"address\" : address , \"reference\" : reference , \"city\" : city , \"state\" : state , \"zip_code\" : zipcode , } url = self . _parse_url ( \"/charge/submit_address\" ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) async def check_pending_charge ( self , reference : str ) -> Response : \"\"\" When you get \"pending\" as a charge status or if there was an exception when calling any of the /charge endpoints, wait 10 seconds or more, then make a check to see if its status has changed. Don't call too early as you may get a lot more pending than you should. Args: reference: The reference to check Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/charge/ { reference } \" ) return await self . _handle_request ( HTTPMethod . GET , url )","title":"AsyncCharge"},{"location":"reference/charge/#pypaystack2.api.charge.AsyncCharge.charge","text":"Initiate a payment by integrating the payment channel of your choice. Parameters: Name Type Description Default email str Customer's email address required amount int Amount should be in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR required bank Optional [ dict ] Bank account to charge (don't send if charging an authorization code) None auth_code Optional [ str ] An authorization code to charge (don't send if charging a bank account) None pin Optional [ str ] 4-digit PIN (send with a non-reusable authorization code) None metadata Optional [ dict ] A dictionary of data. None reference Optional [ str ] Unique transaction reference. Only -, .`, = and alphanumeric characters allowed. None ussd Optional [ dict ] USSD type to charge (don't send if charging an authorization code, bank or card) None mobile_money Optional [ dict ] Mobile details (don't send if charging an authorization code, bank or card) None device_id Optional [ str ] This is the unique identifier of the device a user uses in making payment. Only -, .`, = and alphanumeric characters allowed. None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/charge.py 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 async def charge ( self , email : str , amount : int , bank : Optional [ dict ] = None , auth_code : Optional [ str ] = None , pin : Optional [ str ] = None , metadata : Optional [ dict ] = None , reference : Optional [ str ] = None , ussd : Optional [ dict ] = None , mobile_money : Optional [ dict ] = None , device_id : Optional [ str ] = None , birthday : Optional [ str ] = None , ) -> Response : \"\"\"Initiate a payment by integrating the payment channel of your choice. Args: email: Customer's email address amount: Amount should be in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR bank: Bank account to charge (don't send if charging an authorization code) auth_code: An authorization code to charge (don't send if charging a bank account) pin: 4-digit PIN (send with a non-reusable authorization code) metadata: A dictionary of data. reference: Unique transaction reference. Only -, .\\\\`, = and alphanumeric characters allowed. ussd: USSD type to charge (don't send if charging an authorization code, bank or card) mobile_money: Mobile details (don't send if charging an authorization code, bank or card) device_id: This is the unique identifier of the device a user uses in making payment. Only -, .\\\\`, = and alphanumeric characters allowed. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" amount = validate_amount ( amount ) payload = { \"email\" : email , \"amount\" : amount } optional_params = [ ( \"bank\" , bank ), ( \"authorization_code\" , auth_code ), ( \"pin\" , pin ), ( \"metadata\" , metadata ), ( \"reference\" , reference ), ( \"ussd\" , ussd ), ( \"mobile_money\" , mobile_money ), ( \"device_id\" , device_id ), ( \"birthday\" , birthday ), ] payload = add_to_payload ( optional_params , payload ) url = self . _parse_url ( \"/charge\" ) return await self . _handle_request ( HTTPMethod . POST , url , payload )","title":"charge()"},{"location":"reference/charge/#pypaystack2.api.charge.AsyncCharge.check_pending_charge","text":"When you get \"pending\" as a charge status or if there was an exception when calling any of the /charge endpoints, wait 10 seconds or more, then make a check to see if its status has changed. Don't call too early as you may get a lot more pending than you should. Parameters: Name Type Description Default reference str The reference to check required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/charge.py 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 async def check_pending_charge ( self , reference : str ) -> Response : \"\"\" When you get \"pending\" as a charge status or if there was an exception when calling any of the /charge endpoints, wait 10 seconds or more, then make a check to see if its status has changed. Don't call too early as you may get a lot more pending than you should. Args: reference: The reference to check Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/charge/ { reference } \" ) return await self . _handle_request ( HTTPMethod . GET , url )","title":"check_pending_charge()"},{"location":"reference/charge/#pypaystack2.api.charge.AsyncCharge.set_address","text":"Submit address to continue a charge Parameters: Name Type Description Default address str Address submitted by user required reference str Reference for ongoing transaction required city str City submitted by user required state str State submitted by user required zipcode str sZipcode submitted by user required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/charge.py 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 async def set_address ( self , address : str , reference : str , city : str , state : str , zipcode : str , ) -> Response : \"\"\"Submit address to continue a charge Args: address: Address submitted by user reference: Reference for ongoing transaction city: City submitted by user state: State submitted by user zipcode: sZipcode submitted by user Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"address\" : address , \"reference\" : reference , \"city\" : city , \"state\" : state , \"zip_code\" : zipcode , } url = self . _parse_url ( \"/charge/submit_address\" ) return await self . _handle_request ( HTTPMethod . POST , url , payload )","title":"set_address()"},{"location":"reference/charge/#pypaystack2.api.charge.AsyncCharge.submit_birthday","text":"Submit Birthday when requested Parameters: Name Type Description Default birthday str Birthday submitted by user. ISO Format e.g. 2016-09-21 required reference str Reference for ongoing transaction required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/charge.py 280 281 282 283 284 285 286 287 288 289 290 291 292 293 async def submit_birthday ( self , birthday : str , reference : str ) -> Response : \"\"\"Submit Birthday when requested Args: birthday: Birthday submitted by user. ISO Format e.g. 2016-09-21 reference: Reference for ongoing transaction Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"birthday\" : birthday , \"reference\" : reference } url = self . _parse_url ( \"/charge/submit_birthday\" ) return await self . _handle_request ( HTTPMethod . POST , url , payload )","title":"submit_birthday()"},{"location":"reference/charge/#pypaystack2.api.charge.AsyncCharge.submit_otp","text":"Submit OTP to complete a charge Parameters: Name Type Description Default otp str OTP submitted by user required reference str Reference for ongoing transaction required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/charge.py 250 251 252 253 254 255 256 257 258 259 260 261 262 263 async def submit_otp ( self , otp : str , reference : str ) -> Response : \"\"\"Submit OTP to complete a charge Args: otp: OTP submitted by user reference: Reference for ongoing transaction Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"otp\" : otp , \"reference\" : reference } url = self . _parse_url ( \"/charge/submit_otp\" ) return await self . _handle_request ( HTTPMethod . POST , url , payload )","title":"submit_otp()"},{"location":"reference/charge/#pypaystack2.api.charge.AsyncCharge.submit_phone","text":"Submit Phone when requested Parameters: Name Type Description Default phone str Phone submitted by user required reference str Reference for ongoing transaction required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/charge.py 265 266 267 268 269 270 271 272 273 274 275 276 277 278 async def submit_phone ( self , phone : str , reference : str ) -> Response : \"\"\"Submit Phone when requested Args: phone: Phone submitted by user reference: Reference for ongoing transaction Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"phone\" : phone , \"reference\" : reference } url = self . _parse_url ( \"/charge/submit_phone\" ) return await self . _handle_request ( HTTPMethod . POST , url , payload )","title":"submit_phone()"},{"location":"reference/charge/#pypaystack2.api.charge.AsyncCharge.submit_pin","text":"Submit PIN to continue a charge Parameters: Name Type Description Default pin str PIN submitted by user required reference str Reference for transaction that requested pin required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/charge.py 235 236 237 238 239 240 241 242 243 244 245 246 247 248 async def submit_pin ( self , pin : str , reference : str ) -> Response : \"\"\"Submit PIN to continue a charge Args: pin: PIN submitted by user reference: Reference for transaction that requested pin Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"pin\" : pin , \"reference\" : reference } url = self . _parse_url ( \"/charge/submit_pin\" ) return await self . _handle_request ( HTTPMethod . POST , url , payload )","title":"submit_pin()"},{"location":"reference/charge/#pypaystack2.api.charge.Charge","text":"Bases: BaseAPI Provides a wrapper for paystack Charge API The Charge API allows you to configure a payment channel of your choice when initiating a payment. https://paystack.com/docs/api/charge/ Source code in pypaystack2/api/charge.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 class Charge ( BaseAPI ): \"\"\"Provides a wrapper for paystack Charge API The Charge API allows you to configure a payment channel of your choice when initiating a payment. [https://paystack.com/docs/api/charge/](https://paystack.com/docs/api/charge/) \"\"\" def charge ( self , email : str , amount : int , bank : Optional [ dict ] = None , auth_code : Optional [ str ] = None , pin : Optional [ str ] = None , metadata : Optional [ dict ] = None , reference : Optional [ str ] = None , ussd : Optional [ dict ] = None , mobile_money : Optional [ dict ] = None , device_id : Optional [ str ] = None , birthday : Optional [ str ] = None , ) -> Response : \"\"\"Initiate a payment by integrating the payment channel of your choice. Args: email: Customer's email address amount: Amount should be in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR bank: Bank account to charge (don't send if charging an authorization code) auth_code: An authorization code to charge (don't send if charging a bank account) pin: 4-digit PIN (send with a non-reusable authorization code) metadata: A dictionary of data. reference: Unique transaction reference. Only -, .\\\\`, = and alphanumeric characters allowed. ussd: USSD type to charge (don't send if charging an authorization code, bank or card) mobile_money: Mobile details (don't send if charging an authorization code, bank or card) device_id: This is the unique identifier of the device a user uses in making payment. Only -, .\\\\`, = and alphanumeric characters allowed. birthday: Date of birth. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" amount = validate_amount ( amount ) payload = { \"email\" : email , \"amount\" : amount } optional_params = [ ( \"bank\" , bank ), ( \"authorization_code\" , auth_code ), ( \"pin\" , pin ), ( \"metadata\" , metadata ), ( \"reference\" , reference ), ( \"ussd\" , ussd ), ( \"mobile_money\" , mobile_money ), ( \"device_id\" , device_id ), ( \"birthday\" , birthday ), ] payload = add_to_payload ( optional_params , payload ) url = self . _parse_url ( \"/charge\" ) return self . _handle_request ( HTTPMethod . POST , url , payload ) def submit_pin ( self , pin : str , reference : str ) -> Response : \"\"\"Submit PIN to continue a charge Args: pin: PIN submitted by user reference: Reference for transaction that requested pin Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"pin\" : pin , \"reference\" : reference } url = self . _parse_url ( \"/charge/submit_pin\" ) return self . _handle_request ( HTTPMethod . POST , url , payload ) def submit_otp ( self , otp : str , reference : str ) -> Response : \"\"\"Submit OTP to complete a charge Args: otp: OTP submitted by user reference: Reference for ongoing transaction Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"otp\" : otp , \"reference\" : reference } url = self . _parse_url ( \"/charge/submit_otp\" ) return self . _handle_request ( HTTPMethod . POST , url , payload ) def submit_phone ( self , phone : str , reference : str ) -> Response : \"\"\"Submit Phone when requested Args: phone: Phone submitted by user reference: Reference for ongoing transaction Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"phone\" : phone , \"reference\" : reference } url = self . _parse_url ( \"/charge/submit_phone\" ) return self . _handle_request ( HTTPMethod . POST , url , payload ) def submit_birthday ( self , birthday : str , reference : str ) -> Response : \"\"\"Submit Birthday when requested Args: birthday: Birthday submitted by user. ISO Format e.g. 2016-09-21 reference: Reference for ongoing transaction Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"birthday\" : birthday , \"reference\" : reference } url = self . _parse_url ( \"/charge/submit_birthday\" ) return self . _handle_request ( HTTPMethod . POST , url , payload ) def set_address ( self , address : str , reference : str , city : str , state : str , zipcode : str , ) -> Response : \"\"\"Submit address to continue a charge Args: address: Address submitted by user reference: Reference for ongoing transaction city: City submitted by user state: State submitted by user zipcode: sZipcode submitted by user Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"address\" : address , \"reference\" : reference , \"city\" : city , \"state\" : state , \"zip_code\" : zipcode , } url = self . _parse_url ( \"/charge/submit_address\" ) return self . _handle_request ( HTTPMethod . POST , url , payload ) def check_pending_charge ( self , reference : str ) -> Response : \"\"\" When you get \"pending\" as a charge status or if there was an exception when calling any of the /charge endpoints, wait 10 seconds or more, then make a check to see if its status has changed. Don't call too early as you may get a lot more pending than you should. Args: reference: The reference to check Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/charge/ { reference } \" ) return self . _handle_request ( HTTPMethod . GET , url )","title":"Charge"},{"location":"reference/charge/#pypaystack2.api.charge.Charge.charge","text":"Initiate a payment by integrating the payment channel of your choice. Parameters: Name Type Description Default email str Customer's email address required amount int Amount should be in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR required bank Optional [ dict ] Bank account to charge (don't send if charging an authorization code) None auth_code Optional [ str ] An authorization code to charge (don't send if charging a bank account) None pin Optional [ str ] 4-digit PIN (send with a non-reusable authorization code) None metadata Optional [ dict ] A dictionary of data. None reference Optional [ str ] Unique transaction reference. Only -, .`, = and alphanumeric characters allowed. None ussd Optional [ dict ] USSD type to charge (don't send if charging an authorization code, bank or card) None mobile_money Optional [ dict ] Mobile details (don't send if charging an authorization code, bank or card) None device_id Optional [ str ] This is the unique identifier of the device a user uses in making payment. Only -, .`, = and alphanumeric characters allowed. None birthday Optional [ str ] Date of birth. None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/charge.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 def charge ( self , email : str , amount : int , bank : Optional [ dict ] = None , auth_code : Optional [ str ] = None , pin : Optional [ str ] = None , metadata : Optional [ dict ] = None , reference : Optional [ str ] = None , ussd : Optional [ dict ] = None , mobile_money : Optional [ dict ] = None , device_id : Optional [ str ] = None , birthday : Optional [ str ] = None , ) -> Response : \"\"\"Initiate a payment by integrating the payment channel of your choice. Args: email: Customer's email address amount: Amount should be in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR bank: Bank account to charge (don't send if charging an authorization code) auth_code: An authorization code to charge (don't send if charging a bank account) pin: 4-digit PIN (send with a non-reusable authorization code) metadata: A dictionary of data. reference: Unique transaction reference. Only -, .\\\\`, = and alphanumeric characters allowed. ussd: USSD type to charge (don't send if charging an authorization code, bank or card) mobile_money: Mobile details (don't send if charging an authorization code, bank or card) device_id: This is the unique identifier of the device a user uses in making payment. Only -, .\\\\`, = and alphanumeric characters allowed. birthday: Date of birth. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" amount = validate_amount ( amount ) payload = { \"email\" : email , \"amount\" : amount } optional_params = [ ( \"bank\" , bank ), ( \"authorization_code\" , auth_code ), ( \"pin\" , pin ), ( \"metadata\" , metadata ), ( \"reference\" , reference ), ( \"ussd\" , ussd ), ( \"mobile_money\" , mobile_money ), ( \"device_id\" , device_id ), ( \"birthday\" , birthday ), ] payload = add_to_payload ( optional_params , payload ) url = self . _parse_url ( \"/charge\" ) return self . _handle_request ( HTTPMethod . POST , url , payload )","title":"charge()"},{"location":"reference/charge/#pypaystack2.api.charge.Charge.check_pending_charge","text":"When you get \"pending\" as a charge status or if there was an exception when calling any of the /charge endpoints, wait 10 seconds or more, then make a check to see if its status has changed. Don't call too early as you may get a lot more pending than you should. Parameters: Name Type Description Default reference str The reference to check required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/charge.py 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 def check_pending_charge ( self , reference : str ) -> Response : \"\"\" When you get \"pending\" as a charge status or if there was an exception when calling any of the /charge endpoints, wait 10 seconds or more, then make a check to see if its status has changed. Don't call too early as you may get a lot more pending than you should. Args: reference: The reference to check Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/charge/ { reference } \" ) return self . _handle_request ( HTTPMethod . GET , url )","title":"check_pending_charge()"},{"location":"reference/charge/#pypaystack2.api.charge.Charge.set_address","text":"Submit address to continue a charge Parameters: Name Type Description Default address str Address submitted by user required reference str Reference for ongoing transaction required city str City submitted by user required state str State submitted by user required zipcode str sZipcode submitted by user required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/charge.py 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 def set_address ( self , address : str , reference : str , city : str , state : str , zipcode : str , ) -> Response : \"\"\"Submit address to continue a charge Args: address: Address submitted by user reference: Reference for ongoing transaction city: City submitted by user state: State submitted by user zipcode: sZipcode submitted by user Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"address\" : address , \"reference\" : reference , \"city\" : city , \"state\" : state , \"zip_code\" : zipcode , } url = self . _parse_url ( \"/charge/submit_address\" ) return self . _handle_request ( HTTPMethod . POST , url , payload )","title":"set_address()"},{"location":"reference/charge/#pypaystack2.api.charge.Charge.submit_birthday","text":"Submit Birthday when requested Parameters: Name Type Description Default birthday str Birthday submitted by user. ISO Format e.g. 2016-09-21 required reference str Reference for ongoing transaction required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/charge.py 112 113 114 115 116 117 118 119 120 121 122 123 124 125 def submit_birthday ( self , birthday : str , reference : str ) -> Response : \"\"\"Submit Birthday when requested Args: birthday: Birthday submitted by user. ISO Format e.g. 2016-09-21 reference: Reference for ongoing transaction Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"birthday\" : birthday , \"reference\" : reference } url = self . _parse_url ( \"/charge/submit_birthday\" ) return self . _handle_request ( HTTPMethod . POST , url , payload )","title":"submit_birthday()"},{"location":"reference/charge/#pypaystack2.api.charge.Charge.submit_otp","text":"Submit OTP to complete a charge Parameters: Name Type Description Default otp str OTP submitted by user required reference str Reference for ongoing transaction required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/charge.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 def submit_otp ( self , otp : str , reference : str ) -> Response : \"\"\"Submit OTP to complete a charge Args: otp: OTP submitted by user reference: Reference for ongoing transaction Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"otp\" : otp , \"reference\" : reference } url = self . _parse_url ( \"/charge/submit_otp\" ) return self . _handle_request ( HTTPMethod . POST , url , payload )","title":"submit_otp()"},{"location":"reference/charge/#pypaystack2.api.charge.Charge.submit_phone","text":"Submit Phone when requested Parameters: Name Type Description Default phone str Phone submitted by user required reference str Reference for ongoing transaction required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/charge.py 97 98 99 100 101 102 103 104 105 106 107 108 109 110 def submit_phone ( self , phone : str , reference : str ) -> Response : \"\"\"Submit Phone when requested Args: phone: Phone submitted by user reference: Reference for ongoing transaction Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"phone\" : phone , \"reference\" : reference } url = self . _parse_url ( \"/charge/submit_phone\" ) return self . _handle_request ( HTTPMethod . POST , url , payload )","title":"submit_phone()"},{"location":"reference/charge/#pypaystack2.api.charge.Charge.submit_pin","text":"Submit PIN to continue a charge Parameters: Name Type Description Default pin str PIN submitted by user required reference str Reference for transaction that requested pin required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/charge.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 def submit_pin ( self , pin : str , reference : str ) -> Response : \"\"\"Submit PIN to continue a charge Args: pin: PIN submitted by user reference: Reference for transaction that requested pin Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"pin\" : pin , \"reference\" : reference } url = self . _parse_url ( \"/charge/submit_pin\" ) return self . _handle_request ( HTTPMethod . POST , url , payload )","title":"submit_pin()"},{"location":"reference/customer/","text":"AsyncCustomer Bases: BaseAsyncAPI Provides a wrapper for paystack Customer API The Customers API allows you to create and manage customers in your integration. https://paystack.com/docs/api/#customer Source code in pypaystack2/api/customers.py 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 class AsyncCustomer ( BaseAsyncAPI ): \"\"\"Provides a wrapper for paystack Customer API The Customers API allows you to create and manage customers in your integration. https://paystack.com/docs/api/#customer \"\"\" async def create ( self , email : str , first_name : Optional [ str ] = None , last_name : Optional [ str ] = None , phone : Optional [ str ] = None , metadata : Optional [ dict ] = None , ) -> Response : \"\"\"Create a customer on your integration. Note: The `first_name`, `last_name` and `phone` are optional parameters. However, when creating a customer that would be assigned a Dedicated Virtual Account and your business category falls under Betting, Financial services, and General Service, then these parameters become compulsory. Args: email: Customer's email address first_name: Customer's first name last_name: Customer's last name phone: Customer's phone number metadata: A dictionary that you can attach to the customer. It can be used to store additional information in a structured format. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/customer/\" ) payload = { \"email\" : email , } optional_params = [ ( \"first_name\" , first_name ), ( \"last_name\" , last_name ), ( \"phone\" , phone ), ( \"metadata\" , metadata ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) async def get_customers ( self , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , page : int = 1 , pagination : int = 50 , ) -> Response : \"\"\"Fetches customers available on your integration. Args: start_date: A timestamp from which to start listing customers e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing customers e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 page: Specify exactly what page you want to retrieve. If not specified, we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" query_params = [ ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ] url = self . _parse_url ( f \"/customer/?perPage= { pagination } \" ) url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url ) async def get_customer ( self , email_or_code : str ) -> Response : \"\"\"Get details of a customer on your integration. Args: email_or_code: An email or customer code for the customer you want to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/customer/ { email_or_code } /\" ) return await self . _handle_request ( HTTPMethod . GET , url ) async def update ( self , code : str , first_name : Optional [ str ] = None , last_name : Optional [ str ] = None , phone : Optional [ str ] = None , metadata : Optional [ dict ] = None , ) -> Response : \"\"\"Update a customer's details on your integration Args: code: Customer's code first_name: Customer's first name last_name: Customer's last name phone: Customer's phone number metadata: A dictionary that you can attach to the customer. It can be used to store additional information in a structured format. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/customer/ { code } /\" ) payload = {} optional_params = [ ( \"first_name\" , first_name ), ( \"last_name\" , last_name ), ( \"phone\" , phone ), ( \"metadata\" , metadata ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . PUT , url , payload ) async def validate ( self , email_or_code : str , first_name : str , last_name : str , identification_type : Identification , country : Country , bvn : str , identification_number : Optional [ str ] = None , bank_code : Optional [ str ] = None , account_number : Optional [ str ] = None , middle_name : Optional [ str ] = None , ) -> Response : \"\"\"Validate a customer's identity Args: email_or_code: Customer's email or code first_name: Customer's first name last_name: Customer's last name identification_type: Enum of Identification e.g `Identification.BVN` identification_number: An identification number based on the `identification_type` country: Customer's Country e.g `Country.NIGERIA` bvn: Customer's Bank Verification Number bank_code: You can get the list of Bank Codes by calling the Miscellaneous API `get_banks` method. (required if type is bank_account) account_number: Customer's bank account number. (required if type is bank_account) middle_name: Customer's middle name Returns: A named tuple containing the response gotten from paystack's server. \"\"\" if identification_type == Identification . BANK_ACCOUNT : if bank_code is None : raise InvalidDataError ( \"`bank_code` is required if identification type is `Identification.BANK_ACCOUNT`\" ) if account_number is None : raise InvalidDataError ( \"`account_number` is required if identification type is `Identification.BANK_ACCOUNT`\" ) url = self . _parse_url ( f \"/customer/ { email_or_code } /identification\" ) payload = { \"first_name\" : first_name , \"last_name\" : last_name , \"type\" : identification_type , \"country\" : country , \"bvn\" : bvn , } optional_params = [ ( \"bank_code\" , bank_code ), ( \"account_number\" , account_number ), ( \"middle_name\" , middle_name ), ( \"value\" , identification_number ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) async def flag ( self , customer : str , risk_action : Optional [ RiskAction ] = None , ) -> Response : \"\"\"Whitelist or blacklist a customer on your integration Args: customer: Customer's code, or email address risk_action: One of the possible risk actions from the RiskAction enum e.g `RiskAction.DEFAULT` Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/customer/set_risk_action\" ) payload = { \"customer\" : customer , } optional_params = [ ( \"risk_action\" , risk_action ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) async def deactivate ( self , auth_code : str , ) -> Response : \"\"\"Deactivate an authorization when the card needs to be forgotten Args: auth_code: Authorization code to be deactivated Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/customer/deactivate_authorization\" ) payload = { \"authorization_code\" : auth_code , } return await self . _handle_request ( HTTPMethod . POST , url , payload ) create ( email , first_name = None , last_name = None , phone = None , metadata = None ) async Create a customer on your integration. Note The first_name , last_name and phone are optional parameters. However, when creating a customer that would be assigned a Dedicated Virtual Account and your business category falls under Betting, Financial services, and General Service, then these parameters become compulsory. Parameters: Name Type Description Default email str Customer's email address required first_name Optional [ str ] Customer's first name None last_name Optional [ str ] Customer's last name None phone Optional [ str ] Customer's phone number None metadata Optional [ dict ] A dictionary that you can attach to the customer. It can be used to store additional information in a structured format. None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/customers.py 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 async def create ( self , email : str , first_name : Optional [ str ] = None , last_name : Optional [ str ] = None , phone : Optional [ str ] = None , metadata : Optional [ dict ] = None , ) -> Response : \"\"\"Create a customer on your integration. Note: The `first_name`, `last_name` and `phone` are optional parameters. However, when creating a customer that would be assigned a Dedicated Virtual Account and your business category falls under Betting, Financial services, and General Service, then these parameters become compulsory. Args: email: Customer's email address first_name: Customer's first name last_name: Customer's last name phone: Customer's phone number metadata: A dictionary that you can attach to the customer. It can be used to store additional information in a structured format. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/customer/\" ) payload = { \"email\" : email , } optional_params = [ ( \"first_name\" , first_name ), ( \"last_name\" , last_name ), ( \"phone\" , phone ), ( \"metadata\" , metadata ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) deactivate ( auth_code ) async Deactivate an authorization when the card needs to be forgotten Parameters: Name Type Description Default auth_code str Authorization code to be deactivated required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/customers.py 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 async def deactivate ( self , auth_code : str , ) -> Response : \"\"\"Deactivate an authorization when the card needs to be forgotten Args: auth_code: Authorization code to be deactivated Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/customer/deactivate_authorization\" ) payload = { \"authorization_code\" : auth_code , } return await self . _handle_request ( HTTPMethod . POST , url , payload ) flag ( customer , risk_action = None ) async Whitelist or blacklist a customer on your integration Parameters: Name Type Description Default customer str Customer's code, or email address required risk_action Optional [ RiskAction ] One of the possible risk actions from the RiskAction enum e.g RiskAction.DEFAULT None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/customers.py 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 async def flag ( self , customer : str , risk_action : Optional [ RiskAction ] = None , ) -> Response : \"\"\"Whitelist or blacklist a customer on your integration Args: customer: Customer's code, or email address risk_action: One of the possible risk actions from the RiskAction enum e.g `RiskAction.DEFAULT` Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/customer/set_risk_action\" ) payload = { \"customer\" : customer , } optional_params = [ ( \"risk_action\" , risk_action ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) get_customer ( email_or_code ) async Get details of a customer on your integration. Parameters: Name Type Description Default email_or_code str An email or customer code for the customer you want to fetch required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/customers.py 321 322 323 324 325 326 327 328 329 330 331 332 async def get_customer ( self , email_or_code : str ) -> Response : \"\"\"Get details of a customer on your integration. Args: email_or_code: An email or customer code for the customer you want to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/customer/ { email_or_code } /\" ) return await self . _handle_request ( HTTPMethod . GET , url ) get_customers ( start_date = None , end_date = None , page = 1 , pagination = 50 ) async Fetches customers available on your integration. Parameters: Name Type Description Default start_date Optional [ str ] A timestamp from which to start listing customers e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None end_date Optional [ str ] A timestamp at which to stop listing customers e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None page int Specify exactly what page you want to retrieve. If not specified, we use a default value of 1. 1 pagination int Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. 50 Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/customers.py 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 async def get_customers ( self , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , page : int = 1 , pagination : int = 50 , ) -> Response : \"\"\"Fetches customers available on your integration. Args: start_date: A timestamp from which to start listing customers e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing customers e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 page: Specify exactly what page you want to retrieve. If not specified, we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" query_params = [ ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ] url = self . _parse_url ( f \"/customer/?perPage= { pagination } \" ) url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url ) update ( code , first_name = None , last_name = None , phone = None , metadata = None ) async Update a customer's details on your integration Parameters: Name Type Description Default code str Customer's code required first_name Optional [ str ] Customer's first name None last_name Optional [ str ] Customer's last name None phone Optional [ str ] Customer's phone number None metadata Optional [ dict ] A dictionary that you can attach to the customer. It can be used to store additional information in a structured format. None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/customers.py 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 async def update ( self , code : str , first_name : Optional [ str ] = None , last_name : Optional [ str ] = None , phone : Optional [ str ] = None , metadata : Optional [ dict ] = None , ) -> Response : \"\"\"Update a customer's details on your integration Args: code: Customer's code first_name: Customer's first name last_name: Customer's last name phone: Customer's phone number metadata: A dictionary that you can attach to the customer. It can be used to store additional information in a structured format. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/customer/ { code } /\" ) payload = {} optional_params = [ ( \"first_name\" , first_name ), ( \"last_name\" , last_name ), ( \"phone\" , phone ), ( \"metadata\" , metadata ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . PUT , url , payload ) validate ( email_or_code , first_name , last_name , identification_type , country , bvn , identification_number = None , bank_code = None , account_number = None , middle_name = None ) async Validate a customer's identity Parameters: Name Type Description Default email_or_code str Customer's email or code required first_name str Customer's first name required last_name str Customer's last name required identification_type Identification Enum of Identification e.g Identification.BVN required identification_number Optional [ str ] An identification number based on the identification_type None country Country Customer's Country e.g Country.NIGERIA required bvn str Customer's Bank Verification Number required bank_code Optional [ str ] You can get the list of Bank Codes by calling the Miscellaneous API get_banks method. (required if type is bank_account) None account_number Optional [ str ] Customer's bank account number. (required if type is bank_account) None middle_name Optional [ str ] Customer's middle name None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/customers.py 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 async def validate ( self , email_or_code : str , first_name : str , last_name : str , identification_type : Identification , country : Country , bvn : str , identification_number : Optional [ str ] = None , bank_code : Optional [ str ] = None , account_number : Optional [ str ] = None , middle_name : Optional [ str ] = None , ) -> Response : \"\"\"Validate a customer's identity Args: email_or_code: Customer's email or code first_name: Customer's first name last_name: Customer's last name identification_type: Enum of Identification e.g `Identification.BVN` identification_number: An identification number based on the `identification_type` country: Customer's Country e.g `Country.NIGERIA` bvn: Customer's Bank Verification Number bank_code: You can get the list of Bank Codes by calling the Miscellaneous API `get_banks` method. (required if type is bank_account) account_number: Customer's bank account number. (required if type is bank_account) middle_name: Customer's middle name Returns: A named tuple containing the response gotten from paystack's server. \"\"\" if identification_type == Identification . BANK_ACCOUNT : if bank_code is None : raise InvalidDataError ( \"`bank_code` is required if identification type is `Identification.BANK_ACCOUNT`\" ) if account_number is None : raise InvalidDataError ( \"`account_number` is required if identification type is `Identification.BANK_ACCOUNT`\" ) url = self . _parse_url ( f \"/customer/ { email_or_code } /identification\" ) payload = { \"first_name\" : first_name , \"last_name\" : last_name , \"type\" : identification_type , \"country\" : country , \"bvn\" : bvn , } optional_params = [ ( \"bank_code\" , bank_code ), ( \"account_number\" , account_number ), ( \"middle_name\" , middle_name ), ( \"value\" , identification_number ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) Customer Bases: BaseAPI Provides a wrapper for paystack Customer API The Customers API allows you to create and manage customers in your integration. https://paystack.com/docs/api/#customer Source code in pypaystack2/api/customers.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 class Customer ( BaseAPI ): \"\"\"Provides a wrapper for paystack Customer API The Customers API allows you to create and manage customers in your integration. https://paystack.com/docs/api/#customer \"\"\" def create ( self , email : str , first_name : Optional [ str ] = None , last_name : Optional [ str ] = None , phone : Optional [ str ] = None , metadata : Optional [ dict ] = None , ) -> Response : \"\"\"Create a customer on your integration. Note: The `first_name`, `last_name` and `phone` are optional parameters. However, when creating a customer that would be assigned a Dedicated Virtual Account and your business category falls under Betting, Financial services, and General Service, then these parameters become compulsory. Args: email: Customer's email address first_name: Customer's first name last_name: Customer's last name phone: Customer's phone number metadata: A dictionary that you can attach to the customer. It can be used to store additional information in a structured format. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/customer/\" ) payload = { \"email\" : email , } optional_params = [ ( \"first_name\" , first_name ), ( \"last_name\" , last_name ), ( \"phone\" , phone ), ( \"metadata\" , metadata ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . POST , url , payload ) def get_customers ( self , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , page : int = 1 , pagination : int = 50 , ) -> Response : \"\"\"Fetches customers available on your integration. Args: start_date: A timestamp from which to start listing customers e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing customers e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 page: Specify exactly what page you want to retrieve. If not specified, we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" query_params = [ ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ] url = self . _parse_url ( f \"/customer/?perPage= { pagination } \" ) url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url ) def get_customer ( self , email_or_code : str ) -> Response : \"\"\"Get details of a customer on your integration. Args: email_or_code: An email or customer code for the customer you want to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/customer/ { email_or_code } /\" ) return self . _handle_request ( HTTPMethod . GET , url ) def update ( self , code : str , first_name : Optional [ str ] = None , last_name : Optional [ str ] = None , phone : Optional [ str ] = None , metadata : Optional [ dict ] = None , ) -> Response : \"\"\"Update a customer's details on your integration Args: code: Customer's code first_name: Customer's first name last_name: Customer's last name phone: Customer's phone number metadata: A dictionary that you can attach to the customer. It can be used to store additional information in a structured format. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/customer/ { code } /\" ) payload = {} optional_params = [ ( \"first_name\" , first_name ), ( \"last_name\" , last_name ), ( \"phone\" , phone ), ( \"metadata\" , metadata ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . PUT , url , payload ) def validate ( self , email_or_code : str , first_name : str , last_name : str , identification_type : Identification , country : Country , bvn : str , identification_number : Optional [ str ] = None , bank_code : Optional [ str ] = None , account_number : Optional [ str ] = None , middle_name : Optional [ str ] = None , ) -> Response : \"\"\"Validate a customer's identity Args: email_or_code: Customer's email or code first_name: Customer's first name last_name: Customer's last name identification_type: Enum of Identification e.g `Identification.BVN` identification_number: An identification number based on the `identification_type` country: Customer's Country e.g `Country.NIGERIA` bvn: Customer's Bank Verification Number bank_code: You can get the list of Bank Codes by calling the Miscellaneous API `get_banks` method. (required if type is bank_account) account_number: Customer's bank account number. (required if type is bank_account) middle_name: Customer's middle name Returns: A named tuple containing the response gotten from paystack's server. \"\"\" if identification_type == Identification . BANK_ACCOUNT : if bank_code is None : raise InvalidDataError ( \"`bank_code` is required if identification type is `Identification.BANK_ACCOUNT`\" ) if account_number is None : raise InvalidDataError ( \"`account_number` is required if identification type is `Identification.BANK_ACCOUNT`\" ) url = self . _parse_url ( f \"/customer/ { email_or_code } /identification\" ) payload = { \"first_name\" : first_name , \"last_name\" : last_name , \"type\" : identification_type , \"country\" : country , \"bvn\" : bvn , } optional_params = [ ( \"bank_code\" , bank_code ), ( \"account_number\" , account_number ), ( \"middle_name\" , middle_name ), ( \"value\" , identification_number ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . POST , url , payload ) def flag ( self , customer : str , risk_action : Optional [ RiskAction ] = None , ) -> Response : \"\"\"Whitelist or blacklist a customer on your integration Args: customer: Customer's code, or email address risk_action: One of the possible risk actions from the RiskAction enum e.g `RiskAction.DEFAULT` Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/customer/set_risk_action\" ) payload = { \"customer\" : customer , } optional_params = [ ( \"risk_action\" , risk_action ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . POST , url , payload ) def deactivate ( self , auth_code : str , ) -> Response : \"\"\"Deactivate an authorization when the card needs to be forgotten Args: auth_code: Authorization code to be deactivated Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/customer/deactivate_authorization\" ) payload = { \"authorization_code\" : auth_code , } return self . _handle_request ( HTTPMethod . POST , url , payload ) create ( email , first_name = None , last_name = None , phone = None , metadata = None ) Create a customer on your integration. Note The first_name , last_name and phone are optional parameters. However, when creating a customer that would be assigned a Dedicated Virtual Account and your business category falls under Betting, Financial services, and General Service, then these parameters become compulsory. Parameters: Name Type Description Default email str Customer's email address required first_name Optional [ str ] Customer's first name None last_name Optional [ str ] Customer's last name None phone Optional [ str ] Customer's phone number None metadata Optional [ dict ] A dictionary that you can attach to the customer. It can be used to store additional information in a structured format. None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/customers.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 def create ( self , email : str , first_name : Optional [ str ] = None , last_name : Optional [ str ] = None , phone : Optional [ str ] = None , metadata : Optional [ dict ] = None , ) -> Response : \"\"\"Create a customer on your integration. Note: The `first_name`, `last_name` and `phone` are optional parameters. However, when creating a customer that would be assigned a Dedicated Virtual Account and your business category falls under Betting, Financial services, and General Service, then these parameters become compulsory. Args: email: Customer's email address first_name: Customer's first name last_name: Customer's last name phone: Customer's phone number metadata: A dictionary that you can attach to the customer. It can be used to store additional information in a structured format. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/customer/\" ) payload = { \"email\" : email , } optional_params = [ ( \"first_name\" , first_name ), ( \"last_name\" , last_name ), ( \"phone\" , phone ), ( \"metadata\" , metadata ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . POST , url , payload ) deactivate ( auth_code ) Deactivate an authorization when the card needs to be forgotten Parameters: Name Type Description Default auth_code str Authorization code to be deactivated required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/customers.py 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 def deactivate ( self , auth_code : str , ) -> Response : \"\"\"Deactivate an authorization when the card needs to be forgotten Args: auth_code: Authorization code to be deactivated Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/customer/deactivate_authorization\" ) payload = { \"authorization_code\" : auth_code , } return self . _handle_request ( HTTPMethod . POST , url , payload ) flag ( customer , risk_action = None ) Whitelist or blacklist a customer on your integration Parameters: Name Type Description Default customer str Customer's code, or email address required risk_action Optional [ RiskAction ] One of the possible risk actions from the RiskAction enum e.g RiskAction.DEFAULT None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/customers.py 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 def flag ( self , customer : str , risk_action : Optional [ RiskAction ] = None , ) -> Response : \"\"\"Whitelist or blacklist a customer on your integration Args: customer: Customer's code, or email address risk_action: One of the possible risk actions from the RiskAction enum e.g `RiskAction.DEFAULT` Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/customer/set_risk_action\" ) payload = { \"customer\" : customer , } optional_params = [ ( \"risk_action\" , risk_action ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . POST , url , payload ) get_customer ( email_or_code ) Get details of a customer on your integration. Parameters: Name Type Description Default email_or_code str An email or customer code for the customer you want to fetch required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/customers.py 93 94 95 96 97 98 99 100 101 102 103 104 def get_customer ( self , email_or_code : str ) -> Response : \"\"\"Get details of a customer on your integration. Args: email_or_code: An email or customer code for the customer you want to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/customer/ { email_or_code } /\" ) return self . _handle_request ( HTTPMethod . GET , url ) get_customers ( start_date = None , end_date = None , page = 1 , pagination = 50 ) Fetches customers available on your integration. Parameters: Name Type Description Default start_date Optional [ str ] A timestamp from which to start listing customers e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None end_date Optional [ str ] A timestamp at which to stop listing customers e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None page int Specify exactly what page you want to retrieve. If not specified, we use a default value of 1. 1 pagination int Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. 50 Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/customers.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 def get_customers ( self , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , page : int = 1 , pagination : int = 50 , ) -> Response : \"\"\"Fetches customers available on your integration. Args: start_date: A timestamp from which to start listing customers e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing customers e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 page: Specify exactly what page you want to retrieve. If not specified, we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" query_params = [ ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ] url = self . _parse_url ( f \"/customer/?perPage= { pagination } \" ) url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url ) update ( code , first_name = None , last_name = None , phone = None , metadata = None ) Update a customer's details on your integration Parameters: Name Type Description Default code str Customer's code required first_name Optional [ str ] Customer's first name None last_name Optional [ str ] Customer's last name None phone Optional [ str ] Customer's phone number None metadata Optional [ dict ] A dictionary that you can attach to the customer. It can be used to store additional information in a structured format. None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/customers.py 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 def update ( self , code : str , first_name : Optional [ str ] = None , last_name : Optional [ str ] = None , phone : Optional [ str ] = None , metadata : Optional [ dict ] = None , ) -> Response : \"\"\"Update a customer's details on your integration Args: code: Customer's code first_name: Customer's first name last_name: Customer's last name phone: Customer's phone number metadata: A dictionary that you can attach to the customer. It can be used to store additional information in a structured format. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/customer/ { code } /\" ) payload = {} optional_params = [ ( \"first_name\" , first_name ), ( \"last_name\" , last_name ), ( \"phone\" , phone ), ( \"metadata\" , metadata ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . PUT , url , payload ) validate ( email_or_code , first_name , last_name , identification_type , country , bvn , identification_number = None , bank_code = None , account_number = None , middle_name = None ) Validate a customer's identity Parameters: Name Type Description Default email_or_code str Customer's email or code required first_name str Customer's first name required last_name str Customer's last name required identification_type Identification Enum of Identification e.g Identification.BVN required identification_number Optional [ str ] An identification number based on the identification_type None country Country Customer's Country e.g Country.NIGERIA required bvn str Customer's Bank Verification Number required bank_code Optional [ str ] You can get the list of Bank Codes by calling the Miscellaneous API get_banks method. (required if type is bank_account) None account_number Optional [ str ] Customer's bank account number. (required if type is bank_account) None middle_name Optional [ str ] Customer's middle name None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/customers.py 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 def validate ( self , email_or_code : str , first_name : str , last_name : str , identification_type : Identification , country : Country , bvn : str , identification_number : Optional [ str ] = None , bank_code : Optional [ str ] = None , account_number : Optional [ str ] = None , middle_name : Optional [ str ] = None , ) -> Response : \"\"\"Validate a customer's identity Args: email_or_code: Customer's email or code first_name: Customer's first name last_name: Customer's last name identification_type: Enum of Identification e.g `Identification.BVN` identification_number: An identification number based on the `identification_type` country: Customer's Country e.g `Country.NIGERIA` bvn: Customer's Bank Verification Number bank_code: You can get the list of Bank Codes by calling the Miscellaneous API `get_banks` method. (required if type is bank_account) account_number: Customer's bank account number. (required if type is bank_account) middle_name: Customer's middle name Returns: A named tuple containing the response gotten from paystack's server. \"\"\" if identification_type == Identification . BANK_ACCOUNT : if bank_code is None : raise InvalidDataError ( \"`bank_code` is required if identification type is `Identification.BANK_ACCOUNT`\" ) if account_number is None : raise InvalidDataError ( \"`account_number` is required if identification type is `Identification.BANK_ACCOUNT`\" ) url = self . _parse_url ( f \"/customer/ { email_or_code } /identification\" ) payload = { \"first_name\" : first_name , \"last_name\" : last_name , \"type\" : identification_type , \"country\" : country , \"bvn\" : bvn , } optional_params = [ ( \"bank_code\" , bank_code ), ( \"account_number\" , account_number ), ( \"middle_name\" , middle_name ), ( \"value\" , identification_number ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . POST , url , payload )","title":"Customer"},{"location":"reference/customer/#pypaystack2.api.customers.AsyncCustomer","text":"Bases: BaseAsyncAPI Provides a wrapper for paystack Customer API The Customers API allows you to create and manage customers in your integration. https://paystack.com/docs/api/#customer Source code in pypaystack2/api/customers.py 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 class AsyncCustomer ( BaseAsyncAPI ): \"\"\"Provides a wrapper for paystack Customer API The Customers API allows you to create and manage customers in your integration. https://paystack.com/docs/api/#customer \"\"\" async def create ( self , email : str , first_name : Optional [ str ] = None , last_name : Optional [ str ] = None , phone : Optional [ str ] = None , metadata : Optional [ dict ] = None , ) -> Response : \"\"\"Create a customer on your integration. Note: The `first_name`, `last_name` and `phone` are optional parameters. However, when creating a customer that would be assigned a Dedicated Virtual Account and your business category falls under Betting, Financial services, and General Service, then these parameters become compulsory. Args: email: Customer's email address first_name: Customer's first name last_name: Customer's last name phone: Customer's phone number metadata: A dictionary that you can attach to the customer. It can be used to store additional information in a structured format. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/customer/\" ) payload = { \"email\" : email , } optional_params = [ ( \"first_name\" , first_name ), ( \"last_name\" , last_name ), ( \"phone\" , phone ), ( \"metadata\" , metadata ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) async def get_customers ( self , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , page : int = 1 , pagination : int = 50 , ) -> Response : \"\"\"Fetches customers available on your integration. Args: start_date: A timestamp from which to start listing customers e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing customers e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 page: Specify exactly what page you want to retrieve. If not specified, we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" query_params = [ ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ] url = self . _parse_url ( f \"/customer/?perPage= { pagination } \" ) url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url ) async def get_customer ( self , email_or_code : str ) -> Response : \"\"\"Get details of a customer on your integration. Args: email_or_code: An email or customer code for the customer you want to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/customer/ { email_or_code } /\" ) return await self . _handle_request ( HTTPMethod . GET , url ) async def update ( self , code : str , first_name : Optional [ str ] = None , last_name : Optional [ str ] = None , phone : Optional [ str ] = None , metadata : Optional [ dict ] = None , ) -> Response : \"\"\"Update a customer's details on your integration Args: code: Customer's code first_name: Customer's first name last_name: Customer's last name phone: Customer's phone number metadata: A dictionary that you can attach to the customer. It can be used to store additional information in a structured format. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/customer/ { code } /\" ) payload = {} optional_params = [ ( \"first_name\" , first_name ), ( \"last_name\" , last_name ), ( \"phone\" , phone ), ( \"metadata\" , metadata ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . PUT , url , payload ) async def validate ( self , email_or_code : str , first_name : str , last_name : str , identification_type : Identification , country : Country , bvn : str , identification_number : Optional [ str ] = None , bank_code : Optional [ str ] = None , account_number : Optional [ str ] = None , middle_name : Optional [ str ] = None , ) -> Response : \"\"\"Validate a customer's identity Args: email_or_code: Customer's email or code first_name: Customer's first name last_name: Customer's last name identification_type: Enum of Identification e.g `Identification.BVN` identification_number: An identification number based on the `identification_type` country: Customer's Country e.g `Country.NIGERIA` bvn: Customer's Bank Verification Number bank_code: You can get the list of Bank Codes by calling the Miscellaneous API `get_banks` method. (required if type is bank_account) account_number: Customer's bank account number. (required if type is bank_account) middle_name: Customer's middle name Returns: A named tuple containing the response gotten from paystack's server. \"\"\" if identification_type == Identification . BANK_ACCOUNT : if bank_code is None : raise InvalidDataError ( \"`bank_code` is required if identification type is `Identification.BANK_ACCOUNT`\" ) if account_number is None : raise InvalidDataError ( \"`account_number` is required if identification type is `Identification.BANK_ACCOUNT`\" ) url = self . _parse_url ( f \"/customer/ { email_or_code } /identification\" ) payload = { \"first_name\" : first_name , \"last_name\" : last_name , \"type\" : identification_type , \"country\" : country , \"bvn\" : bvn , } optional_params = [ ( \"bank_code\" , bank_code ), ( \"account_number\" , account_number ), ( \"middle_name\" , middle_name ), ( \"value\" , identification_number ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) async def flag ( self , customer : str , risk_action : Optional [ RiskAction ] = None , ) -> Response : \"\"\"Whitelist or blacklist a customer on your integration Args: customer: Customer's code, or email address risk_action: One of the possible risk actions from the RiskAction enum e.g `RiskAction.DEFAULT` Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/customer/set_risk_action\" ) payload = { \"customer\" : customer , } optional_params = [ ( \"risk_action\" , risk_action ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) async def deactivate ( self , auth_code : str , ) -> Response : \"\"\"Deactivate an authorization when the card needs to be forgotten Args: auth_code: Authorization code to be deactivated Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/customer/deactivate_authorization\" ) payload = { \"authorization_code\" : auth_code , } return await self . _handle_request ( HTTPMethod . POST , url , payload )","title":"AsyncCustomer"},{"location":"reference/customer/#pypaystack2.api.customers.AsyncCustomer.create","text":"Create a customer on your integration. Note The first_name , last_name and phone are optional parameters. However, when creating a customer that would be assigned a Dedicated Virtual Account and your business category falls under Betting, Financial services, and General Service, then these parameters become compulsory. Parameters: Name Type Description Default email str Customer's email address required first_name Optional [ str ] Customer's first name None last_name Optional [ str ] Customer's last name None phone Optional [ str ] Customer's phone number None metadata Optional [ dict ] A dictionary that you can attach to the customer. It can be used to store additional information in a structured format. None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/customers.py 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 async def create ( self , email : str , first_name : Optional [ str ] = None , last_name : Optional [ str ] = None , phone : Optional [ str ] = None , metadata : Optional [ dict ] = None , ) -> Response : \"\"\"Create a customer on your integration. Note: The `first_name`, `last_name` and `phone` are optional parameters. However, when creating a customer that would be assigned a Dedicated Virtual Account and your business category falls under Betting, Financial services, and General Service, then these parameters become compulsory. Args: email: Customer's email address first_name: Customer's first name last_name: Customer's last name phone: Customer's phone number metadata: A dictionary that you can attach to the customer. It can be used to store additional information in a structured format. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/customer/\" ) payload = { \"email\" : email , } optional_params = [ ( \"first_name\" , first_name ), ( \"last_name\" , last_name ), ( \"phone\" , phone ), ( \"metadata\" , metadata ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . POST , url , payload )","title":"create()"},{"location":"reference/customer/#pypaystack2.api.customers.AsyncCustomer.deactivate","text":"Deactivate an authorization when the card needs to be forgotten Parameters: Name Type Description Default auth_code str Authorization code to be deactivated required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/customers.py 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 async def deactivate ( self , auth_code : str , ) -> Response : \"\"\"Deactivate an authorization when the card needs to be forgotten Args: auth_code: Authorization code to be deactivated Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/customer/deactivate_authorization\" ) payload = { \"authorization_code\" : auth_code , } return await self . _handle_request ( HTTPMethod . POST , url , payload )","title":"deactivate()"},{"location":"reference/customer/#pypaystack2.api.customers.AsyncCustomer.flag","text":"Whitelist or blacklist a customer on your integration Parameters: Name Type Description Default customer str Customer's code, or email address required risk_action Optional [ RiskAction ] One of the possible risk actions from the RiskAction enum e.g RiskAction.DEFAULT None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/customers.py 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 async def flag ( self , customer : str , risk_action : Optional [ RiskAction ] = None , ) -> Response : \"\"\"Whitelist or blacklist a customer on your integration Args: customer: Customer's code, or email address risk_action: One of the possible risk actions from the RiskAction enum e.g `RiskAction.DEFAULT` Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/customer/set_risk_action\" ) payload = { \"customer\" : customer , } optional_params = [ ( \"risk_action\" , risk_action ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . POST , url , payload )","title":"flag()"},{"location":"reference/customer/#pypaystack2.api.customers.AsyncCustomer.get_customer","text":"Get details of a customer on your integration. Parameters: Name Type Description Default email_or_code str An email or customer code for the customer you want to fetch required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/customers.py 321 322 323 324 325 326 327 328 329 330 331 332 async def get_customer ( self , email_or_code : str ) -> Response : \"\"\"Get details of a customer on your integration. Args: email_or_code: An email or customer code for the customer you want to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/customer/ { email_or_code } /\" ) return await self . _handle_request ( HTTPMethod . GET , url )","title":"get_customer()"},{"location":"reference/customer/#pypaystack2.api.customers.AsyncCustomer.get_customers","text":"Fetches customers available on your integration. Parameters: Name Type Description Default start_date Optional [ str ] A timestamp from which to start listing customers e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None end_date Optional [ str ] A timestamp at which to stop listing customers e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None page int Specify exactly what page you want to retrieve. If not specified, we use a default value of 1. 1 pagination int Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. 50 Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/customers.py 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 async def get_customers ( self , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , page : int = 1 , pagination : int = 50 , ) -> Response : \"\"\"Fetches customers available on your integration. Args: start_date: A timestamp from which to start listing customers e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing customers e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 page: Specify exactly what page you want to retrieve. If not specified, we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" query_params = [ ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ] url = self . _parse_url ( f \"/customer/?perPage= { pagination } \" ) url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url )","title":"get_customers()"},{"location":"reference/customer/#pypaystack2.api.customers.AsyncCustomer.update","text":"Update a customer's details on your integration Parameters: Name Type Description Default code str Customer's code required first_name Optional [ str ] Customer's first name None last_name Optional [ str ] Customer's last name None phone Optional [ str ] Customer's phone number None metadata Optional [ dict ] A dictionary that you can attach to the customer. It can be used to store additional information in a structured format. None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/customers.py 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 async def update ( self , code : str , first_name : Optional [ str ] = None , last_name : Optional [ str ] = None , phone : Optional [ str ] = None , metadata : Optional [ dict ] = None , ) -> Response : \"\"\"Update a customer's details on your integration Args: code: Customer's code first_name: Customer's first name last_name: Customer's last name phone: Customer's phone number metadata: A dictionary that you can attach to the customer. It can be used to store additional information in a structured format. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/customer/ { code } /\" ) payload = {} optional_params = [ ( \"first_name\" , first_name ), ( \"last_name\" , last_name ), ( \"phone\" , phone ), ( \"metadata\" , metadata ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . PUT , url , payload )","title":"update()"},{"location":"reference/customer/#pypaystack2.api.customers.AsyncCustomer.validate","text":"Validate a customer's identity Parameters: Name Type Description Default email_or_code str Customer's email or code required first_name str Customer's first name required last_name str Customer's last name required identification_type Identification Enum of Identification e.g Identification.BVN required identification_number Optional [ str ] An identification number based on the identification_type None country Country Customer's Country e.g Country.NIGERIA required bvn str Customer's Bank Verification Number required bank_code Optional [ str ] You can get the list of Bank Codes by calling the Miscellaneous API get_banks method. (required if type is bank_account) None account_number Optional [ str ] Customer's bank account number. (required if type is bank_account) None middle_name Optional [ str ] Customer's middle name None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/customers.py 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 async def validate ( self , email_or_code : str , first_name : str , last_name : str , identification_type : Identification , country : Country , bvn : str , identification_number : Optional [ str ] = None , bank_code : Optional [ str ] = None , account_number : Optional [ str ] = None , middle_name : Optional [ str ] = None , ) -> Response : \"\"\"Validate a customer's identity Args: email_or_code: Customer's email or code first_name: Customer's first name last_name: Customer's last name identification_type: Enum of Identification e.g `Identification.BVN` identification_number: An identification number based on the `identification_type` country: Customer's Country e.g `Country.NIGERIA` bvn: Customer's Bank Verification Number bank_code: You can get the list of Bank Codes by calling the Miscellaneous API `get_banks` method. (required if type is bank_account) account_number: Customer's bank account number. (required if type is bank_account) middle_name: Customer's middle name Returns: A named tuple containing the response gotten from paystack's server. \"\"\" if identification_type == Identification . BANK_ACCOUNT : if bank_code is None : raise InvalidDataError ( \"`bank_code` is required if identification type is `Identification.BANK_ACCOUNT`\" ) if account_number is None : raise InvalidDataError ( \"`account_number` is required if identification type is `Identification.BANK_ACCOUNT`\" ) url = self . _parse_url ( f \"/customer/ { email_or_code } /identification\" ) payload = { \"first_name\" : first_name , \"last_name\" : last_name , \"type\" : identification_type , \"country\" : country , \"bvn\" : bvn , } optional_params = [ ( \"bank_code\" , bank_code ), ( \"account_number\" , account_number ), ( \"middle_name\" , middle_name ), ( \"value\" , identification_number ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . POST , url , payload )","title":"validate()"},{"location":"reference/customer/#pypaystack2.api.customers.Customer","text":"Bases: BaseAPI Provides a wrapper for paystack Customer API The Customers API allows you to create and manage customers in your integration. https://paystack.com/docs/api/#customer Source code in pypaystack2/api/customers.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 class Customer ( BaseAPI ): \"\"\"Provides a wrapper for paystack Customer API The Customers API allows you to create and manage customers in your integration. https://paystack.com/docs/api/#customer \"\"\" def create ( self , email : str , first_name : Optional [ str ] = None , last_name : Optional [ str ] = None , phone : Optional [ str ] = None , metadata : Optional [ dict ] = None , ) -> Response : \"\"\"Create a customer on your integration. Note: The `first_name`, `last_name` and `phone` are optional parameters. However, when creating a customer that would be assigned a Dedicated Virtual Account and your business category falls under Betting, Financial services, and General Service, then these parameters become compulsory. Args: email: Customer's email address first_name: Customer's first name last_name: Customer's last name phone: Customer's phone number metadata: A dictionary that you can attach to the customer. It can be used to store additional information in a structured format. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/customer/\" ) payload = { \"email\" : email , } optional_params = [ ( \"first_name\" , first_name ), ( \"last_name\" , last_name ), ( \"phone\" , phone ), ( \"metadata\" , metadata ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . POST , url , payload ) def get_customers ( self , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , page : int = 1 , pagination : int = 50 , ) -> Response : \"\"\"Fetches customers available on your integration. Args: start_date: A timestamp from which to start listing customers e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing customers e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 page: Specify exactly what page you want to retrieve. If not specified, we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" query_params = [ ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ] url = self . _parse_url ( f \"/customer/?perPage= { pagination } \" ) url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url ) def get_customer ( self , email_or_code : str ) -> Response : \"\"\"Get details of a customer on your integration. Args: email_or_code: An email or customer code for the customer you want to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/customer/ { email_or_code } /\" ) return self . _handle_request ( HTTPMethod . GET , url ) def update ( self , code : str , first_name : Optional [ str ] = None , last_name : Optional [ str ] = None , phone : Optional [ str ] = None , metadata : Optional [ dict ] = None , ) -> Response : \"\"\"Update a customer's details on your integration Args: code: Customer's code first_name: Customer's first name last_name: Customer's last name phone: Customer's phone number metadata: A dictionary that you can attach to the customer. It can be used to store additional information in a structured format. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/customer/ { code } /\" ) payload = {} optional_params = [ ( \"first_name\" , first_name ), ( \"last_name\" , last_name ), ( \"phone\" , phone ), ( \"metadata\" , metadata ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . PUT , url , payload ) def validate ( self , email_or_code : str , first_name : str , last_name : str , identification_type : Identification , country : Country , bvn : str , identification_number : Optional [ str ] = None , bank_code : Optional [ str ] = None , account_number : Optional [ str ] = None , middle_name : Optional [ str ] = None , ) -> Response : \"\"\"Validate a customer's identity Args: email_or_code: Customer's email or code first_name: Customer's first name last_name: Customer's last name identification_type: Enum of Identification e.g `Identification.BVN` identification_number: An identification number based on the `identification_type` country: Customer's Country e.g `Country.NIGERIA` bvn: Customer's Bank Verification Number bank_code: You can get the list of Bank Codes by calling the Miscellaneous API `get_banks` method. (required if type is bank_account) account_number: Customer's bank account number. (required if type is bank_account) middle_name: Customer's middle name Returns: A named tuple containing the response gotten from paystack's server. \"\"\" if identification_type == Identification . BANK_ACCOUNT : if bank_code is None : raise InvalidDataError ( \"`bank_code` is required if identification type is `Identification.BANK_ACCOUNT`\" ) if account_number is None : raise InvalidDataError ( \"`account_number` is required if identification type is `Identification.BANK_ACCOUNT`\" ) url = self . _parse_url ( f \"/customer/ { email_or_code } /identification\" ) payload = { \"first_name\" : first_name , \"last_name\" : last_name , \"type\" : identification_type , \"country\" : country , \"bvn\" : bvn , } optional_params = [ ( \"bank_code\" , bank_code ), ( \"account_number\" , account_number ), ( \"middle_name\" , middle_name ), ( \"value\" , identification_number ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . POST , url , payload ) def flag ( self , customer : str , risk_action : Optional [ RiskAction ] = None , ) -> Response : \"\"\"Whitelist or blacklist a customer on your integration Args: customer: Customer's code, or email address risk_action: One of the possible risk actions from the RiskAction enum e.g `RiskAction.DEFAULT` Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/customer/set_risk_action\" ) payload = { \"customer\" : customer , } optional_params = [ ( \"risk_action\" , risk_action ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . POST , url , payload ) def deactivate ( self , auth_code : str , ) -> Response : \"\"\"Deactivate an authorization when the card needs to be forgotten Args: auth_code: Authorization code to be deactivated Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/customer/deactivate_authorization\" ) payload = { \"authorization_code\" : auth_code , } return self . _handle_request ( HTTPMethod . POST , url , payload )","title":"Customer"},{"location":"reference/customer/#pypaystack2.api.customers.Customer.create","text":"Create a customer on your integration. Note The first_name , last_name and phone are optional parameters. However, when creating a customer that would be assigned a Dedicated Virtual Account and your business category falls under Betting, Financial services, and General Service, then these parameters become compulsory. Parameters: Name Type Description Default email str Customer's email address required first_name Optional [ str ] Customer's first name None last_name Optional [ str ] Customer's last name None phone Optional [ str ] Customer's phone number None metadata Optional [ dict ] A dictionary that you can attach to the customer. It can be used to store additional information in a structured format. None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/customers.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 def create ( self , email : str , first_name : Optional [ str ] = None , last_name : Optional [ str ] = None , phone : Optional [ str ] = None , metadata : Optional [ dict ] = None , ) -> Response : \"\"\"Create a customer on your integration. Note: The `first_name`, `last_name` and `phone` are optional parameters. However, when creating a customer that would be assigned a Dedicated Virtual Account and your business category falls under Betting, Financial services, and General Service, then these parameters become compulsory. Args: email: Customer's email address first_name: Customer's first name last_name: Customer's last name phone: Customer's phone number metadata: A dictionary that you can attach to the customer. It can be used to store additional information in a structured format. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/customer/\" ) payload = { \"email\" : email , } optional_params = [ ( \"first_name\" , first_name ), ( \"last_name\" , last_name ), ( \"phone\" , phone ), ( \"metadata\" , metadata ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . POST , url , payload )","title":"create()"},{"location":"reference/customer/#pypaystack2.api.customers.Customer.deactivate","text":"Deactivate an authorization when the card needs to be forgotten Parameters: Name Type Description Default auth_code str Authorization code to be deactivated required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/customers.py 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 def deactivate ( self , auth_code : str , ) -> Response : \"\"\"Deactivate an authorization when the card needs to be forgotten Args: auth_code: Authorization code to be deactivated Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/customer/deactivate_authorization\" ) payload = { \"authorization_code\" : auth_code , } return self . _handle_request ( HTTPMethod . POST , url , payload )","title":"deactivate()"},{"location":"reference/customer/#pypaystack2.api.customers.Customer.flag","text":"Whitelist or blacklist a customer on your integration Parameters: Name Type Description Default customer str Customer's code, or email address required risk_action Optional [ RiskAction ] One of the possible risk actions from the RiskAction enum e.g RiskAction.DEFAULT None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/customers.py 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 def flag ( self , customer : str , risk_action : Optional [ RiskAction ] = None , ) -> Response : \"\"\"Whitelist or blacklist a customer on your integration Args: customer: Customer's code, or email address risk_action: One of the possible risk actions from the RiskAction enum e.g `RiskAction.DEFAULT` Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/customer/set_risk_action\" ) payload = { \"customer\" : customer , } optional_params = [ ( \"risk_action\" , risk_action ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . POST , url , payload )","title":"flag()"},{"location":"reference/customer/#pypaystack2.api.customers.Customer.get_customer","text":"Get details of a customer on your integration. Parameters: Name Type Description Default email_or_code str An email or customer code for the customer you want to fetch required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/customers.py 93 94 95 96 97 98 99 100 101 102 103 104 def get_customer ( self , email_or_code : str ) -> Response : \"\"\"Get details of a customer on your integration. Args: email_or_code: An email or customer code for the customer you want to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/customer/ { email_or_code } /\" ) return self . _handle_request ( HTTPMethod . GET , url )","title":"get_customer()"},{"location":"reference/customer/#pypaystack2.api.customers.Customer.get_customers","text":"Fetches customers available on your integration. Parameters: Name Type Description Default start_date Optional [ str ] A timestamp from which to start listing customers e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None end_date Optional [ str ] A timestamp at which to stop listing customers e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None page int Specify exactly what page you want to retrieve. If not specified, we use a default value of 1. 1 pagination int Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. 50 Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/customers.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 def get_customers ( self , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , page : int = 1 , pagination : int = 50 , ) -> Response : \"\"\"Fetches customers available on your integration. Args: start_date: A timestamp from which to start listing customers e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing customers e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 page: Specify exactly what page you want to retrieve. If not specified, we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" query_params = [ ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ] url = self . _parse_url ( f \"/customer/?perPage= { pagination } \" ) url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url )","title":"get_customers()"},{"location":"reference/customer/#pypaystack2.api.customers.Customer.update","text":"Update a customer's details on your integration Parameters: Name Type Description Default code str Customer's code required first_name Optional [ str ] Customer's first name None last_name Optional [ str ] Customer's last name None phone Optional [ str ] Customer's phone number None metadata Optional [ dict ] A dictionary that you can attach to the customer. It can be used to store additional information in a structured format. None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/customers.py 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 def update ( self , code : str , first_name : Optional [ str ] = None , last_name : Optional [ str ] = None , phone : Optional [ str ] = None , metadata : Optional [ dict ] = None , ) -> Response : \"\"\"Update a customer's details on your integration Args: code: Customer's code first_name: Customer's first name last_name: Customer's last name phone: Customer's phone number metadata: A dictionary that you can attach to the customer. It can be used to store additional information in a structured format. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/customer/ { code } /\" ) payload = {} optional_params = [ ( \"first_name\" , first_name ), ( \"last_name\" , last_name ), ( \"phone\" , phone ), ( \"metadata\" , metadata ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . PUT , url , payload )","title":"update()"},{"location":"reference/customer/#pypaystack2.api.customers.Customer.validate","text":"Validate a customer's identity Parameters: Name Type Description Default email_or_code str Customer's email or code required first_name str Customer's first name required last_name str Customer's last name required identification_type Identification Enum of Identification e.g Identification.BVN required identification_number Optional [ str ] An identification number based on the identification_type None country Country Customer's Country e.g Country.NIGERIA required bvn str Customer's Bank Verification Number required bank_code Optional [ str ] You can get the list of Bank Codes by calling the Miscellaneous API get_banks method. (required if type is bank_account) None account_number Optional [ str ] Customer's bank account number. (required if type is bank_account) None middle_name Optional [ str ] Customer's middle name None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/customers.py 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 def validate ( self , email_or_code : str , first_name : str , last_name : str , identification_type : Identification , country : Country , bvn : str , identification_number : Optional [ str ] = None , bank_code : Optional [ str ] = None , account_number : Optional [ str ] = None , middle_name : Optional [ str ] = None , ) -> Response : \"\"\"Validate a customer's identity Args: email_or_code: Customer's email or code first_name: Customer's first name last_name: Customer's last name identification_type: Enum of Identification e.g `Identification.BVN` identification_number: An identification number based on the `identification_type` country: Customer's Country e.g `Country.NIGERIA` bvn: Customer's Bank Verification Number bank_code: You can get the list of Bank Codes by calling the Miscellaneous API `get_banks` method. (required if type is bank_account) account_number: Customer's bank account number. (required if type is bank_account) middle_name: Customer's middle name Returns: A named tuple containing the response gotten from paystack's server. \"\"\" if identification_type == Identification . BANK_ACCOUNT : if bank_code is None : raise InvalidDataError ( \"`bank_code` is required if identification type is `Identification.BANK_ACCOUNT`\" ) if account_number is None : raise InvalidDataError ( \"`account_number` is required if identification type is `Identification.BANK_ACCOUNT`\" ) url = self . _parse_url ( f \"/customer/ { email_or_code } /identification\" ) payload = { \"first_name\" : first_name , \"last_name\" : last_name , \"type\" : identification_type , \"country\" : country , \"bvn\" : bvn , } optional_params = [ ( \"bank_code\" , bank_code ), ( \"account_number\" , account_number ), ( \"middle_name\" , middle_name ), ( \"value\" , identification_number ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . POST , url , payload )","title":"validate()"},{"location":"reference/dedicated_accounts/","text":"AsyncDedicatedAccount Bases: BaseAsyncAPI Provides a wrapper for paystack Dedicated Virtual Account API The Dedicated Virtual Account API enables Nigerian merchants to manage unique payment accounts of their customers. https://paystack.com/docs/api/#dedicated-virtual-account Note This feature is only available to businesses in Nigeria. Source code in pypaystack2/api/dedicated_accounts.py 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 class AsyncDedicatedAccount ( BaseAsyncAPI ): \"\"\"Provides a wrapper for paystack Dedicated Virtual Account API The Dedicated Virtual Account API enables Nigerian merchants to manage unique payment accounts of their customers. https://paystack.com/docs/api/#dedicated-virtual-account Note: This feature is only available to businesses in Nigeria. \"\"\" async def create ( self , customer : str , preferred_bank : Optional [ str ] = None , subaccount : Optional [ str ] = None , split_code : Optional [ str ] = None , first_name : Optional [ str ] = None , last_name : Optional [ str ] = None , phone : Optional [ str ] = None , ) -> Response : \"\"\"Create a dedicated virtual account and assign to a customer Note: * This feature is only available to businesses in Nigeria. * Paystack currently supports Access Bank and Wema Bank. * To create Dedicated Virtual Accounts using your test secret key, use ``test-bank`` as the ``preferred_bank`` You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Args: customer: Customer ID or code preferred_bank: The bank slug for preferred bank. To get a list of available banks, use the Miscellaneous API ``.get_providers`` method. subaccount: Subaccount code of the account you want to split the transaction with split_code: Split code consisting of the lists of accounts you want to split the transaction with first_name: Customer's first name last_name: Customer's last name phone: Customer's phone number Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/dedicated_account\" ) payload = { \"customer\" : customer , } optional_params = [ ( \"preferred_bank\" , preferred_bank ), ( \"subaccount\" , subaccount ), ( \"split_code\" , split_code ), ( \"first_name\" , first_name ), ( \"last_name\" , last_name ), ( \"phone\" , phone ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) async def get_dedicated_accounts ( self , active : bool = True , currency : Currency = Currency . NGN , provider_slug : Optional [ str ] = None , bank_id : Optional [ str ] = None , customer : Optional [ str ] = None , ) -> Response : \"\"\"Fetches dedicated virtual accounts available on your integration. Note: * This feature is only available to businesses in Nigeria. * Paystack currently supports Access Bank and Wema Bank. * To create Dedicated Virtual Accounts using your test secret key, use ``test-bank`` as the ``preferred_bank`` You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Args: active: Status of the dedicated virtual account currency: The currency of the dedicated virtual account. Only ``Currency.NGN`` is currently allowed provider_slug: The bank's slug in lowercase, without spaces e.g. wema-bank bank_id: The bank's ID e.g. 035 customer: The customer's ID Returns: A named tuple containing the response gotten from paystack's server. \"\"\" query_params = [ ( \"currency\" , currency ), ( \"provider_slug\" , provider_slug ), ( \"bank_id\" , bank_id ), ( \"customer\" , customer ), ] url = self . _parse_url ( f \"/dedicated_account?active= { active } \" ) url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url ) async def get_dedicated_account ( self , dedicated_account_id : int ) -> Response : \"\"\"Get details of a dedicated virtual account on your integration. Note: * This feature is only available to businesses in Nigeria. * Paystack currently supports Access Bank and Wema Bank. * To create Dedicated Virtual Accounts using your test secret key, use ``test-bank`` as the ``preferred_bank`` You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Args: dedicated_account_id: ID of dedicated virtual account Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/dedicated_account/ { dedicated_account_id } \" ) return await self . _handle_request ( HTTPMethod . GET , url ) async def requery ( self , account_number : str , provider_slug : str , date : Optional [ str ] ) -> Response : \"\"\"Get details of a dedicated virtual account on your integration. Note: * This feature is only available to businesses in Nigeria. * Paystack currently supports Access Bank and Wema Bank. * To create Dedicated Virtual Accounts using your test secret key, use ``test-bank`` as the ``preferred_bank`` You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Args: account_number: Virtual account number to requery provider_slug: The bank's slug in lowercase, without spaces e.g. wema-bank date: The day the transfer was made in YYYY-MM-DD ISO format Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/dedicated_account?account_number= { account_number } \" ) query_params = [ ( \"provider_slug\" , provider_slug ), ( \"date\" , date ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url ) async def deactivate ( self , dedicated_account_id : int ) -> Response : \"\"\"Deactivate a dedicated virtual account on your integration. Note: * This feature is only available to businesses in Nigeria. * Paystack currently supports Access Bank and Wema Bank. * To create Dedicated Virtual Accounts using your test secret key, use ``test-bank`` as the ``preferred_bank`` You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Args: dedicated_account_id: ID of dedicated virtual account Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/dedicated_account/ { dedicated_account_id } \" ) return await self . _handle_request ( HTTPMethod . DELETE , url ) async def split ( self , customer : str , subaccount : Optional [ str ] = None , split_code : Optional [ str ] = None , preferred_bank : Optional [ str ] = None , ) -> Response : \"\"\"Split a dedicated virtual account transaction with one or more accounts Note: * This feature is only available to businesses in Nigeria. * Paystack currently supports Access Bank and Wema Bank. * To create Dedicated Virtual Accounts using your test secret key, use ``test-bank`` as the ``preferred_bank`` You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Args: customer: Customer ID or code subaccount: Subaccount code of the account you want to split the transaction with split_code: Split code consisting of the lists of accounts you want to split the transaction with preferred_bank: The bank slug for preferred bank. To get a list of available banks, use the Miscellaneous API ``.get_providers`` method Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/dedicated_account/split\" ) payload = { \"customer\" : customer } optional_params = [ ( \"subaccount\" , subaccount ), ( \"split_code\" , split_code ), ( \"preferred_bank\" , preferred_bank ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) async def remove_split ( self , account_number : str ) -> Response : \"\"\"Removes a split. If you've previously set up split payment for transactions on a dedicated virtual account, you can remove it with this method. Note: * This feature is only available to businesses in Nigeria. * Paystack currently supports Access Bank and Wema Bank. * To create Dedicated Virtual Accounts using your test secret key, use ``test-bank`` as the ``preferred_bank`` You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Args: account_number: Dedicated virtual account number Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/dedicated_account/split\" ) payload = { \"account_number\" : account_number , } return await self . _handle_request ( HTTPMethod . DELETE , url , payload ) async def get_providers ( self ) -> Response : \"\"\"Get available bank providers for a dedicated virtual account Note: * This feature is only available to businesses in Nigeria. * Paystack currently supports Access Bank and Wema Bank. * To create Dedicated Virtual Accounts using your test secret key, use ``test-bank`` as the ``preferred_bank`` You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/dedicated_account/available_providers\" ) return await self . _handle_request ( HTTPMethod . GET , url ) create ( customer , preferred_bank = None , subaccount = None , split_code = None , first_name = None , last_name = None , phone = None ) async Create a dedicated virtual account and assign to a customer Note This feature is only available to businesses in Nigeria. Paystack currently supports Access Bank and Wema Bank. To create Dedicated Virtual Accounts using your test secret key, use test-bank as the preferred_bank You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Parameters: Name Type Description Default customer str Customer ID or code required preferred_bank Optional [ str ] The bank slug for preferred bank. To get a list of available banks, use the Miscellaneous API .get_providers method. None subaccount Optional [ str ] Subaccount code of the account you want to split the transaction with None split_code Optional [ str ] Split code consisting of the lists of accounts you want to split the transaction with None first_name Optional [ str ] Customer's first name None last_name Optional [ str ] Customer's last name None phone Optional [ str ] Customer's phone number None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/dedicated_accounts.py 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 async def create ( self , customer : str , preferred_bank : Optional [ str ] = None , subaccount : Optional [ str ] = None , split_code : Optional [ str ] = None , first_name : Optional [ str ] = None , last_name : Optional [ str ] = None , phone : Optional [ str ] = None , ) -> Response : \"\"\"Create a dedicated virtual account and assign to a customer Note: * This feature is only available to businesses in Nigeria. * Paystack currently supports Access Bank and Wema Bank. * To create Dedicated Virtual Accounts using your test secret key, use ``test-bank`` as the ``preferred_bank`` You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Args: customer: Customer ID or code preferred_bank: The bank slug for preferred bank. To get a list of available banks, use the Miscellaneous API ``.get_providers`` method. subaccount: Subaccount code of the account you want to split the transaction with split_code: Split code consisting of the lists of accounts you want to split the transaction with first_name: Customer's first name last_name: Customer's last name phone: Customer's phone number Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/dedicated_account\" ) payload = { \"customer\" : customer , } optional_params = [ ( \"preferred_bank\" , preferred_bank ), ( \"subaccount\" , subaccount ), ( \"split_code\" , split_code ), ( \"first_name\" , first_name ), ( \"last_name\" , last_name ), ( \"phone\" , phone ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) deactivate ( dedicated_account_id ) async Deactivate a dedicated virtual account on your integration. Note This feature is only available to businesses in Nigeria. Paystack currently supports Access Bank and Wema Bank. To create Dedicated Virtual Accounts using your test secret key, use test-bank as the preferred_bank You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Parameters: Name Type Description Default dedicated_account_id int ID of dedicated virtual account required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/dedicated_accounts.py 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 async def deactivate ( self , dedicated_account_id : int ) -> Response : \"\"\"Deactivate a dedicated virtual account on your integration. Note: * This feature is only available to businesses in Nigeria. * Paystack currently supports Access Bank and Wema Bank. * To create Dedicated Virtual Accounts using your test secret key, use ``test-bank`` as the ``preferred_bank`` You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Args: dedicated_account_id: ID of dedicated virtual account Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/dedicated_account/ { dedicated_account_id } \" ) return await self . _handle_request ( HTTPMethod . DELETE , url ) get_dedicated_account ( dedicated_account_id ) async Get details of a dedicated virtual account on your integration. Note This feature is only available to businesses in Nigeria. Paystack currently supports Access Bank and Wema Bank. To create Dedicated Virtual Accounts using your test secret key, use test-bank as the preferred_bank You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Parameters: Name Type Description Default dedicated_account_id int ID of dedicated virtual account required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/dedicated_accounts.py 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 async def get_dedicated_account ( self , dedicated_account_id : int ) -> Response : \"\"\"Get details of a dedicated virtual account on your integration. Note: * This feature is only available to businesses in Nigeria. * Paystack currently supports Access Bank and Wema Bank. * To create Dedicated Virtual Accounts using your test secret key, use ``test-bank`` as the ``preferred_bank`` You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Args: dedicated_account_id: ID of dedicated virtual account Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/dedicated_account/ { dedicated_account_id } \" ) return await self . _handle_request ( HTTPMethod . GET , url ) get_dedicated_accounts ( active = True , currency = Currency . NGN , provider_slug = None , bank_id = None , customer = None ) async Fetches dedicated virtual accounts available on your integration. Note This feature is only available to businesses in Nigeria. Paystack currently supports Access Bank and Wema Bank. To create Dedicated Virtual Accounts using your test secret key, use test-bank as the preferred_bank You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Parameters: Name Type Description Default active bool Status of the dedicated virtual account True currency Currency The currency of the dedicated virtual account. Only Currency.NGN is currently allowed Currency.NGN provider_slug Optional [ str ] The bank's slug in lowercase, without spaces e.g. wema-bank None bank_id Optional [ str ] The bank's ID e.g. 035 None customer Optional [ str ] The customer's ID None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/dedicated_accounts.py 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 async def get_dedicated_accounts ( self , active : bool = True , currency : Currency = Currency . NGN , provider_slug : Optional [ str ] = None , bank_id : Optional [ str ] = None , customer : Optional [ str ] = None , ) -> Response : \"\"\"Fetches dedicated virtual accounts available on your integration. Note: * This feature is only available to businesses in Nigeria. * Paystack currently supports Access Bank and Wema Bank. * To create Dedicated Virtual Accounts using your test secret key, use ``test-bank`` as the ``preferred_bank`` You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Args: active: Status of the dedicated virtual account currency: The currency of the dedicated virtual account. Only ``Currency.NGN`` is currently allowed provider_slug: The bank's slug in lowercase, without spaces e.g. wema-bank bank_id: The bank's ID e.g. 035 customer: The customer's ID Returns: A named tuple containing the response gotten from paystack's server. \"\"\" query_params = [ ( \"currency\" , currency ), ( \"provider_slug\" , provider_slug ), ( \"bank_id\" , bank_id ), ( \"customer\" , customer ), ] url = self . _parse_url ( f \"/dedicated_account?active= { active } \" ) url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url ) get_providers () async Get available bank providers for a dedicated virtual account Note This feature is only available to businesses in Nigeria. Paystack currently supports Access Bank and Wema Bank. To create Dedicated Virtual Accounts using your test secret key, use test-bank as the preferred_bank You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/dedicated_accounts.py 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 async def get_providers ( self ) -> Response : \"\"\"Get available bank providers for a dedicated virtual account Note: * This feature is only available to businesses in Nigeria. * Paystack currently supports Access Bank and Wema Bank. * To create Dedicated Virtual Accounts using your test secret key, use ``test-bank`` as the ``preferred_bank`` You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/dedicated_account/available_providers\" ) return await self . _handle_request ( HTTPMethod . GET , url ) remove_split ( account_number ) async Removes a split. If you've previously set up split payment for transactions on a dedicated virtual account, you can remove it with this method. Note This feature is only available to businesses in Nigeria. Paystack currently supports Access Bank and Wema Bank. To create Dedicated Virtual Accounts using your test secret key, use test-bank as the preferred_bank You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Parameters: Name Type Description Default account_number str Dedicated virtual account number required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/dedicated_accounts.py 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 async def remove_split ( self , account_number : str ) -> Response : \"\"\"Removes a split. If you've previously set up split payment for transactions on a dedicated virtual account, you can remove it with this method. Note: * This feature is only available to businesses in Nigeria. * Paystack currently supports Access Bank and Wema Bank. * To create Dedicated Virtual Accounts using your test secret key, use ``test-bank`` as the ``preferred_bank`` You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Args: account_number: Dedicated virtual account number Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/dedicated_account/split\" ) payload = { \"account_number\" : account_number , } return await self . _handle_request ( HTTPMethod . DELETE , url , payload ) requery ( account_number , provider_slug , date ) async Get details of a dedicated virtual account on your integration. Note This feature is only available to businesses in Nigeria. Paystack currently supports Access Bank and Wema Bank. To create Dedicated Virtual Accounts using your test secret key, use test-bank as the preferred_bank You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Parameters: Name Type Description Default account_number str Virtual account number to requery required provider_slug str The bank's slug in lowercase, without spaces e.g. wema-bank required date Optional [ str ] The day the transfer was made in YYYY-MM-DD ISO format required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/dedicated_accounts.py 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 async def requery ( self , account_number : str , provider_slug : str , date : Optional [ str ] ) -> Response : \"\"\"Get details of a dedicated virtual account on your integration. Note: * This feature is only available to businesses in Nigeria. * Paystack currently supports Access Bank and Wema Bank. * To create Dedicated Virtual Accounts using your test secret key, use ``test-bank`` as the ``preferred_bank`` You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Args: account_number: Virtual account number to requery provider_slug: The bank's slug in lowercase, without spaces e.g. wema-bank date: The day the transfer was made in YYYY-MM-DD ISO format Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/dedicated_account?account_number= { account_number } \" ) query_params = [ ( \"provider_slug\" , provider_slug ), ( \"date\" , date ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url ) split ( customer , subaccount = None , split_code = None , preferred_bank = None ) async Split a dedicated virtual account transaction with one or more accounts Note This feature is only available to businesses in Nigeria. Paystack currently supports Access Bank and Wema Bank. To create Dedicated Virtual Accounts using your test secret key, use test-bank as the preferred_bank You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Parameters: Name Type Description Default customer str Customer ID or code required subaccount Optional [ str ] Subaccount code of the account you want to split the transaction with None split_code Optional [ str ] Split code consisting of the lists of accounts you want to split the transaction with None preferred_bank Optional [ str ] The bank slug for preferred bank. To get a list of available banks, use the Miscellaneous API .get_providers method None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/dedicated_accounts.py 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 async def split ( self , customer : str , subaccount : Optional [ str ] = None , split_code : Optional [ str ] = None , preferred_bank : Optional [ str ] = None , ) -> Response : \"\"\"Split a dedicated virtual account transaction with one or more accounts Note: * This feature is only available to businesses in Nigeria. * Paystack currently supports Access Bank and Wema Bank. * To create Dedicated Virtual Accounts using your test secret key, use ``test-bank`` as the ``preferred_bank`` You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Args: customer: Customer ID or code subaccount: Subaccount code of the account you want to split the transaction with split_code: Split code consisting of the lists of accounts you want to split the transaction with preferred_bank: The bank slug for preferred bank. To get a list of available banks, use the Miscellaneous API ``.get_providers`` method Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/dedicated_account/split\" ) payload = { \"customer\" : customer } optional_params = [ ( \"subaccount\" , subaccount ), ( \"split_code\" , split_code ), ( \"preferred_bank\" , preferred_bank ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) DedicatedAccount Bases: BaseAPI Provides a wrapper for paystack Dedicated Virtual Account API The Dedicated Virtual Account API enables Nigerian merchants to manage unique payment accounts of their customers. https://paystack.com/docs/api/#dedicated-virtual-account Note This feature is only available to businesses in Nigeria. Source code in pypaystack2/api/dedicated_accounts.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 class DedicatedAccount ( BaseAPI ): \"\"\"Provides a wrapper for paystack Dedicated Virtual Account API The Dedicated Virtual Account API enables Nigerian merchants to manage unique payment accounts of their customers. https://paystack.com/docs/api/#dedicated-virtual-account Note: This feature is only available to businesses in Nigeria. \"\"\" def create ( self , customer : str , preferred_bank : Optional [ str ] = None , subaccount : Optional [ str ] = None , split_code : Optional [ str ] = None , first_name : Optional [ str ] = None , last_name : Optional [ str ] = None , phone : Optional [ str ] = None , ) -> Response : \"\"\"Create a dedicated virtual account and assign to a customer Note: * This feature is only available to businesses in Nigeria. * Paystack currently supports Access Bank and Wema Bank. * To create Dedicated Virtual Accounts using your test secret key, use ``test-bank`` as the ``preferred_bank`` You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Args: customer: Customer ID or code preferred_bank: The bank slug for a preferred bank. To get a list of available banks, use the Miscellaneous API ``.get_providers`` method. subaccount: Subaccount code of the account you want to split the transaction with split_code: Split code consisting of the lists of accounts you want to split the transaction with first_name: Customer's first name last_name: Customer's last name phone: Customer's phone number Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/dedicated_account\" ) payload = { \"customer\" : customer , } optional_params = [ ( \"preferred_bank\" , preferred_bank ), ( \"subaccount\" , subaccount ), ( \"split_code\" , split_code ), ( \"first_name\" , first_name ), ( \"last_name\" , last_name ), ( \"phone\" , phone ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . POST , url , payload ) def get_dedicated_accounts ( self , active : bool = True , currency : Currency = Currency . NGN , provider_slug : Optional [ str ] = None , bank_id : Optional [ str ] = None , customer : Optional [ str ] = None , ) -> Response : \"\"\"Fetches dedicated virtual accounts available on your integration. Note: * This feature is only available to businesses in Nigeria. * Paystack currently supports Access Bank and Wema Bank. * To create Dedicated Virtual Accounts using your test secret key, use ``test-bank`` as the ``preferred_bank`` You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Args: active: Status of the dedicated virtual account currency: The currency of the dedicated virtual account. Only ``Currency.NGN`` is currently allowed provider_slug: The bank's slug in lowercase, without spaces e.g. wema-bank bank_id: The bank's ID e.g., 035 customer: The customer's ID Returns: A named tuple containing the response gotten from paystack's server. \"\"\" query_params = [ ( \"currency\" , currency ), ( \"provider_slug\" , provider_slug ), ( \"bank_id\" , bank_id ), ( \"customer\" , customer ), ] url = self . _parse_url ( f \"/dedicated_account?active= { active } \" ) url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url ) def get_dedicated_account ( self , dedicated_account_id : int ) -> Response : \"\"\"Get details of a dedicated virtual account on your integration. Note: * This feature is only available to businesses in Nigeria. * Paystack currently supports Access Bank and Wema Bank. * To create Dedicated Virtual Accounts using your test secret key, use ``test-bank`` as the ``preferred_bank`` You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Args: dedicated_account_id: ID of dedicated virtual account Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/dedicated_account/ { dedicated_account_id } \" ) return self . _handle_request ( HTTPMethod . GET , url ) def requery ( self , account_number : str , provider_slug : str , date : Optional [ str ] ) -> Response : \"\"\"Get details of a dedicated virtual account on your integration. Note: * This feature is only available to businesses in Nigeria. * Paystack currently supports Access Bank and Wema Bank. * To create Dedicated Virtual Accounts using your test secret key, use ``test-bank`` as the ``preferred_bank`` You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Args: account_number: Virtual account number to requery provider_slug: The bank's slug in lowercase, without spaces e.g. wema-bank date: The day the transfer was made in YYYY-MM-DD ISO format Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/dedicated_account?account_number= { account_number } \" ) query_params = [ ( \"provider_slug\" , provider_slug ), ( \"date\" , date ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url ) def deactivate ( self , dedicated_account_id : int ) -> Response : \"\"\"Deactivate a dedicated virtual account on your integration. Note: * This feature is only available to businesses in Nigeria. * Paystack currently supports Access Bank and Wema Bank. * To create Dedicated Virtual Accounts using your test secret key, use ``test-bank`` as the ``preferred_bank`` You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Args: dedicated_account_id: ID of dedicated virtual account Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/dedicated_account/ { dedicated_account_id } \" ) return self . _handle_request ( HTTPMethod . DELETE , url ) def split ( self , customer : str , subaccount : Optional [ str ] = None , split_code : Optional [ str ] = None , preferred_bank : Optional [ str ] = None , ) -> Response : \"\"\"Split a dedicated virtual account transaction with one or more accounts Note: * This feature is only available to businesses in Nigeria. * Paystack currently supports Access Bank and Wema Bank. * To create Dedicated Virtual Accounts using your test secret key, use ``test-bank`` as the ``preferred_bank`` You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Args: customer: Customer ID or code subaccount: Subaccount code of the account you want to split the transaction with split_code: Split code consisting of the lists of accounts you want to split the transaction with preferred_bank: The bank slug for a preferred bank. To get a list of available banks, use the Miscellaneous API ``.get_providers`` method Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/dedicated_account/split\" ) payload = { \"customer\" : customer } optional_params = [ ( \"subaccount\" , subaccount ), ( \"split_code\" , split_code ), ( \"preferred_bank\" , preferred_bank ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . POST , url , payload ) def remove_split ( self , account_number : str ) -> Response : \"\"\"Removes a split. If you've previously set up split payment for transactions on a dedicated virtual account, you can remove it with this method. Note: * This feature is only available to businesses in Nigeria. * Paystack currently supports Access Bank and Wema Bank. * To create Dedicated Virtual Accounts using your test secret key, use ``test-bank`` as the ``preferred_bank`` You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Args: account_number: Dedicated virtual account number Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/dedicated_account/split\" ) payload = { \"account_number\" : account_number , } return self . _handle_request ( HTTPMethod . DELETE , url , payload ) def get_providers ( self ) -> Response : \"\"\"Get available bank providers for a dedicated virtual account Note: * This feature is only available to businesses in Nigeria. * Paystack currently supports Access Bank and Wema Bank. * To create Dedicated Virtual Accounts using your test secret key, use ``test-bank`` as the ``preferred_bank`` You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/dedicated_account/available_providers\" ) return self . _handle_request ( HTTPMethod . GET , url ) create ( customer , preferred_bank = None , subaccount = None , split_code = None , first_name = None , last_name = None , phone = None ) Create a dedicated virtual account and assign to a customer Note This feature is only available to businesses in Nigeria. Paystack currently supports Access Bank and Wema Bank. To create Dedicated Virtual Accounts using your test secret key, use test-bank as the preferred_bank You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Parameters: Name Type Description Default customer str Customer ID or code required preferred_bank Optional [ str ] The bank slug for a preferred bank. To get a list of available banks, use the Miscellaneous API .get_providers method. None subaccount Optional [ str ] Subaccount code of the account you want to split the transaction with None split_code Optional [ str ] Split code consisting of the lists of accounts you want to split the transaction with None first_name Optional [ str ] Customer's first name None last_name Optional [ str ] Customer's last name None phone Optional [ str ] Customer's phone number None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/dedicated_accounts.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 def create ( self , customer : str , preferred_bank : Optional [ str ] = None , subaccount : Optional [ str ] = None , split_code : Optional [ str ] = None , first_name : Optional [ str ] = None , last_name : Optional [ str ] = None , phone : Optional [ str ] = None , ) -> Response : \"\"\"Create a dedicated virtual account and assign to a customer Note: * This feature is only available to businesses in Nigeria. * Paystack currently supports Access Bank and Wema Bank. * To create Dedicated Virtual Accounts using your test secret key, use ``test-bank`` as the ``preferred_bank`` You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Args: customer: Customer ID or code preferred_bank: The bank slug for a preferred bank. To get a list of available banks, use the Miscellaneous API ``.get_providers`` method. subaccount: Subaccount code of the account you want to split the transaction with split_code: Split code consisting of the lists of accounts you want to split the transaction with first_name: Customer's first name last_name: Customer's last name phone: Customer's phone number Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/dedicated_account\" ) payload = { \"customer\" : customer , } optional_params = [ ( \"preferred_bank\" , preferred_bank ), ( \"subaccount\" , subaccount ), ( \"split_code\" , split_code ), ( \"first_name\" , first_name ), ( \"last_name\" , last_name ), ( \"phone\" , phone ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . POST , url , payload ) deactivate ( dedicated_account_id ) Deactivate a dedicated virtual account on your integration. Note This feature is only available to businesses in Nigeria. Paystack currently supports Access Bank and Wema Bank. To create Dedicated Virtual Accounts using your test secret key, use test-bank as the preferred_bank You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Parameters: Name Type Description Default dedicated_account_id int ID of dedicated virtual account required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/dedicated_accounts.py 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 def deactivate ( self , dedicated_account_id : int ) -> Response : \"\"\"Deactivate a dedicated virtual account on your integration. Note: * This feature is only available to businesses in Nigeria. * Paystack currently supports Access Bank and Wema Bank. * To create Dedicated Virtual Accounts using your test secret key, use ``test-bank`` as the ``preferred_bank`` You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Args: dedicated_account_id: ID of dedicated virtual account Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/dedicated_account/ { dedicated_account_id } \" ) return self . _handle_request ( HTTPMethod . DELETE , url ) get_dedicated_account ( dedicated_account_id ) Get details of a dedicated virtual account on your integration. Note This feature is only available to businesses in Nigeria. Paystack currently supports Access Bank and Wema Bank. To create Dedicated Virtual Accounts using your test secret key, use test-bank as the preferred_bank You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Parameters: Name Type Description Default dedicated_account_id int ID of dedicated virtual account required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/dedicated_accounts.py 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 def get_dedicated_account ( self , dedicated_account_id : int ) -> Response : \"\"\"Get details of a dedicated virtual account on your integration. Note: * This feature is only available to businesses in Nigeria. * Paystack currently supports Access Bank and Wema Bank. * To create Dedicated Virtual Accounts using your test secret key, use ``test-bank`` as the ``preferred_bank`` You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Args: dedicated_account_id: ID of dedicated virtual account Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/dedicated_account/ { dedicated_account_id } \" ) return self . _handle_request ( HTTPMethod . GET , url ) get_dedicated_accounts ( active = True , currency = Currency . NGN , provider_slug = None , bank_id = None , customer = None ) Fetches dedicated virtual accounts available on your integration. Note This feature is only available to businesses in Nigeria. Paystack currently supports Access Bank and Wema Bank. To create Dedicated Virtual Accounts using your test secret key, use test-bank as the preferred_bank You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Parameters: Name Type Description Default active bool Status of the dedicated virtual account True currency Currency The currency of the dedicated virtual account. Only Currency.NGN is currently allowed Currency.NGN provider_slug Optional [ str ] The bank's slug in lowercase, without spaces e.g. wema-bank None bank_id Optional [ str ] The bank's ID e.g., 035 None customer Optional [ str ] The customer's ID None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/dedicated_accounts.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 def get_dedicated_accounts ( self , active : bool = True , currency : Currency = Currency . NGN , provider_slug : Optional [ str ] = None , bank_id : Optional [ str ] = None , customer : Optional [ str ] = None , ) -> Response : \"\"\"Fetches dedicated virtual accounts available on your integration. Note: * This feature is only available to businesses in Nigeria. * Paystack currently supports Access Bank and Wema Bank. * To create Dedicated Virtual Accounts using your test secret key, use ``test-bank`` as the ``preferred_bank`` You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Args: active: Status of the dedicated virtual account currency: The currency of the dedicated virtual account. Only ``Currency.NGN`` is currently allowed provider_slug: The bank's slug in lowercase, without spaces e.g. wema-bank bank_id: The bank's ID e.g., 035 customer: The customer's ID Returns: A named tuple containing the response gotten from paystack's server. \"\"\" query_params = [ ( \"currency\" , currency ), ( \"provider_slug\" , provider_slug ), ( \"bank_id\" , bank_id ), ( \"customer\" , customer ), ] url = self . _parse_url ( f \"/dedicated_account?active= { active } \" ) url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url ) get_providers () Get available bank providers for a dedicated virtual account Note This feature is only available to businesses in Nigeria. Paystack currently supports Access Bank and Wema Bank. To create Dedicated Virtual Accounts using your test secret key, use test-bank as the preferred_bank You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/dedicated_accounts.py 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 def get_providers ( self ) -> Response : \"\"\"Get available bank providers for a dedicated virtual account Note: * This feature is only available to businesses in Nigeria. * Paystack currently supports Access Bank and Wema Bank. * To create Dedicated Virtual Accounts using your test secret key, use ``test-bank`` as the ``preferred_bank`` You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/dedicated_account/available_providers\" ) return self . _handle_request ( HTTPMethod . GET , url ) remove_split ( account_number ) Removes a split. If you've previously set up split payment for transactions on a dedicated virtual account, you can remove it with this method. Note This feature is only available to businesses in Nigeria. Paystack currently supports Access Bank and Wema Bank. To create Dedicated Virtual Accounts using your test secret key, use test-bank as the preferred_bank You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Parameters: Name Type Description Default account_number str Dedicated virtual account number required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/dedicated_accounts.py 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 def remove_split ( self , account_number : str ) -> Response : \"\"\"Removes a split. If you've previously set up split payment for transactions on a dedicated virtual account, you can remove it with this method. Note: * This feature is only available to businesses in Nigeria. * Paystack currently supports Access Bank and Wema Bank. * To create Dedicated Virtual Accounts using your test secret key, use ``test-bank`` as the ``preferred_bank`` You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Args: account_number: Dedicated virtual account number Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/dedicated_account/split\" ) payload = { \"account_number\" : account_number , } return self . _handle_request ( HTTPMethod . DELETE , url , payload ) requery ( account_number , provider_slug , date ) Get details of a dedicated virtual account on your integration. Note This feature is only available to businesses in Nigeria. Paystack currently supports Access Bank and Wema Bank. To create Dedicated Virtual Accounts using your test secret key, use test-bank as the preferred_bank You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Parameters: Name Type Description Default account_number str Virtual account number to requery required provider_slug str The bank's slug in lowercase, without spaces e.g. wema-bank required date Optional [ str ] The day the transfer was made in YYYY-MM-DD ISO format required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/dedicated_accounts.py 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 def requery ( self , account_number : str , provider_slug : str , date : Optional [ str ] ) -> Response : \"\"\"Get details of a dedicated virtual account on your integration. Note: * This feature is only available to businesses in Nigeria. * Paystack currently supports Access Bank and Wema Bank. * To create Dedicated Virtual Accounts using your test secret key, use ``test-bank`` as the ``preferred_bank`` You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Args: account_number: Virtual account number to requery provider_slug: The bank's slug in lowercase, without spaces e.g. wema-bank date: The day the transfer was made in YYYY-MM-DD ISO format Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/dedicated_account?account_number= { account_number } \" ) query_params = [ ( \"provider_slug\" , provider_slug ), ( \"date\" , date ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url ) split ( customer , subaccount = None , split_code = None , preferred_bank = None ) Split a dedicated virtual account transaction with one or more accounts Note This feature is only available to businesses in Nigeria. Paystack currently supports Access Bank and Wema Bank. To create Dedicated Virtual Accounts using your test secret key, use test-bank as the preferred_bank You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Parameters: Name Type Description Default customer str Customer ID or code required subaccount Optional [ str ] Subaccount code of the account you want to split the transaction with None split_code Optional [ str ] Split code consisting of the lists of accounts you want to split the transaction with None preferred_bank Optional [ str ] The bank slug for a preferred bank. To get a list of available banks, use the Miscellaneous API .get_providers method None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/dedicated_accounts.py 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 def split ( self , customer : str , subaccount : Optional [ str ] = None , split_code : Optional [ str ] = None , preferred_bank : Optional [ str ] = None , ) -> Response : \"\"\"Split a dedicated virtual account transaction with one or more accounts Note: * This feature is only available to businesses in Nigeria. * Paystack currently supports Access Bank and Wema Bank. * To create Dedicated Virtual Accounts using your test secret key, use ``test-bank`` as the ``preferred_bank`` You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Args: customer: Customer ID or code subaccount: Subaccount code of the account you want to split the transaction with split_code: Split code consisting of the lists of accounts you want to split the transaction with preferred_bank: The bank slug for a preferred bank. To get a list of available banks, use the Miscellaneous API ``.get_providers`` method Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/dedicated_account/split\" ) payload = { \"customer\" : customer } optional_params = [ ( \"subaccount\" , subaccount ), ( \"split_code\" , split_code ), ( \"preferred_bank\" , preferred_bank ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . POST , url , payload )","title":"Dedicated accounts"},{"location":"reference/dedicated_accounts/#pypaystack2.api.dedicated_accounts.AsyncDedicatedAccount","text":"Bases: BaseAsyncAPI Provides a wrapper for paystack Dedicated Virtual Account API The Dedicated Virtual Account API enables Nigerian merchants to manage unique payment accounts of their customers. https://paystack.com/docs/api/#dedicated-virtual-account Note This feature is only available to businesses in Nigeria. Source code in pypaystack2/api/dedicated_accounts.py 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 class AsyncDedicatedAccount ( BaseAsyncAPI ): \"\"\"Provides a wrapper for paystack Dedicated Virtual Account API The Dedicated Virtual Account API enables Nigerian merchants to manage unique payment accounts of their customers. https://paystack.com/docs/api/#dedicated-virtual-account Note: This feature is only available to businesses in Nigeria. \"\"\" async def create ( self , customer : str , preferred_bank : Optional [ str ] = None , subaccount : Optional [ str ] = None , split_code : Optional [ str ] = None , first_name : Optional [ str ] = None , last_name : Optional [ str ] = None , phone : Optional [ str ] = None , ) -> Response : \"\"\"Create a dedicated virtual account and assign to a customer Note: * This feature is only available to businesses in Nigeria. * Paystack currently supports Access Bank and Wema Bank. * To create Dedicated Virtual Accounts using your test secret key, use ``test-bank`` as the ``preferred_bank`` You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Args: customer: Customer ID or code preferred_bank: The bank slug for preferred bank. To get a list of available banks, use the Miscellaneous API ``.get_providers`` method. subaccount: Subaccount code of the account you want to split the transaction with split_code: Split code consisting of the lists of accounts you want to split the transaction with first_name: Customer's first name last_name: Customer's last name phone: Customer's phone number Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/dedicated_account\" ) payload = { \"customer\" : customer , } optional_params = [ ( \"preferred_bank\" , preferred_bank ), ( \"subaccount\" , subaccount ), ( \"split_code\" , split_code ), ( \"first_name\" , first_name ), ( \"last_name\" , last_name ), ( \"phone\" , phone ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) async def get_dedicated_accounts ( self , active : bool = True , currency : Currency = Currency . NGN , provider_slug : Optional [ str ] = None , bank_id : Optional [ str ] = None , customer : Optional [ str ] = None , ) -> Response : \"\"\"Fetches dedicated virtual accounts available on your integration. Note: * This feature is only available to businesses in Nigeria. * Paystack currently supports Access Bank and Wema Bank. * To create Dedicated Virtual Accounts using your test secret key, use ``test-bank`` as the ``preferred_bank`` You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Args: active: Status of the dedicated virtual account currency: The currency of the dedicated virtual account. Only ``Currency.NGN`` is currently allowed provider_slug: The bank's slug in lowercase, without spaces e.g. wema-bank bank_id: The bank's ID e.g. 035 customer: The customer's ID Returns: A named tuple containing the response gotten from paystack's server. \"\"\" query_params = [ ( \"currency\" , currency ), ( \"provider_slug\" , provider_slug ), ( \"bank_id\" , bank_id ), ( \"customer\" , customer ), ] url = self . _parse_url ( f \"/dedicated_account?active= { active } \" ) url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url ) async def get_dedicated_account ( self , dedicated_account_id : int ) -> Response : \"\"\"Get details of a dedicated virtual account on your integration. Note: * This feature is only available to businesses in Nigeria. * Paystack currently supports Access Bank and Wema Bank. * To create Dedicated Virtual Accounts using your test secret key, use ``test-bank`` as the ``preferred_bank`` You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Args: dedicated_account_id: ID of dedicated virtual account Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/dedicated_account/ { dedicated_account_id } \" ) return await self . _handle_request ( HTTPMethod . GET , url ) async def requery ( self , account_number : str , provider_slug : str , date : Optional [ str ] ) -> Response : \"\"\"Get details of a dedicated virtual account on your integration. Note: * This feature is only available to businesses in Nigeria. * Paystack currently supports Access Bank and Wema Bank. * To create Dedicated Virtual Accounts using your test secret key, use ``test-bank`` as the ``preferred_bank`` You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Args: account_number: Virtual account number to requery provider_slug: The bank's slug in lowercase, without spaces e.g. wema-bank date: The day the transfer was made in YYYY-MM-DD ISO format Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/dedicated_account?account_number= { account_number } \" ) query_params = [ ( \"provider_slug\" , provider_slug ), ( \"date\" , date ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url ) async def deactivate ( self , dedicated_account_id : int ) -> Response : \"\"\"Deactivate a dedicated virtual account on your integration. Note: * This feature is only available to businesses in Nigeria. * Paystack currently supports Access Bank and Wema Bank. * To create Dedicated Virtual Accounts using your test secret key, use ``test-bank`` as the ``preferred_bank`` You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Args: dedicated_account_id: ID of dedicated virtual account Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/dedicated_account/ { dedicated_account_id } \" ) return await self . _handle_request ( HTTPMethod . DELETE , url ) async def split ( self , customer : str , subaccount : Optional [ str ] = None , split_code : Optional [ str ] = None , preferred_bank : Optional [ str ] = None , ) -> Response : \"\"\"Split a dedicated virtual account transaction with one or more accounts Note: * This feature is only available to businesses in Nigeria. * Paystack currently supports Access Bank and Wema Bank. * To create Dedicated Virtual Accounts using your test secret key, use ``test-bank`` as the ``preferred_bank`` You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Args: customer: Customer ID or code subaccount: Subaccount code of the account you want to split the transaction with split_code: Split code consisting of the lists of accounts you want to split the transaction with preferred_bank: The bank slug for preferred bank. To get a list of available banks, use the Miscellaneous API ``.get_providers`` method Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/dedicated_account/split\" ) payload = { \"customer\" : customer } optional_params = [ ( \"subaccount\" , subaccount ), ( \"split_code\" , split_code ), ( \"preferred_bank\" , preferred_bank ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) async def remove_split ( self , account_number : str ) -> Response : \"\"\"Removes a split. If you've previously set up split payment for transactions on a dedicated virtual account, you can remove it with this method. Note: * This feature is only available to businesses in Nigeria. * Paystack currently supports Access Bank and Wema Bank. * To create Dedicated Virtual Accounts using your test secret key, use ``test-bank`` as the ``preferred_bank`` You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Args: account_number: Dedicated virtual account number Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/dedicated_account/split\" ) payload = { \"account_number\" : account_number , } return await self . _handle_request ( HTTPMethod . DELETE , url , payload ) async def get_providers ( self ) -> Response : \"\"\"Get available bank providers for a dedicated virtual account Note: * This feature is only available to businesses in Nigeria. * Paystack currently supports Access Bank and Wema Bank. * To create Dedicated Virtual Accounts using your test secret key, use ``test-bank`` as the ``preferred_bank`` You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/dedicated_account/available_providers\" ) return await self . _handle_request ( HTTPMethod . GET , url )","title":"AsyncDedicatedAccount"},{"location":"reference/dedicated_accounts/#pypaystack2.api.dedicated_accounts.AsyncDedicatedAccount.create","text":"Create a dedicated virtual account and assign to a customer Note This feature is only available to businesses in Nigeria. Paystack currently supports Access Bank and Wema Bank. To create Dedicated Virtual Accounts using your test secret key, use test-bank as the preferred_bank You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Parameters: Name Type Description Default customer str Customer ID or code required preferred_bank Optional [ str ] The bank slug for preferred bank. To get a list of available banks, use the Miscellaneous API .get_providers method. None subaccount Optional [ str ] Subaccount code of the account you want to split the transaction with None split_code Optional [ str ] Split code consisting of the lists of accounts you want to split the transaction with None first_name Optional [ str ] Customer's first name None last_name Optional [ str ] Customer's last name None phone Optional [ str ] Customer's phone number None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/dedicated_accounts.py 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 async def create ( self , customer : str , preferred_bank : Optional [ str ] = None , subaccount : Optional [ str ] = None , split_code : Optional [ str ] = None , first_name : Optional [ str ] = None , last_name : Optional [ str ] = None , phone : Optional [ str ] = None , ) -> Response : \"\"\"Create a dedicated virtual account and assign to a customer Note: * This feature is only available to businesses in Nigeria. * Paystack currently supports Access Bank and Wema Bank. * To create Dedicated Virtual Accounts using your test secret key, use ``test-bank`` as the ``preferred_bank`` You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Args: customer: Customer ID or code preferred_bank: The bank slug for preferred bank. To get a list of available banks, use the Miscellaneous API ``.get_providers`` method. subaccount: Subaccount code of the account you want to split the transaction with split_code: Split code consisting of the lists of accounts you want to split the transaction with first_name: Customer's first name last_name: Customer's last name phone: Customer's phone number Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/dedicated_account\" ) payload = { \"customer\" : customer , } optional_params = [ ( \"preferred_bank\" , preferred_bank ), ( \"subaccount\" , subaccount ), ( \"split_code\" , split_code ), ( \"first_name\" , first_name ), ( \"last_name\" , last_name ), ( \"phone\" , phone ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . POST , url , payload )","title":"create()"},{"location":"reference/dedicated_accounts/#pypaystack2.api.dedicated_accounts.AsyncDedicatedAccount.deactivate","text":"Deactivate a dedicated virtual account on your integration. Note This feature is only available to businesses in Nigeria. Paystack currently supports Access Bank and Wema Bank. To create Dedicated Virtual Accounts using your test secret key, use test-bank as the preferred_bank You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Parameters: Name Type Description Default dedicated_account_id int ID of dedicated virtual account required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/dedicated_accounts.py 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 async def deactivate ( self , dedicated_account_id : int ) -> Response : \"\"\"Deactivate a dedicated virtual account on your integration. Note: * This feature is only available to businesses in Nigeria. * Paystack currently supports Access Bank and Wema Bank. * To create Dedicated Virtual Accounts using your test secret key, use ``test-bank`` as the ``preferred_bank`` You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Args: dedicated_account_id: ID of dedicated virtual account Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/dedicated_account/ { dedicated_account_id } \" ) return await self . _handle_request ( HTTPMethod . DELETE , url )","title":"deactivate()"},{"location":"reference/dedicated_accounts/#pypaystack2.api.dedicated_accounts.AsyncDedicatedAccount.get_dedicated_account","text":"Get details of a dedicated virtual account on your integration. Note This feature is only available to businesses in Nigeria. Paystack currently supports Access Bank and Wema Bank. To create Dedicated Virtual Accounts using your test secret key, use test-bank as the preferred_bank You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Parameters: Name Type Description Default dedicated_account_id int ID of dedicated virtual account required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/dedicated_accounts.py 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 async def get_dedicated_account ( self , dedicated_account_id : int ) -> Response : \"\"\"Get details of a dedicated virtual account on your integration. Note: * This feature is only available to businesses in Nigeria. * Paystack currently supports Access Bank and Wema Bank. * To create Dedicated Virtual Accounts using your test secret key, use ``test-bank`` as the ``preferred_bank`` You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Args: dedicated_account_id: ID of dedicated virtual account Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/dedicated_account/ { dedicated_account_id } \" ) return await self . _handle_request ( HTTPMethod . GET , url )","title":"get_dedicated_account()"},{"location":"reference/dedicated_accounts/#pypaystack2.api.dedicated_accounts.AsyncDedicatedAccount.get_dedicated_accounts","text":"Fetches dedicated virtual accounts available on your integration. Note This feature is only available to businesses in Nigeria. Paystack currently supports Access Bank and Wema Bank. To create Dedicated Virtual Accounts using your test secret key, use test-bank as the preferred_bank You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Parameters: Name Type Description Default active bool Status of the dedicated virtual account True currency Currency The currency of the dedicated virtual account. Only Currency.NGN is currently allowed Currency.NGN provider_slug Optional [ str ] The bank's slug in lowercase, without spaces e.g. wema-bank None bank_id Optional [ str ] The bank's ID e.g. 035 None customer Optional [ str ] The customer's ID None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/dedicated_accounts.py 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 async def get_dedicated_accounts ( self , active : bool = True , currency : Currency = Currency . NGN , provider_slug : Optional [ str ] = None , bank_id : Optional [ str ] = None , customer : Optional [ str ] = None , ) -> Response : \"\"\"Fetches dedicated virtual accounts available on your integration. Note: * This feature is only available to businesses in Nigeria. * Paystack currently supports Access Bank and Wema Bank. * To create Dedicated Virtual Accounts using your test secret key, use ``test-bank`` as the ``preferred_bank`` You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Args: active: Status of the dedicated virtual account currency: The currency of the dedicated virtual account. Only ``Currency.NGN`` is currently allowed provider_slug: The bank's slug in lowercase, without spaces e.g. wema-bank bank_id: The bank's ID e.g. 035 customer: The customer's ID Returns: A named tuple containing the response gotten from paystack's server. \"\"\" query_params = [ ( \"currency\" , currency ), ( \"provider_slug\" , provider_slug ), ( \"bank_id\" , bank_id ), ( \"customer\" , customer ), ] url = self . _parse_url ( f \"/dedicated_account?active= { active } \" ) url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url )","title":"get_dedicated_accounts()"},{"location":"reference/dedicated_accounts/#pypaystack2.api.dedicated_accounts.AsyncDedicatedAccount.get_providers","text":"Get available bank providers for a dedicated virtual account Note This feature is only available to businesses in Nigeria. Paystack currently supports Access Bank and Wema Bank. To create Dedicated Virtual Accounts using your test secret key, use test-bank as the preferred_bank You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/dedicated_accounts.py 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 async def get_providers ( self ) -> Response : \"\"\"Get available bank providers for a dedicated virtual account Note: * This feature is only available to businesses in Nigeria. * Paystack currently supports Access Bank and Wema Bank. * To create Dedicated Virtual Accounts using your test secret key, use ``test-bank`` as the ``preferred_bank`` You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/dedicated_account/available_providers\" ) return await self . _handle_request ( HTTPMethod . GET , url )","title":"get_providers()"},{"location":"reference/dedicated_accounts/#pypaystack2.api.dedicated_accounts.AsyncDedicatedAccount.remove_split","text":"Removes a split. If you've previously set up split payment for transactions on a dedicated virtual account, you can remove it with this method. Note This feature is only available to businesses in Nigeria. Paystack currently supports Access Bank and Wema Bank. To create Dedicated Virtual Accounts using your test secret key, use test-bank as the preferred_bank You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Parameters: Name Type Description Default account_number str Dedicated virtual account number required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/dedicated_accounts.py 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 async def remove_split ( self , account_number : str ) -> Response : \"\"\"Removes a split. If you've previously set up split payment for transactions on a dedicated virtual account, you can remove it with this method. Note: * This feature is only available to businesses in Nigeria. * Paystack currently supports Access Bank and Wema Bank. * To create Dedicated Virtual Accounts using your test secret key, use ``test-bank`` as the ``preferred_bank`` You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Args: account_number: Dedicated virtual account number Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/dedicated_account/split\" ) payload = { \"account_number\" : account_number , } return await self . _handle_request ( HTTPMethod . DELETE , url , payload )","title":"remove_split()"},{"location":"reference/dedicated_accounts/#pypaystack2.api.dedicated_accounts.AsyncDedicatedAccount.requery","text":"Get details of a dedicated virtual account on your integration. Note This feature is only available to businesses in Nigeria. Paystack currently supports Access Bank and Wema Bank. To create Dedicated Virtual Accounts using your test secret key, use test-bank as the preferred_bank You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Parameters: Name Type Description Default account_number str Virtual account number to requery required provider_slug str The bank's slug in lowercase, without spaces e.g. wema-bank required date Optional [ str ] The day the transfer was made in YYYY-MM-DD ISO format required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/dedicated_accounts.py 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 async def requery ( self , account_number : str , provider_slug : str , date : Optional [ str ] ) -> Response : \"\"\"Get details of a dedicated virtual account on your integration. Note: * This feature is only available to businesses in Nigeria. * Paystack currently supports Access Bank and Wema Bank. * To create Dedicated Virtual Accounts using your test secret key, use ``test-bank`` as the ``preferred_bank`` You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Args: account_number: Virtual account number to requery provider_slug: The bank's slug in lowercase, without spaces e.g. wema-bank date: The day the transfer was made in YYYY-MM-DD ISO format Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/dedicated_account?account_number= { account_number } \" ) query_params = [ ( \"provider_slug\" , provider_slug ), ( \"date\" , date ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url )","title":"requery()"},{"location":"reference/dedicated_accounts/#pypaystack2.api.dedicated_accounts.AsyncDedicatedAccount.split","text":"Split a dedicated virtual account transaction with one or more accounts Note This feature is only available to businesses in Nigeria. Paystack currently supports Access Bank and Wema Bank. To create Dedicated Virtual Accounts using your test secret key, use test-bank as the preferred_bank You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Parameters: Name Type Description Default customer str Customer ID or code required subaccount Optional [ str ] Subaccount code of the account you want to split the transaction with None split_code Optional [ str ] Split code consisting of the lists of accounts you want to split the transaction with None preferred_bank Optional [ str ] The bank slug for preferred bank. To get a list of available banks, use the Miscellaneous API .get_providers method None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/dedicated_accounts.py 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 async def split ( self , customer : str , subaccount : Optional [ str ] = None , split_code : Optional [ str ] = None , preferred_bank : Optional [ str ] = None , ) -> Response : \"\"\"Split a dedicated virtual account transaction with one or more accounts Note: * This feature is only available to businesses in Nigeria. * Paystack currently supports Access Bank and Wema Bank. * To create Dedicated Virtual Accounts using your test secret key, use ``test-bank`` as the ``preferred_bank`` You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Args: customer: Customer ID or code subaccount: Subaccount code of the account you want to split the transaction with split_code: Split code consisting of the lists of accounts you want to split the transaction with preferred_bank: The bank slug for preferred bank. To get a list of available banks, use the Miscellaneous API ``.get_providers`` method Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/dedicated_account/split\" ) payload = { \"customer\" : customer } optional_params = [ ( \"subaccount\" , subaccount ), ( \"split_code\" , split_code ), ( \"preferred_bank\" , preferred_bank ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . POST , url , payload )","title":"split()"},{"location":"reference/dedicated_accounts/#pypaystack2.api.dedicated_accounts.DedicatedAccount","text":"Bases: BaseAPI Provides a wrapper for paystack Dedicated Virtual Account API The Dedicated Virtual Account API enables Nigerian merchants to manage unique payment accounts of their customers. https://paystack.com/docs/api/#dedicated-virtual-account Note This feature is only available to businesses in Nigeria. Source code in pypaystack2/api/dedicated_accounts.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 class DedicatedAccount ( BaseAPI ): \"\"\"Provides a wrapper for paystack Dedicated Virtual Account API The Dedicated Virtual Account API enables Nigerian merchants to manage unique payment accounts of their customers. https://paystack.com/docs/api/#dedicated-virtual-account Note: This feature is only available to businesses in Nigeria. \"\"\" def create ( self , customer : str , preferred_bank : Optional [ str ] = None , subaccount : Optional [ str ] = None , split_code : Optional [ str ] = None , first_name : Optional [ str ] = None , last_name : Optional [ str ] = None , phone : Optional [ str ] = None , ) -> Response : \"\"\"Create a dedicated virtual account and assign to a customer Note: * This feature is only available to businesses in Nigeria. * Paystack currently supports Access Bank and Wema Bank. * To create Dedicated Virtual Accounts using your test secret key, use ``test-bank`` as the ``preferred_bank`` You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Args: customer: Customer ID or code preferred_bank: The bank slug for a preferred bank. To get a list of available banks, use the Miscellaneous API ``.get_providers`` method. subaccount: Subaccount code of the account you want to split the transaction with split_code: Split code consisting of the lists of accounts you want to split the transaction with first_name: Customer's first name last_name: Customer's last name phone: Customer's phone number Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/dedicated_account\" ) payload = { \"customer\" : customer , } optional_params = [ ( \"preferred_bank\" , preferred_bank ), ( \"subaccount\" , subaccount ), ( \"split_code\" , split_code ), ( \"first_name\" , first_name ), ( \"last_name\" , last_name ), ( \"phone\" , phone ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . POST , url , payload ) def get_dedicated_accounts ( self , active : bool = True , currency : Currency = Currency . NGN , provider_slug : Optional [ str ] = None , bank_id : Optional [ str ] = None , customer : Optional [ str ] = None , ) -> Response : \"\"\"Fetches dedicated virtual accounts available on your integration. Note: * This feature is only available to businesses in Nigeria. * Paystack currently supports Access Bank and Wema Bank. * To create Dedicated Virtual Accounts using your test secret key, use ``test-bank`` as the ``preferred_bank`` You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Args: active: Status of the dedicated virtual account currency: The currency of the dedicated virtual account. Only ``Currency.NGN`` is currently allowed provider_slug: The bank's slug in lowercase, without spaces e.g. wema-bank bank_id: The bank's ID e.g., 035 customer: The customer's ID Returns: A named tuple containing the response gotten from paystack's server. \"\"\" query_params = [ ( \"currency\" , currency ), ( \"provider_slug\" , provider_slug ), ( \"bank_id\" , bank_id ), ( \"customer\" , customer ), ] url = self . _parse_url ( f \"/dedicated_account?active= { active } \" ) url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url ) def get_dedicated_account ( self , dedicated_account_id : int ) -> Response : \"\"\"Get details of a dedicated virtual account on your integration. Note: * This feature is only available to businesses in Nigeria. * Paystack currently supports Access Bank and Wema Bank. * To create Dedicated Virtual Accounts using your test secret key, use ``test-bank`` as the ``preferred_bank`` You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Args: dedicated_account_id: ID of dedicated virtual account Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/dedicated_account/ { dedicated_account_id } \" ) return self . _handle_request ( HTTPMethod . GET , url ) def requery ( self , account_number : str , provider_slug : str , date : Optional [ str ] ) -> Response : \"\"\"Get details of a dedicated virtual account on your integration. Note: * This feature is only available to businesses in Nigeria. * Paystack currently supports Access Bank and Wema Bank. * To create Dedicated Virtual Accounts using your test secret key, use ``test-bank`` as the ``preferred_bank`` You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Args: account_number: Virtual account number to requery provider_slug: The bank's slug in lowercase, without spaces e.g. wema-bank date: The day the transfer was made in YYYY-MM-DD ISO format Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/dedicated_account?account_number= { account_number } \" ) query_params = [ ( \"provider_slug\" , provider_slug ), ( \"date\" , date ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url ) def deactivate ( self , dedicated_account_id : int ) -> Response : \"\"\"Deactivate a dedicated virtual account on your integration. Note: * This feature is only available to businesses in Nigeria. * Paystack currently supports Access Bank and Wema Bank. * To create Dedicated Virtual Accounts using your test secret key, use ``test-bank`` as the ``preferred_bank`` You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Args: dedicated_account_id: ID of dedicated virtual account Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/dedicated_account/ { dedicated_account_id } \" ) return self . _handle_request ( HTTPMethod . DELETE , url ) def split ( self , customer : str , subaccount : Optional [ str ] = None , split_code : Optional [ str ] = None , preferred_bank : Optional [ str ] = None , ) -> Response : \"\"\"Split a dedicated virtual account transaction with one or more accounts Note: * This feature is only available to businesses in Nigeria. * Paystack currently supports Access Bank and Wema Bank. * To create Dedicated Virtual Accounts using your test secret key, use ``test-bank`` as the ``preferred_bank`` You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Args: customer: Customer ID or code subaccount: Subaccount code of the account you want to split the transaction with split_code: Split code consisting of the lists of accounts you want to split the transaction with preferred_bank: The bank slug for a preferred bank. To get a list of available banks, use the Miscellaneous API ``.get_providers`` method Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/dedicated_account/split\" ) payload = { \"customer\" : customer } optional_params = [ ( \"subaccount\" , subaccount ), ( \"split_code\" , split_code ), ( \"preferred_bank\" , preferred_bank ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . POST , url , payload ) def remove_split ( self , account_number : str ) -> Response : \"\"\"Removes a split. If you've previously set up split payment for transactions on a dedicated virtual account, you can remove it with this method. Note: * This feature is only available to businesses in Nigeria. * Paystack currently supports Access Bank and Wema Bank. * To create Dedicated Virtual Accounts using your test secret key, use ``test-bank`` as the ``preferred_bank`` You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Args: account_number: Dedicated virtual account number Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/dedicated_account/split\" ) payload = { \"account_number\" : account_number , } return self . _handle_request ( HTTPMethod . DELETE , url , payload ) def get_providers ( self ) -> Response : \"\"\"Get available bank providers for a dedicated virtual account Note: * This feature is only available to businesses in Nigeria. * Paystack currently supports Access Bank and Wema Bank. * To create Dedicated Virtual Accounts using your test secret key, use ``test-bank`` as the ``preferred_bank`` You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/dedicated_account/available_providers\" ) return self . _handle_request ( HTTPMethod . GET , url )","title":"DedicatedAccount"},{"location":"reference/dedicated_accounts/#pypaystack2.api.dedicated_accounts.DedicatedAccount.create","text":"Create a dedicated virtual account and assign to a customer Note This feature is only available to businesses in Nigeria. Paystack currently supports Access Bank and Wema Bank. To create Dedicated Virtual Accounts using your test secret key, use test-bank as the preferred_bank You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Parameters: Name Type Description Default customer str Customer ID or code required preferred_bank Optional [ str ] The bank slug for a preferred bank. To get a list of available banks, use the Miscellaneous API .get_providers method. None subaccount Optional [ str ] Subaccount code of the account you want to split the transaction with None split_code Optional [ str ] Split code consisting of the lists of accounts you want to split the transaction with None first_name Optional [ str ] Customer's first name None last_name Optional [ str ] Customer's last name None phone Optional [ str ] Customer's phone number None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/dedicated_accounts.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 def create ( self , customer : str , preferred_bank : Optional [ str ] = None , subaccount : Optional [ str ] = None , split_code : Optional [ str ] = None , first_name : Optional [ str ] = None , last_name : Optional [ str ] = None , phone : Optional [ str ] = None , ) -> Response : \"\"\"Create a dedicated virtual account and assign to a customer Note: * This feature is only available to businesses in Nigeria. * Paystack currently supports Access Bank and Wema Bank. * To create Dedicated Virtual Accounts using your test secret key, use ``test-bank`` as the ``preferred_bank`` You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Args: customer: Customer ID or code preferred_bank: The bank slug for a preferred bank. To get a list of available banks, use the Miscellaneous API ``.get_providers`` method. subaccount: Subaccount code of the account you want to split the transaction with split_code: Split code consisting of the lists of accounts you want to split the transaction with first_name: Customer's first name last_name: Customer's last name phone: Customer's phone number Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/dedicated_account\" ) payload = { \"customer\" : customer , } optional_params = [ ( \"preferred_bank\" , preferred_bank ), ( \"subaccount\" , subaccount ), ( \"split_code\" , split_code ), ( \"first_name\" , first_name ), ( \"last_name\" , last_name ), ( \"phone\" , phone ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . POST , url , payload )","title":"create()"},{"location":"reference/dedicated_accounts/#pypaystack2.api.dedicated_accounts.DedicatedAccount.deactivate","text":"Deactivate a dedicated virtual account on your integration. Note This feature is only available to businesses in Nigeria. Paystack currently supports Access Bank and Wema Bank. To create Dedicated Virtual Accounts using your test secret key, use test-bank as the preferred_bank You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Parameters: Name Type Description Default dedicated_account_id int ID of dedicated virtual account required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/dedicated_accounts.py 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 def deactivate ( self , dedicated_account_id : int ) -> Response : \"\"\"Deactivate a dedicated virtual account on your integration. Note: * This feature is only available to businesses in Nigeria. * Paystack currently supports Access Bank and Wema Bank. * To create Dedicated Virtual Accounts using your test secret key, use ``test-bank`` as the ``preferred_bank`` You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Args: dedicated_account_id: ID of dedicated virtual account Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/dedicated_account/ { dedicated_account_id } \" ) return self . _handle_request ( HTTPMethod . DELETE , url )","title":"deactivate()"},{"location":"reference/dedicated_accounts/#pypaystack2.api.dedicated_accounts.DedicatedAccount.get_dedicated_account","text":"Get details of a dedicated virtual account on your integration. Note This feature is only available to businesses in Nigeria. Paystack currently supports Access Bank and Wema Bank. To create Dedicated Virtual Accounts using your test secret key, use test-bank as the preferred_bank You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Parameters: Name Type Description Default dedicated_account_id int ID of dedicated virtual account required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/dedicated_accounts.py 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 def get_dedicated_account ( self , dedicated_account_id : int ) -> Response : \"\"\"Get details of a dedicated virtual account on your integration. Note: * This feature is only available to businesses in Nigeria. * Paystack currently supports Access Bank and Wema Bank. * To create Dedicated Virtual Accounts using your test secret key, use ``test-bank`` as the ``preferred_bank`` You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Args: dedicated_account_id: ID of dedicated virtual account Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/dedicated_account/ { dedicated_account_id } \" ) return self . _handle_request ( HTTPMethod . GET , url )","title":"get_dedicated_account()"},{"location":"reference/dedicated_accounts/#pypaystack2.api.dedicated_accounts.DedicatedAccount.get_dedicated_accounts","text":"Fetches dedicated virtual accounts available on your integration. Note This feature is only available to businesses in Nigeria. Paystack currently supports Access Bank and Wema Bank. To create Dedicated Virtual Accounts using your test secret key, use test-bank as the preferred_bank You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Parameters: Name Type Description Default active bool Status of the dedicated virtual account True currency Currency The currency of the dedicated virtual account. Only Currency.NGN is currently allowed Currency.NGN provider_slug Optional [ str ] The bank's slug in lowercase, without spaces e.g. wema-bank None bank_id Optional [ str ] The bank's ID e.g., 035 None customer Optional [ str ] The customer's ID None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/dedicated_accounts.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 def get_dedicated_accounts ( self , active : bool = True , currency : Currency = Currency . NGN , provider_slug : Optional [ str ] = None , bank_id : Optional [ str ] = None , customer : Optional [ str ] = None , ) -> Response : \"\"\"Fetches dedicated virtual accounts available on your integration. Note: * This feature is only available to businesses in Nigeria. * Paystack currently supports Access Bank and Wema Bank. * To create Dedicated Virtual Accounts using your test secret key, use ``test-bank`` as the ``preferred_bank`` You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Args: active: Status of the dedicated virtual account currency: The currency of the dedicated virtual account. Only ``Currency.NGN`` is currently allowed provider_slug: The bank's slug in lowercase, without spaces e.g. wema-bank bank_id: The bank's ID e.g., 035 customer: The customer's ID Returns: A named tuple containing the response gotten from paystack's server. \"\"\" query_params = [ ( \"currency\" , currency ), ( \"provider_slug\" , provider_slug ), ( \"bank_id\" , bank_id ), ( \"customer\" , customer ), ] url = self . _parse_url ( f \"/dedicated_account?active= { active } \" ) url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url )","title":"get_dedicated_accounts()"},{"location":"reference/dedicated_accounts/#pypaystack2.api.dedicated_accounts.DedicatedAccount.get_providers","text":"Get available bank providers for a dedicated virtual account Note This feature is only available to businesses in Nigeria. Paystack currently supports Access Bank and Wema Bank. To create Dedicated Virtual Accounts using your test secret key, use test-bank as the preferred_bank You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/dedicated_accounts.py 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 def get_providers ( self ) -> Response : \"\"\"Get available bank providers for a dedicated virtual account Note: * This feature is only available to businesses in Nigeria. * Paystack currently supports Access Bank and Wema Bank. * To create Dedicated Virtual Accounts using your test secret key, use ``test-bank`` as the ``preferred_bank`` You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/dedicated_account/available_providers\" ) return self . _handle_request ( HTTPMethod . GET , url )","title":"get_providers()"},{"location":"reference/dedicated_accounts/#pypaystack2.api.dedicated_accounts.DedicatedAccount.remove_split","text":"Removes a split. If you've previously set up split payment for transactions on a dedicated virtual account, you can remove it with this method. Note This feature is only available to businesses in Nigeria. Paystack currently supports Access Bank and Wema Bank. To create Dedicated Virtual Accounts using your test secret key, use test-bank as the preferred_bank You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Parameters: Name Type Description Default account_number str Dedicated virtual account number required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/dedicated_accounts.py 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 def remove_split ( self , account_number : str ) -> Response : \"\"\"Removes a split. If you've previously set up split payment for transactions on a dedicated virtual account, you can remove it with this method. Note: * This feature is only available to businesses in Nigeria. * Paystack currently supports Access Bank and Wema Bank. * To create Dedicated Virtual Accounts using your test secret key, use ``test-bank`` as the ``preferred_bank`` You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Args: account_number: Dedicated virtual account number Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/dedicated_account/split\" ) payload = { \"account_number\" : account_number , } return self . _handle_request ( HTTPMethod . DELETE , url , payload )","title":"remove_split()"},{"location":"reference/dedicated_accounts/#pypaystack2.api.dedicated_accounts.DedicatedAccount.requery","text":"Get details of a dedicated virtual account on your integration. Note This feature is only available to businesses in Nigeria. Paystack currently supports Access Bank and Wema Bank. To create Dedicated Virtual Accounts using your test secret key, use test-bank as the preferred_bank You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Parameters: Name Type Description Default account_number str Virtual account number to requery required provider_slug str The bank's slug in lowercase, without spaces e.g. wema-bank required date Optional [ str ] The day the transfer was made in YYYY-MM-DD ISO format required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/dedicated_accounts.py 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 def requery ( self , account_number : str , provider_slug : str , date : Optional [ str ] ) -> Response : \"\"\"Get details of a dedicated virtual account on your integration. Note: * This feature is only available to businesses in Nigeria. * Paystack currently supports Access Bank and Wema Bank. * To create Dedicated Virtual Accounts using your test secret key, use ``test-bank`` as the ``preferred_bank`` You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Args: account_number: Virtual account number to requery provider_slug: The bank's slug in lowercase, without spaces e.g. wema-bank date: The day the transfer was made in YYYY-MM-DD ISO format Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/dedicated_account?account_number= { account_number } \" ) query_params = [ ( \"provider_slug\" , provider_slug ), ( \"date\" , date ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url )","title":"requery()"},{"location":"reference/dedicated_accounts/#pypaystack2.api.dedicated_accounts.DedicatedAccount.split","text":"Split a dedicated virtual account transaction with one or more accounts Note This feature is only available to businesses in Nigeria. Paystack currently supports Access Bank and Wema Bank. To create Dedicated Virtual Accounts using your test secret key, use test-bank as the preferred_bank You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Parameters: Name Type Description Default customer str Customer ID or code required subaccount Optional [ str ] Subaccount code of the account you want to split the transaction with None split_code Optional [ str ] Split code consisting of the lists of accounts you want to split the transaction with None preferred_bank Optional [ str ] The bank slug for a preferred bank. To get a list of available banks, use the Miscellaneous API .get_providers method None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/dedicated_accounts.py 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 def split ( self , customer : str , subaccount : Optional [ str ] = None , split_code : Optional [ str ] = None , preferred_bank : Optional [ str ] = None , ) -> Response : \"\"\"Split a dedicated virtual account transaction with one or more accounts Note: * This feature is only available to businesses in Nigeria. * Paystack currently supports Access Bank and Wema Bank. * To create Dedicated Virtual Accounts using your test secret key, use ``test-bank`` as the ``preferred_bank`` You can also make a transfer to the test virtual accounts using paystack's demo bank app. https://demobank.paystackintegrations.com/ Args: customer: Customer ID or code subaccount: Subaccount code of the account you want to split the transaction with split_code: Split code consisting of the lists of accounts you want to split the transaction with preferred_bank: The bank slug for a preferred bank. To get a list of available banks, use the Miscellaneous API ``.get_providers`` method Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/dedicated_account/split\" ) payload = { \"customer\" : customer } optional_params = [ ( \"subaccount\" , subaccount ), ( \"split_code\" , split_code ), ( \"preferred_bank\" , preferred_bank ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . POST , url , payload )","title":"split()"},{"location":"reference/disputes/","text":"AsyncDispute Bases: BaseAsyncAPI Provides a wrapper for paystack Disputes API The Disputes API allows you manage transaction disputes on your integration. https://paystack.com/docs/api/#dispute Source code in pypaystack2/api/disputes.py 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 class AsyncDispute ( BaseAsyncAPI ): \"\"\"Provides a wrapper for paystack Disputes API The Disputes API allows you manage transaction disputes on your integration. https://paystack.com/docs/api/#dispute \"\"\" async def get_disputes ( self , start_date : str , end_date : str , pagination : int = 50 , page : int = 1 , transaction : Optional [ str ] = None , status : Optional [ DisputeStatus ] = None , ) -> Response : \"\"\"Fetches disputes filed against you Args: start_date: A timestamp from which to start listing dispute e.g. 2016-09-21 end_date: A timestamp at which to stop listing dispute e.g. 2016-09-21 pagination : Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. page: Specifies exactly what dispute you want to page. If not specified we use a default value of 1. transaction: Transaction ID status: Any of DisputeStatus enum values. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/dispute?perPage= { pagination } \" ) query_params = [ ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ( \"transaction\" , transaction ), ( \"status\" , status ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url ) async def get_dispute ( self , id : str ) -> Response : \"\"\"Get more details about a dispute. Args: id: The dispute ID you want to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/dispute/ { id } \" ) return await self . _handle_request ( HTTPMethod . GET , url ) async def get_transaction_disputes ( self , id : str ) -> Response : \"\"\"This method retrieves disputes for a particular transaction Args: id: The transaction ID you want to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/dispute/transaction/ { id } \" ) return await self . _handle_request ( HTTPMethod . GET , url ) async def update_dispute ( self , id : str , refund_amount : int , uploaded_filename : Optional [ str ] ) -> Response : \"\"\"Update details of a dispute on your integration Args: id: Dispute ID refund_amount: the amount to refund, in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR uploaded_filename: filename of attachment returned via response from upload url(GET /dispute/:id/upload_url) Returns: A named tuple containing the response gotten from paystack's server. \"\"\" refund_amount = validate_amount ( refund_amount ) payload = { \"refund_amount\" : refund_amount } payload = add_to_payload ([( \"uploaded_filename\" , uploaded_filename )], payload ) url = self . _parse_url ( f \"/dispute/ { id } \" ) return await self . _handle_request ( HTTPMethod . PUT , url , payload ) async def add_evidence ( self , id : str , customer_email : str , customer_name : str , customer_phone : str , service_details : str , delivery_address : Optional [ str ] = None , delivery_date : Optional [ str ] = None , ) -> Response : \"\"\"Provide evidence for a dispute Args: id: Dispute ID customer_email: Customer email customer_name: Customer name customer_phone: Customer phone service_details: Details of service involved delivery_address: Delivery Address delivery_date: ISO 8601 representation of delivery date (YYYY-MM-DD) Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"customer_email\" : customer_email , \"customer_name\" : customer_name , \"customer_phone\" : customer_phone , \"service_details\" : service_details , } optional_params = [ ( \"delivery_address\" , delivery_address ), ( \"delivery_date\" , delivery_date ), ] payload = add_to_payload ( optional_params , payload ) url = self . _parse_url ( f \"dispute/ { id } /evidence\" ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) async def get_upload_url ( self , id : str , upload_filename : str ) -> Response : \"\"\"Get URL to upload a dispute evidence. Args: id: Dispute ID upload_filename: The file name, with its extension, that you want to upload. e.g. filename.pdf Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/dispute/ { id } /upload_url?upload_filename= { upload_filename } \" ) return await self . _handle_request ( HTTPMethod . GET , url ) async def resolve_dispute ( self , id : str , resolution : Resolution , message : str , refund_amount : int , uploaded_filename : str , evidence : Optional [ int ] = None , ) -> Response : \"\"\"Resolve a dispute on your integration Args: id: Dispute ID resolution: Any of the Resolution enum value. message: Reason for resolving refund_amount: the amount to refund, in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR uploaded_filename: filename of attachment returned via response from upload url(GET /dispute/:id/upload_url) evidence: Evidence ID for fraud claims Returns: A named tuple containing the response gotten from paystack's server. \"\"\" refund_amount = validate_amount ( refund_amount ) payload = { \"resolution\" : resolution , \"message\" : message , \"refund_amount\" : refund_amount , \"uploaded_filename\" : uploaded_filename , } payload = add_to_payload ([( \"evidence\" , evidence )], payload ) url = self . _parse_url ( f \"/dispute/ { id } /resolve\" ) return await self . _handle_request ( HTTPMethod . PUT , url , payload ) async def export_disputes ( self , start_date : str , end_date : str , pagination : int = 50 , page : int = 1 , transaction : Optional [ str ] = None , status : Optional [ DisputeStatus ] = None , ) -> Response : \"\"\"Export disputes available on your integration. Args: start_date: A timestamp from which to start listing dispute e.g. 2016-09-21 end_date: A timestamp at which to stop listing dispute e.g. 2016-09-21 pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. page: Specifies exactly what dispute you want to page. If not specified we use a default value of 1. transaction: Transaction ID status: Any value from the DisputeStatus enum Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/dispute/export?perPage= { pagination } \" ) query_params = [ ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ( \"transaction\" , transaction ), ( \"status\" , status ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url ) add_evidence ( id , customer_email , customer_name , customer_phone , service_details , delivery_address = None , delivery_date = None ) async Provide evidence for a dispute Parameters: Name Type Description Default id str Dispute ID required customer_email str Customer email required customer_name str Customer name required customer_phone str Customer phone required service_details str Details of service involved required delivery_address Optional [ str ] Delivery Address None delivery_date Optional [ str ] ISO 8601 representation of delivery date (YYYY-MM-DD) None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/disputes.py 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 async def add_evidence ( self , id : str , customer_email : str , customer_name : str , customer_phone : str , service_details : str , delivery_address : Optional [ str ] = None , delivery_date : Optional [ str ] = None , ) -> Response : \"\"\"Provide evidence for a dispute Args: id: Dispute ID customer_email: Customer email customer_name: Customer name customer_phone: Customer phone service_details: Details of service involved delivery_address: Delivery Address delivery_date: ISO 8601 representation of delivery date (YYYY-MM-DD) Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"customer_email\" : customer_email , \"customer_name\" : customer_name , \"customer_phone\" : customer_phone , \"service_details\" : service_details , } optional_params = [ ( \"delivery_address\" , delivery_address ), ( \"delivery_date\" , delivery_date ), ] payload = add_to_payload ( optional_params , payload ) url = self . _parse_url ( f \"dispute/ { id } /evidence\" ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) export_disputes ( start_date , end_date , pagination = 50 , page = 1 , transaction = None , status = None ) async Export disputes available on your integration. Parameters: Name Type Description Default start_date str A timestamp from which to start listing dispute e.g. 2016-09-21 required end_date str A timestamp at which to stop listing dispute e.g. 2016-09-21 required pagination int Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. 50 page int Specifies exactly what dispute you want to page. If not specified we use a default value of 1. 1 transaction Optional [ str ] Transaction ID None status Optional [ DisputeStatus ] Any value from the DisputeStatus enum None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/disputes.py 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 async def export_disputes ( self , start_date : str , end_date : str , pagination : int = 50 , page : int = 1 , transaction : Optional [ str ] = None , status : Optional [ DisputeStatus ] = None , ) -> Response : \"\"\"Export disputes available on your integration. Args: start_date: A timestamp from which to start listing dispute e.g. 2016-09-21 end_date: A timestamp at which to stop listing dispute e.g. 2016-09-21 pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. page: Specifies exactly what dispute you want to page. If not specified we use a default value of 1. transaction: Transaction ID status: Any value from the DisputeStatus enum Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/dispute/export?perPage= { pagination } \" ) query_params = [ ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ( \"transaction\" , transaction ), ( \"status\" , status ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url ) get_dispute ( id ) async Get more details about a dispute. Parameters: Name Type Description Default id str The dispute ID you want to fetch required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/disputes.py 274 275 276 277 278 279 280 281 282 283 284 285 async def get_dispute ( self , id : str ) -> Response : \"\"\"Get more details about a dispute. Args: id: The dispute ID you want to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/dispute/ { id } \" ) return await self . _handle_request ( HTTPMethod . GET , url ) get_disputes ( start_date , end_date , pagination = 50 , page = 1 , transaction = None , status = None ) async Fetches disputes filed against you Parameters: Name Type Description Default start_date str A timestamp from which to start listing dispute e.g. 2016-09-21 required end_date str A timestamp at which to stop listing dispute e.g. 2016-09-21 required pagination Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. 50 page int Specifies exactly what dispute you want to page. If not specified we use a default value of 1. 1 transaction Optional [ str ] Transaction ID None status Optional [ DisputeStatus ] Any of DisputeStatus enum values. None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/disputes.py 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 async def get_disputes ( self , start_date : str , end_date : str , pagination : int = 50 , page : int = 1 , transaction : Optional [ str ] = None , status : Optional [ DisputeStatus ] = None , ) -> Response : \"\"\"Fetches disputes filed against you Args: start_date: A timestamp from which to start listing dispute e.g. 2016-09-21 end_date: A timestamp at which to stop listing dispute e.g. 2016-09-21 pagination : Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. page: Specifies exactly what dispute you want to page. If not specified we use a default value of 1. transaction: Transaction ID status: Any of DisputeStatus enum values. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/dispute?perPage= { pagination } \" ) query_params = [ ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ( \"transaction\" , transaction ), ( \"status\" , status ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url ) get_transaction_disputes ( id ) async This method retrieves disputes for a particular transaction Parameters: Name Type Description Default id str The transaction ID you want to fetch required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/disputes.py 287 288 289 290 291 292 293 294 295 296 297 298 async def get_transaction_disputes ( self , id : str ) -> Response : \"\"\"This method retrieves disputes for a particular transaction Args: id: The transaction ID you want to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/dispute/transaction/ { id } \" ) return await self . _handle_request ( HTTPMethod . GET , url ) get_upload_url ( id , upload_filename ) async Get URL to upload a dispute evidence. Parameters: Name Type Description Default id str Dispute ID required upload_filename str The file name, with its extension, that you want to upload. e.g. filename.pdf required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/disputes.py 360 361 362 363 364 365 366 367 368 369 370 371 372 373 async def get_upload_url ( self , id : str , upload_filename : str ) -> Response : \"\"\"Get URL to upload a dispute evidence. Args: id: Dispute ID upload_filename: The file name, with its extension, that you want to upload. e.g. filename.pdf Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/dispute/ { id } /upload_url?upload_filename= { upload_filename } \" ) return await self . _handle_request ( HTTPMethod . GET , url ) resolve_dispute ( id , resolution , message , refund_amount , uploaded_filename , evidence = None ) async Resolve a dispute on your integration Parameters: Name Type Description Default id str Dispute ID required resolution Resolution Any of the Resolution enum value. required message str Reason for resolving required refund_amount int the amount to refund, in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR required uploaded_filename str filename of attachment returned via response from upload url(GET /dispute/:id/upload_url) required evidence Optional [ int ] Evidence ID for fraud claims None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/disputes.py 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 async def resolve_dispute ( self , id : str , resolution : Resolution , message : str , refund_amount : int , uploaded_filename : str , evidence : Optional [ int ] = None , ) -> Response : \"\"\"Resolve a dispute on your integration Args: id: Dispute ID resolution: Any of the Resolution enum value. message: Reason for resolving refund_amount: the amount to refund, in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR uploaded_filename: filename of attachment returned via response from upload url(GET /dispute/:id/upload_url) evidence: Evidence ID for fraud claims Returns: A named tuple containing the response gotten from paystack's server. \"\"\" refund_amount = validate_amount ( refund_amount ) payload = { \"resolution\" : resolution , \"message\" : message , \"refund_amount\" : refund_amount , \"uploaded_filename\" : uploaded_filename , } payload = add_to_payload ([( \"evidence\" , evidence )], payload ) url = self . _parse_url ( f \"/dispute/ { id } /resolve\" ) return await self . _handle_request ( HTTPMethod . PUT , url , payload ) update_dispute ( id , refund_amount , uploaded_filename ) async Update details of a dispute on your integration Parameters: Name Type Description Default id str Dispute ID required refund_amount int the amount to refund, in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR required uploaded_filename Optional [ str ] filename of attachment returned via response from upload url(GET /dispute/:id/upload_url) required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/disputes.py 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 async def update_dispute ( self , id : str , refund_amount : int , uploaded_filename : Optional [ str ] ) -> Response : \"\"\"Update details of a dispute on your integration Args: id: Dispute ID refund_amount: the amount to refund, in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR uploaded_filename: filename of attachment returned via response from upload url(GET /dispute/:id/upload_url) Returns: A named tuple containing the response gotten from paystack's server. \"\"\" refund_amount = validate_amount ( refund_amount ) payload = { \"refund_amount\" : refund_amount } payload = add_to_payload ([( \"uploaded_filename\" , uploaded_filename )], payload ) url = self . _parse_url ( f \"/dispute/ { id } \" ) return await self . _handle_request ( HTTPMethod . PUT , url , payload ) Dispute Bases: BaseAPI Provides a wrapper for paystack Disputes API The Disputes API allows you manage transaction disputes on your integration. https://paystack.com/docs/api/#dispute Source code in pypaystack2/api/disputes.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 class Dispute ( BaseAPI ): \"\"\"Provides a wrapper for paystack Disputes API The Disputes API allows you manage transaction disputes on your integration. https://paystack.com/docs/api/#dispute \"\"\" def get_disputes ( self , start_date : str , end_date : str , pagination : int = 50 , page : int = 1 , transaction : Optional [ str ] = None , status : Optional [ DisputeStatus ] = None , ) -> Response : \"\"\"Fetches disputes filed against you Args: start_date: A timestamp from which to start listing dispute e.g. 2016-09-21 end_date: A timestamp at which to stop listing dispute e.g. 2016-09-21 pagination : Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. page: Specifies exactly what dispute you want to page. If not specified we use a default value of 1. transaction: Transaction ID status: Any of DisputeStatus enum values. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/dispute?perPage= { pagination } \" ) query_params = [ ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ( \"transaction\" , transaction ), ( \"status\" , status ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url ) def get_dispute ( self , id : str ) -> Response : \"\"\"Get more details about a dispute. Args: id: The dispute ID you want to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/dispute/ { id } \" ) return self . _handle_request ( HTTPMethod . GET , url ) def get_transaction_disputes ( self , id : str ) -> Response : \"\"\"This method retrieves disputes for a particular transaction Args: id: The transaction ID you want to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/dispute/transaction/ { id } \" ) return self . _handle_request ( HTTPMethod . GET , url ) def update_dispute ( self , id : str , refund_amount : int , uploaded_filename : Optional [ str ] ) -> Response : \"\"\"Update details of a dispute on your integration Args: id: Dispute ID refund_amount: the amount to refund, in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR uploaded_filename: filename of attachment returned via response from upload url(GET /dispute/:id/upload_url) Returns: A named tuple containing the response gotten from paystack's server. \"\"\" refund_amount = validate_amount ( refund_amount ) payload = { \"refund_amount\" : refund_amount } payload = add_to_payload ([( \"uploaded_filename\" , uploaded_filename )], payload ) url = self . _parse_url ( f \"/dispute/ { id } \" ) return self . _handle_request ( HTTPMethod . PUT , url , payload ) def add_evidence ( self , id : str , customer_email : str , customer_name : str , customer_phone : str , service_details : str , delivery_address : Optional [ str ] = None , delivery_date : Optional [ str ] = None , ) -> Response : \"\"\"Provide evidence for a dispute Args: id: Dispute ID customer_email: Customer email customer_name: Customer name customer_phone: Customer phone service_details: Details of service involved delivery_address: Delivery Address delivery_date: ISO 8601 representation of delivery date (YYYY-MM-DD) Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"customer_email\" : customer_email , \"customer_name\" : customer_name , \"customer_phone\" : customer_phone , \"service_details\" : service_details , } optional_params = [ ( \"delivery_address\" , delivery_address ), ( \"delivery_date\" , delivery_date ), ] payload = add_to_payload ( optional_params , payload ) url = self . _parse_url ( f \"dispute/ { id } /evidence\" ) return self . _handle_request ( HTTPMethod . POST , url , payload ) def get_upload_url ( self , id : str , upload_filename : str ) -> Response : \"\"\"Get URL to upload a dispute evidence. Args: id: Dispute ID upload_filename: The file name, with its extension, that you want to upload. e.g. filename.pdf Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/dispute/ { id } /upload_url?upload_filename= { upload_filename } \" ) return self . _handle_request ( HTTPMethod . GET , url ) def resolve_dispute ( self , id : str , resolution : Resolution , message : str , refund_amount : int , uploaded_filename : str , evidence : Optional [ int ] = None , ) -> Response : \"\"\"Resolve a dispute on your integration Args: id: Dispute ID resolution: Any of the Resolution enum value. message: Reason for resolving refund_amount: the amount to refund, in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR uploaded_filename: filename of attachment returned via response from upload url(GET /dispute/:id/upload_url) evidence: Evidence ID for fraud claims Returns: A named tuple containing the response gotten from paystack's server. \"\"\" refund_amount = validate_amount ( refund_amount ) payload = { \"resolution\" : resolution , \"message\" : message , \"refund_amount\" : refund_amount , \"uploaded_filename\" : uploaded_filename , } payload = add_to_payload ([( \"evidence\" , evidence )], payload ) url = self . _parse_url ( f \"/dispute/ { id } /resolve\" ) return self . _handle_request ( HTTPMethod . PUT , url , payload ) def export_disputes ( self , start_date : str , end_date : str , pagination : int = 50 , page : int = 1 , transaction : Optional [ str ] = None , status : Optional [ DisputeStatus ] = None , ) -> Response : \"\"\"Export disputes available on your integration. Args: start_date: A timestamp from which to start listing dispute e.g. 2016-09-21 end_date: A timestamp at which to stop listing dispute e.g. 2016-09-21 pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. page: Specifies exactly what dispute you want to page. If not specified we use a default value of 1. transaction: Transaction ID status: Any value from the DisputeStatus enum Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/dispute/export?perPage= { pagination } \" ) query_params = [ ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ( \"transaction\" , transaction ), ( \"status\" , status ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url ) add_evidence ( id , customer_email , customer_name , customer_phone , service_details , delivery_address = None , delivery_date = None ) Provide evidence for a dispute Parameters: Name Type Description Default id str Dispute ID required customer_email str Customer email required customer_name str Customer name required customer_phone str Customer phone required service_details str Details of service involved required delivery_address Optional [ str ] Delivery Address None delivery_date Optional [ str ] ISO 8601 representation of delivery date (YYYY-MM-DD) None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/disputes.py 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 def add_evidence ( self , id : str , customer_email : str , customer_name : str , customer_phone : str , service_details : str , delivery_address : Optional [ str ] = None , delivery_date : Optional [ str ] = None , ) -> Response : \"\"\"Provide evidence for a dispute Args: id: Dispute ID customer_email: Customer email customer_name: Customer name customer_phone: Customer phone service_details: Details of service involved delivery_address: Delivery Address delivery_date: ISO 8601 representation of delivery date (YYYY-MM-DD) Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"customer_email\" : customer_email , \"customer_name\" : customer_name , \"customer_phone\" : customer_phone , \"service_details\" : service_details , } optional_params = [ ( \"delivery_address\" , delivery_address ), ( \"delivery_date\" , delivery_date ), ] payload = add_to_payload ( optional_params , payload ) url = self . _parse_url ( f \"dispute/ { id } /evidence\" ) return self . _handle_request ( HTTPMethod . POST , url , payload ) export_disputes ( start_date , end_date , pagination = 50 , page = 1 , transaction = None , status = None ) Export disputes available on your integration. Parameters: Name Type Description Default start_date str A timestamp from which to start listing dispute e.g. 2016-09-21 required end_date str A timestamp at which to stop listing dispute e.g. 2016-09-21 required pagination int Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. 50 page int Specifies exactly what dispute you want to page. If not specified we use a default value of 1. 1 transaction Optional [ str ] Transaction ID None status Optional [ DisputeStatus ] Any value from the DisputeStatus enum None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/disputes.py 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 def export_disputes ( self , start_date : str , end_date : str , pagination : int = 50 , page : int = 1 , transaction : Optional [ str ] = None , status : Optional [ DisputeStatus ] = None , ) -> Response : \"\"\"Export disputes available on your integration. Args: start_date: A timestamp from which to start listing dispute e.g. 2016-09-21 end_date: A timestamp at which to stop listing dispute e.g. 2016-09-21 pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. page: Specifies exactly what dispute you want to page. If not specified we use a default value of 1. transaction: Transaction ID status: Any value from the DisputeStatus enum Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/dispute/export?perPage= { pagination } \" ) query_params = [ ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ( \"transaction\" , transaction ), ( \"status\" , status ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url ) get_dispute ( id ) Get more details about a dispute. Parameters: Name Type Description Default id str The dispute ID you want to fetch required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/disputes.py 58 59 60 61 62 63 64 65 66 67 68 69 def get_dispute ( self , id : str ) -> Response : \"\"\"Get more details about a dispute. Args: id: The dispute ID you want to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/dispute/ { id } \" ) return self . _handle_request ( HTTPMethod . GET , url ) get_disputes ( start_date , end_date , pagination = 50 , page = 1 , transaction = None , status = None ) Fetches disputes filed against you Parameters: Name Type Description Default start_date str A timestamp from which to start listing dispute e.g. 2016-09-21 required end_date str A timestamp at which to stop listing dispute e.g. 2016-09-21 required pagination Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. 50 page int Specifies exactly what dispute you want to page. If not specified we use a default value of 1. 1 transaction Optional [ str ] Transaction ID None status Optional [ DisputeStatus ] Any of DisputeStatus enum values. None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/disputes.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 def get_disputes ( self , start_date : str , end_date : str , pagination : int = 50 , page : int = 1 , transaction : Optional [ str ] = None , status : Optional [ DisputeStatus ] = None , ) -> Response : \"\"\"Fetches disputes filed against you Args: start_date: A timestamp from which to start listing dispute e.g. 2016-09-21 end_date: A timestamp at which to stop listing dispute e.g. 2016-09-21 pagination : Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. page: Specifies exactly what dispute you want to page. If not specified we use a default value of 1. transaction: Transaction ID status: Any of DisputeStatus enum values. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/dispute?perPage= { pagination } \" ) query_params = [ ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ( \"transaction\" , transaction ), ( \"status\" , status ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url ) get_transaction_disputes ( id ) This method retrieves disputes for a particular transaction Parameters: Name Type Description Default id str The transaction ID you want to fetch required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/disputes.py 71 72 73 74 75 76 77 78 79 80 81 82 def get_transaction_disputes ( self , id : str ) -> Response : \"\"\"This method retrieves disputes for a particular transaction Args: id: The transaction ID you want to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/dispute/transaction/ { id } \" ) return self . _handle_request ( HTTPMethod . GET , url ) get_upload_url ( id , upload_filename ) Get URL to upload a dispute evidence. Parameters: Name Type Description Default id str Dispute ID required upload_filename str The file name, with its extension, that you want to upload. e.g. filename.pdf required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/disputes.py 144 145 146 147 148 149 150 151 152 153 154 155 156 157 def get_upload_url ( self , id : str , upload_filename : str ) -> Response : \"\"\"Get URL to upload a dispute evidence. Args: id: Dispute ID upload_filename: The file name, with its extension, that you want to upload. e.g. filename.pdf Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/dispute/ { id } /upload_url?upload_filename= { upload_filename } \" ) return self . _handle_request ( HTTPMethod . GET , url ) resolve_dispute ( id , resolution , message , refund_amount , uploaded_filename , evidence = None ) Resolve a dispute on your integration Parameters: Name Type Description Default id str Dispute ID required resolution Resolution Any of the Resolution enum value. required message str Reason for resolving required refund_amount int the amount to refund, in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR required uploaded_filename str filename of attachment returned via response from upload url(GET /dispute/:id/upload_url) required evidence Optional [ int ] Evidence ID for fraud claims None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/disputes.py 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 def resolve_dispute ( self , id : str , resolution : Resolution , message : str , refund_amount : int , uploaded_filename : str , evidence : Optional [ int ] = None , ) -> Response : \"\"\"Resolve a dispute on your integration Args: id: Dispute ID resolution: Any of the Resolution enum value. message: Reason for resolving refund_amount: the amount to refund, in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR uploaded_filename: filename of attachment returned via response from upload url(GET /dispute/:id/upload_url) evidence: Evidence ID for fraud claims Returns: A named tuple containing the response gotten from paystack's server. \"\"\" refund_amount = validate_amount ( refund_amount ) payload = { \"resolution\" : resolution , \"message\" : message , \"refund_amount\" : refund_amount , \"uploaded_filename\" : uploaded_filename , } payload = add_to_payload ([( \"evidence\" , evidence )], payload ) url = self . _parse_url ( f \"/dispute/ { id } /resolve\" ) return self . _handle_request ( HTTPMethod . PUT , url , payload ) update_dispute ( id , refund_amount , uploaded_filename ) Update details of a dispute on your integration Parameters: Name Type Description Default id str Dispute ID required refund_amount int the amount to refund, in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR required uploaded_filename Optional [ str ] filename of attachment returned via response from upload url(GET /dispute/:id/upload_url) required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/disputes.py 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 def update_dispute ( self , id : str , refund_amount : int , uploaded_filename : Optional [ str ] ) -> Response : \"\"\"Update details of a dispute on your integration Args: id: Dispute ID refund_amount: the amount to refund, in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR uploaded_filename: filename of attachment returned via response from upload url(GET /dispute/:id/upload_url) Returns: A named tuple containing the response gotten from paystack's server. \"\"\" refund_amount = validate_amount ( refund_amount ) payload = { \"refund_amount\" : refund_amount } payload = add_to_payload ([( \"uploaded_filename\" , uploaded_filename )], payload ) url = self . _parse_url ( f \"/dispute/ { id } \" ) return self . _handle_request ( HTTPMethod . PUT , url , payload )","title":"Disputes"},{"location":"reference/disputes/#pypaystack2.api.disputes.AsyncDispute","text":"Bases: BaseAsyncAPI Provides a wrapper for paystack Disputes API The Disputes API allows you manage transaction disputes on your integration. https://paystack.com/docs/api/#dispute Source code in pypaystack2/api/disputes.py 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 class AsyncDispute ( BaseAsyncAPI ): \"\"\"Provides a wrapper for paystack Disputes API The Disputes API allows you manage transaction disputes on your integration. https://paystack.com/docs/api/#dispute \"\"\" async def get_disputes ( self , start_date : str , end_date : str , pagination : int = 50 , page : int = 1 , transaction : Optional [ str ] = None , status : Optional [ DisputeStatus ] = None , ) -> Response : \"\"\"Fetches disputes filed against you Args: start_date: A timestamp from which to start listing dispute e.g. 2016-09-21 end_date: A timestamp at which to stop listing dispute e.g. 2016-09-21 pagination : Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. page: Specifies exactly what dispute you want to page. If not specified we use a default value of 1. transaction: Transaction ID status: Any of DisputeStatus enum values. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/dispute?perPage= { pagination } \" ) query_params = [ ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ( \"transaction\" , transaction ), ( \"status\" , status ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url ) async def get_dispute ( self , id : str ) -> Response : \"\"\"Get more details about a dispute. Args: id: The dispute ID you want to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/dispute/ { id } \" ) return await self . _handle_request ( HTTPMethod . GET , url ) async def get_transaction_disputes ( self , id : str ) -> Response : \"\"\"This method retrieves disputes for a particular transaction Args: id: The transaction ID you want to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/dispute/transaction/ { id } \" ) return await self . _handle_request ( HTTPMethod . GET , url ) async def update_dispute ( self , id : str , refund_amount : int , uploaded_filename : Optional [ str ] ) -> Response : \"\"\"Update details of a dispute on your integration Args: id: Dispute ID refund_amount: the amount to refund, in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR uploaded_filename: filename of attachment returned via response from upload url(GET /dispute/:id/upload_url) Returns: A named tuple containing the response gotten from paystack's server. \"\"\" refund_amount = validate_amount ( refund_amount ) payload = { \"refund_amount\" : refund_amount } payload = add_to_payload ([( \"uploaded_filename\" , uploaded_filename )], payload ) url = self . _parse_url ( f \"/dispute/ { id } \" ) return await self . _handle_request ( HTTPMethod . PUT , url , payload ) async def add_evidence ( self , id : str , customer_email : str , customer_name : str , customer_phone : str , service_details : str , delivery_address : Optional [ str ] = None , delivery_date : Optional [ str ] = None , ) -> Response : \"\"\"Provide evidence for a dispute Args: id: Dispute ID customer_email: Customer email customer_name: Customer name customer_phone: Customer phone service_details: Details of service involved delivery_address: Delivery Address delivery_date: ISO 8601 representation of delivery date (YYYY-MM-DD) Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"customer_email\" : customer_email , \"customer_name\" : customer_name , \"customer_phone\" : customer_phone , \"service_details\" : service_details , } optional_params = [ ( \"delivery_address\" , delivery_address ), ( \"delivery_date\" , delivery_date ), ] payload = add_to_payload ( optional_params , payload ) url = self . _parse_url ( f \"dispute/ { id } /evidence\" ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) async def get_upload_url ( self , id : str , upload_filename : str ) -> Response : \"\"\"Get URL to upload a dispute evidence. Args: id: Dispute ID upload_filename: The file name, with its extension, that you want to upload. e.g. filename.pdf Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/dispute/ { id } /upload_url?upload_filename= { upload_filename } \" ) return await self . _handle_request ( HTTPMethod . GET , url ) async def resolve_dispute ( self , id : str , resolution : Resolution , message : str , refund_amount : int , uploaded_filename : str , evidence : Optional [ int ] = None , ) -> Response : \"\"\"Resolve a dispute on your integration Args: id: Dispute ID resolution: Any of the Resolution enum value. message: Reason for resolving refund_amount: the amount to refund, in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR uploaded_filename: filename of attachment returned via response from upload url(GET /dispute/:id/upload_url) evidence: Evidence ID for fraud claims Returns: A named tuple containing the response gotten from paystack's server. \"\"\" refund_amount = validate_amount ( refund_amount ) payload = { \"resolution\" : resolution , \"message\" : message , \"refund_amount\" : refund_amount , \"uploaded_filename\" : uploaded_filename , } payload = add_to_payload ([( \"evidence\" , evidence )], payload ) url = self . _parse_url ( f \"/dispute/ { id } /resolve\" ) return await self . _handle_request ( HTTPMethod . PUT , url , payload ) async def export_disputes ( self , start_date : str , end_date : str , pagination : int = 50 , page : int = 1 , transaction : Optional [ str ] = None , status : Optional [ DisputeStatus ] = None , ) -> Response : \"\"\"Export disputes available on your integration. Args: start_date: A timestamp from which to start listing dispute e.g. 2016-09-21 end_date: A timestamp at which to stop listing dispute e.g. 2016-09-21 pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. page: Specifies exactly what dispute you want to page. If not specified we use a default value of 1. transaction: Transaction ID status: Any value from the DisputeStatus enum Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/dispute/export?perPage= { pagination } \" ) query_params = [ ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ( \"transaction\" , transaction ), ( \"status\" , status ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url )","title":"AsyncDispute"},{"location":"reference/disputes/#pypaystack2.api.disputes.AsyncDispute.add_evidence","text":"Provide evidence for a dispute Parameters: Name Type Description Default id str Dispute ID required customer_email str Customer email required customer_name str Customer name required customer_phone str Customer phone required service_details str Details of service involved required delivery_address Optional [ str ] Delivery Address None delivery_date Optional [ str ] ISO 8601 representation of delivery date (YYYY-MM-DD) None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/disputes.py 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 async def add_evidence ( self , id : str , customer_email : str , customer_name : str , customer_phone : str , service_details : str , delivery_address : Optional [ str ] = None , delivery_date : Optional [ str ] = None , ) -> Response : \"\"\"Provide evidence for a dispute Args: id: Dispute ID customer_email: Customer email customer_name: Customer name customer_phone: Customer phone service_details: Details of service involved delivery_address: Delivery Address delivery_date: ISO 8601 representation of delivery date (YYYY-MM-DD) Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"customer_email\" : customer_email , \"customer_name\" : customer_name , \"customer_phone\" : customer_phone , \"service_details\" : service_details , } optional_params = [ ( \"delivery_address\" , delivery_address ), ( \"delivery_date\" , delivery_date ), ] payload = add_to_payload ( optional_params , payload ) url = self . _parse_url ( f \"dispute/ { id } /evidence\" ) return await self . _handle_request ( HTTPMethod . POST , url , payload )","title":"add_evidence()"},{"location":"reference/disputes/#pypaystack2.api.disputes.AsyncDispute.export_disputes","text":"Export disputes available on your integration. Parameters: Name Type Description Default start_date str A timestamp from which to start listing dispute e.g. 2016-09-21 required end_date str A timestamp at which to stop listing dispute e.g. 2016-09-21 required pagination int Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. 50 page int Specifies exactly what dispute you want to page. If not specified we use a default value of 1. 1 transaction Optional [ str ] Transaction ID None status Optional [ DisputeStatus ] Any value from the DisputeStatus enum None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/disputes.py 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 async def export_disputes ( self , start_date : str , end_date : str , pagination : int = 50 , page : int = 1 , transaction : Optional [ str ] = None , status : Optional [ DisputeStatus ] = None , ) -> Response : \"\"\"Export disputes available on your integration. Args: start_date: A timestamp from which to start listing dispute e.g. 2016-09-21 end_date: A timestamp at which to stop listing dispute e.g. 2016-09-21 pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. page: Specifies exactly what dispute you want to page. If not specified we use a default value of 1. transaction: Transaction ID status: Any value from the DisputeStatus enum Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/dispute/export?perPage= { pagination } \" ) query_params = [ ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ( \"transaction\" , transaction ), ( \"status\" , status ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url )","title":"export_disputes()"},{"location":"reference/disputes/#pypaystack2.api.disputes.AsyncDispute.get_dispute","text":"Get more details about a dispute. Parameters: Name Type Description Default id str The dispute ID you want to fetch required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/disputes.py 274 275 276 277 278 279 280 281 282 283 284 285 async def get_dispute ( self , id : str ) -> Response : \"\"\"Get more details about a dispute. Args: id: The dispute ID you want to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/dispute/ { id } \" ) return await self . _handle_request ( HTTPMethod . GET , url )","title":"get_dispute()"},{"location":"reference/disputes/#pypaystack2.api.disputes.AsyncDispute.get_disputes","text":"Fetches disputes filed against you Parameters: Name Type Description Default start_date str A timestamp from which to start listing dispute e.g. 2016-09-21 required end_date str A timestamp at which to stop listing dispute e.g. 2016-09-21 required pagination Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. 50 page int Specifies exactly what dispute you want to page. If not specified we use a default value of 1. 1 transaction Optional [ str ] Transaction ID None status Optional [ DisputeStatus ] Any of DisputeStatus enum values. None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/disputes.py 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 async def get_disputes ( self , start_date : str , end_date : str , pagination : int = 50 , page : int = 1 , transaction : Optional [ str ] = None , status : Optional [ DisputeStatus ] = None , ) -> Response : \"\"\"Fetches disputes filed against you Args: start_date: A timestamp from which to start listing dispute e.g. 2016-09-21 end_date: A timestamp at which to stop listing dispute e.g. 2016-09-21 pagination : Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. page: Specifies exactly what dispute you want to page. If not specified we use a default value of 1. transaction: Transaction ID status: Any of DisputeStatus enum values. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/dispute?perPage= { pagination } \" ) query_params = [ ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ( \"transaction\" , transaction ), ( \"status\" , status ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url )","title":"get_disputes()"},{"location":"reference/disputes/#pypaystack2.api.disputes.AsyncDispute.get_transaction_disputes","text":"This method retrieves disputes for a particular transaction Parameters: Name Type Description Default id str The transaction ID you want to fetch required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/disputes.py 287 288 289 290 291 292 293 294 295 296 297 298 async def get_transaction_disputes ( self , id : str ) -> Response : \"\"\"This method retrieves disputes for a particular transaction Args: id: The transaction ID you want to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/dispute/transaction/ { id } \" ) return await self . _handle_request ( HTTPMethod . GET , url )","title":"get_transaction_disputes()"},{"location":"reference/disputes/#pypaystack2.api.disputes.AsyncDispute.get_upload_url","text":"Get URL to upload a dispute evidence. Parameters: Name Type Description Default id str Dispute ID required upload_filename str The file name, with its extension, that you want to upload. e.g. filename.pdf required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/disputes.py 360 361 362 363 364 365 366 367 368 369 370 371 372 373 async def get_upload_url ( self , id : str , upload_filename : str ) -> Response : \"\"\"Get URL to upload a dispute evidence. Args: id: Dispute ID upload_filename: The file name, with its extension, that you want to upload. e.g. filename.pdf Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/dispute/ { id } /upload_url?upload_filename= { upload_filename } \" ) return await self . _handle_request ( HTTPMethod . GET , url )","title":"get_upload_url()"},{"location":"reference/disputes/#pypaystack2.api.disputes.AsyncDispute.resolve_dispute","text":"Resolve a dispute on your integration Parameters: Name Type Description Default id str Dispute ID required resolution Resolution Any of the Resolution enum value. required message str Reason for resolving required refund_amount int the amount to refund, in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR required uploaded_filename str filename of attachment returned via response from upload url(GET /dispute/:id/upload_url) required evidence Optional [ int ] Evidence ID for fraud claims None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/disputes.py 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 async def resolve_dispute ( self , id : str , resolution : Resolution , message : str , refund_amount : int , uploaded_filename : str , evidence : Optional [ int ] = None , ) -> Response : \"\"\"Resolve a dispute on your integration Args: id: Dispute ID resolution: Any of the Resolution enum value. message: Reason for resolving refund_amount: the amount to refund, in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR uploaded_filename: filename of attachment returned via response from upload url(GET /dispute/:id/upload_url) evidence: Evidence ID for fraud claims Returns: A named tuple containing the response gotten from paystack's server. \"\"\" refund_amount = validate_amount ( refund_amount ) payload = { \"resolution\" : resolution , \"message\" : message , \"refund_amount\" : refund_amount , \"uploaded_filename\" : uploaded_filename , } payload = add_to_payload ([( \"evidence\" , evidence )], payload ) url = self . _parse_url ( f \"/dispute/ { id } /resolve\" ) return await self . _handle_request ( HTTPMethod . PUT , url , payload )","title":"resolve_dispute()"},{"location":"reference/disputes/#pypaystack2.api.disputes.AsyncDispute.update_dispute","text":"Update details of a dispute on your integration Parameters: Name Type Description Default id str Dispute ID required refund_amount int the amount to refund, in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR required uploaded_filename Optional [ str ] filename of attachment returned via response from upload url(GET /dispute/:id/upload_url) required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/disputes.py 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 async def update_dispute ( self , id : str , refund_amount : int , uploaded_filename : Optional [ str ] ) -> Response : \"\"\"Update details of a dispute on your integration Args: id: Dispute ID refund_amount: the amount to refund, in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR uploaded_filename: filename of attachment returned via response from upload url(GET /dispute/:id/upload_url) Returns: A named tuple containing the response gotten from paystack's server. \"\"\" refund_amount = validate_amount ( refund_amount ) payload = { \"refund_amount\" : refund_amount } payload = add_to_payload ([( \"uploaded_filename\" , uploaded_filename )], payload ) url = self . _parse_url ( f \"/dispute/ { id } \" ) return await self . _handle_request ( HTTPMethod . PUT , url , payload )","title":"update_dispute()"},{"location":"reference/disputes/#pypaystack2.api.disputes.Dispute","text":"Bases: BaseAPI Provides a wrapper for paystack Disputes API The Disputes API allows you manage transaction disputes on your integration. https://paystack.com/docs/api/#dispute Source code in pypaystack2/api/disputes.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 class Dispute ( BaseAPI ): \"\"\"Provides a wrapper for paystack Disputes API The Disputes API allows you manage transaction disputes on your integration. https://paystack.com/docs/api/#dispute \"\"\" def get_disputes ( self , start_date : str , end_date : str , pagination : int = 50 , page : int = 1 , transaction : Optional [ str ] = None , status : Optional [ DisputeStatus ] = None , ) -> Response : \"\"\"Fetches disputes filed against you Args: start_date: A timestamp from which to start listing dispute e.g. 2016-09-21 end_date: A timestamp at which to stop listing dispute e.g. 2016-09-21 pagination : Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. page: Specifies exactly what dispute you want to page. If not specified we use a default value of 1. transaction: Transaction ID status: Any of DisputeStatus enum values. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/dispute?perPage= { pagination } \" ) query_params = [ ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ( \"transaction\" , transaction ), ( \"status\" , status ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url ) def get_dispute ( self , id : str ) -> Response : \"\"\"Get more details about a dispute. Args: id: The dispute ID you want to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/dispute/ { id } \" ) return self . _handle_request ( HTTPMethod . GET , url ) def get_transaction_disputes ( self , id : str ) -> Response : \"\"\"This method retrieves disputes for a particular transaction Args: id: The transaction ID you want to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/dispute/transaction/ { id } \" ) return self . _handle_request ( HTTPMethod . GET , url ) def update_dispute ( self , id : str , refund_amount : int , uploaded_filename : Optional [ str ] ) -> Response : \"\"\"Update details of a dispute on your integration Args: id: Dispute ID refund_amount: the amount to refund, in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR uploaded_filename: filename of attachment returned via response from upload url(GET /dispute/:id/upload_url) Returns: A named tuple containing the response gotten from paystack's server. \"\"\" refund_amount = validate_amount ( refund_amount ) payload = { \"refund_amount\" : refund_amount } payload = add_to_payload ([( \"uploaded_filename\" , uploaded_filename )], payload ) url = self . _parse_url ( f \"/dispute/ { id } \" ) return self . _handle_request ( HTTPMethod . PUT , url , payload ) def add_evidence ( self , id : str , customer_email : str , customer_name : str , customer_phone : str , service_details : str , delivery_address : Optional [ str ] = None , delivery_date : Optional [ str ] = None , ) -> Response : \"\"\"Provide evidence for a dispute Args: id: Dispute ID customer_email: Customer email customer_name: Customer name customer_phone: Customer phone service_details: Details of service involved delivery_address: Delivery Address delivery_date: ISO 8601 representation of delivery date (YYYY-MM-DD) Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"customer_email\" : customer_email , \"customer_name\" : customer_name , \"customer_phone\" : customer_phone , \"service_details\" : service_details , } optional_params = [ ( \"delivery_address\" , delivery_address ), ( \"delivery_date\" , delivery_date ), ] payload = add_to_payload ( optional_params , payload ) url = self . _parse_url ( f \"dispute/ { id } /evidence\" ) return self . _handle_request ( HTTPMethod . POST , url , payload ) def get_upload_url ( self , id : str , upload_filename : str ) -> Response : \"\"\"Get URL to upload a dispute evidence. Args: id: Dispute ID upload_filename: The file name, with its extension, that you want to upload. e.g. filename.pdf Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/dispute/ { id } /upload_url?upload_filename= { upload_filename } \" ) return self . _handle_request ( HTTPMethod . GET , url ) def resolve_dispute ( self , id : str , resolution : Resolution , message : str , refund_amount : int , uploaded_filename : str , evidence : Optional [ int ] = None , ) -> Response : \"\"\"Resolve a dispute on your integration Args: id: Dispute ID resolution: Any of the Resolution enum value. message: Reason for resolving refund_amount: the amount to refund, in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR uploaded_filename: filename of attachment returned via response from upload url(GET /dispute/:id/upload_url) evidence: Evidence ID for fraud claims Returns: A named tuple containing the response gotten from paystack's server. \"\"\" refund_amount = validate_amount ( refund_amount ) payload = { \"resolution\" : resolution , \"message\" : message , \"refund_amount\" : refund_amount , \"uploaded_filename\" : uploaded_filename , } payload = add_to_payload ([( \"evidence\" , evidence )], payload ) url = self . _parse_url ( f \"/dispute/ { id } /resolve\" ) return self . _handle_request ( HTTPMethod . PUT , url , payload ) def export_disputes ( self , start_date : str , end_date : str , pagination : int = 50 , page : int = 1 , transaction : Optional [ str ] = None , status : Optional [ DisputeStatus ] = None , ) -> Response : \"\"\"Export disputes available on your integration. Args: start_date: A timestamp from which to start listing dispute e.g. 2016-09-21 end_date: A timestamp at which to stop listing dispute e.g. 2016-09-21 pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. page: Specifies exactly what dispute you want to page. If not specified we use a default value of 1. transaction: Transaction ID status: Any value from the DisputeStatus enum Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/dispute/export?perPage= { pagination } \" ) query_params = [ ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ( \"transaction\" , transaction ), ( \"status\" , status ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url )","title":"Dispute"},{"location":"reference/disputes/#pypaystack2.api.disputes.Dispute.add_evidence","text":"Provide evidence for a dispute Parameters: Name Type Description Default id str Dispute ID required customer_email str Customer email required customer_name str Customer name required customer_phone str Customer phone required service_details str Details of service involved required delivery_address Optional [ str ] Delivery Address None delivery_date Optional [ str ] ISO 8601 representation of delivery date (YYYY-MM-DD) None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/disputes.py 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 def add_evidence ( self , id : str , customer_email : str , customer_name : str , customer_phone : str , service_details : str , delivery_address : Optional [ str ] = None , delivery_date : Optional [ str ] = None , ) -> Response : \"\"\"Provide evidence for a dispute Args: id: Dispute ID customer_email: Customer email customer_name: Customer name customer_phone: Customer phone service_details: Details of service involved delivery_address: Delivery Address delivery_date: ISO 8601 representation of delivery date (YYYY-MM-DD) Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"customer_email\" : customer_email , \"customer_name\" : customer_name , \"customer_phone\" : customer_phone , \"service_details\" : service_details , } optional_params = [ ( \"delivery_address\" , delivery_address ), ( \"delivery_date\" , delivery_date ), ] payload = add_to_payload ( optional_params , payload ) url = self . _parse_url ( f \"dispute/ { id } /evidence\" ) return self . _handle_request ( HTTPMethod . POST , url , payload )","title":"add_evidence()"},{"location":"reference/disputes/#pypaystack2.api.disputes.Dispute.export_disputes","text":"Export disputes available on your integration. Parameters: Name Type Description Default start_date str A timestamp from which to start listing dispute e.g. 2016-09-21 required end_date str A timestamp at which to stop listing dispute e.g. 2016-09-21 required pagination int Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. 50 page int Specifies exactly what dispute you want to page. If not specified we use a default value of 1. 1 transaction Optional [ str ] Transaction ID None status Optional [ DisputeStatus ] Any value from the DisputeStatus enum None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/disputes.py 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 def export_disputes ( self , start_date : str , end_date : str , pagination : int = 50 , page : int = 1 , transaction : Optional [ str ] = None , status : Optional [ DisputeStatus ] = None , ) -> Response : \"\"\"Export disputes available on your integration. Args: start_date: A timestamp from which to start listing dispute e.g. 2016-09-21 end_date: A timestamp at which to stop listing dispute e.g. 2016-09-21 pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. page: Specifies exactly what dispute you want to page. If not specified we use a default value of 1. transaction: Transaction ID status: Any value from the DisputeStatus enum Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/dispute/export?perPage= { pagination } \" ) query_params = [ ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ( \"transaction\" , transaction ), ( \"status\" , status ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url )","title":"export_disputes()"},{"location":"reference/disputes/#pypaystack2.api.disputes.Dispute.get_dispute","text":"Get more details about a dispute. Parameters: Name Type Description Default id str The dispute ID you want to fetch required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/disputes.py 58 59 60 61 62 63 64 65 66 67 68 69 def get_dispute ( self , id : str ) -> Response : \"\"\"Get more details about a dispute. Args: id: The dispute ID you want to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/dispute/ { id } \" ) return self . _handle_request ( HTTPMethod . GET , url )","title":"get_dispute()"},{"location":"reference/disputes/#pypaystack2.api.disputes.Dispute.get_disputes","text":"Fetches disputes filed against you Parameters: Name Type Description Default start_date str A timestamp from which to start listing dispute e.g. 2016-09-21 required end_date str A timestamp at which to stop listing dispute e.g. 2016-09-21 required pagination Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. 50 page int Specifies exactly what dispute you want to page. If not specified we use a default value of 1. 1 transaction Optional [ str ] Transaction ID None status Optional [ DisputeStatus ] Any of DisputeStatus enum values. None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/disputes.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 def get_disputes ( self , start_date : str , end_date : str , pagination : int = 50 , page : int = 1 , transaction : Optional [ str ] = None , status : Optional [ DisputeStatus ] = None , ) -> Response : \"\"\"Fetches disputes filed against you Args: start_date: A timestamp from which to start listing dispute e.g. 2016-09-21 end_date: A timestamp at which to stop listing dispute e.g. 2016-09-21 pagination : Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. page: Specifies exactly what dispute you want to page. If not specified we use a default value of 1. transaction: Transaction ID status: Any of DisputeStatus enum values. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/dispute?perPage= { pagination } \" ) query_params = [ ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ( \"transaction\" , transaction ), ( \"status\" , status ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url )","title":"get_disputes()"},{"location":"reference/disputes/#pypaystack2.api.disputes.Dispute.get_transaction_disputes","text":"This method retrieves disputes for a particular transaction Parameters: Name Type Description Default id str The transaction ID you want to fetch required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/disputes.py 71 72 73 74 75 76 77 78 79 80 81 82 def get_transaction_disputes ( self , id : str ) -> Response : \"\"\"This method retrieves disputes for a particular transaction Args: id: The transaction ID you want to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/dispute/transaction/ { id } \" ) return self . _handle_request ( HTTPMethod . GET , url )","title":"get_transaction_disputes()"},{"location":"reference/disputes/#pypaystack2.api.disputes.Dispute.get_upload_url","text":"Get URL to upload a dispute evidence. Parameters: Name Type Description Default id str Dispute ID required upload_filename str The file name, with its extension, that you want to upload. e.g. filename.pdf required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/disputes.py 144 145 146 147 148 149 150 151 152 153 154 155 156 157 def get_upload_url ( self , id : str , upload_filename : str ) -> Response : \"\"\"Get URL to upload a dispute evidence. Args: id: Dispute ID upload_filename: The file name, with its extension, that you want to upload. e.g. filename.pdf Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/dispute/ { id } /upload_url?upload_filename= { upload_filename } \" ) return self . _handle_request ( HTTPMethod . GET , url )","title":"get_upload_url()"},{"location":"reference/disputes/#pypaystack2.api.disputes.Dispute.resolve_dispute","text":"Resolve a dispute on your integration Parameters: Name Type Description Default id str Dispute ID required resolution Resolution Any of the Resolution enum value. required message str Reason for resolving required refund_amount int the amount to refund, in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR required uploaded_filename str filename of attachment returned via response from upload url(GET /dispute/:id/upload_url) required evidence Optional [ int ] Evidence ID for fraud claims None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/disputes.py 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 def resolve_dispute ( self , id : str , resolution : Resolution , message : str , refund_amount : int , uploaded_filename : str , evidence : Optional [ int ] = None , ) -> Response : \"\"\"Resolve a dispute on your integration Args: id: Dispute ID resolution: Any of the Resolution enum value. message: Reason for resolving refund_amount: the amount to refund, in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR uploaded_filename: filename of attachment returned via response from upload url(GET /dispute/:id/upload_url) evidence: Evidence ID for fraud claims Returns: A named tuple containing the response gotten from paystack's server. \"\"\" refund_amount = validate_amount ( refund_amount ) payload = { \"resolution\" : resolution , \"message\" : message , \"refund_amount\" : refund_amount , \"uploaded_filename\" : uploaded_filename , } payload = add_to_payload ([( \"evidence\" , evidence )], payload ) url = self . _parse_url ( f \"/dispute/ { id } /resolve\" ) return self . _handle_request ( HTTPMethod . PUT , url , payload )","title":"resolve_dispute()"},{"location":"reference/disputes/#pypaystack2.api.disputes.Dispute.update_dispute","text":"Update details of a dispute on your integration Parameters: Name Type Description Default id str Dispute ID required refund_amount int the amount to refund, in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR required uploaded_filename Optional [ str ] filename of attachment returned via response from upload url(GET /dispute/:id/upload_url) required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/disputes.py 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 def update_dispute ( self , id : str , refund_amount : int , uploaded_filename : Optional [ str ] ) -> Response : \"\"\"Update details of a dispute on your integration Args: id: Dispute ID refund_amount: the amount to refund, in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR uploaded_filename: filename of attachment returned via response from upload url(GET /dispute/:id/upload_url) Returns: A named tuple containing the response gotten from paystack's server. \"\"\" refund_amount = validate_amount ( refund_amount ) payload = { \"refund_amount\" : refund_amount } payload = add_to_payload ([( \"uploaded_filename\" , uploaded_filename )], payload ) url = self . _parse_url ( f \"/dispute/ { id } \" ) return self . _handle_request ( HTTPMethod . PUT , url , payload )","title":"update_dispute()"},{"location":"reference/integration/","text":"AsyncIntegration Bases: BaseAsyncAPI Provides a wrapper for paystack Integration API The Integration API allows you to manage some settings on your integration. https://paystack.com/docs/api/#control-panel Source code in pypaystack2/api/integration.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 class AsyncIntegration ( BaseAsyncAPI ): \"\"\"Provides a wrapper for paystack Integration API The Integration API allows you to manage some settings on your integration. https://paystack.com/docs/api/#control-panel \"\"\" async def get_payment_session_timeout ( self ) -> Response : \"\"\"Fetch the payment session timeout on your integration Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/integration/payment_session_timeout\" ) return await self . _handle_request ( HTTPMethod . GET , url ) async def update_payment_session_timeout ( self , timeout : int ) -> Response : \"\"\"Update the payment session timeout on your integration Args: timeout: Time before stopping session (in seconds). Set to 0 to cancel session timeouts Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"timeout\" : timeout } url = self . _parse_url ( \"/integration/payment_session_timeout\" ) return await self . _handle_request ( HTTPMethod . PUT , url , payload ) get_payment_session_timeout () async Fetch the payment session timeout on your integration Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/integration.py 44 45 46 47 48 49 50 51 52 async def get_payment_session_timeout ( self ) -> Response : \"\"\"Fetch the payment session timeout on your integration Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/integration/payment_session_timeout\" ) return await self . _handle_request ( HTTPMethod . GET , url ) update_payment_session_timeout ( timeout ) async Update the payment session timeout on your integration Parameters: Name Type Description Default timeout int Time before stopping session (in seconds). Set to 0 to cancel session timeouts required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/integration.py 54 55 56 57 58 59 60 61 62 63 64 65 66 async def update_payment_session_timeout ( self , timeout : int ) -> Response : \"\"\"Update the payment session timeout on your integration Args: timeout: Time before stopping session (in seconds). Set to 0 to cancel session timeouts Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"timeout\" : timeout } url = self . _parse_url ( \"/integration/payment_session_timeout\" ) return await self . _handle_request ( HTTPMethod . PUT , url , payload ) Integration Bases: BaseAPI Provides a wrapper for paystack Integration API The Integration API allows you to manage some settings on your integration. https://paystack.com/docs/api/#control-panel Source code in pypaystack2/api/integration.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Integration ( BaseAPI ): \"\"\"Provides a wrapper for paystack Integration API The Integration API allows you to manage some settings on your integration. https://paystack.com/docs/api/#control-panel \"\"\" def get_payment_session_timeout ( self ) -> Response : \"\"\"Fetch the payment session timeout on your integration Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/integration/payment_session_timeout\" ) return self . _handle_request ( HTTPMethod . GET , url ) def update_payment_session_timeout ( self , timeout : int ) -> Response : \"\"\"Update the payment session timeout on your integration Args: timeout: Time before stopping session (in seconds). Set to 0 to cancel session timeouts Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"timeout\" : timeout } url = self . _parse_url ( \"/integration/payment_session_timeout\" ) return self . _handle_request ( HTTPMethod . PUT , url , payload ) get_payment_session_timeout () Fetch the payment session timeout on your integration Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/integration.py 12 13 14 15 16 17 18 19 20 def get_payment_session_timeout ( self ) -> Response : \"\"\"Fetch the payment session timeout on your integration Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/integration/payment_session_timeout\" ) return self . _handle_request ( HTTPMethod . GET , url ) update_payment_session_timeout ( timeout ) Update the payment session timeout on your integration Parameters: Name Type Description Default timeout int Time before stopping session (in seconds). Set to 0 to cancel session timeouts required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/integration.py 22 23 24 25 26 27 28 29 30 31 32 33 34 def update_payment_session_timeout ( self , timeout : int ) -> Response : \"\"\"Update the payment session timeout on your integration Args: timeout: Time before stopping session (in seconds). Set to 0 to cancel session timeouts Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"timeout\" : timeout } url = self . _parse_url ( \"/integration/payment_session_timeout\" ) return self . _handle_request ( HTTPMethod . PUT , url , payload )","title":"Integration"},{"location":"reference/integration/#pypaystack2.api.integration.AsyncIntegration","text":"Bases: BaseAsyncAPI Provides a wrapper for paystack Integration API The Integration API allows you to manage some settings on your integration. https://paystack.com/docs/api/#control-panel Source code in pypaystack2/api/integration.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 class AsyncIntegration ( BaseAsyncAPI ): \"\"\"Provides a wrapper for paystack Integration API The Integration API allows you to manage some settings on your integration. https://paystack.com/docs/api/#control-panel \"\"\" async def get_payment_session_timeout ( self ) -> Response : \"\"\"Fetch the payment session timeout on your integration Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/integration/payment_session_timeout\" ) return await self . _handle_request ( HTTPMethod . GET , url ) async def update_payment_session_timeout ( self , timeout : int ) -> Response : \"\"\"Update the payment session timeout on your integration Args: timeout: Time before stopping session (in seconds). Set to 0 to cancel session timeouts Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"timeout\" : timeout } url = self . _parse_url ( \"/integration/payment_session_timeout\" ) return await self . _handle_request ( HTTPMethod . PUT , url , payload )","title":"AsyncIntegration"},{"location":"reference/integration/#pypaystack2.api.integration.AsyncIntegration.get_payment_session_timeout","text":"Fetch the payment session timeout on your integration Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/integration.py 44 45 46 47 48 49 50 51 52 async def get_payment_session_timeout ( self ) -> Response : \"\"\"Fetch the payment session timeout on your integration Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/integration/payment_session_timeout\" ) return await self . _handle_request ( HTTPMethod . GET , url )","title":"get_payment_session_timeout()"},{"location":"reference/integration/#pypaystack2.api.integration.AsyncIntegration.update_payment_session_timeout","text":"Update the payment session timeout on your integration Parameters: Name Type Description Default timeout int Time before stopping session (in seconds). Set to 0 to cancel session timeouts required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/integration.py 54 55 56 57 58 59 60 61 62 63 64 65 66 async def update_payment_session_timeout ( self , timeout : int ) -> Response : \"\"\"Update the payment session timeout on your integration Args: timeout: Time before stopping session (in seconds). Set to 0 to cancel session timeouts Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"timeout\" : timeout } url = self . _parse_url ( \"/integration/payment_session_timeout\" ) return await self . _handle_request ( HTTPMethod . PUT , url , payload )","title":"update_payment_session_timeout()"},{"location":"reference/integration/#pypaystack2.api.integration.Integration","text":"Bases: BaseAPI Provides a wrapper for paystack Integration API The Integration API allows you to manage some settings on your integration. https://paystack.com/docs/api/#control-panel Source code in pypaystack2/api/integration.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Integration ( BaseAPI ): \"\"\"Provides a wrapper for paystack Integration API The Integration API allows you to manage some settings on your integration. https://paystack.com/docs/api/#control-panel \"\"\" def get_payment_session_timeout ( self ) -> Response : \"\"\"Fetch the payment session timeout on your integration Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/integration/payment_session_timeout\" ) return self . _handle_request ( HTTPMethod . GET , url ) def update_payment_session_timeout ( self , timeout : int ) -> Response : \"\"\"Update the payment session timeout on your integration Args: timeout: Time before stopping session (in seconds). Set to 0 to cancel session timeouts Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"timeout\" : timeout } url = self . _parse_url ( \"/integration/payment_session_timeout\" ) return self . _handle_request ( HTTPMethod . PUT , url , payload )","title":"Integration"},{"location":"reference/integration/#pypaystack2.api.integration.Integration.get_payment_session_timeout","text":"Fetch the payment session timeout on your integration Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/integration.py 12 13 14 15 16 17 18 19 20 def get_payment_session_timeout ( self ) -> Response : \"\"\"Fetch the payment session timeout on your integration Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/integration/payment_session_timeout\" ) return self . _handle_request ( HTTPMethod . GET , url )","title":"get_payment_session_timeout()"},{"location":"reference/integration/#pypaystack2.api.integration.Integration.update_payment_session_timeout","text":"Update the payment session timeout on your integration Parameters: Name Type Description Default timeout int Time before stopping session (in seconds). Set to 0 to cancel session timeouts required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/integration.py 22 23 24 25 26 27 28 29 30 31 32 33 34 def update_payment_session_timeout ( self , timeout : int ) -> Response : \"\"\"Update the payment session timeout on your integration Args: timeout: Time before stopping session (in seconds). Set to 0 to cancel session timeouts Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"timeout\" : timeout } url = self . _parse_url ( \"/integration/payment_session_timeout\" ) return self . _handle_request ( HTTPMethod . PUT , url , payload )","title":"update_payment_session_timeout()"},{"location":"reference/miscellaneous/","text":"AsyncMiscellaneous Bases: BaseAsyncAPI Provides a wrapper for paystack Miscellaneous API The Miscellaneous API are supporting APIs that can be used to provide more details to other APIs. https://paystack.com/docs/api/#miscellaneous Source code in pypaystack2/api/miscellaneous.py 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 class AsyncMiscellaneous ( BaseAsyncAPI ): \"\"\"Provides a wrapper for paystack Miscellaneous API The Miscellaneous API are supporting APIs that can be used to provide more details to other APIs. https://paystack.com/docs/api/#miscellaneous \"\"\" async def get_banks ( self , country : Country , use_cursor : bool = False , next : Optional [ str ] = None , previous : Optional [ str ] = None , gateway : Optional [ Gateway ] = None , type : Optional [ BankType ] = None , currency : Optional [ Currency ] = None , pagination : int = 50 , ) -> Response : \"\"\"Get a list of all supported banks and their properties Args: country: The country from which to obtain the list of supported banks. any value from the ``Country`` enum. use_cursor: Flag to enable cursor pagination. next: A cursor that indicates your place in the list. It can be used to fetch the next page of the list previous: A cursor that indicates your place in the list. It should be used to fetch the previous page of the list after an intial next request gateway: The gateway type of the bank. Any value from the ``Gateway`` enum. type: Type of financial channel. For Ghanaian channels, please use either mobile_money for mobile money channels OR ghipps for bank channels currency: Any value from the Currency enum. pagination: The number of objects to return per page. Defaults to 50, and limited to 100 records per page. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" country = Country . get_full ( country ) url = self . _parse_url ( f \"/bank?perPage= { pagination } \" ) query_params = [ ( \"country\" , country ), ( \"use_cursor\" , use_cursor ), ( \"next\" , next ), ( \"previous\" , previous ), ( \"gateway\" , gateway ), ( \"type\" , type ), ( \"currency\" , currency ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url ) async def get_providers ( self , pay_with_bank_transfer : bool = False , ) -> Response : \"\"\"Get a list of all providers for Dedicated Virtual Account Args: pay_with_bank_transfer: A flag to filter for available providers Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/bank?pay_with_bank_transfer= { pay_with_bank_transfer } \" ) return await self . _handle_request ( HTTPMethod . GET , url ) async def get_countries ( self ) -> Response : \"\"\"Gets a list of Countries that Paystack currently supports Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/country\" ) return await self . _handle_request ( HTTPMethod . GET , url ) async def get_states ( self , country : Country ) -> Response : \"\"\"Get a list of states for a country for address verification. Args: country: Any value from the country enum. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/address_verification/states?country= { country } \" ) return await self . _handle_request ( HTTPMethod . GET , url ) get_banks ( country , use_cursor = False , next = None , previous = None , gateway = None , type = None , currency = None , pagination = 50 ) async Get a list of all supported banks and their properties Parameters: Name Type Description Default country Country The country from which to obtain the list of supported banks. any value from the Country enum. required use_cursor bool Flag to enable cursor pagination. False next Optional [ str ] A cursor that indicates your place in the list. It can be used to fetch the next page of the list None previous Optional [ str ] A cursor that indicates your place in the list. It should be used to fetch the previous page of the list after an intial next request None gateway Optional [ Gateway ] The gateway type of the bank. Any value from the Gateway enum. None type Optional [ BankType ] Type of financial channel. For Ghanaian channels, please use either mobile_money for mobile money channels OR ghipps for bank channels None currency Optional [ Currency ] Any value from the Currency enum. None pagination int The number of objects to return per page. Defaults to 50, and limited to 100 records per page. 50 Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/miscellaneous.py 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 async def get_banks ( self , country : Country , use_cursor : bool = False , next : Optional [ str ] = None , previous : Optional [ str ] = None , gateway : Optional [ Gateway ] = None , type : Optional [ BankType ] = None , currency : Optional [ Currency ] = None , pagination : int = 50 , ) -> Response : \"\"\"Get a list of all supported banks and their properties Args: country: The country from which to obtain the list of supported banks. any value from the ``Country`` enum. use_cursor: Flag to enable cursor pagination. next: A cursor that indicates your place in the list. It can be used to fetch the next page of the list previous: A cursor that indicates your place in the list. It should be used to fetch the previous page of the list after an intial next request gateway: The gateway type of the bank. Any value from the ``Gateway`` enum. type: Type of financial channel. For Ghanaian channels, please use either mobile_money for mobile money channels OR ghipps for bank channels currency: Any value from the Currency enum. pagination: The number of objects to return per page. Defaults to 50, and limited to 100 records per page. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" country = Country . get_full ( country ) url = self . _parse_url ( f \"/bank?perPage= { pagination } \" ) query_params = [ ( \"country\" , country ), ( \"use_cursor\" , use_cursor ), ( \"next\" , next ), ( \"previous\" , previous ), ( \"gateway\" , gateway ), ( \"type\" , type ), ( \"currency\" , currency ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url ) get_countries () async Gets a list of Countries that Paystack currently supports Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/miscellaneous.py 171 172 173 174 175 176 177 178 179 async def get_countries ( self ) -> Response : \"\"\"Gets a list of Countries that Paystack currently supports Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/country\" ) return await self . _handle_request ( HTTPMethod . GET , url ) get_providers ( pay_with_bank_transfer = False ) async Get a list of all providers for Dedicated Virtual Account Parameters: Name Type Description Default pay_with_bank_transfer bool A flag to filter for available providers False Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/miscellaneous.py 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 async def get_providers ( self , pay_with_bank_transfer : bool = False , ) -> Response : \"\"\"Get a list of all providers for Dedicated Virtual Account Args: pay_with_bank_transfer: A flag to filter for available providers Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/bank?pay_with_bank_transfer= { pay_with_bank_transfer } \" ) return await self . _handle_request ( HTTPMethod . GET , url ) get_states ( country ) async Get a list of states for a country for address verification. Parameters: Name Type Description Default country Country Any value from the country enum. required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/miscellaneous.py 181 182 183 184 185 186 187 188 189 190 191 192 async def get_states ( self , country : Country ) -> Response : \"\"\"Get a list of states for a country for address verification. Args: country: Any value from the country enum. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/address_verification/states?country= { country } \" ) return await self . _handle_request ( HTTPMethod . GET , url ) Miscellaneous Bases: BaseAPI Provides a wrapper for paystack Miscellaneous API The Miscellaneous API are supporting APIs that can be used to provide more details to other APIs. https://paystack.com/docs/api/#miscellaneous Source code in pypaystack2/api/miscellaneous.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 class Miscellaneous ( BaseAPI ): \"\"\"Provides a wrapper for paystack Miscellaneous API The Miscellaneous API are supporting APIs that can be used to provide more details to other APIs. https://paystack.com/docs/api/#miscellaneous \"\"\" def get_banks ( self , country : Country , use_cursor : bool = False , next : Optional [ str ] = None , previous : Optional [ str ] = None , gateway : Optional [ Gateway ] = None , type : Optional [ BankType ] = None , currency : Optional [ Currency ] = None , pagination : int = 50 , ) -> Response : \"\"\"Get a list of all supported banks and their properties Args: country: The country from which to obtain the list of supported banks. any value from the ``Country`` enum. use_cursor: Flag to enable cursor pagination. next: A cursor that indicates your place in the list. It can be used to fetch the next page of the list previous: A cursor that indicates your place in the list. It should be used to fetch the previous page of the list after an intial next request gateway: The gateway type of the bank. Any value from the ``Gateway`` enum. type: Type of financial channel. For Ghanaian channels, please use either mobile_money for mobile money channels OR ghipps for bank channels currency: Any value from the Currency enum. pagination: The number of objects to return per page. Defaults to 50, and limited to 100 records per page. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" country = Country . get_full ( country ) url = self . _parse_url ( f \"/bank?perPage= { pagination } \" ) query_params = [ ( \"country\" , country ), ( \"use_cursor\" , use_cursor ), ( \"next\" , next ), ( \"previous\" , previous ), ( \"gateway\" , gateway ), ( \"type\" , type ), ( \"currency\" , currency ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url ) def get_providers ( self , pay_with_bank_transfer : bool = False , ) -> Response : \"\"\"Get a list of all providers for Dedicated Virtual Account Args: pay_with_bank_transfer: A flag to filter for available providers Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/bank?pay_with_bank_transfer= { pay_with_bank_transfer } \" ) return self . _handle_request ( HTTPMethod . GET , url ) def get_countries ( self ) -> Response : \"\"\"Gets a list of Countries that Paystack currently supports Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/country\" ) return self . _handle_request ( HTTPMethod . GET , url ) def get_states ( self , country : Country ) -> Response : \"\"\"Get a list of states for a country for address verification. Args: country: Any value from the country enum. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/address_verification/states?country= { country } \" ) return self . _handle_request ( HTTPMethod . GET , url ) get_banks ( country , use_cursor = False , next = None , previous = None , gateway = None , type = None , currency = None , pagination = 50 ) Get a list of all supported banks and their properties Parameters: Name Type Description Default country Country The country from which to obtain the list of supported banks. any value from the Country enum. required use_cursor bool Flag to enable cursor pagination. False next Optional [ str ] A cursor that indicates your place in the list. It can be used to fetch the next page of the list None previous Optional [ str ] A cursor that indicates your place in the list. It should be used to fetch the previous page of the list after an intial next request None gateway Optional [ Gateway ] The gateway type of the bank. Any value from the Gateway enum. None type Optional [ BankType ] Type of financial channel. For Ghanaian channels, please use either mobile_money for mobile money channels OR ghipps for bank channels None currency Optional [ Currency ] Any value from the Currency enum. None pagination int The number of objects to return per page. Defaults to 50, and limited to 100 records per page. 50 Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/miscellaneous.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 def get_banks ( self , country : Country , use_cursor : bool = False , next : Optional [ str ] = None , previous : Optional [ str ] = None , gateway : Optional [ Gateway ] = None , type : Optional [ BankType ] = None , currency : Optional [ Currency ] = None , pagination : int = 50 , ) -> Response : \"\"\"Get a list of all supported banks and their properties Args: country: The country from which to obtain the list of supported banks. any value from the ``Country`` enum. use_cursor: Flag to enable cursor pagination. next: A cursor that indicates your place in the list. It can be used to fetch the next page of the list previous: A cursor that indicates your place in the list. It should be used to fetch the previous page of the list after an intial next request gateway: The gateway type of the bank. Any value from the ``Gateway`` enum. type: Type of financial channel. For Ghanaian channels, please use either mobile_money for mobile money channels OR ghipps for bank channels currency: Any value from the Currency enum. pagination: The number of objects to return per page. Defaults to 50, and limited to 100 records per page. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" country = Country . get_full ( country ) url = self . _parse_url ( f \"/bank?perPage= { pagination } \" ) query_params = [ ( \"country\" , country ), ( \"use_cursor\" , use_cursor ), ( \"next\" , next ), ( \"previous\" , previous ), ( \"gateway\" , gateway ), ( \"type\" , type ), ( \"currency\" , currency ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url ) get_countries () Gets a list of Countries that Paystack currently supports Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/miscellaneous.py 81 82 83 84 85 86 87 88 89 def get_countries ( self ) -> Response : \"\"\"Gets a list of Countries that Paystack currently supports Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/country\" ) return self . _handle_request ( HTTPMethod . GET , url ) get_providers ( pay_with_bank_transfer = False ) Get a list of all providers for Dedicated Virtual Account Parameters: Name Type Description Default pay_with_bank_transfer bool A flag to filter for available providers False Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/miscellaneous.py 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 def get_providers ( self , pay_with_bank_transfer : bool = False , ) -> Response : \"\"\"Get a list of all providers for Dedicated Virtual Account Args: pay_with_bank_transfer: A flag to filter for available providers Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/bank?pay_with_bank_transfer= { pay_with_bank_transfer } \" ) return self . _handle_request ( HTTPMethod . GET , url ) get_states ( country ) Get a list of states for a country for address verification. Parameters: Name Type Description Default country Country Any value from the country enum. required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/miscellaneous.py 91 92 93 94 95 96 97 98 99 100 101 102 def get_states ( self , country : Country ) -> Response : \"\"\"Get a list of states for a country for address verification. Args: country: Any value from the country enum. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/address_verification/states?country= { country } \" ) return self . _handle_request ( HTTPMethod . GET , url )","title":"Miscellaneous"},{"location":"reference/miscellaneous/#pypaystack2.api.miscellaneous.AsyncMiscellaneous","text":"Bases: BaseAsyncAPI Provides a wrapper for paystack Miscellaneous API The Miscellaneous API are supporting APIs that can be used to provide more details to other APIs. https://paystack.com/docs/api/#miscellaneous Source code in pypaystack2/api/miscellaneous.py 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 class AsyncMiscellaneous ( BaseAsyncAPI ): \"\"\"Provides a wrapper for paystack Miscellaneous API The Miscellaneous API are supporting APIs that can be used to provide more details to other APIs. https://paystack.com/docs/api/#miscellaneous \"\"\" async def get_banks ( self , country : Country , use_cursor : bool = False , next : Optional [ str ] = None , previous : Optional [ str ] = None , gateway : Optional [ Gateway ] = None , type : Optional [ BankType ] = None , currency : Optional [ Currency ] = None , pagination : int = 50 , ) -> Response : \"\"\"Get a list of all supported banks and their properties Args: country: The country from which to obtain the list of supported banks. any value from the ``Country`` enum. use_cursor: Flag to enable cursor pagination. next: A cursor that indicates your place in the list. It can be used to fetch the next page of the list previous: A cursor that indicates your place in the list. It should be used to fetch the previous page of the list after an intial next request gateway: The gateway type of the bank. Any value from the ``Gateway`` enum. type: Type of financial channel. For Ghanaian channels, please use either mobile_money for mobile money channels OR ghipps for bank channels currency: Any value from the Currency enum. pagination: The number of objects to return per page. Defaults to 50, and limited to 100 records per page. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" country = Country . get_full ( country ) url = self . _parse_url ( f \"/bank?perPage= { pagination } \" ) query_params = [ ( \"country\" , country ), ( \"use_cursor\" , use_cursor ), ( \"next\" , next ), ( \"previous\" , previous ), ( \"gateway\" , gateway ), ( \"type\" , type ), ( \"currency\" , currency ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url ) async def get_providers ( self , pay_with_bank_transfer : bool = False , ) -> Response : \"\"\"Get a list of all providers for Dedicated Virtual Account Args: pay_with_bank_transfer: A flag to filter for available providers Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/bank?pay_with_bank_transfer= { pay_with_bank_transfer } \" ) return await self . _handle_request ( HTTPMethod . GET , url ) async def get_countries ( self ) -> Response : \"\"\"Gets a list of Countries that Paystack currently supports Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/country\" ) return await self . _handle_request ( HTTPMethod . GET , url ) async def get_states ( self , country : Country ) -> Response : \"\"\"Get a list of states for a country for address verification. Args: country: Any value from the country enum. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/address_verification/states?country= { country } \" ) return await self . _handle_request ( HTTPMethod . GET , url )","title":"AsyncMiscellaneous"},{"location":"reference/miscellaneous/#pypaystack2.api.miscellaneous.AsyncMiscellaneous.get_banks","text":"Get a list of all supported banks and their properties Parameters: Name Type Description Default country Country The country from which to obtain the list of supported banks. any value from the Country enum. required use_cursor bool Flag to enable cursor pagination. False next Optional [ str ] A cursor that indicates your place in the list. It can be used to fetch the next page of the list None previous Optional [ str ] A cursor that indicates your place in the list. It should be used to fetch the previous page of the list after an intial next request None gateway Optional [ Gateway ] The gateway type of the bank. Any value from the Gateway enum. None type Optional [ BankType ] Type of financial channel. For Ghanaian channels, please use either mobile_money for mobile money channels OR ghipps for bank channels None currency Optional [ Currency ] Any value from the Currency enum. None pagination int The number of objects to return per page. Defaults to 50, and limited to 100 records per page. 50 Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/miscellaneous.py 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 async def get_banks ( self , country : Country , use_cursor : bool = False , next : Optional [ str ] = None , previous : Optional [ str ] = None , gateway : Optional [ Gateway ] = None , type : Optional [ BankType ] = None , currency : Optional [ Currency ] = None , pagination : int = 50 , ) -> Response : \"\"\"Get a list of all supported banks and their properties Args: country: The country from which to obtain the list of supported banks. any value from the ``Country`` enum. use_cursor: Flag to enable cursor pagination. next: A cursor that indicates your place in the list. It can be used to fetch the next page of the list previous: A cursor that indicates your place in the list. It should be used to fetch the previous page of the list after an intial next request gateway: The gateway type of the bank. Any value from the ``Gateway`` enum. type: Type of financial channel. For Ghanaian channels, please use either mobile_money for mobile money channels OR ghipps for bank channels currency: Any value from the Currency enum. pagination: The number of objects to return per page. Defaults to 50, and limited to 100 records per page. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" country = Country . get_full ( country ) url = self . _parse_url ( f \"/bank?perPage= { pagination } \" ) query_params = [ ( \"country\" , country ), ( \"use_cursor\" , use_cursor ), ( \"next\" , next ), ( \"previous\" , previous ), ( \"gateway\" , gateway ), ( \"type\" , type ), ( \"currency\" , currency ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url )","title":"get_banks()"},{"location":"reference/miscellaneous/#pypaystack2.api.miscellaneous.AsyncMiscellaneous.get_countries","text":"Gets a list of Countries that Paystack currently supports Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/miscellaneous.py 171 172 173 174 175 176 177 178 179 async def get_countries ( self ) -> Response : \"\"\"Gets a list of Countries that Paystack currently supports Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/country\" ) return await self . _handle_request ( HTTPMethod . GET , url )","title":"get_countries()"},{"location":"reference/miscellaneous/#pypaystack2.api.miscellaneous.AsyncMiscellaneous.get_providers","text":"Get a list of all providers for Dedicated Virtual Account Parameters: Name Type Description Default pay_with_bank_transfer bool A flag to filter for available providers False Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/miscellaneous.py 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 async def get_providers ( self , pay_with_bank_transfer : bool = False , ) -> Response : \"\"\"Get a list of all providers for Dedicated Virtual Account Args: pay_with_bank_transfer: A flag to filter for available providers Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/bank?pay_with_bank_transfer= { pay_with_bank_transfer } \" ) return await self . _handle_request ( HTTPMethod . GET , url )","title":"get_providers()"},{"location":"reference/miscellaneous/#pypaystack2.api.miscellaneous.AsyncMiscellaneous.get_states","text":"Get a list of states for a country for address verification. Parameters: Name Type Description Default country Country Any value from the country enum. required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/miscellaneous.py 181 182 183 184 185 186 187 188 189 190 191 192 async def get_states ( self , country : Country ) -> Response : \"\"\"Get a list of states for a country for address verification. Args: country: Any value from the country enum. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/address_verification/states?country= { country } \" ) return await self . _handle_request ( HTTPMethod . GET , url )","title":"get_states()"},{"location":"reference/miscellaneous/#pypaystack2.api.miscellaneous.Miscellaneous","text":"Bases: BaseAPI Provides a wrapper for paystack Miscellaneous API The Miscellaneous API are supporting APIs that can be used to provide more details to other APIs. https://paystack.com/docs/api/#miscellaneous Source code in pypaystack2/api/miscellaneous.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 class Miscellaneous ( BaseAPI ): \"\"\"Provides a wrapper for paystack Miscellaneous API The Miscellaneous API are supporting APIs that can be used to provide more details to other APIs. https://paystack.com/docs/api/#miscellaneous \"\"\" def get_banks ( self , country : Country , use_cursor : bool = False , next : Optional [ str ] = None , previous : Optional [ str ] = None , gateway : Optional [ Gateway ] = None , type : Optional [ BankType ] = None , currency : Optional [ Currency ] = None , pagination : int = 50 , ) -> Response : \"\"\"Get a list of all supported banks and their properties Args: country: The country from which to obtain the list of supported banks. any value from the ``Country`` enum. use_cursor: Flag to enable cursor pagination. next: A cursor that indicates your place in the list. It can be used to fetch the next page of the list previous: A cursor that indicates your place in the list. It should be used to fetch the previous page of the list after an intial next request gateway: The gateway type of the bank. Any value from the ``Gateway`` enum. type: Type of financial channel. For Ghanaian channels, please use either mobile_money for mobile money channels OR ghipps for bank channels currency: Any value from the Currency enum. pagination: The number of objects to return per page. Defaults to 50, and limited to 100 records per page. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" country = Country . get_full ( country ) url = self . _parse_url ( f \"/bank?perPage= { pagination } \" ) query_params = [ ( \"country\" , country ), ( \"use_cursor\" , use_cursor ), ( \"next\" , next ), ( \"previous\" , previous ), ( \"gateway\" , gateway ), ( \"type\" , type ), ( \"currency\" , currency ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url ) def get_providers ( self , pay_with_bank_transfer : bool = False , ) -> Response : \"\"\"Get a list of all providers for Dedicated Virtual Account Args: pay_with_bank_transfer: A flag to filter for available providers Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/bank?pay_with_bank_transfer= { pay_with_bank_transfer } \" ) return self . _handle_request ( HTTPMethod . GET , url ) def get_countries ( self ) -> Response : \"\"\"Gets a list of Countries that Paystack currently supports Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/country\" ) return self . _handle_request ( HTTPMethod . GET , url ) def get_states ( self , country : Country ) -> Response : \"\"\"Get a list of states for a country for address verification. Args: country: Any value from the country enum. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/address_verification/states?country= { country } \" ) return self . _handle_request ( HTTPMethod . GET , url )","title":"Miscellaneous"},{"location":"reference/miscellaneous/#pypaystack2.api.miscellaneous.Miscellaneous.get_banks","text":"Get a list of all supported banks and their properties Parameters: Name Type Description Default country Country The country from which to obtain the list of supported banks. any value from the Country enum. required use_cursor bool Flag to enable cursor pagination. False next Optional [ str ] A cursor that indicates your place in the list. It can be used to fetch the next page of the list None previous Optional [ str ] A cursor that indicates your place in the list. It should be used to fetch the previous page of the list after an intial next request None gateway Optional [ Gateway ] The gateway type of the bank. Any value from the Gateway enum. None type Optional [ BankType ] Type of financial channel. For Ghanaian channels, please use either mobile_money for mobile money channels OR ghipps for bank channels None currency Optional [ Currency ] Any value from the Currency enum. None pagination int The number of objects to return per page. Defaults to 50, and limited to 100 records per page. 50 Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/miscellaneous.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 def get_banks ( self , country : Country , use_cursor : bool = False , next : Optional [ str ] = None , previous : Optional [ str ] = None , gateway : Optional [ Gateway ] = None , type : Optional [ BankType ] = None , currency : Optional [ Currency ] = None , pagination : int = 50 , ) -> Response : \"\"\"Get a list of all supported banks and their properties Args: country: The country from which to obtain the list of supported banks. any value from the ``Country`` enum. use_cursor: Flag to enable cursor pagination. next: A cursor that indicates your place in the list. It can be used to fetch the next page of the list previous: A cursor that indicates your place in the list. It should be used to fetch the previous page of the list after an intial next request gateway: The gateway type of the bank. Any value from the ``Gateway`` enum. type: Type of financial channel. For Ghanaian channels, please use either mobile_money for mobile money channels OR ghipps for bank channels currency: Any value from the Currency enum. pagination: The number of objects to return per page. Defaults to 50, and limited to 100 records per page. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" country = Country . get_full ( country ) url = self . _parse_url ( f \"/bank?perPage= { pagination } \" ) query_params = [ ( \"country\" , country ), ( \"use_cursor\" , use_cursor ), ( \"next\" , next ), ( \"previous\" , previous ), ( \"gateway\" , gateway ), ( \"type\" , type ), ( \"currency\" , currency ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url )","title":"get_banks()"},{"location":"reference/miscellaneous/#pypaystack2.api.miscellaneous.Miscellaneous.get_countries","text":"Gets a list of Countries that Paystack currently supports Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/miscellaneous.py 81 82 83 84 85 86 87 88 89 def get_countries ( self ) -> Response : \"\"\"Gets a list of Countries that Paystack currently supports Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/country\" ) return self . _handle_request ( HTTPMethod . GET , url )","title":"get_countries()"},{"location":"reference/miscellaneous/#pypaystack2.api.miscellaneous.Miscellaneous.get_providers","text":"Get a list of all providers for Dedicated Virtual Account Parameters: Name Type Description Default pay_with_bank_transfer bool A flag to filter for available providers False Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/miscellaneous.py 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 def get_providers ( self , pay_with_bank_transfer : bool = False , ) -> Response : \"\"\"Get a list of all providers for Dedicated Virtual Account Args: pay_with_bank_transfer: A flag to filter for available providers Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/bank?pay_with_bank_transfer= { pay_with_bank_transfer } \" ) return self . _handle_request ( HTTPMethod . GET , url )","title":"get_providers()"},{"location":"reference/miscellaneous/#pypaystack2.api.miscellaneous.Miscellaneous.get_states","text":"Get a list of states for a country for address verification. Parameters: Name Type Description Default country Country Any value from the country enum. required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/miscellaneous.py 91 92 93 94 95 96 97 98 99 100 101 102 def get_states ( self , country : Country ) -> Response : \"\"\"Get a list of states for a country for address verification. Args: country: Any value from the country enum. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/address_verification/states?country= { country } \" ) return self . _handle_request ( HTTPMethod . GET , url )","title":"get_states()"},{"location":"reference/payment_pages/","text":"AsyncPaymentPage Bases: BaseAsyncAPI Provides a wrapper for paystack Payment Pages API The Payment Pages API provides a quick and secure way to collect payment for products. https://paystack.com/docs/api/#page Source code in pypaystack2/api/payment_pages.py 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 class AsyncPaymentPage ( BaseAsyncAPI ): \"\"\"Provides a wrapper for paystack Payment Pages API The Payment Pages API provides a quick and secure way to collect payment for products. https://paystack.com/docs/api/#page \"\"\" async def create ( self , name : str , description : Optional [ str ] = None , amount : Optional [ int ] = None , slug : Optional [ str ] = None , metadata : Optional [ str ] = None , redirect_url : Optional [ str ] = None , custom_fields : Optional [ list ] = None , ) -> Response : \"\"\"Create a payment page on your integration Args: name: Name of page description: A description for this page amount: Amount should be in kobo if currency is ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR`` slug: URL slug you would like to be associated with this page. Page will be accessible at ``https://paystack.com/pay/[slug]`` metadata: Extra data to configure the payment page including subaccount, logo image, transaction charge redirect_url: If you would like Paystack to redirect someplace upon successful payment, specify the URL here. custom_fields: If you would like to accept custom fields, specify them here. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/page\" ) payload = { \"name\" : name } optional_params = [ ( \"description\" , description ), ( \"amount\" , amount ), ( \"slug\" , slug ), ( \"metadata\" , metadata ), ( \"redirect_url\" , redirect_url ), ( \"custom_fields\" , custom_fields ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) async def get_pages ( self , page : int = 1 , pagination : int = 50 , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , ) -> Response : \"\"\"Fetch payment pages available on your integration. Args: page: Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. start_date: A timestamp from which to start listing page e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing page e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/page?perPage=\" + str ( pagination )) query_params = [ ( \"page\" , page ), ( \"start_date\" , start_date ), ( \"end_date\" , end_date ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url ) async def get_page ( self , id_or_slug : str ) -> Response : \"\"\"Get details of a payment page on your integration. Args: id_or_slug: The page ``ID`` or ``slug`` you want to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/page/ { id_or_slug } \" ) return await self . _handle_request ( HTTPMethod . GET , url ) async def update ( self , id_or_slug : str , name : str , description : str , amount : int , active : Optional [ bool ] = None , ) -> Response : \"\"\"Get details of a payment page on your integration. Args: id_or_slug: The page ``ID`` or ``slug`` you want to fetch name: Name of page description: A description for the page amount: Default amount you want to accept using this page. If none is set, customer is free to provide any amount of their choice. The latter scenario is useful for accepting donations active: Set to ``False`` to deactivate page url Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/page/ { id_or_slug } \" ) payload = { \"name\" : name , \"description\" : description , } optional_params = [ ( \"amount\" , amount ), ( \"active\" , active ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . PUT , url , payload ) async def check_slug_available ( self , slug : str ) -> Response : \"\"\"Check the availability of a slug for a payment page. Args: slug: URL slug to be confirmed Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/page/check_slug_availability/ { slug } \" ) return await self . _handle_request ( HTTPMethod . GET , url ) async def add_products ( self , id : str , products : list [ int ]) -> Response : \"\"\"Add products to a payment page Args: id: ID of the payment page products: Ids of all the products Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/page/ { id } /product\" ) payload = { \"product\" : products } return await self . _handle_request ( HTTPMethod . POST , url , payload ) add_products ( id , products ) async Add products to a payment page Parameters: Name Type Description Default id str ID of the payment page required products list [ int ] Ids of all the products required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/payment_pages.py 310 311 312 313 314 315 316 317 318 319 320 321 322 323 async def add_products ( self , id : str , products : list [ int ]) -> Response : \"\"\"Add products to a payment page Args: id: ID of the payment page products: Ids of all the products Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/page/ { id } /product\" ) payload = { \"product\" : products } return await self . _handle_request ( HTTPMethod . POST , url , payload ) check_slug_available ( slug ) async Check the availability of a slug for a payment page. Parameters: Name Type Description Default slug str URL slug to be confirmed required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/payment_pages.py 297 298 299 300 301 302 303 304 305 306 307 308 async def check_slug_available ( self , slug : str ) -> Response : \"\"\"Check the availability of a slug for a payment page. Args: slug: URL slug to be confirmed Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/page/check_slug_availability/ { slug } \" ) return await self . _handle_request ( HTTPMethod . GET , url ) create ( name , description = None , amount = None , slug = None , metadata = None , redirect_url = None , custom_fields = None ) async Create a payment page on your integration Parameters: Name Type Description Default name str Name of page required description Optional [ str ] A description for this page None amount Optional [ int ] Amount should be in kobo if currency is Currency.NGN , pesewas, if currency is Currency.GHS , and cents, if currency is Currency.ZAR None slug Optional [ str ] URL slug you would like to be associated with this page. Page will be accessible at https://paystack.com/pay/[slug] None metadata Optional [ str ] Extra data to configure the payment page including subaccount, logo image, transaction charge None redirect_url Optional [ str ] If you would like Paystack to redirect someplace upon successful payment, specify the URL here. None custom_fields Optional [ list ] If you would like to accept custom fields, specify them here. None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/payment_pages.py 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 async def create ( self , name : str , description : Optional [ str ] = None , amount : Optional [ int ] = None , slug : Optional [ str ] = None , metadata : Optional [ str ] = None , redirect_url : Optional [ str ] = None , custom_fields : Optional [ list ] = None , ) -> Response : \"\"\"Create a payment page on your integration Args: name: Name of page description: A description for this page amount: Amount should be in kobo if currency is ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR`` slug: URL slug you would like to be associated with this page. Page will be accessible at ``https://paystack.com/pay/[slug]`` metadata: Extra data to configure the payment page including subaccount, logo image, transaction charge redirect_url: If you would like Paystack to redirect someplace upon successful payment, specify the URL here. custom_fields: If you would like to accept custom fields, specify them here. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/page\" ) payload = { \"name\" : name } optional_params = [ ( \"description\" , description ), ( \"amount\" , amount ), ( \"slug\" , slug ), ( \"metadata\" , metadata ), ( \"redirect_url\" , redirect_url ), ( \"custom_fields\" , custom_fields ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) get_page ( id_or_slug ) async Get details of a payment page on your integration. Parameters: Name Type Description Default id_or_slug str The page ID or slug you want to fetch required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/payment_pages.py 248 249 250 251 252 253 254 255 256 257 258 259 async def get_page ( self , id_or_slug : str ) -> Response : \"\"\"Get details of a payment page on your integration. Args: id_or_slug: The page ``ID`` or ``slug`` you want to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/page/ { id_or_slug } \" ) return await self . _handle_request ( HTTPMethod . GET , url ) get_pages ( page = 1 , pagination = 50 , start_date = None , end_date = None ) async Fetch payment pages available on your integration. Parameters: Name Type Description Default page int Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. 1 pagination int Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. 50 start_date Optional [ str ] A timestamp from which to start listing page e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None end_date Optional [ str ] A timestamp at which to stop listing page e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/payment_pages.py 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 async def get_pages ( self , page : int = 1 , pagination : int = 50 , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , ) -> Response : \"\"\"Fetch payment pages available on your integration. Args: page: Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. start_date: A timestamp from which to start listing page e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing page e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/page?perPage=\" + str ( pagination )) query_params = [ ( \"page\" , page ), ( \"start_date\" , start_date ), ( \"end_date\" , end_date ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url ) update ( id_or_slug , name , description , amount , active = None ) async Get details of a payment page on your integration. Parameters: Name Type Description Default id_or_slug str The page ID or slug you want to fetch required name str Name of page required description str A description for the page required amount int Default amount you want to accept using this page. If none is set, customer is free to provide any amount of their choice. The latter scenario is useful for accepting donations required active Optional [ bool ] Set to False to deactivate page url None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/payment_pages.py 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 async def update ( self , id_or_slug : str , name : str , description : str , amount : int , active : Optional [ bool ] = None , ) -> Response : \"\"\"Get details of a payment page on your integration. Args: id_or_slug: The page ``ID`` or ``slug`` you want to fetch name: Name of page description: A description for the page amount: Default amount you want to accept using this page. If none is set, customer is free to provide any amount of their choice. The latter scenario is useful for accepting donations active: Set to ``False`` to deactivate page url Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/page/ { id_or_slug } \" ) payload = { \"name\" : name , \"description\" : description , } optional_params = [ ( \"amount\" , amount ), ( \"active\" , active ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . PUT , url , payload ) PaymentPage Bases: BaseAPI Provides a wrapper for paystack Payment Pages API The Payment Pages API provides a quick and secure way to collect payment for products. https://paystack.com/docs/api/#page Source code in pypaystack2/api/payment_pages.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 class PaymentPage ( BaseAPI ): \"\"\"Provides a wrapper for paystack Payment Pages API The Payment Pages API provides a quick and secure way to collect payment for products. https://paystack.com/docs/api/#page \"\"\" def create ( self , name : str , description : Optional [ str ] = None , amount : Optional [ int ] = None , slug : Optional [ str ] = None , metadata : Optional [ str ] = None , redirect_url : Optional [ str ] = None , custom_fields : Optional [ list ] = None , ) -> Response : \"\"\"Create a payment page on your integration Args: name: Name of page description: A description for this page amount: Amount should be in kobo if currency is ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR`` slug: URL slug you would like to be associated with this page. Page will be accessible at ``https://paystack.com/pay/[slug]`` metadata: Extra data to configure the payment page including subaccount, logo image, transaction charge redirect_url: If you would like Paystack to redirect someplace upon successful payment, specify the URL here. custom_fields: If you would like to accept custom fields, specify them here. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/page\" ) payload = { \"name\" : name } optional_params = [ ( \"description\" , description ), ( \"amount\" , amount ), ( \"slug\" , slug ), ( \"metadata\" , metadata ), ( \"redirect_url\" , redirect_url ), ( \"custom_fields\" , custom_fields ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . POST , url , payload ) def get_pages ( self , page : int = 1 , pagination : int = 50 , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , ) -> Response : \"\"\"Fetch payment pages available on your integration. Args: page: Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. start_date: A timestamp from which to start listing page e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing page e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/page?perPage=\" + str ( pagination )) query_params = [ ( \"page\" , page ), ( \"start_date\" , start_date ), ( \"end_date\" , end_date ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url ) def get_page ( self , id_or_slug : str ) -> Response : \"\"\"Get details of a payment page on your integration. Args: id_or_slug: The page ``ID`` or ``slug`` you want to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/page/ { id_or_slug } \" ) return self . _handle_request ( HTTPMethod . GET , url ) def update ( self , id_or_slug : str , name : str , description : str , amount : int , active : Optional [ bool ] = None , ) -> Response : \"\"\"Get details of a payment page on your integration. Args: id_or_slug: The page ``ID`` or ``slug`` you want to fetch name: Name of page description: A description for the page amount: Default amount you want to accept using this page. If none is set, customer is free to provide any amount of their choice. The latter scenario is useful for accepting donations active: Set to ``False`` to deactivate page url Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/page/ { id_or_slug } \" ) payload = { \"name\" : name , \"description\" : description , } optional_params = [ ( \"amount\" , amount ), ( \"active\" , active ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . PUT , url , payload ) def check_slug_available ( self , slug : str ) -> Response : \"\"\"Check the availability of a slug for a payment page. Args: slug: URL slug to be confirmed Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/page/check_slug_availability/ { slug } \" ) return self . _handle_request ( HTTPMethod . GET , url ) def add_products ( self , id : str , products : list [ int ]) -> Response : \"\"\"Add products to a payment page Args: id: ID of the payment page products: Ids of all the products Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/page/ { id } /product\" ) payload = { \"product\" : products } return self . _handle_request ( HTTPMethod . POST , url , payload ) add_products ( id , products ) Add products to a payment page Parameters: Name Type Description Default id str ID of the payment page required products list [ int ] Ids of all the products required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/payment_pages.py 151 152 153 154 155 156 157 158 159 160 161 162 163 164 def add_products ( self , id : str , products : list [ int ]) -> Response : \"\"\"Add products to a payment page Args: id: ID of the payment page products: Ids of all the products Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/page/ { id } /product\" ) payload = { \"product\" : products } return self . _handle_request ( HTTPMethod . POST , url , payload ) check_slug_available ( slug ) Check the availability of a slug for a payment page. Parameters: Name Type Description Default slug str URL slug to be confirmed required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/payment_pages.py 138 139 140 141 142 143 144 145 146 147 148 149 def check_slug_available ( self , slug : str ) -> Response : \"\"\"Check the availability of a slug for a payment page. Args: slug: URL slug to be confirmed Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/page/check_slug_availability/ { slug } \" ) return self . _handle_request ( HTTPMethod . GET , url ) create ( name , description = None , amount = None , slug = None , metadata = None , redirect_url = None , custom_fields = None ) Create a payment page on your integration Parameters: Name Type Description Default name str Name of page required description Optional [ str ] A description for this page None amount Optional [ int ] Amount should be in kobo if currency is Currency.NGN , pesewas, if currency is Currency.GHS , and cents, if currency is Currency.ZAR None slug Optional [ str ] URL slug you would like to be associated with this page. Page will be accessible at https://paystack.com/pay/[slug] None metadata Optional [ str ] Extra data to configure the payment page including subaccount, logo image, transaction charge None redirect_url Optional [ str ] If you would like Paystack to redirect someplace upon successful payment, specify the URL here. None custom_fields Optional [ list ] If you would like to accept custom fields, specify them here. None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/payment_pages.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 def create ( self , name : str , description : Optional [ str ] = None , amount : Optional [ int ] = None , slug : Optional [ str ] = None , metadata : Optional [ str ] = None , redirect_url : Optional [ str ] = None , custom_fields : Optional [ list ] = None , ) -> Response : \"\"\"Create a payment page on your integration Args: name: Name of page description: A description for this page amount: Amount should be in kobo if currency is ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR`` slug: URL slug you would like to be associated with this page. Page will be accessible at ``https://paystack.com/pay/[slug]`` metadata: Extra data to configure the payment page including subaccount, logo image, transaction charge redirect_url: If you would like Paystack to redirect someplace upon successful payment, specify the URL here. custom_fields: If you would like to accept custom fields, specify them here. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/page\" ) payload = { \"name\" : name } optional_params = [ ( \"description\" , description ), ( \"amount\" , amount ), ( \"slug\" , slug ), ( \"metadata\" , metadata ), ( \"redirect_url\" , redirect_url ), ( \"custom_fields\" , custom_fields ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . POST , url , payload ) get_page ( id_or_slug ) Get details of a payment page on your integration. Parameters: Name Type Description Default id_or_slug str The page ID or slug you want to fetch required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/payment_pages.py 89 90 91 92 93 94 95 96 97 98 99 100 def get_page ( self , id_or_slug : str ) -> Response : \"\"\"Get details of a payment page on your integration. Args: id_or_slug: The page ``ID`` or ``slug`` you want to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/page/ { id_or_slug } \" ) return self . _handle_request ( HTTPMethod . GET , url ) get_pages ( page = 1 , pagination = 50 , start_date = None , end_date = None ) Fetch payment pages available on your integration. Parameters: Name Type Description Default page int Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. 1 pagination int Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. 50 start_date Optional [ str ] A timestamp from which to start listing page e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None end_date Optional [ str ] A timestamp at which to stop listing page e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/payment_pages.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def get_pages ( self , page : int = 1 , pagination : int = 50 , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , ) -> Response : \"\"\"Fetch payment pages available on your integration. Args: page: Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. start_date: A timestamp from which to start listing page e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing page e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/page?perPage=\" + str ( pagination )) query_params = [ ( \"page\" , page ), ( \"start_date\" , start_date ), ( \"end_date\" , end_date ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url ) update ( id_or_slug , name , description , amount , active = None ) Get details of a payment page on your integration. Parameters: Name Type Description Default id_or_slug str The page ID or slug you want to fetch required name str Name of page required description str A description for the page required amount int Default amount you want to accept using this page. If none is set, customer is free to provide any amount of their choice. The latter scenario is useful for accepting donations required active Optional [ bool ] Set to False to deactivate page url None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/payment_pages.py 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 def update ( self , id_or_slug : str , name : str , description : str , amount : int , active : Optional [ bool ] = None , ) -> Response : \"\"\"Get details of a payment page on your integration. Args: id_or_slug: The page ``ID`` or ``slug`` you want to fetch name: Name of page description: A description for the page amount: Default amount you want to accept using this page. If none is set, customer is free to provide any amount of their choice. The latter scenario is useful for accepting donations active: Set to ``False`` to deactivate page url Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/page/ { id_or_slug } \" ) payload = { \"name\" : name , \"description\" : description , } optional_params = [ ( \"amount\" , amount ), ( \"active\" , active ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . PUT , url , payload )","title":"Payment pages"},{"location":"reference/payment_pages/#pypaystack2.api.payment_pages.AsyncPaymentPage","text":"Bases: BaseAsyncAPI Provides a wrapper for paystack Payment Pages API The Payment Pages API provides a quick and secure way to collect payment for products. https://paystack.com/docs/api/#page Source code in pypaystack2/api/payment_pages.py 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 class AsyncPaymentPage ( BaseAsyncAPI ): \"\"\"Provides a wrapper for paystack Payment Pages API The Payment Pages API provides a quick and secure way to collect payment for products. https://paystack.com/docs/api/#page \"\"\" async def create ( self , name : str , description : Optional [ str ] = None , amount : Optional [ int ] = None , slug : Optional [ str ] = None , metadata : Optional [ str ] = None , redirect_url : Optional [ str ] = None , custom_fields : Optional [ list ] = None , ) -> Response : \"\"\"Create a payment page on your integration Args: name: Name of page description: A description for this page amount: Amount should be in kobo if currency is ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR`` slug: URL slug you would like to be associated with this page. Page will be accessible at ``https://paystack.com/pay/[slug]`` metadata: Extra data to configure the payment page including subaccount, logo image, transaction charge redirect_url: If you would like Paystack to redirect someplace upon successful payment, specify the URL here. custom_fields: If you would like to accept custom fields, specify them here. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/page\" ) payload = { \"name\" : name } optional_params = [ ( \"description\" , description ), ( \"amount\" , amount ), ( \"slug\" , slug ), ( \"metadata\" , metadata ), ( \"redirect_url\" , redirect_url ), ( \"custom_fields\" , custom_fields ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) async def get_pages ( self , page : int = 1 , pagination : int = 50 , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , ) -> Response : \"\"\"Fetch payment pages available on your integration. Args: page: Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. start_date: A timestamp from which to start listing page e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing page e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/page?perPage=\" + str ( pagination )) query_params = [ ( \"page\" , page ), ( \"start_date\" , start_date ), ( \"end_date\" , end_date ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url ) async def get_page ( self , id_or_slug : str ) -> Response : \"\"\"Get details of a payment page on your integration. Args: id_or_slug: The page ``ID`` or ``slug`` you want to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/page/ { id_or_slug } \" ) return await self . _handle_request ( HTTPMethod . GET , url ) async def update ( self , id_or_slug : str , name : str , description : str , amount : int , active : Optional [ bool ] = None , ) -> Response : \"\"\"Get details of a payment page on your integration. Args: id_or_slug: The page ``ID`` or ``slug`` you want to fetch name: Name of page description: A description for the page amount: Default amount you want to accept using this page. If none is set, customer is free to provide any amount of their choice. The latter scenario is useful for accepting donations active: Set to ``False`` to deactivate page url Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/page/ { id_or_slug } \" ) payload = { \"name\" : name , \"description\" : description , } optional_params = [ ( \"amount\" , amount ), ( \"active\" , active ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . PUT , url , payload ) async def check_slug_available ( self , slug : str ) -> Response : \"\"\"Check the availability of a slug for a payment page. Args: slug: URL slug to be confirmed Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/page/check_slug_availability/ { slug } \" ) return await self . _handle_request ( HTTPMethod . GET , url ) async def add_products ( self , id : str , products : list [ int ]) -> Response : \"\"\"Add products to a payment page Args: id: ID of the payment page products: Ids of all the products Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/page/ { id } /product\" ) payload = { \"product\" : products } return await self . _handle_request ( HTTPMethod . POST , url , payload )","title":"AsyncPaymentPage"},{"location":"reference/payment_pages/#pypaystack2.api.payment_pages.AsyncPaymentPage.add_products","text":"Add products to a payment page Parameters: Name Type Description Default id str ID of the payment page required products list [ int ] Ids of all the products required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/payment_pages.py 310 311 312 313 314 315 316 317 318 319 320 321 322 323 async def add_products ( self , id : str , products : list [ int ]) -> Response : \"\"\"Add products to a payment page Args: id: ID of the payment page products: Ids of all the products Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/page/ { id } /product\" ) payload = { \"product\" : products } return await self . _handle_request ( HTTPMethod . POST , url , payload )","title":"add_products()"},{"location":"reference/payment_pages/#pypaystack2.api.payment_pages.AsyncPaymentPage.check_slug_available","text":"Check the availability of a slug for a payment page. Parameters: Name Type Description Default slug str URL slug to be confirmed required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/payment_pages.py 297 298 299 300 301 302 303 304 305 306 307 308 async def check_slug_available ( self , slug : str ) -> Response : \"\"\"Check the availability of a slug for a payment page. Args: slug: URL slug to be confirmed Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/page/check_slug_availability/ { slug } \" ) return await self . _handle_request ( HTTPMethod . GET , url )","title":"check_slug_available()"},{"location":"reference/payment_pages/#pypaystack2.api.payment_pages.AsyncPaymentPage.create","text":"Create a payment page on your integration Parameters: Name Type Description Default name str Name of page required description Optional [ str ] A description for this page None amount Optional [ int ] Amount should be in kobo if currency is Currency.NGN , pesewas, if currency is Currency.GHS , and cents, if currency is Currency.ZAR None slug Optional [ str ] URL slug you would like to be associated with this page. Page will be accessible at https://paystack.com/pay/[slug] None metadata Optional [ str ] Extra data to configure the payment page including subaccount, logo image, transaction charge None redirect_url Optional [ str ] If you would like Paystack to redirect someplace upon successful payment, specify the URL here. None custom_fields Optional [ list ] If you would like to accept custom fields, specify them here. None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/payment_pages.py 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 async def create ( self , name : str , description : Optional [ str ] = None , amount : Optional [ int ] = None , slug : Optional [ str ] = None , metadata : Optional [ str ] = None , redirect_url : Optional [ str ] = None , custom_fields : Optional [ list ] = None , ) -> Response : \"\"\"Create a payment page on your integration Args: name: Name of page description: A description for this page amount: Amount should be in kobo if currency is ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR`` slug: URL slug you would like to be associated with this page. Page will be accessible at ``https://paystack.com/pay/[slug]`` metadata: Extra data to configure the payment page including subaccount, logo image, transaction charge redirect_url: If you would like Paystack to redirect someplace upon successful payment, specify the URL here. custom_fields: If you would like to accept custom fields, specify them here. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/page\" ) payload = { \"name\" : name } optional_params = [ ( \"description\" , description ), ( \"amount\" , amount ), ( \"slug\" , slug ), ( \"metadata\" , metadata ), ( \"redirect_url\" , redirect_url ), ( \"custom_fields\" , custom_fields ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . POST , url , payload )","title":"create()"},{"location":"reference/payment_pages/#pypaystack2.api.payment_pages.AsyncPaymentPage.get_page","text":"Get details of a payment page on your integration. Parameters: Name Type Description Default id_or_slug str The page ID or slug you want to fetch required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/payment_pages.py 248 249 250 251 252 253 254 255 256 257 258 259 async def get_page ( self , id_or_slug : str ) -> Response : \"\"\"Get details of a payment page on your integration. Args: id_or_slug: The page ``ID`` or ``slug`` you want to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/page/ { id_or_slug } \" ) return await self . _handle_request ( HTTPMethod . GET , url )","title":"get_page()"},{"location":"reference/payment_pages/#pypaystack2.api.payment_pages.AsyncPaymentPage.get_pages","text":"Fetch payment pages available on your integration. Parameters: Name Type Description Default page int Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. 1 pagination int Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. 50 start_date Optional [ str ] A timestamp from which to start listing page e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None end_date Optional [ str ] A timestamp at which to stop listing page e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/payment_pages.py 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 async def get_pages ( self , page : int = 1 , pagination : int = 50 , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , ) -> Response : \"\"\"Fetch payment pages available on your integration. Args: page: Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. start_date: A timestamp from which to start listing page e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing page e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/page?perPage=\" + str ( pagination )) query_params = [ ( \"page\" , page ), ( \"start_date\" , start_date ), ( \"end_date\" , end_date ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url )","title":"get_pages()"},{"location":"reference/payment_pages/#pypaystack2.api.payment_pages.AsyncPaymentPage.update","text":"Get details of a payment page on your integration. Parameters: Name Type Description Default id_or_slug str The page ID or slug you want to fetch required name str Name of page required description str A description for the page required amount int Default amount you want to accept using this page. If none is set, customer is free to provide any amount of their choice. The latter scenario is useful for accepting donations required active Optional [ bool ] Set to False to deactivate page url None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/payment_pages.py 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 async def update ( self , id_or_slug : str , name : str , description : str , amount : int , active : Optional [ bool ] = None , ) -> Response : \"\"\"Get details of a payment page on your integration. Args: id_or_slug: The page ``ID`` or ``slug`` you want to fetch name: Name of page description: A description for the page amount: Default amount you want to accept using this page. If none is set, customer is free to provide any amount of their choice. The latter scenario is useful for accepting donations active: Set to ``False`` to deactivate page url Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/page/ { id_or_slug } \" ) payload = { \"name\" : name , \"description\" : description , } optional_params = [ ( \"amount\" , amount ), ( \"active\" , active ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . PUT , url , payload )","title":"update()"},{"location":"reference/payment_pages/#pypaystack2.api.payment_pages.PaymentPage","text":"Bases: BaseAPI Provides a wrapper for paystack Payment Pages API The Payment Pages API provides a quick and secure way to collect payment for products. https://paystack.com/docs/api/#page Source code in pypaystack2/api/payment_pages.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 class PaymentPage ( BaseAPI ): \"\"\"Provides a wrapper for paystack Payment Pages API The Payment Pages API provides a quick and secure way to collect payment for products. https://paystack.com/docs/api/#page \"\"\" def create ( self , name : str , description : Optional [ str ] = None , amount : Optional [ int ] = None , slug : Optional [ str ] = None , metadata : Optional [ str ] = None , redirect_url : Optional [ str ] = None , custom_fields : Optional [ list ] = None , ) -> Response : \"\"\"Create a payment page on your integration Args: name: Name of page description: A description for this page amount: Amount should be in kobo if currency is ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR`` slug: URL slug you would like to be associated with this page. Page will be accessible at ``https://paystack.com/pay/[slug]`` metadata: Extra data to configure the payment page including subaccount, logo image, transaction charge redirect_url: If you would like Paystack to redirect someplace upon successful payment, specify the URL here. custom_fields: If you would like to accept custom fields, specify them here. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/page\" ) payload = { \"name\" : name } optional_params = [ ( \"description\" , description ), ( \"amount\" , amount ), ( \"slug\" , slug ), ( \"metadata\" , metadata ), ( \"redirect_url\" , redirect_url ), ( \"custom_fields\" , custom_fields ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . POST , url , payload ) def get_pages ( self , page : int = 1 , pagination : int = 50 , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , ) -> Response : \"\"\"Fetch payment pages available on your integration. Args: page: Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. start_date: A timestamp from which to start listing page e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing page e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/page?perPage=\" + str ( pagination )) query_params = [ ( \"page\" , page ), ( \"start_date\" , start_date ), ( \"end_date\" , end_date ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url ) def get_page ( self , id_or_slug : str ) -> Response : \"\"\"Get details of a payment page on your integration. Args: id_or_slug: The page ``ID`` or ``slug`` you want to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/page/ { id_or_slug } \" ) return self . _handle_request ( HTTPMethod . GET , url ) def update ( self , id_or_slug : str , name : str , description : str , amount : int , active : Optional [ bool ] = None , ) -> Response : \"\"\"Get details of a payment page on your integration. Args: id_or_slug: The page ``ID`` or ``slug`` you want to fetch name: Name of page description: A description for the page amount: Default amount you want to accept using this page. If none is set, customer is free to provide any amount of their choice. The latter scenario is useful for accepting donations active: Set to ``False`` to deactivate page url Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/page/ { id_or_slug } \" ) payload = { \"name\" : name , \"description\" : description , } optional_params = [ ( \"amount\" , amount ), ( \"active\" , active ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . PUT , url , payload ) def check_slug_available ( self , slug : str ) -> Response : \"\"\"Check the availability of a slug for a payment page. Args: slug: URL slug to be confirmed Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/page/check_slug_availability/ { slug } \" ) return self . _handle_request ( HTTPMethod . GET , url ) def add_products ( self , id : str , products : list [ int ]) -> Response : \"\"\"Add products to a payment page Args: id: ID of the payment page products: Ids of all the products Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/page/ { id } /product\" ) payload = { \"product\" : products } return self . _handle_request ( HTTPMethod . POST , url , payload )","title":"PaymentPage"},{"location":"reference/payment_pages/#pypaystack2.api.payment_pages.PaymentPage.add_products","text":"Add products to a payment page Parameters: Name Type Description Default id str ID of the payment page required products list [ int ] Ids of all the products required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/payment_pages.py 151 152 153 154 155 156 157 158 159 160 161 162 163 164 def add_products ( self , id : str , products : list [ int ]) -> Response : \"\"\"Add products to a payment page Args: id: ID of the payment page products: Ids of all the products Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/page/ { id } /product\" ) payload = { \"product\" : products } return self . _handle_request ( HTTPMethod . POST , url , payload )","title":"add_products()"},{"location":"reference/payment_pages/#pypaystack2.api.payment_pages.PaymentPage.check_slug_available","text":"Check the availability of a slug for a payment page. Parameters: Name Type Description Default slug str URL slug to be confirmed required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/payment_pages.py 138 139 140 141 142 143 144 145 146 147 148 149 def check_slug_available ( self , slug : str ) -> Response : \"\"\"Check the availability of a slug for a payment page. Args: slug: URL slug to be confirmed Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/page/check_slug_availability/ { slug } \" ) return self . _handle_request ( HTTPMethod . GET , url )","title":"check_slug_available()"},{"location":"reference/payment_pages/#pypaystack2.api.payment_pages.PaymentPage.create","text":"Create a payment page on your integration Parameters: Name Type Description Default name str Name of page required description Optional [ str ] A description for this page None amount Optional [ int ] Amount should be in kobo if currency is Currency.NGN , pesewas, if currency is Currency.GHS , and cents, if currency is Currency.ZAR None slug Optional [ str ] URL slug you would like to be associated with this page. Page will be accessible at https://paystack.com/pay/[slug] None metadata Optional [ str ] Extra data to configure the payment page including subaccount, logo image, transaction charge None redirect_url Optional [ str ] If you would like Paystack to redirect someplace upon successful payment, specify the URL here. None custom_fields Optional [ list ] If you would like to accept custom fields, specify them here. None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/payment_pages.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 def create ( self , name : str , description : Optional [ str ] = None , amount : Optional [ int ] = None , slug : Optional [ str ] = None , metadata : Optional [ str ] = None , redirect_url : Optional [ str ] = None , custom_fields : Optional [ list ] = None , ) -> Response : \"\"\"Create a payment page on your integration Args: name: Name of page description: A description for this page amount: Amount should be in kobo if currency is ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR`` slug: URL slug you would like to be associated with this page. Page will be accessible at ``https://paystack.com/pay/[slug]`` metadata: Extra data to configure the payment page including subaccount, logo image, transaction charge redirect_url: If you would like Paystack to redirect someplace upon successful payment, specify the URL here. custom_fields: If you would like to accept custom fields, specify them here. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/page\" ) payload = { \"name\" : name } optional_params = [ ( \"description\" , description ), ( \"amount\" , amount ), ( \"slug\" , slug ), ( \"metadata\" , metadata ), ( \"redirect_url\" , redirect_url ), ( \"custom_fields\" , custom_fields ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . POST , url , payload )","title":"create()"},{"location":"reference/payment_pages/#pypaystack2.api.payment_pages.PaymentPage.get_page","text":"Get details of a payment page on your integration. Parameters: Name Type Description Default id_or_slug str The page ID or slug you want to fetch required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/payment_pages.py 89 90 91 92 93 94 95 96 97 98 99 100 def get_page ( self , id_or_slug : str ) -> Response : \"\"\"Get details of a payment page on your integration. Args: id_or_slug: The page ``ID`` or ``slug`` you want to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/page/ { id_or_slug } \" ) return self . _handle_request ( HTTPMethod . GET , url )","title":"get_page()"},{"location":"reference/payment_pages/#pypaystack2.api.payment_pages.PaymentPage.get_pages","text":"Fetch payment pages available on your integration. Parameters: Name Type Description Default page int Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. 1 pagination int Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. 50 start_date Optional [ str ] A timestamp from which to start listing page e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None end_date Optional [ str ] A timestamp at which to stop listing page e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/payment_pages.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def get_pages ( self , page : int = 1 , pagination : int = 50 , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , ) -> Response : \"\"\"Fetch payment pages available on your integration. Args: page: Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. start_date: A timestamp from which to start listing page e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing page e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/page?perPage=\" + str ( pagination )) query_params = [ ( \"page\" , page ), ( \"start_date\" , start_date ), ( \"end_date\" , end_date ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url )","title":"get_pages()"},{"location":"reference/payment_pages/#pypaystack2.api.payment_pages.PaymentPage.update","text":"Get details of a payment page on your integration. Parameters: Name Type Description Default id_or_slug str The page ID or slug you want to fetch required name str Name of page required description str A description for the page required amount int Default amount you want to accept using this page. If none is set, customer is free to provide any amount of their choice. The latter scenario is useful for accepting donations required active Optional [ bool ] Set to False to deactivate page url None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/payment_pages.py 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 def update ( self , id_or_slug : str , name : str , description : str , amount : int , active : Optional [ bool ] = None , ) -> Response : \"\"\"Get details of a payment page on your integration. Args: id_or_slug: The page ``ID`` or ``slug`` you want to fetch name: Name of page description: A description for the page amount: Default amount you want to accept using this page. If none is set, customer is free to provide any amount of their choice. The latter scenario is useful for accepting donations active: Set to ``False`` to deactivate page url Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/page/ { id_or_slug } \" ) payload = { \"name\" : name , \"description\" : description , } optional_params = [ ( \"amount\" , amount ), ( \"active\" , active ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . PUT , url , payload )","title":"update()"},{"location":"reference/payment_requests/","text":"AsyncPaymentRequest Bases: BaseAsyncAPI Provides a wrapper for paystack Payment Requests API The Payment Requests API allows you to manage requests for payment of goods and services. https://paystack.com/docs/api/payment-request/ Source code in pypaystack2/api/payment_requests.py 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 class AsyncPaymentRequest ( BaseAsyncAPI ): \"\"\"Provides a wrapper for paystack Payment Requests API The Payment Requests API allows you to manage requests for payment of goods and services. https://paystack.com/docs/api/payment-request/ \"\"\" async def create ( self , customer : str , amount : int , due_date : Optional [ str ] = None , description : Optional [ str ] = None , line_items : Optional [ list [ LineItem ]] = None , tax : Optional [ list [ Tax ]] = None , currency : Optional [ Currency ] = None , send_notification : Optional [ bool ] = None , draft : Optional [ bool ] = None , has_invoice : Optional [ bool ] = None , invoice_number : Optional [ int ] = None , split_code : Optional [ str ] = None , ) -> Response : \"\"\"Create a payment request for a transaction on your integration Args: customer: Customer id or code amount: Payment request amount. It should be used when line items and tax values aren't specified. due_date: ISO 8601 representation of request due date description: A short description of the payment request line_items: List of line items int the format [{\"name\":\"item 1\", \"amount\":2000, \"quantity\": 1}] tax: List of taxes to be charged in the format [{\"name\":\"VAT\", \"amount\":2000}] currency: Any value from Currency enum. default ``Currency.NGN`` send_notification: Indicates whether Paystack sends an email notification to customer. Defaults to ``True`` draft: Indicate if request should be saved as draft. Defaults to ``False`` and overrides send_notification has_invoice: Set to ``True`` to create a draft invoice (adds an auto incrementing invoice number if none is provided) even if there are no line_items or tax passed invoice_number: Numeric value of invoice. Invoice will start from 1 and auto increment from there. This field is to help override whatever value Paystack decides. Auto increment for subsequent invoices continue from this point. split_code: The split code of the transaction split. e.g. SPL_98WF13Eb3w Returns: A named tuple containing the response gotten from paystack's server. \"\"\" if line_items : line_items = [ item . dict for item in line_items ] if tax : tax = [ unit_tax . dict for unit_tax in tax ] url = self . _parse_url ( \"/paymentrequest\" ) payload = { \"customer\" : customer , \"amount\" : amount } optional_params = [ ( \"due_date\" , due_date ), ( \"description\" , description ), ( \"line_items\" , line_items ), ( \"tax\" , tax ), ( \"currency\" , currency ), ( \"send_notification\" , send_notification ), ( \"draft\" , draft ), ( \"has_invoice\" , has_invoice ), ( \"invoice_number\" , invoice_number ), ( \"split_code\" , split_code ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) async def get_payment_requests ( self , customer : Optional [ str ] = None , status : Optional [ Status ] = None , currency : Optional [ Currency ] = None , include_archive : bool = False , page : int = 1 , pagination : int = 50 , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , ) -> Response : \"\"\"Fetches the payment requests available on your integration. Args: customer: Filter by customer ID status: Filter by payment request status. Any value from enum of ``Status`` currency: Filter by currency. Any value from enum of ``Currency`` include_archive: Show archived payment requests. page: Specify exactly what payment request you want to page. If not specify we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. start_date: A timestamp from which to start listing payment request e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing payment request e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/paymentrequest?perPage= { pagination } \" ) query_params = [ ( \"customer\" , customer ), ( \"status\" , status ), ( \"currency\" , currency ), ( \"include_archive\" , include_archive ), ( \"page\" , page ), ( \"start_date\" , start_date ), ( \"end_date\" , end_date ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url ) async def get_payment_request ( self , id_or_code : str ) -> Response : \"\"\"Get details of a payment request on your integration. Args: id_or_code: Payment Request id or code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/paymentrequest/ { id_or_code } \" ) return await self . _handle_request ( HTTPMethod . GET , url ) async def verify ( self , code : str ) -> Response : \"\"\"Verify details of a payment request on your integration. Args: code: Payment Request id or code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/paymentrequest/verify/ { code } \" ) return await self . _handle_request ( HTTPMethod . GET , url ) async def send_notification ( self , id_or_code : str ) -> Response : \"\"\"Send notification of a payment request to your customers Args: id_or_code: Payment Request id or code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/paymentrequest/notify/ { id_or_code } \" ) return await self . _handle_request ( HTTPMethod . POST , url ) async def get_total ( self ) -> Response : \"\"\"Get payment requests metric Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/paymentrequest/totals\" ) return await self . _handle_request ( HTTPMethod . GET , url ) async def finalize ( self , id_or_code : str ) -> Response : \"\"\"Finalize a draft payment request Args: id_or_code: Payment Request id or code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/paymentrequest/finalize/ { id_or_code } \" ) return await self . _handle_request ( HTTPMethod . POST , url ) async def update ( self , id_or_code : str , customer : str , amount : int , due_date : Optional [ str ] = None , description : Optional [ str ] = None , line_items : Optional [ list [ dict ]] = None , tax : Optional [ list [ dict ]] = None , currency : Optional [ Currency ] = None , send_notification : Optional [ bool ] = None , draft : Optional [ bool ] = None , invoice_number : Optional [ int ] = None , split_code : Optional [ str ] = None , ) -> Response : \"\"\"Update a payment request details on your integration Args: id_or_code: Payment Request id or code customer: Customer id or code amount: Payment request amount. Only useful if line items and tax values are ignored. method will throw a friendly warning in the response if neither is available. due_date: ISO 8601 representation of request due date description: A short description of the payment request line_items: List of line items in the format [{\"name\":\"item 1\", \"amount\":2000}] tax: List of taxes to be charged in the format [{\"name\":\"VAT\", \"amount\":2000}] currency: Specify the currency of the payment request. Any value from the ``Currency`` enum send_notification: Indicates whether Paystack sends an email notification to customer. Defaults to ``True`` draft: Indicate if request should be saved as draft. Defaults to false and overrides send_notification invoice_number: Numeric value of invoice. Invoice will start from 1 and auto increment from there. This field is to help override whatever value Paystack decides. Auto increment for subsequent invoices continue from this point. split_code: The split code of the transaction split. e.g. SPL_98WF13Eb3w Returns: A named tuple containing the response gotten from paystack's server. \"\"\" amount = validate_amount ( amount ) url = self . _parse_url ( f \"/paymentrequest/ { id_or_code } \" ) payload = { \"customer\" : customer , \"amount\" : amount , } optional_params = [ ( \"due_date\" , due_date ), ( \"description\" , description ), ( \"line_items\" , line_items ), ( \"tax\" , tax ), ( \"currency\" , currency ), ( \"send_notification\" , send_notification ), ( \"draft\" , draft ), ( \"invoice_number\" , invoice_number ), ( \"split_code\" , split_code ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . PUT , url , payload ) async def archive ( self , id_or_code : str ) -> Response : \"\"\"Used to archive a payment request. A payment request will no longer be fetched on list or returned on verify. Args: id_or_code: Payment Request id or code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/paymentrequest/archive/ { id_or_code } \" ) return await self . _handle_request ( HTTPMethod . POST , url ) archive ( id_or_code ) async Used to archive a payment request. A payment request will no longer be fetched on list or returned on verify. Parameters: Name Type Description Default id_or_code str Payment Request id or code required Returns: A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/payment_requests.py 492 493 494 495 496 497 498 499 500 501 502 503 async def archive ( self , id_or_code : str ) -> Response : \"\"\"Used to archive a payment request. A payment request will no longer be fetched on list or returned on verify. Args: id_or_code: Payment Request id or code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/paymentrequest/archive/ { id_or_code } \" ) return await self . _handle_request ( HTTPMethod . POST , url ) create ( customer , amount , due_date = None , description = None , line_items = None , tax = None , currency = None , send_notification = None , draft = None , has_invoice = None , invoice_number = None , split_code = None ) async Create a payment request for a transaction on your integration Parameters: Name Type Description Default customer str Customer id or code required amount int Payment request amount. It should be used when line items and tax values aren't specified. required due_date Optional [ str ] ISO 8601 representation of request due date None description Optional [ str ] A short description of the payment request None line_items Optional [ list [ LineItem ]] List of line items int the format [{\"name\":\"item 1\", \"amount\":2000, \"quantity\": 1}] None tax Optional [ list [ Tax ]] List of taxes to be charged in the format [{\"name\":\"VAT\", \"amount\":2000}] None currency Optional [ Currency ] Any value from Currency enum. default Currency.NGN None send_notification Optional [ bool ] Indicates whether Paystack sends an email notification to customer. Defaults to True None draft Optional [ bool ] Indicate if request should be saved as draft. Defaults to False and overrides send_notification None has_invoice Optional [ bool ] Set to True to create a draft invoice (adds an auto incrementing invoice number if none is provided) even if there are no line_items or tax passed None invoice_number Optional [ int ] Numeric value of invoice. Invoice will start from 1 and auto increment from there. This field is to help override whatever value Paystack decides. Auto increment for subsequent invoices continue from this point. None split_code Optional [ str ] The split code of the transaction split. e.g. SPL_98WF13Eb3w None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/payment_requests.py 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 async def create ( self , customer : str , amount : int , due_date : Optional [ str ] = None , description : Optional [ str ] = None , line_items : Optional [ list [ LineItem ]] = None , tax : Optional [ list [ Tax ]] = None , currency : Optional [ Currency ] = None , send_notification : Optional [ bool ] = None , draft : Optional [ bool ] = None , has_invoice : Optional [ bool ] = None , invoice_number : Optional [ int ] = None , split_code : Optional [ str ] = None , ) -> Response : \"\"\"Create a payment request for a transaction on your integration Args: customer: Customer id or code amount: Payment request amount. It should be used when line items and tax values aren't specified. due_date: ISO 8601 representation of request due date description: A short description of the payment request line_items: List of line items int the format [{\"name\":\"item 1\", \"amount\":2000, \"quantity\": 1}] tax: List of taxes to be charged in the format [{\"name\":\"VAT\", \"amount\":2000}] currency: Any value from Currency enum. default ``Currency.NGN`` send_notification: Indicates whether Paystack sends an email notification to customer. Defaults to ``True`` draft: Indicate if request should be saved as draft. Defaults to ``False`` and overrides send_notification has_invoice: Set to ``True`` to create a draft invoice (adds an auto incrementing invoice number if none is provided) even if there are no line_items or tax passed invoice_number: Numeric value of invoice. Invoice will start from 1 and auto increment from there. This field is to help override whatever value Paystack decides. Auto increment for subsequent invoices continue from this point. split_code: The split code of the transaction split. e.g. SPL_98WF13Eb3w Returns: A named tuple containing the response gotten from paystack's server. \"\"\" if line_items : line_items = [ item . dict for item in line_items ] if tax : tax = [ unit_tax . dict for unit_tax in tax ] url = self . _parse_url ( \"/paymentrequest\" ) payload = { \"customer\" : customer , \"amount\" : amount } optional_params = [ ( \"due_date\" , due_date ), ( \"description\" , description ), ( \"line_items\" , line_items ), ( \"tax\" , tax ), ( \"currency\" , currency ), ( \"send_notification\" , send_notification ), ( \"draft\" , draft ), ( \"has_invoice\" , has_invoice ), ( \"invoice_number\" , invoice_number ), ( \"split_code\" , split_code ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) finalize ( id_or_code ) async Finalize a draft payment request Parameters: Name Type Description Default id_or_code str Payment Request id or code required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/payment_requests.py 420 421 422 423 424 425 426 427 428 429 430 431 async def finalize ( self , id_or_code : str ) -> Response : \"\"\"Finalize a draft payment request Args: id_or_code: Payment Request id or code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/paymentrequest/finalize/ { id_or_code } \" ) return await self . _handle_request ( HTTPMethod . POST , url ) get_payment_request ( id_or_code ) async Get details of a payment request on your integration. Parameters: Name Type Description Default id_or_code str Payment Request id or code required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/payment_requests.py 371 372 373 374 375 376 377 378 379 380 381 382 async def get_payment_request ( self , id_or_code : str ) -> Response : \"\"\"Get details of a payment request on your integration. Args: id_or_code: Payment Request id or code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/paymentrequest/ { id_or_code } \" ) return await self . _handle_request ( HTTPMethod . GET , url ) get_payment_requests ( customer = None , status = None , currency = None , include_archive = False , page = 1 , pagination = 50 , start_date = None , end_date = None ) async Fetches the payment requests available on your integration. Parameters: Name Type Description Default customer Optional [ str ] Filter by customer ID None status Optional [ Status ] Filter by payment request status. Any value from enum of Status None currency Optional [ Currency ] Filter by currency. Any value from enum of Currency None include_archive bool Show archived payment requests. False page int Specify exactly what payment request you want to page. If not specify we use a default value of 1. 1 pagination int Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. 50 start_date Optional [ str ] A timestamp from which to start listing payment request e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None end_date Optional [ str ] A timestamp at which to stop listing payment request e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/payment_requests.py 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 async def get_payment_requests ( self , customer : Optional [ str ] = None , status : Optional [ Status ] = None , currency : Optional [ Currency ] = None , include_archive : bool = False , page : int = 1 , pagination : int = 50 , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , ) -> Response : \"\"\"Fetches the payment requests available on your integration. Args: customer: Filter by customer ID status: Filter by payment request status. Any value from enum of ``Status`` currency: Filter by currency. Any value from enum of ``Currency`` include_archive: Show archived payment requests. page: Specify exactly what payment request you want to page. If not specify we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. start_date: A timestamp from which to start listing payment request e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing payment request e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/paymentrequest?perPage= { pagination } \" ) query_params = [ ( \"customer\" , customer ), ( \"status\" , status ), ( \"currency\" , currency ), ( \"include_archive\" , include_archive ), ( \"page\" , page ), ( \"start_date\" , start_date ), ( \"end_date\" , end_date ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url ) get_total () async Get payment requests metric Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/payment_requests.py 410 411 412 413 414 415 416 417 418 async def get_total ( self ) -> Response : \"\"\"Get payment requests metric Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/paymentrequest/totals\" ) return await self . _handle_request ( HTTPMethod . GET , url ) send_notification ( id_or_code ) async Send notification of a payment request to your customers Parameters: Name Type Description Default id_or_code str Payment Request id or code required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/payment_requests.py 397 398 399 400 401 402 403 404 405 406 407 408 async def send_notification ( self , id_or_code : str ) -> Response : \"\"\"Send notification of a payment request to your customers Args: id_or_code: Payment Request id or code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/paymentrequest/notify/ { id_or_code } \" ) return await self . _handle_request ( HTTPMethod . POST , url ) update ( id_or_code , customer , amount , due_date = None , description = None , line_items = None , tax = None , currency = None , send_notification = None , draft = None , invoice_number = None , split_code = None ) async Update a payment request details on your integration Parameters: Name Type Description Default id_or_code str Payment Request id or code required customer str Customer id or code required amount int Payment request amount. Only useful if line items and tax values are ignored. method will throw a friendly warning in the response if neither is available. required due_date Optional [ str ] ISO 8601 representation of request due date None description Optional [ str ] A short description of the payment request None line_items Optional [ list [ dict ]] List of line items in the format [{\"name\":\"item 1\", \"amount\":2000}] None tax Optional [ list [ dict ]] List of taxes to be charged in the format [{\"name\":\"VAT\", \"amount\":2000}] None currency Optional [ Currency ] Specify the currency of the payment request. Any value from the Currency enum None send_notification Optional [ bool ] Indicates whether Paystack sends an email notification to customer. Defaults to True None draft Optional [ bool ] Indicate if request should be saved as draft. Defaults to false and overrides send_notification None invoice_number Optional [ int ] Numeric value of invoice. Invoice will start from 1 and auto increment from there. This field is to help override whatever value Paystack decides. Auto increment for subsequent invoices continue from this point. None split_code Optional [ str ] The split code of the transaction split. e.g. SPL_98WF13Eb3w None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/payment_requests.py 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 async def update ( self , id_or_code : str , customer : str , amount : int , due_date : Optional [ str ] = None , description : Optional [ str ] = None , line_items : Optional [ list [ dict ]] = None , tax : Optional [ list [ dict ]] = None , currency : Optional [ Currency ] = None , send_notification : Optional [ bool ] = None , draft : Optional [ bool ] = None , invoice_number : Optional [ int ] = None , split_code : Optional [ str ] = None , ) -> Response : \"\"\"Update a payment request details on your integration Args: id_or_code: Payment Request id or code customer: Customer id or code amount: Payment request amount. Only useful if line items and tax values are ignored. method will throw a friendly warning in the response if neither is available. due_date: ISO 8601 representation of request due date description: A short description of the payment request line_items: List of line items in the format [{\"name\":\"item 1\", \"amount\":2000}] tax: List of taxes to be charged in the format [{\"name\":\"VAT\", \"amount\":2000}] currency: Specify the currency of the payment request. Any value from the ``Currency`` enum send_notification: Indicates whether Paystack sends an email notification to customer. Defaults to ``True`` draft: Indicate if request should be saved as draft. Defaults to false and overrides send_notification invoice_number: Numeric value of invoice. Invoice will start from 1 and auto increment from there. This field is to help override whatever value Paystack decides. Auto increment for subsequent invoices continue from this point. split_code: The split code of the transaction split. e.g. SPL_98WF13Eb3w Returns: A named tuple containing the response gotten from paystack's server. \"\"\" amount = validate_amount ( amount ) url = self . _parse_url ( f \"/paymentrequest/ { id_or_code } \" ) payload = { \"customer\" : customer , \"amount\" : amount , } optional_params = [ ( \"due_date\" , due_date ), ( \"description\" , description ), ( \"line_items\" , line_items ), ( \"tax\" , tax ), ( \"currency\" , currency ), ( \"send_notification\" , send_notification ), ( \"draft\" , draft ), ( \"invoice_number\" , invoice_number ), ( \"split_code\" , split_code ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . PUT , url , payload ) verify ( code ) async Verify details of a payment request on your integration. Parameters: Name Type Description Default code str Payment Request id or code required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/payment_requests.py 384 385 386 387 388 389 390 391 392 393 394 395 async def verify ( self , code : str ) -> Response : \"\"\"Verify details of a payment request on your integration. Args: code: Payment Request id or code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/paymentrequest/verify/ { code } \" ) return await self . _handle_request ( HTTPMethod . GET , url ) PaymentRequest Bases: BaseAPI Provides a wrapper for paystack Payment Requests API The Payment Requests API allows you to manage requests for payment of goods and services. https://paystack.com/docs/api/payment-request/ Source code in pypaystack2/api/payment_requests.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 class PaymentRequest ( BaseAPI ): \"\"\"Provides a wrapper for paystack Payment Requests API The Payment Requests API allows you to manage requests for payment of goods and services. https://paystack.com/docs/api/payment-request/ \"\"\" def create ( self , customer : str , amount : int , due_date : Optional [ str ] = None , description : Optional [ str ] = None , line_items : Optional [ list [ LineItem ]] = None , tax : Optional [ list [ Tax ]] = None , currency : Optional [ Currency ] = None , send_notification : Optional [ bool ] = None , draft : Optional [ bool ] = None , has_invoice : Optional [ bool ] = None , invoice_number : Optional [ int ] = None , split_code : Optional [ str ] = None , ) -> Response : \"\"\"Create a payment request for a transaction on your integration Args: customer: Customer id or code amount: Payment request amount. It should be used when line items and tax values aren't specified. due_date: ISO 8601 representation of request due date description: A short description of the payment request line_items: List of line items int the format [{\"name\":\"item 1\", \"amount\":2000, \"quantity\": 1}] tax: List of taxes to be charged in the format [{\"name\":\"VAT\", \"amount\":2000}] currency: Any value from Currency enum. default ``Currency.NGN`` send_notification: Indicates whether Paystack sends an email notification to customer. Defaults to ``True`` draft: Indicate if request should be saved as draft. Defaults to ``False`` and overrides send_notification has_invoice: Set to ``True`` to create a draft invoice (adds an auto-incrementing invoice number if none is provided) even if there are no line_items or tax passed invoice_number: Numeric value of invoice. Invoice will start from 1 and auto increment from there. This field is to help override whatever value Paystack decides. Auto increment for subsequent invoices continue from this point. split_code: The split code of the transaction split. e.g. SPL_98WF13Eb3w Returns: A named tuple containing the response gotten from paystack's server. \"\"\" if line_items : line_items = [ item . dict for item in line_items ] if tax : tax = [ unit_tax . dict for unit_tax in tax ] url = self . _parse_url ( \"/paymentrequest\" ) payload = { \"customer\" : customer , \"amount\" : amount } optional_params = [ ( \"due_date\" , due_date ), ( \"description\" , description ), ( \"line_items\" , line_items ), ( \"tax\" , tax ), ( \"currency\" , currency ), ( \"send_notification\" , send_notification ), ( \"draft\" , draft ), ( \"has_invoice\" , has_invoice ), ( \"invoice_number\" , invoice_number ), ( \"split_code\" , split_code ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . POST , url , payload ) def get_payment_requests ( self , customer : Optional [ str ] = None , status : Optional [ Status ] = None , currency : Optional [ Currency ] = None , include_archive : bool = False , page : int = 1 , pagination : int = 50 , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , ) -> Response : \"\"\"Fetches the payment requests available on your integration. Args: customer: Filter by customer ID status: Filter by payment request status. Any value from enum of ``Status`` currency: Filter by currency. Any value from enum of ``Currency`` include_archive: Show archived payment requests. page: Specify exactly what payment request you want to page. If not specified, we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50. start_date: A timestamp from which to start listing payment requests e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing payment requests e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/paymentrequest?perPage= { pagination } \" ) query_params = [ ( \"customer\" , customer ), ( \"status\" , status ), ( \"currency\" , currency ), ( \"include_archive\" , include_archive ), ( \"page\" , page ), ( \"start_date\" , start_date ), ( \"end_date\" , end_date ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url ) def get_payment_request ( self , id_or_code : str ) -> Response : \"\"\"Get details of a payment request on your integration Args: id_or_code: The payment request ID or code you want to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/paymentrequest/ { id_or_code } \" ) return self . _handle_request ( HTTPMethod . GET , url ) def verify ( self , code : str ) -> Response : \"\"\"Verify details of a payment request on your integration. Args: code: Payment Request id or code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/paymentrequest/verify/ { code } \" ) return self . _handle_request ( HTTPMethod . GET , url ) def send_notification ( self , id_or_code : str ) -> Response : \"\"\"Send notification of a payment request to your customers Args: id_or_code: Payment Request id or code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/paymentrequest/notify/ { id_or_code } \" ) return self . _handle_request ( HTTPMethod . POST , url ) def get_total ( self ) -> Response : \"\"\"Get payment requests metric Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/paymentrequest/totals\" ) return self . _handle_request ( HTTPMethod . GET , url ) def finalize ( self , id_or_code : str ) -> Response : \"\"\"Finalize a draft payment request Args: id_or_code: Payment Request id or code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/paymentrequest/finalize/ { id_or_code } \" ) return self . _handle_request ( HTTPMethod . POST , url ) def update ( self , id_or_code : str , customer : str , amount : int , due_date : Optional [ str ] = None , description : Optional [ str ] = None , line_items : Optional [ list [ dict ]] = None , tax : Optional [ list [ dict ]] = None , currency : Optional [ Currency ] = None , send_notification : Optional [ bool ] = None , draft : Optional [ bool ] = None , invoice_number : Optional [ int ] = None , split_code : Optional [ str ] = None , ) -> Response : \"\"\"Update the payment request details on your integration Args: id_or_code: Payment Request id or code customer: Customer id or code amount: Payment request amount. Only useful if line items and tax values are ignored. method will throw a friendly warning in the response if neither is available. due_date: ISO 8601 representation of request due date description: A short description of the payment request line_items: List of line items in the format [{\"name\":\"item 1\", \"amount\":2000}] tax: List of taxes to be charged in the format [{\"name\":\"VAT\", \"amount\":2000}] currency: Specify the currency of the Payment Request id or code. Any value from the ``Currency`` enum send_notification: Indicates whether Paystack sends an email notification to customer. Defaults to ``True`` draft: Indicate if request should be saved as draft. Defaults to false and overrides send_notification invoice_number: Numeric value of invoice. Invoice will start from 1 and auto increment from there. This field is to help override whatever value Paystack decides. Auto increment for subsequent invoices continue from this point. split_code: The split code of the transaction split. e.g. SPL_98WF13Eb3w Returns: A named tuple containing the response gotten from paystack's server. \"\"\" amount = validate_amount ( amount ) url = self . _parse_url ( f \"/paymentrequest/ { id_or_code } \" ) payload = { \"customer\" : customer , \"amount\" : amount , } optional_params = [ ( \"due_date\" , due_date ), ( \"description\" , description ), ( \"line_items\" , line_items ), ( \"tax\" , tax ), ( \"currency\" , currency ), ( \"send_notification\" , send_notification ), ( \"draft\" , draft ), ( \"invoice_number\" , invoice_number ), ( \"split_code\" , split_code ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . PUT , url , payload ) def archive ( self , id_or_code : str ) -> Response : \"\"\"Used to archive a payment request. A payment request will no longer be fetched on list or returned on verify. Args: id_or_code: Payment Request id or code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/paymentrequest/archive/ { id_or_code } \" ) return self . _handle_request ( HTTPMethod . POST , url ) archive ( id_or_code ) Used to archive a payment request. A payment request will no longer be fetched on list or returned on verify. Parameters: Name Type Description Default id_or_code str Payment Request id or code required Returns: A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/payment_requests.py 248 249 250 251 252 253 254 255 256 257 258 259 def archive ( self , id_or_code : str ) -> Response : \"\"\"Used to archive a payment request. A payment request will no longer be fetched on list or returned on verify. Args: id_or_code: Payment Request id or code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/paymentrequest/archive/ { id_or_code } \" ) return self . _handle_request ( HTTPMethod . POST , url ) create ( customer , amount , due_date = None , description = None , line_items = None , tax = None , currency = None , send_notification = None , draft = None , has_invoice = None , invoice_number = None , split_code = None ) Create a payment request for a transaction on your integration Parameters: Name Type Description Default customer str Customer id or code required amount int Payment request amount. It should be used when line items and tax values aren't specified. required due_date Optional [ str ] ISO 8601 representation of request due date None description Optional [ str ] A short description of the payment request None line_items Optional [ list [ LineItem ]] List of line items int the format [{\"name\":\"item 1\", \"amount\":2000, \"quantity\": 1}] None tax Optional [ list [ Tax ]] List of taxes to be charged in the format [{\"name\":\"VAT\", \"amount\":2000}] None currency Optional [ Currency ] Any value from Currency enum. default Currency.NGN None send_notification Optional [ bool ] Indicates whether Paystack sends an email notification to customer. Defaults to True None draft Optional [ bool ] Indicate if request should be saved as draft. Defaults to False and overrides send_notification None has_invoice Optional [ bool ] Set to True to create a draft invoice (adds an auto-incrementing invoice number if none is provided) even if there are no line_items or tax passed None invoice_number Optional [ int ] Numeric value of invoice. Invoice will start from 1 and auto increment from there. This field is to help override whatever value Paystack decides. Auto increment for subsequent invoices continue from this point. None split_code Optional [ str ] The split code of the transaction split. e.g. SPL_98WF13Eb3w None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/payment_requests.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 def create ( self , customer : str , amount : int , due_date : Optional [ str ] = None , description : Optional [ str ] = None , line_items : Optional [ list [ LineItem ]] = None , tax : Optional [ list [ Tax ]] = None , currency : Optional [ Currency ] = None , send_notification : Optional [ bool ] = None , draft : Optional [ bool ] = None , has_invoice : Optional [ bool ] = None , invoice_number : Optional [ int ] = None , split_code : Optional [ str ] = None , ) -> Response : \"\"\"Create a payment request for a transaction on your integration Args: customer: Customer id or code amount: Payment request amount. It should be used when line items and tax values aren't specified. due_date: ISO 8601 representation of request due date description: A short description of the payment request line_items: List of line items int the format [{\"name\":\"item 1\", \"amount\":2000, \"quantity\": 1}] tax: List of taxes to be charged in the format [{\"name\":\"VAT\", \"amount\":2000}] currency: Any value from Currency enum. default ``Currency.NGN`` send_notification: Indicates whether Paystack sends an email notification to customer. Defaults to ``True`` draft: Indicate if request should be saved as draft. Defaults to ``False`` and overrides send_notification has_invoice: Set to ``True`` to create a draft invoice (adds an auto-incrementing invoice number if none is provided) even if there are no line_items or tax passed invoice_number: Numeric value of invoice. Invoice will start from 1 and auto increment from there. This field is to help override whatever value Paystack decides. Auto increment for subsequent invoices continue from this point. split_code: The split code of the transaction split. e.g. SPL_98WF13Eb3w Returns: A named tuple containing the response gotten from paystack's server. \"\"\" if line_items : line_items = [ item . dict for item in line_items ] if tax : tax = [ unit_tax . dict for unit_tax in tax ] url = self . _parse_url ( \"/paymentrequest\" ) payload = { \"customer\" : customer , \"amount\" : amount } optional_params = [ ( \"due_date\" , due_date ), ( \"description\" , description ), ( \"line_items\" , line_items ), ( \"tax\" , tax ), ( \"currency\" , currency ), ( \"send_notification\" , send_notification ), ( \"draft\" , draft ), ( \"has_invoice\" , has_invoice ), ( \"invoice_number\" , invoice_number ), ( \"split_code\" , split_code ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . POST , url , payload ) finalize ( id_or_code ) Finalize a draft payment request Parameters: Name Type Description Default id_or_code str Payment Request id or code required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/payment_requests.py 176 177 178 179 180 181 182 183 184 185 186 187 def finalize ( self , id_or_code : str ) -> Response : \"\"\"Finalize a draft payment request Args: id_or_code: Payment Request id or code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/paymentrequest/finalize/ { id_or_code } \" ) return self . _handle_request ( HTTPMethod . POST , url ) get_payment_request ( id_or_code ) Get details of a payment request on your integration Parameters: Name Type Description Default id_or_code str The payment request ID or code you want to fetch required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/payment_requests.py 127 128 129 130 131 132 133 134 135 136 137 138 def get_payment_request ( self , id_or_code : str ) -> Response : \"\"\"Get details of a payment request on your integration Args: id_or_code: The payment request ID or code you want to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/paymentrequest/ { id_or_code } \" ) return self . _handle_request ( HTTPMethod . GET , url ) get_payment_requests ( customer = None , status = None , currency = None , include_archive = False , page = 1 , pagination = 50 , start_date = None , end_date = None ) Fetches the payment requests available on your integration. Parameters: Name Type Description Default customer Optional [ str ] Filter by customer ID None status Optional [ Status ] Filter by payment request status. Any value from enum of Status None currency Optional [ Currency ] Filter by currency. Any value from enum of Currency None include_archive bool Show archived payment requests. False page int Specify exactly what payment request you want to page. If not specified, we use a default value of 1. 1 pagination int Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50. 50 start_date Optional [ str ] A timestamp from which to start listing payment requests e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None end_date Optional [ str ] A timestamp at which to stop listing payment requests e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/payment_requests.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 def get_payment_requests ( self , customer : Optional [ str ] = None , status : Optional [ Status ] = None , currency : Optional [ Currency ] = None , include_archive : bool = False , page : int = 1 , pagination : int = 50 , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , ) -> Response : \"\"\"Fetches the payment requests available on your integration. Args: customer: Filter by customer ID status: Filter by payment request status. Any value from enum of ``Status`` currency: Filter by currency. Any value from enum of ``Currency`` include_archive: Show archived payment requests. page: Specify exactly what payment request you want to page. If not specified, we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50. start_date: A timestamp from which to start listing payment requests e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing payment requests e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/paymentrequest?perPage= { pagination } \" ) query_params = [ ( \"customer\" , customer ), ( \"status\" , status ), ( \"currency\" , currency ), ( \"include_archive\" , include_archive ), ( \"page\" , page ), ( \"start_date\" , start_date ), ( \"end_date\" , end_date ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url ) get_total () Get payment requests metric Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/payment_requests.py 166 167 168 169 170 171 172 173 174 def get_total ( self ) -> Response : \"\"\"Get payment requests metric Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/paymentrequest/totals\" ) return self . _handle_request ( HTTPMethod . GET , url ) send_notification ( id_or_code ) Send notification of a payment request to your customers Parameters: Name Type Description Default id_or_code str Payment Request id or code required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/payment_requests.py 153 154 155 156 157 158 159 160 161 162 163 164 def send_notification ( self , id_or_code : str ) -> Response : \"\"\"Send notification of a payment request to your customers Args: id_or_code: Payment Request id or code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/paymentrequest/notify/ { id_or_code } \" ) return self . _handle_request ( HTTPMethod . POST , url ) update ( id_or_code , customer , amount , due_date = None , description = None , line_items = None , tax = None , currency = None , send_notification = None , draft = None , invoice_number = None , split_code = None ) Update the payment request details on your integration Parameters: Name Type Description Default id_or_code str Payment Request id or code required customer str Customer id or code required amount int Payment request amount. Only useful if line items and tax values are ignored. method will throw a friendly warning in the response if neither is available. required due_date Optional [ str ] ISO 8601 representation of request due date None description Optional [ str ] A short description of the payment request None line_items Optional [ list [ dict ]] List of line items in the format [{\"name\":\"item 1\", \"amount\":2000}] None tax Optional [ list [ dict ]] List of taxes to be charged in the format [{\"name\":\"VAT\", \"amount\":2000}] None currency Optional [ Currency ] Specify the currency of the Payment Request id or code. Any value from the Currency enum None send_notification Optional [ bool ] Indicates whether Paystack sends an email notification to customer. Defaults to True None draft Optional [ bool ] Indicate if request should be saved as draft. Defaults to false and overrides send_notification None invoice_number Optional [ int ] Numeric value of invoice. Invoice will start from 1 and auto increment from there. This field is to help override whatever value Paystack decides. Auto increment for subsequent invoices continue from this point. None split_code Optional [ str ] The split code of the transaction split. e.g. SPL_98WF13Eb3w None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/payment_requests.py 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 def update ( self , id_or_code : str , customer : str , amount : int , due_date : Optional [ str ] = None , description : Optional [ str ] = None , line_items : Optional [ list [ dict ]] = None , tax : Optional [ list [ dict ]] = None , currency : Optional [ Currency ] = None , send_notification : Optional [ bool ] = None , draft : Optional [ bool ] = None , invoice_number : Optional [ int ] = None , split_code : Optional [ str ] = None , ) -> Response : \"\"\"Update the payment request details on your integration Args: id_or_code: Payment Request id or code customer: Customer id or code amount: Payment request amount. Only useful if line items and tax values are ignored. method will throw a friendly warning in the response if neither is available. due_date: ISO 8601 representation of request due date description: A short description of the payment request line_items: List of line items in the format [{\"name\":\"item 1\", \"amount\":2000}] tax: List of taxes to be charged in the format [{\"name\":\"VAT\", \"amount\":2000}] currency: Specify the currency of the Payment Request id or code. Any value from the ``Currency`` enum send_notification: Indicates whether Paystack sends an email notification to customer. Defaults to ``True`` draft: Indicate if request should be saved as draft. Defaults to false and overrides send_notification invoice_number: Numeric value of invoice. Invoice will start from 1 and auto increment from there. This field is to help override whatever value Paystack decides. Auto increment for subsequent invoices continue from this point. split_code: The split code of the transaction split. e.g. SPL_98WF13Eb3w Returns: A named tuple containing the response gotten from paystack's server. \"\"\" amount = validate_amount ( amount ) url = self . _parse_url ( f \"/paymentrequest/ { id_or_code } \" ) payload = { \"customer\" : customer , \"amount\" : amount , } optional_params = [ ( \"due_date\" , due_date ), ( \"description\" , description ), ( \"line_items\" , line_items ), ( \"tax\" , tax ), ( \"currency\" , currency ), ( \"send_notification\" , send_notification ), ( \"draft\" , draft ), ( \"invoice_number\" , invoice_number ), ( \"split_code\" , split_code ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . PUT , url , payload ) verify ( code ) Verify details of a payment request on your integration. Parameters: Name Type Description Default code str Payment Request id or code required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/payment_requests.py 140 141 142 143 144 145 146 147 148 149 150 151 def verify ( self , code : str ) -> Response : \"\"\"Verify details of a payment request on your integration. Args: code: Payment Request id or code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/paymentrequest/verify/ { code } \" ) return self . _handle_request ( HTTPMethod . GET , url )","title":"Payment requests"},{"location":"reference/payment_requests/#pypaystack2.api.payment_requests.AsyncPaymentRequest","text":"Bases: BaseAsyncAPI Provides a wrapper for paystack Payment Requests API The Payment Requests API allows you to manage requests for payment of goods and services. https://paystack.com/docs/api/payment-request/ Source code in pypaystack2/api/payment_requests.py 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 class AsyncPaymentRequest ( BaseAsyncAPI ): \"\"\"Provides a wrapper for paystack Payment Requests API The Payment Requests API allows you to manage requests for payment of goods and services. https://paystack.com/docs/api/payment-request/ \"\"\" async def create ( self , customer : str , amount : int , due_date : Optional [ str ] = None , description : Optional [ str ] = None , line_items : Optional [ list [ LineItem ]] = None , tax : Optional [ list [ Tax ]] = None , currency : Optional [ Currency ] = None , send_notification : Optional [ bool ] = None , draft : Optional [ bool ] = None , has_invoice : Optional [ bool ] = None , invoice_number : Optional [ int ] = None , split_code : Optional [ str ] = None , ) -> Response : \"\"\"Create a payment request for a transaction on your integration Args: customer: Customer id or code amount: Payment request amount. It should be used when line items and tax values aren't specified. due_date: ISO 8601 representation of request due date description: A short description of the payment request line_items: List of line items int the format [{\"name\":\"item 1\", \"amount\":2000, \"quantity\": 1}] tax: List of taxes to be charged in the format [{\"name\":\"VAT\", \"amount\":2000}] currency: Any value from Currency enum. default ``Currency.NGN`` send_notification: Indicates whether Paystack sends an email notification to customer. Defaults to ``True`` draft: Indicate if request should be saved as draft. Defaults to ``False`` and overrides send_notification has_invoice: Set to ``True`` to create a draft invoice (adds an auto incrementing invoice number if none is provided) even if there are no line_items or tax passed invoice_number: Numeric value of invoice. Invoice will start from 1 and auto increment from there. This field is to help override whatever value Paystack decides. Auto increment for subsequent invoices continue from this point. split_code: The split code of the transaction split. e.g. SPL_98WF13Eb3w Returns: A named tuple containing the response gotten from paystack's server. \"\"\" if line_items : line_items = [ item . dict for item in line_items ] if tax : tax = [ unit_tax . dict for unit_tax in tax ] url = self . _parse_url ( \"/paymentrequest\" ) payload = { \"customer\" : customer , \"amount\" : amount } optional_params = [ ( \"due_date\" , due_date ), ( \"description\" , description ), ( \"line_items\" , line_items ), ( \"tax\" , tax ), ( \"currency\" , currency ), ( \"send_notification\" , send_notification ), ( \"draft\" , draft ), ( \"has_invoice\" , has_invoice ), ( \"invoice_number\" , invoice_number ), ( \"split_code\" , split_code ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) async def get_payment_requests ( self , customer : Optional [ str ] = None , status : Optional [ Status ] = None , currency : Optional [ Currency ] = None , include_archive : bool = False , page : int = 1 , pagination : int = 50 , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , ) -> Response : \"\"\"Fetches the payment requests available on your integration. Args: customer: Filter by customer ID status: Filter by payment request status. Any value from enum of ``Status`` currency: Filter by currency. Any value from enum of ``Currency`` include_archive: Show archived payment requests. page: Specify exactly what payment request you want to page. If not specify we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. start_date: A timestamp from which to start listing payment request e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing payment request e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/paymentrequest?perPage= { pagination } \" ) query_params = [ ( \"customer\" , customer ), ( \"status\" , status ), ( \"currency\" , currency ), ( \"include_archive\" , include_archive ), ( \"page\" , page ), ( \"start_date\" , start_date ), ( \"end_date\" , end_date ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url ) async def get_payment_request ( self , id_or_code : str ) -> Response : \"\"\"Get details of a payment request on your integration. Args: id_or_code: Payment Request id or code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/paymentrequest/ { id_or_code } \" ) return await self . _handle_request ( HTTPMethod . GET , url ) async def verify ( self , code : str ) -> Response : \"\"\"Verify details of a payment request on your integration. Args: code: Payment Request id or code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/paymentrequest/verify/ { code } \" ) return await self . _handle_request ( HTTPMethod . GET , url ) async def send_notification ( self , id_or_code : str ) -> Response : \"\"\"Send notification of a payment request to your customers Args: id_or_code: Payment Request id or code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/paymentrequest/notify/ { id_or_code } \" ) return await self . _handle_request ( HTTPMethod . POST , url ) async def get_total ( self ) -> Response : \"\"\"Get payment requests metric Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/paymentrequest/totals\" ) return await self . _handle_request ( HTTPMethod . GET , url ) async def finalize ( self , id_or_code : str ) -> Response : \"\"\"Finalize a draft payment request Args: id_or_code: Payment Request id or code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/paymentrequest/finalize/ { id_or_code } \" ) return await self . _handle_request ( HTTPMethod . POST , url ) async def update ( self , id_or_code : str , customer : str , amount : int , due_date : Optional [ str ] = None , description : Optional [ str ] = None , line_items : Optional [ list [ dict ]] = None , tax : Optional [ list [ dict ]] = None , currency : Optional [ Currency ] = None , send_notification : Optional [ bool ] = None , draft : Optional [ bool ] = None , invoice_number : Optional [ int ] = None , split_code : Optional [ str ] = None , ) -> Response : \"\"\"Update a payment request details on your integration Args: id_or_code: Payment Request id or code customer: Customer id or code amount: Payment request amount. Only useful if line items and tax values are ignored. method will throw a friendly warning in the response if neither is available. due_date: ISO 8601 representation of request due date description: A short description of the payment request line_items: List of line items in the format [{\"name\":\"item 1\", \"amount\":2000}] tax: List of taxes to be charged in the format [{\"name\":\"VAT\", \"amount\":2000}] currency: Specify the currency of the payment request. Any value from the ``Currency`` enum send_notification: Indicates whether Paystack sends an email notification to customer. Defaults to ``True`` draft: Indicate if request should be saved as draft. Defaults to false and overrides send_notification invoice_number: Numeric value of invoice. Invoice will start from 1 and auto increment from there. This field is to help override whatever value Paystack decides. Auto increment for subsequent invoices continue from this point. split_code: The split code of the transaction split. e.g. SPL_98WF13Eb3w Returns: A named tuple containing the response gotten from paystack's server. \"\"\" amount = validate_amount ( amount ) url = self . _parse_url ( f \"/paymentrequest/ { id_or_code } \" ) payload = { \"customer\" : customer , \"amount\" : amount , } optional_params = [ ( \"due_date\" , due_date ), ( \"description\" , description ), ( \"line_items\" , line_items ), ( \"tax\" , tax ), ( \"currency\" , currency ), ( \"send_notification\" , send_notification ), ( \"draft\" , draft ), ( \"invoice_number\" , invoice_number ), ( \"split_code\" , split_code ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . PUT , url , payload ) async def archive ( self , id_or_code : str ) -> Response : \"\"\"Used to archive a payment request. A payment request will no longer be fetched on list or returned on verify. Args: id_or_code: Payment Request id or code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/paymentrequest/archive/ { id_or_code } \" ) return await self . _handle_request ( HTTPMethod . POST , url )","title":"AsyncPaymentRequest"},{"location":"reference/payment_requests/#pypaystack2.api.payment_requests.AsyncPaymentRequest.archive","text":"Used to archive a payment request. A payment request will no longer be fetched on list or returned on verify. Parameters: Name Type Description Default id_or_code str Payment Request id or code required Returns: A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/payment_requests.py 492 493 494 495 496 497 498 499 500 501 502 503 async def archive ( self , id_or_code : str ) -> Response : \"\"\"Used to archive a payment request. A payment request will no longer be fetched on list or returned on verify. Args: id_or_code: Payment Request id or code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/paymentrequest/archive/ { id_or_code } \" ) return await self . _handle_request ( HTTPMethod . POST , url )","title":"archive()"},{"location":"reference/payment_requests/#pypaystack2.api.payment_requests.AsyncPaymentRequest.create","text":"Create a payment request for a transaction on your integration Parameters: Name Type Description Default customer str Customer id or code required amount int Payment request amount. It should be used when line items and tax values aren't specified. required due_date Optional [ str ] ISO 8601 representation of request due date None description Optional [ str ] A short description of the payment request None line_items Optional [ list [ LineItem ]] List of line items int the format [{\"name\":\"item 1\", \"amount\":2000, \"quantity\": 1}] None tax Optional [ list [ Tax ]] List of taxes to be charged in the format [{\"name\":\"VAT\", \"amount\":2000}] None currency Optional [ Currency ] Any value from Currency enum. default Currency.NGN None send_notification Optional [ bool ] Indicates whether Paystack sends an email notification to customer. Defaults to True None draft Optional [ bool ] Indicate if request should be saved as draft. Defaults to False and overrides send_notification None has_invoice Optional [ bool ] Set to True to create a draft invoice (adds an auto incrementing invoice number if none is provided) even if there are no line_items or tax passed None invoice_number Optional [ int ] Numeric value of invoice. Invoice will start from 1 and auto increment from there. This field is to help override whatever value Paystack decides. Auto increment for subsequent invoices continue from this point. None split_code Optional [ str ] The split code of the transaction split. e.g. SPL_98WF13Eb3w None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/payment_requests.py 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 async def create ( self , customer : str , amount : int , due_date : Optional [ str ] = None , description : Optional [ str ] = None , line_items : Optional [ list [ LineItem ]] = None , tax : Optional [ list [ Tax ]] = None , currency : Optional [ Currency ] = None , send_notification : Optional [ bool ] = None , draft : Optional [ bool ] = None , has_invoice : Optional [ bool ] = None , invoice_number : Optional [ int ] = None , split_code : Optional [ str ] = None , ) -> Response : \"\"\"Create a payment request for a transaction on your integration Args: customer: Customer id or code amount: Payment request amount. It should be used when line items and tax values aren't specified. due_date: ISO 8601 representation of request due date description: A short description of the payment request line_items: List of line items int the format [{\"name\":\"item 1\", \"amount\":2000, \"quantity\": 1}] tax: List of taxes to be charged in the format [{\"name\":\"VAT\", \"amount\":2000}] currency: Any value from Currency enum. default ``Currency.NGN`` send_notification: Indicates whether Paystack sends an email notification to customer. Defaults to ``True`` draft: Indicate if request should be saved as draft. Defaults to ``False`` and overrides send_notification has_invoice: Set to ``True`` to create a draft invoice (adds an auto incrementing invoice number if none is provided) even if there are no line_items or tax passed invoice_number: Numeric value of invoice. Invoice will start from 1 and auto increment from there. This field is to help override whatever value Paystack decides. Auto increment for subsequent invoices continue from this point. split_code: The split code of the transaction split. e.g. SPL_98WF13Eb3w Returns: A named tuple containing the response gotten from paystack's server. \"\"\" if line_items : line_items = [ item . dict for item in line_items ] if tax : tax = [ unit_tax . dict for unit_tax in tax ] url = self . _parse_url ( \"/paymentrequest\" ) payload = { \"customer\" : customer , \"amount\" : amount } optional_params = [ ( \"due_date\" , due_date ), ( \"description\" , description ), ( \"line_items\" , line_items ), ( \"tax\" , tax ), ( \"currency\" , currency ), ( \"send_notification\" , send_notification ), ( \"draft\" , draft ), ( \"has_invoice\" , has_invoice ), ( \"invoice_number\" , invoice_number ), ( \"split_code\" , split_code ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . POST , url , payload )","title":"create()"},{"location":"reference/payment_requests/#pypaystack2.api.payment_requests.AsyncPaymentRequest.finalize","text":"Finalize a draft payment request Parameters: Name Type Description Default id_or_code str Payment Request id or code required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/payment_requests.py 420 421 422 423 424 425 426 427 428 429 430 431 async def finalize ( self , id_or_code : str ) -> Response : \"\"\"Finalize a draft payment request Args: id_or_code: Payment Request id or code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/paymentrequest/finalize/ { id_or_code } \" ) return await self . _handle_request ( HTTPMethod . POST , url )","title":"finalize()"},{"location":"reference/payment_requests/#pypaystack2.api.payment_requests.AsyncPaymentRequest.get_payment_request","text":"Get details of a payment request on your integration. Parameters: Name Type Description Default id_or_code str Payment Request id or code required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/payment_requests.py 371 372 373 374 375 376 377 378 379 380 381 382 async def get_payment_request ( self , id_or_code : str ) -> Response : \"\"\"Get details of a payment request on your integration. Args: id_or_code: Payment Request id or code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/paymentrequest/ { id_or_code } \" ) return await self . _handle_request ( HTTPMethod . GET , url )","title":"get_payment_request()"},{"location":"reference/payment_requests/#pypaystack2.api.payment_requests.AsyncPaymentRequest.get_payment_requests","text":"Fetches the payment requests available on your integration. Parameters: Name Type Description Default customer Optional [ str ] Filter by customer ID None status Optional [ Status ] Filter by payment request status. Any value from enum of Status None currency Optional [ Currency ] Filter by currency. Any value from enum of Currency None include_archive bool Show archived payment requests. False page int Specify exactly what payment request you want to page. If not specify we use a default value of 1. 1 pagination int Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. 50 start_date Optional [ str ] A timestamp from which to start listing payment request e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None end_date Optional [ str ] A timestamp at which to stop listing payment request e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/payment_requests.py 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 async def get_payment_requests ( self , customer : Optional [ str ] = None , status : Optional [ Status ] = None , currency : Optional [ Currency ] = None , include_archive : bool = False , page : int = 1 , pagination : int = 50 , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , ) -> Response : \"\"\"Fetches the payment requests available on your integration. Args: customer: Filter by customer ID status: Filter by payment request status. Any value from enum of ``Status`` currency: Filter by currency. Any value from enum of ``Currency`` include_archive: Show archived payment requests. page: Specify exactly what payment request you want to page. If not specify we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. start_date: A timestamp from which to start listing payment request e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing payment request e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/paymentrequest?perPage= { pagination } \" ) query_params = [ ( \"customer\" , customer ), ( \"status\" , status ), ( \"currency\" , currency ), ( \"include_archive\" , include_archive ), ( \"page\" , page ), ( \"start_date\" , start_date ), ( \"end_date\" , end_date ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url )","title":"get_payment_requests()"},{"location":"reference/payment_requests/#pypaystack2.api.payment_requests.AsyncPaymentRequest.get_total","text":"Get payment requests metric Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/payment_requests.py 410 411 412 413 414 415 416 417 418 async def get_total ( self ) -> Response : \"\"\"Get payment requests metric Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/paymentrequest/totals\" ) return await self . _handle_request ( HTTPMethod . GET , url )","title":"get_total()"},{"location":"reference/payment_requests/#pypaystack2.api.payment_requests.AsyncPaymentRequest.send_notification","text":"Send notification of a payment request to your customers Parameters: Name Type Description Default id_or_code str Payment Request id or code required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/payment_requests.py 397 398 399 400 401 402 403 404 405 406 407 408 async def send_notification ( self , id_or_code : str ) -> Response : \"\"\"Send notification of a payment request to your customers Args: id_or_code: Payment Request id or code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/paymentrequest/notify/ { id_or_code } \" ) return await self . _handle_request ( HTTPMethod . POST , url )","title":"send_notification()"},{"location":"reference/payment_requests/#pypaystack2.api.payment_requests.AsyncPaymentRequest.update","text":"Update a payment request details on your integration Parameters: Name Type Description Default id_or_code str Payment Request id or code required customer str Customer id or code required amount int Payment request amount. Only useful if line items and tax values are ignored. method will throw a friendly warning in the response if neither is available. required due_date Optional [ str ] ISO 8601 representation of request due date None description Optional [ str ] A short description of the payment request None line_items Optional [ list [ dict ]] List of line items in the format [{\"name\":\"item 1\", \"amount\":2000}] None tax Optional [ list [ dict ]] List of taxes to be charged in the format [{\"name\":\"VAT\", \"amount\":2000}] None currency Optional [ Currency ] Specify the currency of the payment request. Any value from the Currency enum None send_notification Optional [ bool ] Indicates whether Paystack sends an email notification to customer. Defaults to True None draft Optional [ bool ] Indicate if request should be saved as draft. Defaults to false and overrides send_notification None invoice_number Optional [ int ] Numeric value of invoice. Invoice will start from 1 and auto increment from there. This field is to help override whatever value Paystack decides. Auto increment for subsequent invoices continue from this point. None split_code Optional [ str ] The split code of the transaction split. e.g. SPL_98WF13Eb3w None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/payment_requests.py 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 async def update ( self , id_or_code : str , customer : str , amount : int , due_date : Optional [ str ] = None , description : Optional [ str ] = None , line_items : Optional [ list [ dict ]] = None , tax : Optional [ list [ dict ]] = None , currency : Optional [ Currency ] = None , send_notification : Optional [ bool ] = None , draft : Optional [ bool ] = None , invoice_number : Optional [ int ] = None , split_code : Optional [ str ] = None , ) -> Response : \"\"\"Update a payment request details on your integration Args: id_or_code: Payment Request id or code customer: Customer id or code amount: Payment request amount. Only useful if line items and tax values are ignored. method will throw a friendly warning in the response if neither is available. due_date: ISO 8601 representation of request due date description: A short description of the payment request line_items: List of line items in the format [{\"name\":\"item 1\", \"amount\":2000}] tax: List of taxes to be charged in the format [{\"name\":\"VAT\", \"amount\":2000}] currency: Specify the currency of the payment request. Any value from the ``Currency`` enum send_notification: Indicates whether Paystack sends an email notification to customer. Defaults to ``True`` draft: Indicate if request should be saved as draft. Defaults to false and overrides send_notification invoice_number: Numeric value of invoice. Invoice will start from 1 and auto increment from there. This field is to help override whatever value Paystack decides. Auto increment for subsequent invoices continue from this point. split_code: The split code of the transaction split. e.g. SPL_98WF13Eb3w Returns: A named tuple containing the response gotten from paystack's server. \"\"\" amount = validate_amount ( amount ) url = self . _parse_url ( f \"/paymentrequest/ { id_or_code } \" ) payload = { \"customer\" : customer , \"amount\" : amount , } optional_params = [ ( \"due_date\" , due_date ), ( \"description\" , description ), ( \"line_items\" , line_items ), ( \"tax\" , tax ), ( \"currency\" , currency ), ( \"send_notification\" , send_notification ), ( \"draft\" , draft ), ( \"invoice_number\" , invoice_number ), ( \"split_code\" , split_code ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . PUT , url , payload )","title":"update()"},{"location":"reference/payment_requests/#pypaystack2.api.payment_requests.AsyncPaymentRequest.verify","text":"Verify details of a payment request on your integration. Parameters: Name Type Description Default code str Payment Request id or code required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/payment_requests.py 384 385 386 387 388 389 390 391 392 393 394 395 async def verify ( self , code : str ) -> Response : \"\"\"Verify details of a payment request on your integration. Args: code: Payment Request id or code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/paymentrequest/verify/ { code } \" ) return await self . _handle_request ( HTTPMethod . GET , url )","title":"verify()"},{"location":"reference/payment_requests/#pypaystack2.api.payment_requests.PaymentRequest","text":"Bases: BaseAPI Provides a wrapper for paystack Payment Requests API The Payment Requests API allows you to manage requests for payment of goods and services. https://paystack.com/docs/api/payment-request/ Source code in pypaystack2/api/payment_requests.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 class PaymentRequest ( BaseAPI ): \"\"\"Provides a wrapper for paystack Payment Requests API The Payment Requests API allows you to manage requests for payment of goods and services. https://paystack.com/docs/api/payment-request/ \"\"\" def create ( self , customer : str , amount : int , due_date : Optional [ str ] = None , description : Optional [ str ] = None , line_items : Optional [ list [ LineItem ]] = None , tax : Optional [ list [ Tax ]] = None , currency : Optional [ Currency ] = None , send_notification : Optional [ bool ] = None , draft : Optional [ bool ] = None , has_invoice : Optional [ bool ] = None , invoice_number : Optional [ int ] = None , split_code : Optional [ str ] = None , ) -> Response : \"\"\"Create a payment request for a transaction on your integration Args: customer: Customer id or code amount: Payment request amount. It should be used when line items and tax values aren't specified. due_date: ISO 8601 representation of request due date description: A short description of the payment request line_items: List of line items int the format [{\"name\":\"item 1\", \"amount\":2000, \"quantity\": 1}] tax: List of taxes to be charged in the format [{\"name\":\"VAT\", \"amount\":2000}] currency: Any value from Currency enum. default ``Currency.NGN`` send_notification: Indicates whether Paystack sends an email notification to customer. Defaults to ``True`` draft: Indicate if request should be saved as draft. Defaults to ``False`` and overrides send_notification has_invoice: Set to ``True`` to create a draft invoice (adds an auto-incrementing invoice number if none is provided) even if there are no line_items or tax passed invoice_number: Numeric value of invoice. Invoice will start from 1 and auto increment from there. This field is to help override whatever value Paystack decides. Auto increment for subsequent invoices continue from this point. split_code: The split code of the transaction split. e.g. SPL_98WF13Eb3w Returns: A named tuple containing the response gotten from paystack's server. \"\"\" if line_items : line_items = [ item . dict for item in line_items ] if tax : tax = [ unit_tax . dict for unit_tax in tax ] url = self . _parse_url ( \"/paymentrequest\" ) payload = { \"customer\" : customer , \"amount\" : amount } optional_params = [ ( \"due_date\" , due_date ), ( \"description\" , description ), ( \"line_items\" , line_items ), ( \"tax\" , tax ), ( \"currency\" , currency ), ( \"send_notification\" , send_notification ), ( \"draft\" , draft ), ( \"has_invoice\" , has_invoice ), ( \"invoice_number\" , invoice_number ), ( \"split_code\" , split_code ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . POST , url , payload ) def get_payment_requests ( self , customer : Optional [ str ] = None , status : Optional [ Status ] = None , currency : Optional [ Currency ] = None , include_archive : bool = False , page : int = 1 , pagination : int = 50 , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , ) -> Response : \"\"\"Fetches the payment requests available on your integration. Args: customer: Filter by customer ID status: Filter by payment request status. Any value from enum of ``Status`` currency: Filter by currency. Any value from enum of ``Currency`` include_archive: Show archived payment requests. page: Specify exactly what payment request you want to page. If not specified, we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50. start_date: A timestamp from which to start listing payment requests e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing payment requests e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/paymentrequest?perPage= { pagination } \" ) query_params = [ ( \"customer\" , customer ), ( \"status\" , status ), ( \"currency\" , currency ), ( \"include_archive\" , include_archive ), ( \"page\" , page ), ( \"start_date\" , start_date ), ( \"end_date\" , end_date ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url ) def get_payment_request ( self , id_or_code : str ) -> Response : \"\"\"Get details of a payment request on your integration Args: id_or_code: The payment request ID or code you want to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/paymentrequest/ { id_or_code } \" ) return self . _handle_request ( HTTPMethod . GET , url ) def verify ( self , code : str ) -> Response : \"\"\"Verify details of a payment request on your integration. Args: code: Payment Request id or code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/paymentrequest/verify/ { code } \" ) return self . _handle_request ( HTTPMethod . GET , url ) def send_notification ( self , id_or_code : str ) -> Response : \"\"\"Send notification of a payment request to your customers Args: id_or_code: Payment Request id or code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/paymentrequest/notify/ { id_or_code } \" ) return self . _handle_request ( HTTPMethod . POST , url ) def get_total ( self ) -> Response : \"\"\"Get payment requests metric Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/paymentrequest/totals\" ) return self . _handle_request ( HTTPMethod . GET , url ) def finalize ( self , id_or_code : str ) -> Response : \"\"\"Finalize a draft payment request Args: id_or_code: Payment Request id or code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/paymentrequest/finalize/ { id_or_code } \" ) return self . _handle_request ( HTTPMethod . POST , url ) def update ( self , id_or_code : str , customer : str , amount : int , due_date : Optional [ str ] = None , description : Optional [ str ] = None , line_items : Optional [ list [ dict ]] = None , tax : Optional [ list [ dict ]] = None , currency : Optional [ Currency ] = None , send_notification : Optional [ bool ] = None , draft : Optional [ bool ] = None , invoice_number : Optional [ int ] = None , split_code : Optional [ str ] = None , ) -> Response : \"\"\"Update the payment request details on your integration Args: id_or_code: Payment Request id or code customer: Customer id or code amount: Payment request amount. Only useful if line items and tax values are ignored. method will throw a friendly warning in the response if neither is available. due_date: ISO 8601 representation of request due date description: A short description of the payment request line_items: List of line items in the format [{\"name\":\"item 1\", \"amount\":2000}] tax: List of taxes to be charged in the format [{\"name\":\"VAT\", \"amount\":2000}] currency: Specify the currency of the Payment Request id or code. Any value from the ``Currency`` enum send_notification: Indicates whether Paystack sends an email notification to customer. Defaults to ``True`` draft: Indicate if request should be saved as draft. Defaults to false and overrides send_notification invoice_number: Numeric value of invoice. Invoice will start from 1 and auto increment from there. This field is to help override whatever value Paystack decides. Auto increment for subsequent invoices continue from this point. split_code: The split code of the transaction split. e.g. SPL_98WF13Eb3w Returns: A named tuple containing the response gotten from paystack's server. \"\"\" amount = validate_amount ( amount ) url = self . _parse_url ( f \"/paymentrequest/ { id_or_code } \" ) payload = { \"customer\" : customer , \"amount\" : amount , } optional_params = [ ( \"due_date\" , due_date ), ( \"description\" , description ), ( \"line_items\" , line_items ), ( \"tax\" , tax ), ( \"currency\" , currency ), ( \"send_notification\" , send_notification ), ( \"draft\" , draft ), ( \"invoice_number\" , invoice_number ), ( \"split_code\" , split_code ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . PUT , url , payload ) def archive ( self , id_or_code : str ) -> Response : \"\"\"Used to archive a payment request. A payment request will no longer be fetched on list or returned on verify. Args: id_or_code: Payment Request id or code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/paymentrequest/archive/ { id_or_code } \" ) return self . _handle_request ( HTTPMethod . POST , url )","title":"PaymentRequest"},{"location":"reference/payment_requests/#pypaystack2.api.payment_requests.PaymentRequest.archive","text":"Used to archive a payment request. A payment request will no longer be fetched on list or returned on verify. Parameters: Name Type Description Default id_or_code str Payment Request id or code required Returns: A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/payment_requests.py 248 249 250 251 252 253 254 255 256 257 258 259 def archive ( self , id_or_code : str ) -> Response : \"\"\"Used to archive a payment request. A payment request will no longer be fetched on list or returned on verify. Args: id_or_code: Payment Request id or code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/paymentrequest/archive/ { id_or_code } \" ) return self . _handle_request ( HTTPMethod . POST , url )","title":"archive()"},{"location":"reference/payment_requests/#pypaystack2.api.payment_requests.PaymentRequest.create","text":"Create a payment request for a transaction on your integration Parameters: Name Type Description Default customer str Customer id or code required amount int Payment request amount. It should be used when line items and tax values aren't specified. required due_date Optional [ str ] ISO 8601 representation of request due date None description Optional [ str ] A short description of the payment request None line_items Optional [ list [ LineItem ]] List of line items int the format [{\"name\":\"item 1\", \"amount\":2000, \"quantity\": 1}] None tax Optional [ list [ Tax ]] List of taxes to be charged in the format [{\"name\":\"VAT\", \"amount\":2000}] None currency Optional [ Currency ] Any value from Currency enum. default Currency.NGN None send_notification Optional [ bool ] Indicates whether Paystack sends an email notification to customer. Defaults to True None draft Optional [ bool ] Indicate if request should be saved as draft. Defaults to False and overrides send_notification None has_invoice Optional [ bool ] Set to True to create a draft invoice (adds an auto-incrementing invoice number if none is provided) even if there are no line_items or tax passed None invoice_number Optional [ int ] Numeric value of invoice. Invoice will start from 1 and auto increment from there. This field is to help override whatever value Paystack decides. Auto increment for subsequent invoices continue from this point. None split_code Optional [ str ] The split code of the transaction split. e.g. SPL_98WF13Eb3w None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/payment_requests.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 def create ( self , customer : str , amount : int , due_date : Optional [ str ] = None , description : Optional [ str ] = None , line_items : Optional [ list [ LineItem ]] = None , tax : Optional [ list [ Tax ]] = None , currency : Optional [ Currency ] = None , send_notification : Optional [ bool ] = None , draft : Optional [ bool ] = None , has_invoice : Optional [ bool ] = None , invoice_number : Optional [ int ] = None , split_code : Optional [ str ] = None , ) -> Response : \"\"\"Create a payment request for a transaction on your integration Args: customer: Customer id or code amount: Payment request amount. It should be used when line items and tax values aren't specified. due_date: ISO 8601 representation of request due date description: A short description of the payment request line_items: List of line items int the format [{\"name\":\"item 1\", \"amount\":2000, \"quantity\": 1}] tax: List of taxes to be charged in the format [{\"name\":\"VAT\", \"amount\":2000}] currency: Any value from Currency enum. default ``Currency.NGN`` send_notification: Indicates whether Paystack sends an email notification to customer. Defaults to ``True`` draft: Indicate if request should be saved as draft. Defaults to ``False`` and overrides send_notification has_invoice: Set to ``True`` to create a draft invoice (adds an auto-incrementing invoice number if none is provided) even if there are no line_items or tax passed invoice_number: Numeric value of invoice. Invoice will start from 1 and auto increment from there. This field is to help override whatever value Paystack decides. Auto increment for subsequent invoices continue from this point. split_code: The split code of the transaction split. e.g. SPL_98WF13Eb3w Returns: A named tuple containing the response gotten from paystack's server. \"\"\" if line_items : line_items = [ item . dict for item in line_items ] if tax : tax = [ unit_tax . dict for unit_tax in tax ] url = self . _parse_url ( \"/paymentrequest\" ) payload = { \"customer\" : customer , \"amount\" : amount } optional_params = [ ( \"due_date\" , due_date ), ( \"description\" , description ), ( \"line_items\" , line_items ), ( \"tax\" , tax ), ( \"currency\" , currency ), ( \"send_notification\" , send_notification ), ( \"draft\" , draft ), ( \"has_invoice\" , has_invoice ), ( \"invoice_number\" , invoice_number ), ( \"split_code\" , split_code ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . POST , url , payload )","title":"create()"},{"location":"reference/payment_requests/#pypaystack2.api.payment_requests.PaymentRequest.finalize","text":"Finalize a draft payment request Parameters: Name Type Description Default id_or_code str Payment Request id or code required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/payment_requests.py 176 177 178 179 180 181 182 183 184 185 186 187 def finalize ( self , id_or_code : str ) -> Response : \"\"\"Finalize a draft payment request Args: id_or_code: Payment Request id or code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/paymentrequest/finalize/ { id_or_code } \" ) return self . _handle_request ( HTTPMethod . POST , url )","title":"finalize()"},{"location":"reference/payment_requests/#pypaystack2.api.payment_requests.PaymentRequest.get_payment_request","text":"Get details of a payment request on your integration Parameters: Name Type Description Default id_or_code str The payment request ID or code you want to fetch required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/payment_requests.py 127 128 129 130 131 132 133 134 135 136 137 138 def get_payment_request ( self , id_or_code : str ) -> Response : \"\"\"Get details of a payment request on your integration Args: id_or_code: The payment request ID or code you want to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/paymentrequest/ { id_or_code } \" ) return self . _handle_request ( HTTPMethod . GET , url )","title":"get_payment_request()"},{"location":"reference/payment_requests/#pypaystack2.api.payment_requests.PaymentRequest.get_payment_requests","text":"Fetches the payment requests available on your integration. Parameters: Name Type Description Default customer Optional [ str ] Filter by customer ID None status Optional [ Status ] Filter by payment request status. Any value from enum of Status None currency Optional [ Currency ] Filter by currency. Any value from enum of Currency None include_archive bool Show archived payment requests. False page int Specify exactly what payment request you want to page. If not specified, we use a default value of 1. 1 pagination int Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50. 50 start_date Optional [ str ] A timestamp from which to start listing payment requests e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None end_date Optional [ str ] A timestamp at which to stop listing payment requests e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/payment_requests.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 def get_payment_requests ( self , customer : Optional [ str ] = None , status : Optional [ Status ] = None , currency : Optional [ Currency ] = None , include_archive : bool = False , page : int = 1 , pagination : int = 50 , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , ) -> Response : \"\"\"Fetches the payment requests available on your integration. Args: customer: Filter by customer ID status: Filter by payment request status. Any value from enum of ``Status`` currency: Filter by currency. Any value from enum of ``Currency`` include_archive: Show archived payment requests. page: Specify exactly what payment request you want to page. If not specified, we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50. start_date: A timestamp from which to start listing payment requests e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing payment requests e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/paymentrequest?perPage= { pagination } \" ) query_params = [ ( \"customer\" , customer ), ( \"status\" , status ), ( \"currency\" , currency ), ( \"include_archive\" , include_archive ), ( \"page\" , page ), ( \"start_date\" , start_date ), ( \"end_date\" , end_date ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url )","title":"get_payment_requests()"},{"location":"reference/payment_requests/#pypaystack2.api.payment_requests.PaymentRequest.get_total","text":"Get payment requests metric Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/payment_requests.py 166 167 168 169 170 171 172 173 174 def get_total ( self ) -> Response : \"\"\"Get payment requests metric Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/paymentrequest/totals\" ) return self . _handle_request ( HTTPMethod . GET , url )","title":"get_total()"},{"location":"reference/payment_requests/#pypaystack2.api.payment_requests.PaymentRequest.send_notification","text":"Send notification of a payment request to your customers Parameters: Name Type Description Default id_or_code str Payment Request id or code required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/payment_requests.py 153 154 155 156 157 158 159 160 161 162 163 164 def send_notification ( self , id_or_code : str ) -> Response : \"\"\"Send notification of a payment request to your customers Args: id_or_code: Payment Request id or code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/paymentrequest/notify/ { id_or_code } \" ) return self . _handle_request ( HTTPMethod . POST , url )","title":"send_notification()"},{"location":"reference/payment_requests/#pypaystack2.api.payment_requests.PaymentRequest.update","text":"Update the payment request details on your integration Parameters: Name Type Description Default id_or_code str Payment Request id or code required customer str Customer id or code required amount int Payment request amount. Only useful if line items and tax values are ignored. method will throw a friendly warning in the response if neither is available. required due_date Optional [ str ] ISO 8601 representation of request due date None description Optional [ str ] A short description of the payment request None line_items Optional [ list [ dict ]] List of line items in the format [{\"name\":\"item 1\", \"amount\":2000}] None tax Optional [ list [ dict ]] List of taxes to be charged in the format [{\"name\":\"VAT\", \"amount\":2000}] None currency Optional [ Currency ] Specify the currency of the Payment Request id or code. Any value from the Currency enum None send_notification Optional [ bool ] Indicates whether Paystack sends an email notification to customer. Defaults to True None draft Optional [ bool ] Indicate if request should be saved as draft. Defaults to false and overrides send_notification None invoice_number Optional [ int ] Numeric value of invoice. Invoice will start from 1 and auto increment from there. This field is to help override whatever value Paystack decides. Auto increment for subsequent invoices continue from this point. None split_code Optional [ str ] The split code of the transaction split. e.g. SPL_98WF13Eb3w None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/payment_requests.py 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 def update ( self , id_or_code : str , customer : str , amount : int , due_date : Optional [ str ] = None , description : Optional [ str ] = None , line_items : Optional [ list [ dict ]] = None , tax : Optional [ list [ dict ]] = None , currency : Optional [ Currency ] = None , send_notification : Optional [ bool ] = None , draft : Optional [ bool ] = None , invoice_number : Optional [ int ] = None , split_code : Optional [ str ] = None , ) -> Response : \"\"\"Update the payment request details on your integration Args: id_or_code: Payment Request id or code customer: Customer id or code amount: Payment request amount. Only useful if line items and tax values are ignored. method will throw a friendly warning in the response if neither is available. due_date: ISO 8601 representation of request due date description: A short description of the payment request line_items: List of line items in the format [{\"name\":\"item 1\", \"amount\":2000}] tax: List of taxes to be charged in the format [{\"name\":\"VAT\", \"amount\":2000}] currency: Specify the currency of the Payment Request id or code. Any value from the ``Currency`` enum send_notification: Indicates whether Paystack sends an email notification to customer. Defaults to ``True`` draft: Indicate if request should be saved as draft. Defaults to false and overrides send_notification invoice_number: Numeric value of invoice. Invoice will start from 1 and auto increment from there. This field is to help override whatever value Paystack decides. Auto increment for subsequent invoices continue from this point. split_code: The split code of the transaction split. e.g. SPL_98WF13Eb3w Returns: A named tuple containing the response gotten from paystack's server. \"\"\" amount = validate_amount ( amount ) url = self . _parse_url ( f \"/paymentrequest/ { id_or_code } \" ) payload = { \"customer\" : customer , \"amount\" : amount , } optional_params = [ ( \"due_date\" , due_date ), ( \"description\" , description ), ( \"line_items\" , line_items ), ( \"tax\" , tax ), ( \"currency\" , currency ), ( \"send_notification\" , send_notification ), ( \"draft\" , draft ), ( \"invoice_number\" , invoice_number ), ( \"split_code\" , split_code ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . PUT , url , payload )","title":"update()"},{"location":"reference/payment_requests/#pypaystack2.api.payment_requests.PaymentRequest.verify","text":"Verify details of a payment request on your integration. Parameters: Name Type Description Default code str Payment Request id or code required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/payment_requests.py 140 141 142 143 144 145 146 147 148 149 150 151 def verify ( self , code : str ) -> Response : \"\"\"Verify details of a payment request on your integration. Args: code: Payment Request id or code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/paymentrequest/verify/ { code } \" ) return self . _handle_request ( HTTPMethod . GET , url )","title":"verify()"},{"location":"reference/plans/","text":"AsyncPlan Bases: BaseAsyncAPI Provides a wrapper for paystack Plans API The Plans API allows you to create and manage installment payment options on your integration. https://paystack.com/docs/api/#plan Source code in pypaystack2/api/plans.py 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 class AsyncPlan ( BaseAsyncAPI ): \"\"\"Provides a wrapper for paystack Plans API The Plans API allows you to create and manage installment payment options on your integration. https://paystack.com/docs/api/#plan \"\"\" async def create ( self , name : str , amount : int , interval : Interval , description : Optional [ str ] = None , currency : Optional [ Currency ] = None , invoice_limit : Optional [ int ] = None , send_invoices : bool = False , send_sms : bool = False , ) -> Response : \"\"\"Create a plan on your integration Args: name: Name of plan amount: Amount should be in kobo if currency is ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR`` interval: Any value from the ``Interval`` enum. description: A description for this plan currency: Currency in which amount is set. Any of the value from the ``Currency`` enum invoice_limit: Number of invoices to raise during subscription to this plan. Can be overridden by specifying an ``invoice_limit`` while subscribing send_invoices: Set to ``False`` if you don't want invoices to be sent to your customers send_sms: Set to ``False`` if you don't want text messages to be sent to your customers Returns: A named tuple containing the response gotten from paystack's server. \"\"\" interval = validate_interval ( interval ) amount = validate_amount ( amount ) url = self . _parse_url ( \"/plan/\" ) payload = { \"name\" : name , \"amount\" : amount , \"interval\" : interval , } optional_params = [ ( \"send_invoices\" , send_invoices ), ( \"send_sms\" , send_sms ), ( \"description\" , description ), ( \"currency\" , currency ), ( \"invoice_limit\" , invoice_limit ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) async def get_plans ( self , page : int = 1 , pagination : int = 50 , status : Optional [ Status ] = None , interval : Optional [ Interval ] = None , amount : Optional [ int ] = None , ) -> Response : \"\"\"Fetch plans available on your integration. Args: page: Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. status: Filter list by plans with specified status interval: Filter list by plans with specified interval amount: Filter list by plans with specified amount ( kobo if currency is ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR``) Returns: A named tuple containing the response gotten from paystack's server. \"\"\" if amount : amount = validate_amount ( amount ) url = self . _parse_url ( f \"/plan/?perPage= { pagination } \" ) query_params = [ ( \"page\" , page ), ( \"status\" , status ), ( \"interval\" , interval ), ( \"amount\" , amount ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url ) async def get_plan ( self , id_or_code : str ) -> Response : \"\"\"Get details of a plan on your integration. Args: id_or_code: The plan ``ID`` or ``code`` you want to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/plan/ {} /\" . format ( id_or_code )) return await self . _handle_request ( HTTPMethod . GET , url ) async def update ( self , id_or_code : str , name : Optional [ str ] = None , amount : Optional [ int ] = None , interval : Optional [ Interval ] = None , description : Optional [ str ] = None , currency : Optional [ Currency ] = None , invoice_limit : Optional [ int ] = None , send_invoices : bool = False , send_sms : bool = False , ) -> Response : \"\"\" Args: id_or_code: Plan's ID or code name: Name of plan amount: Amount should be in kobo if currency is ``Currency.NGN`` and pesewas for ``Currency.GHS`` interval: Any value from the ``Interval`` enum. description: A description for this plan. currency: Any value from the ``Currency`` enum. invoice_limit: Number of invoices to raise during subscription to this plan. Can be overridden by specifying an ``invoice_limit`` while subscribing. send_invoices: Set to ``False`` if you don't want invoices to be sent to your customers send_sms: Set to ``False`` if you don't want text messages to be sent to your customers Returns: A named tuple containing the response gotten from paystack's server. \"\"\" interval = validate_interval ( interval ) amount = validate_amount ( amount ) url = self . _parse_url ( \"/plan/ {} /\" . format ( id_or_code )) payload = { \"name\" : name , \"amount\" : amount , \"interval\" : interval , } optional_params = [ ( \"send_invoices\" , send_invoices ), ( \"send_sms\" , send_sms ), ( \"description\" , description ), ( \"currency\" , currency ), ( \"invoice_limit\" , invoice_limit ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . PUT , url , payload ) create ( name , amount , interval , description = None , currency = None , invoice_limit = None , send_invoices = False , send_sms = False ) async Create a plan on your integration Parameters: Name Type Description Default name str Name of plan required amount int Amount should be in kobo if currency is Currency.NGN , pesewas, if currency is Currency.GHS , and cents, if currency is Currency.ZAR required interval Interval Any value from the Interval enum. required description Optional [ str ] A description for this plan None currency Optional [ Currency ] Currency in which amount is set. Any of the value from the Currency enum None invoice_limit Optional [ int ] Number of invoices to raise during subscription to this plan. Can be overridden by specifying an invoice_limit while subscribing None send_invoices bool Set to False if you don't want invoices to be sent to your customers False send_sms bool Set to False if you don't want text messages to be sent to your customers False Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/plans.py 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 async def create ( self , name : str , amount : int , interval : Interval , description : Optional [ str ] = None , currency : Optional [ Currency ] = None , invoice_limit : Optional [ int ] = None , send_invoices : bool = False , send_sms : bool = False , ) -> Response : \"\"\"Create a plan on your integration Args: name: Name of plan amount: Amount should be in kobo if currency is ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR`` interval: Any value from the ``Interval`` enum. description: A description for this plan currency: Currency in which amount is set. Any of the value from the ``Currency`` enum invoice_limit: Number of invoices to raise during subscription to this plan. Can be overridden by specifying an ``invoice_limit`` while subscribing send_invoices: Set to ``False`` if you don't want invoices to be sent to your customers send_sms: Set to ``False`` if you don't want text messages to be sent to your customers Returns: A named tuple containing the response gotten from paystack's server. \"\"\" interval = validate_interval ( interval ) amount = validate_amount ( amount ) url = self . _parse_url ( \"/plan/\" ) payload = { \"name\" : name , \"amount\" : amount , \"interval\" : interval , } optional_params = [ ( \"send_invoices\" , send_invoices ), ( \"send_sms\" , send_sms ), ( \"description\" , description ), ( \"currency\" , currency ), ( \"invoice_limit\" , invoice_limit ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) get_plan ( id_or_code ) async Get details of a plan on your integration. Parameters: Name Type Description Default id_or_code str The plan ID or code you want to fetch required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/plans.py 273 274 275 276 277 278 279 280 281 282 283 async def get_plan ( self , id_or_code : str ) -> Response : \"\"\"Get details of a plan on your integration. Args: id_or_code: The plan ``ID`` or ``code`` you want to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/plan/ {} /\" . format ( id_or_code )) return await self . _handle_request ( HTTPMethod . GET , url ) get_plans ( page = 1 , pagination = 50 , status = None , interval = None , amount = None ) async Fetch plans available on your integration. Parameters: Name Type Description Default page int Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. 1 pagination int Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. 50 status Optional [ Status ] Filter list by plans with specified status None interval Optional [ Interval ] Filter list by plans with specified interval None amount Optional [ int ] Filter list by plans with specified amount ( kobo if currency is Currency.NGN , pesewas, if currency is Currency.GHS , and cents, if currency is Currency.ZAR ) None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/plans.py 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 async def get_plans ( self , page : int = 1 , pagination : int = 50 , status : Optional [ Status ] = None , interval : Optional [ Interval ] = None , amount : Optional [ int ] = None , ) -> Response : \"\"\"Fetch plans available on your integration. Args: page: Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. status: Filter list by plans with specified status interval: Filter list by plans with specified interval amount: Filter list by plans with specified amount ( kobo if currency is ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR``) Returns: A named tuple containing the response gotten from paystack's server. \"\"\" if amount : amount = validate_amount ( amount ) url = self . _parse_url ( f \"/plan/?perPage= { pagination } \" ) query_params = [ ( \"page\" , page ), ( \"status\" , status ), ( \"interval\" , interval ), ( \"amount\" , amount ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url ) update ( id_or_code , name = None , amount = None , interval = None , description = None , currency = None , invoice_limit = None , send_invoices = False , send_sms = False ) async Parameters: Name Type Description Default id_or_code str Plan's ID or code required name Optional [ str ] Name of plan None amount Optional [ int ] Amount should be in kobo if currency is Currency.NGN and pesewas for Currency.GHS None interval Optional [ Interval ] Any value from the Interval enum. None description Optional [ str ] A description for this plan. None currency Optional [ Currency ] Any value from the Currency enum. None invoice_limit Optional [ int ] Number of invoices to raise during subscription to this plan. Can be overridden by specifying an invoice_limit while subscribing. None send_invoices bool Set to False if you don't want invoices to be sent to your customers False send_sms bool Set to False if you don't want text messages to be sent to your customers False Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/plans.py 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 async def update ( self , id_or_code : str , name : Optional [ str ] = None , amount : Optional [ int ] = None , interval : Optional [ Interval ] = None , description : Optional [ str ] = None , currency : Optional [ Currency ] = None , invoice_limit : Optional [ int ] = None , send_invoices : bool = False , send_sms : bool = False , ) -> Response : \"\"\" Args: id_or_code: Plan's ID or code name: Name of plan amount: Amount should be in kobo if currency is ``Currency.NGN`` and pesewas for ``Currency.GHS`` interval: Any value from the ``Interval`` enum. description: A description for this plan. currency: Any value from the ``Currency`` enum. invoice_limit: Number of invoices to raise during subscription to this plan. Can be overridden by specifying an ``invoice_limit`` while subscribing. send_invoices: Set to ``False`` if you don't want invoices to be sent to your customers send_sms: Set to ``False`` if you don't want text messages to be sent to your customers Returns: A named tuple containing the response gotten from paystack's server. \"\"\" interval = validate_interval ( interval ) amount = validate_amount ( amount ) url = self . _parse_url ( \"/plan/ {} /\" . format ( id_or_code )) payload = { \"name\" : name , \"amount\" : amount , \"interval\" : interval , } optional_params = [ ( \"send_invoices\" , send_invoices ), ( \"send_sms\" , send_sms ), ( \"description\" , description ), ( \"currency\" , currency ), ( \"invoice_limit\" , invoice_limit ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . PUT , url , payload ) Plan Bases: BaseAPI Provides a wrapper for paystack Plans API The Plans API allows you to create and manage installment payment options on your integration. https://paystack.com/docs/api/#plan Source code in pypaystack2/api/plans.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 class Plan ( BaseAPI ): \"\"\"Provides a wrapper for paystack Plans API The Plans API allows you to create and manage installment payment options on your integration. https://paystack.com/docs/api/#plan \"\"\" def create ( self , name : str , amount : int , interval : Interval , description : Optional [ str ] = None , currency : Optional [ Currency ] = None , invoice_limit : Optional [ int ] = None , send_invoices : bool = False , send_sms : bool = False , ) -> Response : \"\"\"Create a plan on your integration Args: name: Name of plan amount: Amount should be in kobo if currency is ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR`` interval: Any value from the ``Interval`` enum. description: A description for this plan currency: Currency in which amount is set. Any of the value from the ``Currency`` enum invoice_limit: Number of invoices to raise during subscription to this plan. Can be overridden by specifying an ``invoice_limit`` while subscribing send_invoices: Set to ``False`` if you don't want invoices to be sent to your customers send_sms: Set to ``False`` if you don't want text messages to be sent to your customers Returns: A named tuple containing the response gotten from paystack's server. \"\"\" interval = validate_interval ( interval ) amount = validate_amount ( amount ) url = self . _parse_url ( \"/plan/\" ) payload = { \"name\" : name , \"amount\" : amount , \"interval\" : interval , } optional_params = [ ( \"send_invoices\" , send_invoices ), ( \"send_sms\" , send_sms ), ( \"description\" , description ), ( \"currency\" , currency ), ( \"invoice_limit\" , invoice_limit ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . POST , url , payload ) def get_plans ( self , page : int = 1 , pagination : int = 50 , status : Optional [ Status ] = None , interval : Optional [ Interval ] = None , amount : Optional [ int ] = None , ) -> Response : \"\"\"Fetch plans available on your integration. Args: page: Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50. status: Filter list by plans with specified status interval: Filter list by plans with specified interval amount: Filter list by plans with specified amount ( kobo if currency is ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR``) Returns: A named tuple containing the response gotten from paystack's server. \"\"\" if amount : amount = validate_amount ( amount ) url = self . _parse_url ( f \"/plan/?perPage= { pagination } \" ) query_params = [ ( \"page\" , page ), ( \"status\" , status ), ( \"interval\" , interval ), ( \"amount\" , amount ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url ) def get_plan ( self , id_or_code : str ) -> Response : \"\"\"Get details of a plan on your integration. Args: id_or_code: The plan ``ID`` or ``code`` you want to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/plan/ {} /\" . format ( id_or_code )) return self . _handle_request ( HTTPMethod . GET , url ) def update ( self , id_or_code : str , name : Optional [ str ], amount : Optional [ int ], interval : Optional [ Interval ], description : Optional [ str ] = None , currency : Optional [ Currency ] = None , invoice_limit : Optional [ int ] = None , send_invoices : bool = False , send_sms : bool = False , ) -> Response : \"\"\" Args: id_or_code: Plan's ID or code name: Name of plan amount: Amount should be in kobo if currency is ``Currency.NGN`` and pesewas for ``Currency.GHS`` interval: Any value from the ``Interval`` enum. description: A description for this plan. currency: Any value from the ``Currency`` enum. invoice_limit: Number of invoices to raise during subscription to this plan. Can be overridden by specifying an ``invoice_limit`` while subscribing. send_invoices: Set to ``False`` if you don't want invoices to be sent to your customers send_sms: Set to ``False`` if you don't want text messages to be sent to your customers Returns: A named tuple containing the response gotten from paystack's server. \"\"\" interval = validate_interval ( interval ) amount = validate_amount ( amount ) url = self . _parse_url ( \"/plan/ {} /\" . format ( id_or_code )) payload = { \"name\" : name , \"amount\" : amount , \"interval\" : interval , } optional_params = [ ( \"send_invoices\" , send_invoices ), ( \"send_sms\" , send_sms ), ( \"description\" , description ), ( \"currency\" , currency ), ( \"invoice_limit\" , invoice_limit ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . PUT , url , payload ) create ( name , amount , interval , description = None , currency = None , invoice_limit = None , send_invoices = False , send_sms = False ) Create a plan on your integration Parameters: Name Type Description Default name str Name of plan required amount int Amount should be in kobo if currency is Currency.NGN , pesewas, if currency is Currency.GHS , and cents, if currency is Currency.ZAR required interval Interval Any value from the Interval enum. required description Optional [ str ] A description for this plan None currency Optional [ Currency ] Currency in which amount is set. Any of the value from the Currency enum None invoice_limit Optional [ int ] Number of invoices to raise during subscription to this plan. Can be overridden by specifying an invoice_limit while subscribing None send_invoices bool Set to False if you don't want invoices to be sent to your customers False send_sms bool Set to False if you don't want text messages to be sent to your customers False Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/plans.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 def create ( self , name : str , amount : int , interval : Interval , description : Optional [ str ] = None , currency : Optional [ Currency ] = None , invoice_limit : Optional [ int ] = None , send_invoices : bool = False , send_sms : bool = False , ) -> Response : \"\"\"Create a plan on your integration Args: name: Name of plan amount: Amount should be in kobo if currency is ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR`` interval: Any value from the ``Interval`` enum. description: A description for this plan currency: Currency in which amount is set. Any of the value from the ``Currency`` enum invoice_limit: Number of invoices to raise during subscription to this plan. Can be overridden by specifying an ``invoice_limit`` while subscribing send_invoices: Set to ``False`` if you don't want invoices to be sent to your customers send_sms: Set to ``False`` if you don't want text messages to be sent to your customers Returns: A named tuple containing the response gotten from paystack's server. \"\"\" interval = validate_interval ( interval ) amount = validate_amount ( amount ) url = self . _parse_url ( \"/plan/\" ) payload = { \"name\" : name , \"amount\" : amount , \"interval\" : interval , } optional_params = [ ( \"send_invoices\" , send_invoices ), ( \"send_sms\" , send_sms ), ( \"description\" , description ), ( \"currency\" , currency ), ( \"invoice_limit\" , invoice_limit ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . POST , url , payload ) get_plan ( id_or_code ) Get details of a plan on your integration. Parameters: Name Type Description Default id_or_code str The plan ID or code you want to fetch required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/plans.py 112 113 114 115 116 117 118 119 120 121 122 def get_plan ( self , id_or_code : str ) -> Response : \"\"\"Get details of a plan on your integration. Args: id_or_code: The plan ``ID`` or ``code`` you want to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/plan/ {} /\" . format ( id_or_code )) return self . _handle_request ( HTTPMethod . GET , url ) get_plans ( page = 1 , pagination = 50 , status = None , interval = None , amount = None ) Fetch plans available on your integration. Parameters: Name Type Description Default page int Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1. 1 pagination int Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50. 50 status Optional [ Status ] Filter list by plans with specified status None interval Optional [ Interval ] Filter list by plans with specified interval None amount Optional [ int ] Filter list by plans with specified amount ( kobo if currency is Currency.NGN , pesewas, if currency is Currency.GHS , and cents, if currency is Currency.ZAR ) None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/plans.py 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 def get_plans ( self , page : int = 1 , pagination : int = 50 , status : Optional [ Status ] = None , interval : Optional [ Interval ] = None , amount : Optional [ int ] = None , ) -> Response : \"\"\"Fetch plans available on your integration. Args: page: Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50. status: Filter list by plans with specified status interval: Filter list by plans with specified interval amount: Filter list by plans with specified amount ( kobo if currency is ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR``) Returns: A named tuple containing the response gotten from paystack's server. \"\"\" if amount : amount = validate_amount ( amount ) url = self . _parse_url ( f \"/plan/?perPage= { pagination } \" ) query_params = [ ( \"page\" , page ), ( \"status\" , status ), ( \"interval\" , interval ), ( \"amount\" , amount ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url ) update ( id_or_code , name , amount , interval , description = None , currency = None , invoice_limit = None , send_invoices = False , send_sms = False ) Parameters: Name Type Description Default id_or_code str Plan's ID or code required name Optional [ str ] Name of plan required amount Optional [ int ] Amount should be in kobo if currency is Currency.NGN and pesewas for Currency.GHS required interval Optional [ Interval ] Any value from the Interval enum. required description Optional [ str ] A description for this plan. None currency Optional [ Currency ] Any value from the Currency enum. None invoice_limit Optional [ int ] Number of invoices to raise during subscription to this plan. Can be overridden by specifying an invoice_limit while subscribing. None send_invoices bool Set to False if you don't want invoices to be sent to your customers False send_sms bool Set to False if you don't want text messages to be sent to your customers False Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/plans.py 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 def update ( self , id_or_code : str , name : Optional [ str ], amount : Optional [ int ], interval : Optional [ Interval ], description : Optional [ str ] = None , currency : Optional [ Currency ] = None , invoice_limit : Optional [ int ] = None , send_invoices : bool = False , send_sms : bool = False , ) -> Response : \"\"\" Args: id_or_code: Plan's ID or code name: Name of plan amount: Amount should be in kobo if currency is ``Currency.NGN`` and pesewas for ``Currency.GHS`` interval: Any value from the ``Interval`` enum. description: A description for this plan. currency: Any value from the ``Currency`` enum. invoice_limit: Number of invoices to raise during subscription to this plan. Can be overridden by specifying an ``invoice_limit`` while subscribing. send_invoices: Set to ``False`` if you don't want invoices to be sent to your customers send_sms: Set to ``False`` if you don't want text messages to be sent to your customers Returns: A named tuple containing the response gotten from paystack's server. \"\"\" interval = validate_interval ( interval ) amount = validate_amount ( amount ) url = self . _parse_url ( \"/plan/ {} /\" . format ( id_or_code )) payload = { \"name\" : name , \"amount\" : amount , \"interval\" : interval , } optional_params = [ ( \"send_invoices\" , send_invoices ), ( \"send_sms\" , send_sms ), ( \"description\" , description ), ( \"currency\" , currency ), ( \"invoice_limit\" , invoice_limit ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . PUT , url , payload )","title":"Plans"},{"location":"reference/plans/#pypaystack2.api.plans.AsyncPlan","text":"Bases: BaseAsyncAPI Provides a wrapper for paystack Plans API The Plans API allows you to create and manage installment payment options on your integration. https://paystack.com/docs/api/#plan Source code in pypaystack2/api/plans.py 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 class AsyncPlan ( BaseAsyncAPI ): \"\"\"Provides a wrapper for paystack Plans API The Plans API allows you to create and manage installment payment options on your integration. https://paystack.com/docs/api/#plan \"\"\" async def create ( self , name : str , amount : int , interval : Interval , description : Optional [ str ] = None , currency : Optional [ Currency ] = None , invoice_limit : Optional [ int ] = None , send_invoices : bool = False , send_sms : bool = False , ) -> Response : \"\"\"Create a plan on your integration Args: name: Name of plan amount: Amount should be in kobo if currency is ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR`` interval: Any value from the ``Interval`` enum. description: A description for this plan currency: Currency in which amount is set. Any of the value from the ``Currency`` enum invoice_limit: Number of invoices to raise during subscription to this plan. Can be overridden by specifying an ``invoice_limit`` while subscribing send_invoices: Set to ``False`` if you don't want invoices to be sent to your customers send_sms: Set to ``False`` if you don't want text messages to be sent to your customers Returns: A named tuple containing the response gotten from paystack's server. \"\"\" interval = validate_interval ( interval ) amount = validate_amount ( amount ) url = self . _parse_url ( \"/plan/\" ) payload = { \"name\" : name , \"amount\" : amount , \"interval\" : interval , } optional_params = [ ( \"send_invoices\" , send_invoices ), ( \"send_sms\" , send_sms ), ( \"description\" , description ), ( \"currency\" , currency ), ( \"invoice_limit\" , invoice_limit ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) async def get_plans ( self , page : int = 1 , pagination : int = 50 , status : Optional [ Status ] = None , interval : Optional [ Interval ] = None , amount : Optional [ int ] = None , ) -> Response : \"\"\"Fetch plans available on your integration. Args: page: Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. status: Filter list by plans with specified status interval: Filter list by plans with specified interval amount: Filter list by plans with specified amount ( kobo if currency is ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR``) Returns: A named tuple containing the response gotten from paystack's server. \"\"\" if amount : amount = validate_amount ( amount ) url = self . _parse_url ( f \"/plan/?perPage= { pagination } \" ) query_params = [ ( \"page\" , page ), ( \"status\" , status ), ( \"interval\" , interval ), ( \"amount\" , amount ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url ) async def get_plan ( self , id_or_code : str ) -> Response : \"\"\"Get details of a plan on your integration. Args: id_or_code: The plan ``ID`` or ``code`` you want to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/plan/ {} /\" . format ( id_or_code )) return await self . _handle_request ( HTTPMethod . GET , url ) async def update ( self , id_or_code : str , name : Optional [ str ] = None , amount : Optional [ int ] = None , interval : Optional [ Interval ] = None , description : Optional [ str ] = None , currency : Optional [ Currency ] = None , invoice_limit : Optional [ int ] = None , send_invoices : bool = False , send_sms : bool = False , ) -> Response : \"\"\" Args: id_or_code: Plan's ID or code name: Name of plan amount: Amount should be in kobo if currency is ``Currency.NGN`` and pesewas for ``Currency.GHS`` interval: Any value from the ``Interval`` enum. description: A description for this plan. currency: Any value from the ``Currency`` enum. invoice_limit: Number of invoices to raise during subscription to this plan. Can be overridden by specifying an ``invoice_limit`` while subscribing. send_invoices: Set to ``False`` if you don't want invoices to be sent to your customers send_sms: Set to ``False`` if you don't want text messages to be sent to your customers Returns: A named tuple containing the response gotten from paystack's server. \"\"\" interval = validate_interval ( interval ) amount = validate_amount ( amount ) url = self . _parse_url ( \"/plan/ {} /\" . format ( id_or_code )) payload = { \"name\" : name , \"amount\" : amount , \"interval\" : interval , } optional_params = [ ( \"send_invoices\" , send_invoices ), ( \"send_sms\" , send_sms ), ( \"description\" , description ), ( \"currency\" , currency ), ( \"invoice_limit\" , invoice_limit ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . PUT , url , payload )","title":"AsyncPlan"},{"location":"reference/plans/#pypaystack2.api.plans.AsyncPlan.create","text":"Create a plan on your integration Parameters: Name Type Description Default name str Name of plan required amount int Amount should be in kobo if currency is Currency.NGN , pesewas, if currency is Currency.GHS , and cents, if currency is Currency.ZAR required interval Interval Any value from the Interval enum. required description Optional [ str ] A description for this plan None currency Optional [ Currency ] Currency in which amount is set. Any of the value from the Currency enum None invoice_limit Optional [ int ] Number of invoices to raise during subscription to this plan. Can be overridden by specifying an invoice_limit while subscribing None send_invoices bool Set to False if you don't want invoices to be sent to your customers False send_sms bool Set to False if you don't want text messages to be sent to your customers False Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/plans.py 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 async def create ( self , name : str , amount : int , interval : Interval , description : Optional [ str ] = None , currency : Optional [ Currency ] = None , invoice_limit : Optional [ int ] = None , send_invoices : bool = False , send_sms : bool = False , ) -> Response : \"\"\"Create a plan on your integration Args: name: Name of plan amount: Amount should be in kobo if currency is ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR`` interval: Any value from the ``Interval`` enum. description: A description for this plan currency: Currency in which amount is set. Any of the value from the ``Currency`` enum invoice_limit: Number of invoices to raise during subscription to this plan. Can be overridden by specifying an ``invoice_limit`` while subscribing send_invoices: Set to ``False`` if you don't want invoices to be sent to your customers send_sms: Set to ``False`` if you don't want text messages to be sent to your customers Returns: A named tuple containing the response gotten from paystack's server. \"\"\" interval = validate_interval ( interval ) amount = validate_amount ( amount ) url = self . _parse_url ( \"/plan/\" ) payload = { \"name\" : name , \"amount\" : amount , \"interval\" : interval , } optional_params = [ ( \"send_invoices\" , send_invoices ), ( \"send_sms\" , send_sms ), ( \"description\" , description ), ( \"currency\" , currency ), ( \"invoice_limit\" , invoice_limit ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . POST , url , payload )","title":"create()"},{"location":"reference/plans/#pypaystack2.api.plans.AsyncPlan.get_plan","text":"Get details of a plan on your integration. Parameters: Name Type Description Default id_or_code str The plan ID or code you want to fetch required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/plans.py 273 274 275 276 277 278 279 280 281 282 283 async def get_plan ( self , id_or_code : str ) -> Response : \"\"\"Get details of a plan on your integration. Args: id_or_code: The plan ``ID`` or ``code`` you want to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/plan/ {} /\" . format ( id_or_code )) return await self . _handle_request ( HTTPMethod . GET , url )","title":"get_plan()"},{"location":"reference/plans/#pypaystack2.api.plans.AsyncPlan.get_plans","text":"Fetch plans available on your integration. Parameters: Name Type Description Default page int Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. 1 pagination int Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. 50 status Optional [ Status ] Filter list by plans with specified status None interval Optional [ Interval ] Filter list by plans with specified interval None amount Optional [ int ] Filter list by plans with specified amount ( kobo if currency is Currency.NGN , pesewas, if currency is Currency.GHS , and cents, if currency is Currency.ZAR ) None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/plans.py 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 async def get_plans ( self , page : int = 1 , pagination : int = 50 , status : Optional [ Status ] = None , interval : Optional [ Interval ] = None , amount : Optional [ int ] = None , ) -> Response : \"\"\"Fetch plans available on your integration. Args: page: Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. status: Filter list by plans with specified status interval: Filter list by plans with specified interval amount: Filter list by plans with specified amount ( kobo if currency is ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR``) Returns: A named tuple containing the response gotten from paystack's server. \"\"\" if amount : amount = validate_amount ( amount ) url = self . _parse_url ( f \"/plan/?perPage= { pagination } \" ) query_params = [ ( \"page\" , page ), ( \"status\" , status ), ( \"interval\" , interval ), ( \"amount\" , amount ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url )","title":"get_plans()"},{"location":"reference/plans/#pypaystack2.api.plans.AsyncPlan.update","text":"Parameters: Name Type Description Default id_or_code str Plan's ID or code required name Optional [ str ] Name of plan None amount Optional [ int ] Amount should be in kobo if currency is Currency.NGN and pesewas for Currency.GHS None interval Optional [ Interval ] Any value from the Interval enum. None description Optional [ str ] A description for this plan. None currency Optional [ Currency ] Any value from the Currency enum. None invoice_limit Optional [ int ] Number of invoices to raise during subscription to this plan. Can be overridden by specifying an invoice_limit while subscribing. None send_invoices bool Set to False if you don't want invoices to be sent to your customers False send_sms bool Set to False if you don't want text messages to be sent to your customers False Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/plans.py 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 async def update ( self , id_or_code : str , name : Optional [ str ] = None , amount : Optional [ int ] = None , interval : Optional [ Interval ] = None , description : Optional [ str ] = None , currency : Optional [ Currency ] = None , invoice_limit : Optional [ int ] = None , send_invoices : bool = False , send_sms : bool = False , ) -> Response : \"\"\" Args: id_or_code: Plan's ID or code name: Name of plan amount: Amount should be in kobo if currency is ``Currency.NGN`` and pesewas for ``Currency.GHS`` interval: Any value from the ``Interval`` enum. description: A description for this plan. currency: Any value from the ``Currency`` enum. invoice_limit: Number of invoices to raise during subscription to this plan. Can be overridden by specifying an ``invoice_limit`` while subscribing. send_invoices: Set to ``False`` if you don't want invoices to be sent to your customers send_sms: Set to ``False`` if you don't want text messages to be sent to your customers Returns: A named tuple containing the response gotten from paystack's server. \"\"\" interval = validate_interval ( interval ) amount = validate_amount ( amount ) url = self . _parse_url ( \"/plan/ {} /\" . format ( id_or_code )) payload = { \"name\" : name , \"amount\" : amount , \"interval\" : interval , } optional_params = [ ( \"send_invoices\" , send_invoices ), ( \"send_sms\" , send_sms ), ( \"description\" , description ), ( \"currency\" , currency ), ( \"invoice_limit\" , invoice_limit ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . PUT , url , payload )","title":"update()"},{"location":"reference/plans/#pypaystack2.api.plans.Plan","text":"Bases: BaseAPI Provides a wrapper for paystack Plans API The Plans API allows you to create and manage installment payment options on your integration. https://paystack.com/docs/api/#plan Source code in pypaystack2/api/plans.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 class Plan ( BaseAPI ): \"\"\"Provides a wrapper for paystack Plans API The Plans API allows you to create and manage installment payment options on your integration. https://paystack.com/docs/api/#plan \"\"\" def create ( self , name : str , amount : int , interval : Interval , description : Optional [ str ] = None , currency : Optional [ Currency ] = None , invoice_limit : Optional [ int ] = None , send_invoices : bool = False , send_sms : bool = False , ) -> Response : \"\"\"Create a plan on your integration Args: name: Name of plan amount: Amount should be in kobo if currency is ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR`` interval: Any value from the ``Interval`` enum. description: A description for this plan currency: Currency in which amount is set. Any of the value from the ``Currency`` enum invoice_limit: Number of invoices to raise during subscription to this plan. Can be overridden by specifying an ``invoice_limit`` while subscribing send_invoices: Set to ``False`` if you don't want invoices to be sent to your customers send_sms: Set to ``False`` if you don't want text messages to be sent to your customers Returns: A named tuple containing the response gotten from paystack's server. \"\"\" interval = validate_interval ( interval ) amount = validate_amount ( amount ) url = self . _parse_url ( \"/plan/\" ) payload = { \"name\" : name , \"amount\" : amount , \"interval\" : interval , } optional_params = [ ( \"send_invoices\" , send_invoices ), ( \"send_sms\" , send_sms ), ( \"description\" , description ), ( \"currency\" , currency ), ( \"invoice_limit\" , invoice_limit ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . POST , url , payload ) def get_plans ( self , page : int = 1 , pagination : int = 50 , status : Optional [ Status ] = None , interval : Optional [ Interval ] = None , amount : Optional [ int ] = None , ) -> Response : \"\"\"Fetch plans available on your integration. Args: page: Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50. status: Filter list by plans with specified status interval: Filter list by plans with specified interval amount: Filter list by plans with specified amount ( kobo if currency is ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR``) Returns: A named tuple containing the response gotten from paystack's server. \"\"\" if amount : amount = validate_amount ( amount ) url = self . _parse_url ( f \"/plan/?perPage= { pagination } \" ) query_params = [ ( \"page\" , page ), ( \"status\" , status ), ( \"interval\" , interval ), ( \"amount\" , amount ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url ) def get_plan ( self , id_or_code : str ) -> Response : \"\"\"Get details of a plan on your integration. Args: id_or_code: The plan ``ID`` or ``code`` you want to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/plan/ {} /\" . format ( id_or_code )) return self . _handle_request ( HTTPMethod . GET , url ) def update ( self , id_or_code : str , name : Optional [ str ], amount : Optional [ int ], interval : Optional [ Interval ], description : Optional [ str ] = None , currency : Optional [ Currency ] = None , invoice_limit : Optional [ int ] = None , send_invoices : bool = False , send_sms : bool = False , ) -> Response : \"\"\" Args: id_or_code: Plan's ID or code name: Name of plan amount: Amount should be in kobo if currency is ``Currency.NGN`` and pesewas for ``Currency.GHS`` interval: Any value from the ``Interval`` enum. description: A description for this plan. currency: Any value from the ``Currency`` enum. invoice_limit: Number of invoices to raise during subscription to this plan. Can be overridden by specifying an ``invoice_limit`` while subscribing. send_invoices: Set to ``False`` if you don't want invoices to be sent to your customers send_sms: Set to ``False`` if you don't want text messages to be sent to your customers Returns: A named tuple containing the response gotten from paystack's server. \"\"\" interval = validate_interval ( interval ) amount = validate_amount ( amount ) url = self . _parse_url ( \"/plan/ {} /\" . format ( id_or_code )) payload = { \"name\" : name , \"amount\" : amount , \"interval\" : interval , } optional_params = [ ( \"send_invoices\" , send_invoices ), ( \"send_sms\" , send_sms ), ( \"description\" , description ), ( \"currency\" , currency ), ( \"invoice_limit\" , invoice_limit ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . PUT , url , payload )","title":"Plan"},{"location":"reference/plans/#pypaystack2.api.plans.Plan.create","text":"Create a plan on your integration Parameters: Name Type Description Default name str Name of plan required amount int Amount should be in kobo if currency is Currency.NGN , pesewas, if currency is Currency.GHS , and cents, if currency is Currency.ZAR required interval Interval Any value from the Interval enum. required description Optional [ str ] A description for this plan None currency Optional [ Currency ] Currency in which amount is set. Any of the value from the Currency enum None invoice_limit Optional [ int ] Number of invoices to raise during subscription to this plan. Can be overridden by specifying an invoice_limit while subscribing None send_invoices bool Set to False if you don't want invoices to be sent to your customers False send_sms bool Set to False if you don't want text messages to be sent to your customers False Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/plans.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 def create ( self , name : str , amount : int , interval : Interval , description : Optional [ str ] = None , currency : Optional [ Currency ] = None , invoice_limit : Optional [ int ] = None , send_invoices : bool = False , send_sms : bool = False , ) -> Response : \"\"\"Create a plan on your integration Args: name: Name of plan amount: Amount should be in kobo if currency is ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR`` interval: Any value from the ``Interval`` enum. description: A description for this plan currency: Currency in which amount is set. Any of the value from the ``Currency`` enum invoice_limit: Number of invoices to raise during subscription to this plan. Can be overridden by specifying an ``invoice_limit`` while subscribing send_invoices: Set to ``False`` if you don't want invoices to be sent to your customers send_sms: Set to ``False`` if you don't want text messages to be sent to your customers Returns: A named tuple containing the response gotten from paystack's server. \"\"\" interval = validate_interval ( interval ) amount = validate_amount ( amount ) url = self . _parse_url ( \"/plan/\" ) payload = { \"name\" : name , \"amount\" : amount , \"interval\" : interval , } optional_params = [ ( \"send_invoices\" , send_invoices ), ( \"send_sms\" , send_sms ), ( \"description\" , description ), ( \"currency\" , currency ), ( \"invoice_limit\" , invoice_limit ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . POST , url , payload )","title":"create()"},{"location":"reference/plans/#pypaystack2.api.plans.Plan.get_plan","text":"Get details of a plan on your integration. Parameters: Name Type Description Default id_or_code str The plan ID or code you want to fetch required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/plans.py 112 113 114 115 116 117 118 119 120 121 122 def get_plan ( self , id_or_code : str ) -> Response : \"\"\"Get details of a plan on your integration. Args: id_or_code: The plan ``ID`` or ``code`` you want to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/plan/ {} /\" . format ( id_or_code )) return self . _handle_request ( HTTPMethod . GET , url )","title":"get_plan()"},{"location":"reference/plans/#pypaystack2.api.plans.Plan.get_plans","text":"Fetch plans available on your integration. Parameters: Name Type Description Default page int Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1. 1 pagination int Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50. 50 status Optional [ Status ] Filter list by plans with specified status None interval Optional [ Interval ] Filter list by plans with specified interval None amount Optional [ int ] Filter list by plans with specified amount ( kobo if currency is Currency.NGN , pesewas, if currency is Currency.GHS , and cents, if currency is Currency.ZAR ) None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/plans.py 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 def get_plans ( self , page : int = 1 , pagination : int = 50 , status : Optional [ Status ] = None , interval : Optional [ Interval ] = None , amount : Optional [ int ] = None , ) -> Response : \"\"\"Fetch plans available on your integration. Args: page: Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50. status: Filter list by plans with specified status interval: Filter list by plans with specified interval amount: Filter list by plans with specified amount ( kobo if currency is ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR``) Returns: A named tuple containing the response gotten from paystack's server. \"\"\" if amount : amount = validate_amount ( amount ) url = self . _parse_url ( f \"/plan/?perPage= { pagination } \" ) query_params = [ ( \"page\" , page ), ( \"status\" , status ), ( \"interval\" , interval ), ( \"amount\" , amount ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url )","title":"get_plans()"},{"location":"reference/plans/#pypaystack2.api.plans.Plan.update","text":"Parameters: Name Type Description Default id_or_code str Plan's ID or code required name Optional [ str ] Name of plan required amount Optional [ int ] Amount should be in kobo if currency is Currency.NGN and pesewas for Currency.GHS required interval Optional [ Interval ] Any value from the Interval enum. required description Optional [ str ] A description for this plan. None currency Optional [ Currency ] Any value from the Currency enum. None invoice_limit Optional [ int ] Number of invoices to raise during subscription to this plan. Can be overridden by specifying an invoice_limit while subscribing. None send_invoices bool Set to False if you don't want invoices to be sent to your customers False send_sms bool Set to False if you don't want text messages to be sent to your customers False Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/plans.py 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 def update ( self , id_or_code : str , name : Optional [ str ], amount : Optional [ int ], interval : Optional [ Interval ], description : Optional [ str ] = None , currency : Optional [ Currency ] = None , invoice_limit : Optional [ int ] = None , send_invoices : bool = False , send_sms : bool = False , ) -> Response : \"\"\" Args: id_or_code: Plan's ID or code name: Name of plan amount: Amount should be in kobo if currency is ``Currency.NGN`` and pesewas for ``Currency.GHS`` interval: Any value from the ``Interval`` enum. description: A description for this plan. currency: Any value from the ``Currency`` enum. invoice_limit: Number of invoices to raise during subscription to this plan. Can be overridden by specifying an ``invoice_limit`` while subscribing. send_invoices: Set to ``False`` if you don't want invoices to be sent to your customers send_sms: Set to ``False`` if you don't want text messages to be sent to your customers Returns: A named tuple containing the response gotten from paystack's server. \"\"\" interval = validate_interval ( interval ) amount = validate_amount ( amount ) url = self . _parse_url ( \"/plan/ {} /\" . format ( id_or_code )) payload = { \"name\" : name , \"amount\" : amount , \"interval\" : interval , } optional_params = [ ( \"send_invoices\" , send_invoices ), ( \"send_sms\" , send_sms ), ( \"description\" , description ), ( \"currency\" , currency ), ( \"invoice_limit\" , invoice_limit ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . PUT , url , payload )","title":"update()"},{"location":"reference/products/","text":"AsyncProduct Bases: BaseAsyncAPI Provides a wrapper for paystack Products API The Products API allows you to create and manage inventories on your integration. https://paystack.com/docs/api/#product Source code in pypaystack2/api/products.py 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 class AsyncProduct ( BaseAsyncAPI ): \"\"\"Provides a wrapper for paystack Products API The Products API allows you to create and manage inventories on your integration. https://paystack.com/docs/api/#product \"\"\" async def create ( self , name : str , description : str , price : int , currency : Currency , unlimited : Optional [ bool ] = None , quantity : Optional [ int ] = None , ) -> Response : \"\"\"Create a product on your integration Args: name: Name of product description: A description for this product price: Price should be in kobo if currency is ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR`` currency: Any value from the ``Currency`` enum unlimited: Set to ``True`` if the product has unlimited stock. Leave as ``False`` if the product has limited stock quantity: Number of products in stock. Use if unlimited is ``False`` Returns: A named tuple containing the response gotten from paystack's server. Raises: InvalidDataError: When unlimited is set to True and quantity has a value. \"\"\" if unlimited is True and quantity is not None : raise InvalidDataError ( \"You can't have unlimited set to True and have a quantity value.\" ) url = self . _parse_url ( \"/product\" ) payload = { \"name\" : name , \"description\" : description , \"price\" : price , \"currency\" : currency , } optional_params = [ ( \"unlimited\" , unlimited ), ( \"quantity\" , quantity ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) async def get_products ( self , page : int = 1 , pagination : int = 50 , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , ) -> Response : \"\"\"Fetches products available on your integration. Args: page: Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. start_date: A timestamp from which to start listing product e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: timestamp at which to stop listing product e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/product?perPage=\" + str ( pagination )) query_params = [ ( \"page\" , page ), ( \"start_date\" , start_date ), ( \"end_date\" , end_date ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url ) async def get_product ( self , id : str ) -> Response : \"\"\"Get details of a product on your integration. Args: id: The product ``ID`` you want to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/product/ { id } \" ) return await self . _handle_request ( HTTPMethod . GET , url ) async def update ( self , id : str , name : str , description : str , price : int , currency : Currency , unlimited : Optional [ bool ] = None , quantity : Optional [ int ] = None , ) -> Response : \"\"\"Update a product details on your integration Args: id: Product ID name: Name of product description: A description for this product price: Price should be in kobo if currency is ``Currency.NGN``, pesewas, if currency is GHS, and cents, if currency is ``Currency.ZAR`` currency: Any value from the ``Currency`` enum unlimited: Set to ``True`` if the product has unlimited stock. Leave as ``False`` if the product has limited stock quantity: Number of products in stock. Use if unlimited is ``False`` Returns: A named tuple containing the response gotten from paystack's server. Raises: InvalidDataError: When unlimited is set to True and quantity has a value. \"\"\" if unlimited is True and quantity is not None : raise InvalidDataError ( \"You can't have unlimited set to True and quantity have a value.\" ) url = self . _parse_url ( f \"/product/ { id } \" ) payload = { \"name\" : name , \"description\" : description , \"price\" : price , \"currency\" : currency , } optional_params = [ ( \"unlimited\" , unlimited ), ( \"quantity\" , quantity ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . PUT , url , payload ) create ( name , description , price , currency , unlimited = None , quantity = None ) async Create a product on your integration Parameters: Name Type Description Default name str Name of product required description str A description for this product required price int Price should be in kobo if currency is Currency.NGN , pesewas, if currency is Currency.GHS , and cents, if currency is Currency.ZAR required currency Currency Any value from the Currency enum required unlimited Optional [ bool ] Set to True if the product has unlimited stock. Leave as False if the product has limited stock None quantity Optional [ int ] Number of products in stock. Use if unlimited is False None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Raises: Type Description InvalidDataError When unlimited is set to True and quantity has a value. Source code in pypaystack2/api/products.py 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 async def create ( self , name : str , description : str , price : int , currency : Currency , unlimited : Optional [ bool ] = None , quantity : Optional [ int ] = None , ) -> Response : \"\"\"Create a product on your integration Args: name: Name of product description: A description for this product price: Price should be in kobo if currency is ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR`` currency: Any value from the ``Currency`` enum unlimited: Set to ``True`` if the product has unlimited stock. Leave as ``False`` if the product has limited stock quantity: Number of products in stock. Use if unlimited is ``False`` Returns: A named tuple containing the response gotten from paystack's server. Raises: InvalidDataError: When unlimited is set to True and quantity has a value. \"\"\" if unlimited is True and quantity is not None : raise InvalidDataError ( \"You can't have unlimited set to True and have a quantity value.\" ) url = self . _parse_url ( \"/product\" ) payload = { \"name\" : name , \"description\" : description , \"price\" : price , \"currency\" : currency , } optional_params = [ ( \"unlimited\" , unlimited ), ( \"quantity\" , quantity ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) get_product ( id ) async Get details of a product on your integration. Parameters: Name Type Description Default id str The product ID you want to fetch required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/products.py 246 247 248 249 250 251 252 253 254 255 256 257 async def get_product ( self , id : str ) -> Response : \"\"\"Get details of a product on your integration. Args: id: The product ``ID`` you want to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/product/ { id } \" ) return await self . _handle_request ( HTTPMethod . GET , url ) get_products ( page = 1 , pagination = 50 , start_date = None , end_date = None ) async Fetches products available on your integration. Parameters: Name Type Description Default page int Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. 1 pagination int Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. 50 start_date Optional [ str ] A timestamp from which to start listing product e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None end_date Optional [ str ] timestamp at which to stop listing product e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/products.py 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 async def get_products ( self , page : int = 1 , pagination : int = 50 , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , ) -> Response : \"\"\"Fetches products available on your integration. Args: page: Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. start_date: A timestamp from which to start listing product e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: timestamp at which to stop listing product e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/product?perPage=\" + str ( pagination )) query_params = [ ( \"page\" , page ), ( \"start_date\" , start_date ), ( \"end_date\" , end_date ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url ) update ( id , name , description , price , currency , unlimited = None , quantity = None ) async Update a product details on your integration Parameters: Name Type Description Default id str Product ID required name str Name of product required description str A description for this product required price int Price should be in kobo if currency is Currency.NGN , pesewas, if currency is GHS, and cents, if currency is Currency.ZAR required currency Currency Any value from the Currency enum required unlimited Optional [ bool ] Set to True if the product has unlimited stock. Leave as False if the product has limited stock None quantity Optional [ int ] Number of products in stock. Use if unlimited is False None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Raises: Type Description InvalidDataError When unlimited is set to True and quantity has a value. Source code in pypaystack2/api/products.py 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 async def update ( self , id : str , name : str , description : str , price : int , currency : Currency , unlimited : Optional [ bool ] = None , quantity : Optional [ int ] = None , ) -> Response : \"\"\"Update a product details on your integration Args: id: Product ID name: Name of product description: A description for this product price: Price should be in kobo if currency is ``Currency.NGN``, pesewas, if currency is GHS, and cents, if currency is ``Currency.ZAR`` currency: Any value from the ``Currency`` enum unlimited: Set to ``True`` if the product has unlimited stock. Leave as ``False`` if the product has limited stock quantity: Number of products in stock. Use if unlimited is ``False`` Returns: A named tuple containing the response gotten from paystack's server. Raises: InvalidDataError: When unlimited is set to True and quantity has a value. \"\"\" if unlimited is True and quantity is not None : raise InvalidDataError ( \"You can't have unlimited set to True and quantity have a value.\" ) url = self . _parse_url ( f \"/product/ { id } \" ) payload = { \"name\" : name , \"description\" : description , \"price\" : price , \"currency\" : currency , } optional_params = [ ( \"unlimited\" , unlimited ), ( \"quantity\" , quantity ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . PUT , url , payload ) Product Bases: BaseAPI Provides a wrapper for paystack Products API The Products API allows you to create and manage inventories on your integration. https://paystack.com/docs/api/#product Source code in pypaystack2/api/products.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 class Product ( BaseAPI ): \"\"\"Provides a wrapper for paystack Products API The Products API allows you to create and manage inventories on your integration. https://paystack.com/docs/api/#product \"\"\" def create ( self , name : str , description : str , price : int , currency : Currency , unlimited : Optional [ bool ] = None , quantity : Optional [ int ] = None , ) -> Response : \"\"\"Create a product on your integration Args: name: Name of product description: A description for this product price: Price should be in kobo if currency is ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR`` currency: Any value from the ``Currency`` enum unlimited: Set to ``True`` if the product has unlimited stock. Leave as ``False`` if the product has limited stock quantity: Number of products in stock. Use if unlimited is ``False`` Returns: A named tuple containing the response gotten from paystack's server. Raises: InvalidDataError: When unlimited is set to True and quantity has a value. \"\"\" if unlimited is True and quantity is not None : raise InvalidDataError ( \"You can't have unlimited set to True and have a quantity value.\" ) url = self . _parse_url ( \"/product\" ) payload = { \"name\" : name , \"description\" : description , \"price\" : price , \"currency\" : currency , } optional_params = [ ( \"unlimited\" , unlimited ), ( \"quantity\" , quantity ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . POST , url , payload ) def get_products ( self , page : int = 1 , pagination : int = 50 , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , ) -> Response : \"\"\"Fetches products available on your integration. Args: page: Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. start_date: A timestamp from which to start listing product e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: timestamp at which to stop listing product e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/product?perPage=\" + str ( pagination )) query_params = [ ( \"page\" , page ), ( \"start_date\" , start_date ), ( \"end_date\" , end_date ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url ) def get_product ( self , id : str ) -> Response : \"\"\"Get details of a product on your integration. Args: id: The product ``ID`` you want to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/product/ { id } \" ) return self . _handle_request ( HTTPMethod . GET , url ) def update ( self , id : str , name : str , description : str , price : int , currency : Currency , unlimited : Optional [ bool ] = None , quantity : Optional [ int ] = None , ) -> Response : \"\"\"Update a product details on your integration Args: id: Product ID name: Name of product description: A description for this product price: Price should be in kobo if currency is ``Currency.NGN``, pesewas, if currency is GHS, and cents, if currency is ``Currency.ZAR`` currency: Any value from the ``Currency`` enum unlimited: Set to ``True`` if the product has unlimited stock. Leave as ``False`` if the product has limited stock quantity: Number of products in stock. Use if unlimited is ``False`` Returns: A named tuple containing the response gotten from paystack's server. Raises: InvalidDataError: When unlimited is set to True and quantity has a value. \"\"\" if unlimited is True and quantity is not None : raise InvalidDataError ( \"You can't have unlimited set to True and quantity have a value.\" ) url = self . _parse_url ( f \"/product/ { id } \" ) payload = { \"name\" : name , \"description\" : description , \"price\" : price , \"currency\" : currency , } optional_params = [ ( \"unlimited\" , unlimited ), ( \"quantity\" , quantity ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . PUT , url , payload ) create ( name , description , price , currency , unlimited = None , quantity = None ) Create a product on your integration Parameters: Name Type Description Default name str Name of product required description str A description for this product required price int Price should be in kobo if currency is Currency.NGN , pesewas, if currency is Currency.GHS , and cents, if currency is Currency.ZAR required currency Currency Any value from the Currency enum required unlimited Optional [ bool ] Set to True if the product has unlimited stock. Leave as False if the product has limited stock None quantity Optional [ int ] Number of products in stock. Use if unlimited is False None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Raises: Type Description InvalidDataError When unlimited is set to True and quantity has a value. Source code in pypaystack2/api/products.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 def create ( self , name : str , description : str , price : int , currency : Currency , unlimited : Optional [ bool ] = None , quantity : Optional [ int ] = None , ) -> Response : \"\"\"Create a product on your integration Args: name: Name of product description: A description for this product price: Price should be in kobo if currency is ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR`` currency: Any value from the ``Currency`` enum unlimited: Set to ``True`` if the product has unlimited stock. Leave as ``False`` if the product has limited stock quantity: Number of products in stock. Use if unlimited is ``False`` Returns: A named tuple containing the response gotten from paystack's server. Raises: InvalidDataError: When unlimited is set to True and quantity has a value. \"\"\" if unlimited is True and quantity is not None : raise InvalidDataError ( \"You can't have unlimited set to True and have a quantity value.\" ) url = self . _parse_url ( \"/product\" ) payload = { \"name\" : name , \"description\" : description , \"price\" : price , \"currency\" : currency , } optional_params = [ ( \"unlimited\" , unlimited ), ( \"quantity\" , quantity ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . POST , url , payload ) get_product ( id ) Get details of a product on your integration. Parameters: Name Type Description Default id str The product ID you want to fetch required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/products.py 99 100 101 102 103 104 105 106 107 108 109 110 def get_product ( self , id : str ) -> Response : \"\"\"Get details of a product on your integration. Args: id: The product ``ID`` you want to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/product/ { id } \" ) return self . _handle_request ( HTTPMethod . GET , url ) get_products ( page = 1 , pagination = 50 , start_date = None , end_date = None ) Fetches products available on your integration. Parameters: Name Type Description Default page int Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. 1 pagination int Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. 50 start_date Optional [ str ] A timestamp from which to start listing product e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None end_date Optional [ str ] timestamp at which to stop listing product e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/products.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 def get_products ( self , page : int = 1 , pagination : int = 50 , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , ) -> Response : \"\"\"Fetches products available on your integration. Args: page: Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. start_date: A timestamp from which to start listing product e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: timestamp at which to stop listing product e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/product?perPage=\" + str ( pagination )) query_params = [ ( \"page\" , page ), ( \"start_date\" , start_date ), ( \"end_date\" , end_date ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url ) update ( id , name , description , price , currency , unlimited = None , quantity = None ) Update a product details on your integration Parameters: Name Type Description Default id str Product ID required name str Name of product required description str A description for this product required price int Price should be in kobo if currency is Currency.NGN , pesewas, if currency is GHS, and cents, if currency is Currency.ZAR required currency Currency Any value from the Currency enum required unlimited Optional [ bool ] Set to True if the product has unlimited stock. Leave as False if the product has limited stock None quantity Optional [ int ] Number of products in stock. Use if unlimited is False None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Raises: Type Description InvalidDataError When unlimited is set to True and quantity has a value. Source code in pypaystack2/api/products.py 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 def update ( self , id : str , name : str , description : str , price : int , currency : Currency , unlimited : Optional [ bool ] = None , quantity : Optional [ int ] = None , ) -> Response : \"\"\"Update a product details on your integration Args: id: Product ID name: Name of product description: A description for this product price: Price should be in kobo if currency is ``Currency.NGN``, pesewas, if currency is GHS, and cents, if currency is ``Currency.ZAR`` currency: Any value from the ``Currency`` enum unlimited: Set to ``True`` if the product has unlimited stock. Leave as ``False`` if the product has limited stock quantity: Number of products in stock. Use if unlimited is ``False`` Returns: A named tuple containing the response gotten from paystack's server. Raises: InvalidDataError: When unlimited is set to True and quantity has a value. \"\"\" if unlimited is True and quantity is not None : raise InvalidDataError ( \"You can't have unlimited set to True and quantity have a value.\" ) url = self . _parse_url ( f \"/product/ { id } \" ) payload = { \"name\" : name , \"description\" : description , \"price\" : price , \"currency\" : currency , } optional_params = [ ( \"unlimited\" , unlimited ), ( \"quantity\" , quantity ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . PUT , url , payload )","title":"Products"},{"location":"reference/products/#pypaystack2.api.products.AsyncProduct","text":"Bases: BaseAsyncAPI Provides a wrapper for paystack Products API The Products API allows you to create and manage inventories on your integration. https://paystack.com/docs/api/#product Source code in pypaystack2/api/products.py 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 class AsyncProduct ( BaseAsyncAPI ): \"\"\"Provides a wrapper for paystack Products API The Products API allows you to create and manage inventories on your integration. https://paystack.com/docs/api/#product \"\"\" async def create ( self , name : str , description : str , price : int , currency : Currency , unlimited : Optional [ bool ] = None , quantity : Optional [ int ] = None , ) -> Response : \"\"\"Create a product on your integration Args: name: Name of product description: A description for this product price: Price should be in kobo if currency is ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR`` currency: Any value from the ``Currency`` enum unlimited: Set to ``True`` if the product has unlimited stock. Leave as ``False`` if the product has limited stock quantity: Number of products in stock. Use if unlimited is ``False`` Returns: A named tuple containing the response gotten from paystack's server. Raises: InvalidDataError: When unlimited is set to True and quantity has a value. \"\"\" if unlimited is True and quantity is not None : raise InvalidDataError ( \"You can't have unlimited set to True and have a quantity value.\" ) url = self . _parse_url ( \"/product\" ) payload = { \"name\" : name , \"description\" : description , \"price\" : price , \"currency\" : currency , } optional_params = [ ( \"unlimited\" , unlimited ), ( \"quantity\" , quantity ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) async def get_products ( self , page : int = 1 , pagination : int = 50 , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , ) -> Response : \"\"\"Fetches products available on your integration. Args: page: Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. start_date: A timestamp from which to start listing product e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: timestamp at which to stop listing product e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/product?perPage=\" + str ( pagination )) query_params = [ ( \"page\" , page ), ( \"start_date\" , start_date ), ( \"end_date\" , end_date ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url ) async def get_product ( self , id : str ) -> Response : \"\"\"Get details of a product on your integration. Args: id: The product ``ID`` you want to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/product/ { id } \" ) return await self . _handle_request ( HTTPMethod . GET , url ) async def update ( self , id : str , name : str , description : str , price : int , currency : Currency , unlimited : Optional [ bool ] = None , quantity : Optional [ int ] = None , ) -> Response : \"\"\"Update a product details on your integration Args: id: Product ID name: Name of product description: A description for this product price: Price should be in kobo if currency is ``Currency.NGN``, pesewas, if currency is GHS, and cents, if currency is ``Currency.ZAR`` currency: Any value from the ``Currency`` enum unlimited: Set to ``True`` if the product has unlimited stock. Leave as ``False`` if the product has limited stock quantity: Number of products in stock. Use if unlimited is ``False`` Returns: A named tuple containing the response gotten from paystack's server. Raises: InvalidDataError: When unlimited is set to True and quantity has a value. \"\"\" if unlimited is True and quantity is not None : raise InvalidDataError ( \"You can't have unlimited set to True and quantity have a value.\" ) url = self . _parse_url ( f \"/product/ { id } \" ) payload = { \"name\" : name , \"description\" : description , \"price\" : price , \"currency\" : currency , } optional_params = [ ( \"unlimited\" , unlimited ), ( \"quantity\" , quantity ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . PUT , url , payload )","title":"AsyncProduct"},{"location":"reference/products/#pypaystack2.api.products.AsyncProduct.create","text":"Create a product on your integration Parameters: Name Type Description Default name str Name of product required description str A description for this product required price int Price should be in kobo if currency is Currency.NGN , pesewas, if currency is Currency.GHS , and cents, if currency is Currency.ZAR required currency Currency Any value from the Currency enum required unlimited Optional [ bool ] Set to True if the product has unlimited stock. Leave as False if the product has limited stock None quantity Optional [ int ] Number of products in stock. Use if unlimited is False None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Raises: Type Description InvalidDataError When unlimited is set to True and quantity has a value. Source code in pypaystack2/api/products.py 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 async def create ( self , name : str , description : str , price : int , currency : Currency , unlimited : Optional [ bool ] = None , quantity : Optional [ int ] = None , ) -> Response : \"\"\"Create a product on your integration Args: name: Name of product description: A description for this product price: Price should be in kobo if currency is ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR`` currency: Any value from the ``Currency`` enum unlimited: Set to ``True`` if the product has unlimited stock. Leave as ``False`` if the product has limited stock quantity: Number of products in stock. Use if unlimited is ``False`` Returns: A named tuple containing the response gotten from paystack's server. Raises: InvalidDataError: When unlimited is set to True and quantity has a value. \"\"\" if unlimited is True and quantity is not None : raise InvalidDataError ( \"You can't have unlimited set to True and have a quantity value.\" ) url = self . _parse_url ( \"/product\" ) payload = { \"name\" : name , \"description\" : description , \"price\" : price , \"currency\" : currency , } optional_params = [ ( \"unlimited\" , unlimited ), ( \"quantity\" , quantity ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . POST , url , payload )","title":"create()"},{"location":"reference/products/#pypaystack2.api.products.AsyncProduct.get_product","text":"Get details of a product on your integration. Parameters: Name Type Description Default id str The product ID you want to fetch required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/products.py 246 247 248 249 250 251 252 253 254 255 256 257 async def get_product ( self , id : str ) -> Response : \"\"\"Get details of a product on your integration. Args: id: The product ``ID`` you want to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/product/ { id } \" ) return await self . _handle_request ( HTTPMethod . GET , url )","title":"get_product()"},{"location":"reference/products/#pypaystack2.api.products.AsyncProduct.get_products","text":"Fetches products available on your integration. Parameters: Name Type Description Default page int Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. 1 pagination int Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. 50 start_date Optional [ str ] A timestamp from which to start listing product e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None end_date Optional [ str ] timestamp at which to stop listing product e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/products.py 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 async def get_products ( self , page : int = 1 , pagination : int = 50 , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , ) -> Response : \"\"\"Fetches products available on your integration. Args: page: Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. start_date: A timestamp from which to start listing product e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: timestamp at which to stop listing product e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/product?perPage=\" + str ( pagination )) query_params = [ ( \"page\" , page ), ( \"start_date\" , start_date ), ( \"end_date\" , end_date ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url )","title":"get_products()"},{"location":"reference/products/#pypaystack2.api.products.AsyncProduct.update","text":"Update a product details on your integration Parameters: Name Type Description Default id str Product ID required name str Name of product required description str A description for this product required price int Price should be in kobo if currency is Currency.NGN , pesewas, if currency is GHS, and cents, if currency is Currency.ZAR required currency Currency Any value from the Currency enum required unlimited Optional [ bool ] Set to True if the product has unlimited stock. Leave as False if the product has limited stock None quantity Optional [ int ] Number of products in stock. Use if unlimited is False None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Raises: Type Description InvalidDataError When unlimited is set to True and quantity has a value. Source code in pypaystack2/api/products.py 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 async def update ( self , id : str , name : str , description : str , price : int , currency : Currency , unlimited : Optional [ bool ] = None , quantity : Optional [ int ] = None , ) -> Response : \"\"\"Update a product details on your integration Args: id: Product ID name: Name of product description: A description for this product price: Price should be in kobo if currency is ``Currency.NGN``, pesewas, if currency is GHS, and cents, if currency is ``Currency.ZAR`` currency: Any value from the ``Currency`` enum unlimited: Set to ``True`` if the product has unlimited stock. Leave as ``False`` if the product has limited stock quantity: Number of products in stock. Use if unlimited is ``False`` Returns: A named tuple containing the response gotten from paystack's server. Raises: InvalidDataError: When unlimited is set to True and quantity has a value. \"\"\" if unlimited is True and quantity is not None : raise InvalidDataError ( \"You can't have unlimited set to True and quantity have a value.\" ) url = self . _parse_url ( f \"/product/ { id } \" ) payload = { \"name\" : name , \"description\" : description , \"price\" : price , \"currency\" : currency , } optional_params = [ ( \"unlimited\" , unlimited ), ( \"quantity\" , quantity ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . PUT , url , payload )","title":"update()"},{"location":"reference/products/#pypaystack2.api.products.Product","text":"Bases: BaseAPI Provides a wrapper for paystack Products API The Products API allows you to create and manage inventories on your integration. https://paystack.com/docs/api/#product Source code in pypaystack2/api/products.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 class Product ( BaseAPI ): \"\"\"Provides a wrapper for paystack Products API The Products API allows you to create and manage inventories on your integration. https://paystack.com/docs/api/#product \"\"\" def create ( self , name : str , description : str , price : int , currency : Currency , unlimited : Optional [ bool ] = None , quantity : Optional [ int ] = None , ) -> Response : \"\"\"Create a product on your integration Args: name: Name of product description: A description for this product price: Price should be in kobo if currency is ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR`` currency: Any value from the ``Currency`` enum unlimited: Set to ``True`` if the product has unlimited stock. Leave as ``False`` if the product has limited stock quantity: Number of products in stock. Use if unlimited is ``False`` Returns: A named tuple containing the response gotten from paystack's server. Raises: InvalidDataError: When unlimited is set to True and quantity has a value. \"\"\" if unlimited is True and quantity is not None : raise InvalidDataError ( \"You can't have unlimited set to True and have a quantity value.\" ) url = self . _parse_url ( \"/product\" ) payload = { \"name\" : name , \"description\" : description , \"price\" : price , \"currency\" : currency , } optional_params = [ ( \"unlimited\" , unlimited ), ( \"quantity\" , quantity ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . POST , url , payload ) def get_products ( self , page : int = 1 , pagination : int = 50 , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , ) -> Response : \"\"\"Fetches products available on your integration. Args: page: Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. start_date: A timestamp from which to start listing product e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: timestamp at which to stop listing product e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/product?perPage=\" + str ( pagination )) query_params = [ ( \"page\" , page ), ( \"start_date\" , start_date ), ( \"end_date\" , end_date ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url ) def get_product ( self , id : str ) -> Response : \"\"\"Get details of a product on your integration. Args: id: The product ``ID`` you want to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/product/ { id } \" ) return self . _handle_request ( HTTPMethod . GET , url ) def update ( self , id : str , name : str , description : str , price : int , currency : Currency , unlimited : Optional [ bool ] = None , quantity : Optional [ int ] = None , ) -> Response : \"\"\"Update a product details on your integration Args: id: Product ID name: Name of product description: A description for this product price: Price should be in kobo if currency is ``Currency.NGN``, pesewas, if currency is GHS, and cents, if currency is ``Currency.ZAR`` currency: Any value from the ``Currency`` enum unlimited: Set to ``True`` if the product has unlimited stock. Leave as ``False`` if the product has limited stock quantity: Number of products in stock. Use if unlimited is ``False`` Returns: A named tuple containing the response gotten from paystack's server. Raises: InvalidDataError: When unlimited is set to True and quantity has a value. \"\"\" if unlimited is True and quantity is not None : raise InvalidDataError ( \"You can't have unlimited set to True and quantity have a value.\" ) url = self . _parse_url ( f \"/product/ { id } \" ) payload = { \"name\" : name , \"description\" : description , \"price\" : price , \"currency\" : currency , } optional_params = [ ( \"unlimited\" , unlimited ), ( \"quantity\" , quantity ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . PUT , url , payload )","title":"Product"},{"location":"reference/products/#pypaystack2.api.products.Product.create","text":"Create a product on your integration Parameters: Name Type Description Default name str Name of product required description str A description for this product required price int Price should be in kobo if currency is Currency.NGN , pesewas, if currency is Currency.GHS , and cents, if currency is Currency.ZAR required currency Currency Any value from the Currency enum required unlimited Optional [ bool ] Set to True if the product has unlimited stock. Leave as False if the product has limited stock None quantity Optional [ int ] Number of products in stock. Use if unlimited is False None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Raises: Type Description InvalidDataError When unlimited is set to True and quantity has a value. Source code in pypaystack2/api/products.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 def create ( self , name : str , description : str , price : int , currency : Currency , unlimited : Optional [ bool ] = None , quantity : Optional [ int ] = None , ) -> Response : \"\"\"Create a product on your integration Args: name: Name of product description: A description for this product price: Price should be in kobo if currency is ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR`` currency: Any value from the ``Currency`` enum unlimited: Set to ``True`` if the product has unlimited stock. Leave as ``False`` if the product has limited stock quantity: Number of products in stock. Use if unlimited is ``False`` Returns: A named tuple containing the response gotten from paystack's server. Raises: InvalidDataError: When unlimited is set to True and quantity has a value. \"\"\" if unlimited is True and quantity is not None : raise InvalidDataError ( \"You can't have unlimited set to True and have a quantity value.\" ) url = self . _parse_url ( \"/product\" ) payload = { \"name\" : name , \"description\" : description , \"price\" : price , \"currency\" : currency , } optional_params = [ ( \"unlimited\" , unlimited ), ( \"quantity\" , quantity ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . POST , url , payload )","title":"create()"},{"location":"reference/products/#pypaystack2.api.products.Product.get_product","text":"Get details of a product on your integration. Parameters: Name Type Description Default id str The product ID you want to fetch required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/products.py 99 100 101 102 103 104 105 106 107 108 109 110 def get_product ( self , id : str ) -> Response : \"\"\"Get details of a product on your integration. Args: id: The product ``ID`` you want to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/product/ { id } \" ) return self . _handle_request ( HTTPMethod . GET , url )","title":"get_product()"},{"location":"reference/products/#pypaystack2.api.products.Product.get_products","text":"Fetches products available on your integration. Parameters: Name Type Description Default page int Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. 1 pagination int Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. 50 start_date Optional [ str ] A timestamp from which to start listing product e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None end_date Optional [ str ] timestamp at which to stop listing product e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/products.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 def get_products ( self , page : int = 1 , pagination : int = 50 , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , ) -> Response : \"\"\"Fetches products available on your integration. Args: page: Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. start_date: A timestamp from which to start listing product e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: timestamp at which to stop listing product e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/product?perPage=\" + str ( pagination )) query_params = [ ( \"page\" , page ), ( \"start_date\" , start_date ), ( \"end_date\" , end_date ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url )","title":"get_products()"},{"location":"reference/products/#pypaystack2.api.products.Product.update","text":"Update a product details on your integration Parameters: Name Type Description Default id str Product ID required name str Name of product required description str A description for this product required price int Price should be in kobo if currency is Currency.NGN , pesewas, if currency is GHS, and cents, if currency is Currency.ZAR required currency Currency Any value from the Currency enum required unlimited Optional [ bool ] Set to True if the product has unlimited stock. Leave as False if the product has limited stock None quantity Optional [ int ] Number of products in stock. Use if unlimited is False None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Raises: Type Description InvalidDataError When unlimited is set to True and quantity has a value. Source code in pypaystack2/api/products.py 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 def update ( self , id : str , name : str , description : str , price : int , currency : Currency , unlimited : Optional [ bool ] = None , quantity : Optional [ int ] = None , ) -> Response : \"\"\"Update a product details on your integration Args: id: Product ID name: Name of product description: A description for this product price: Price should be in kobo if currency is ``Currency.NGN``, pesewas, if currency is GHS, and cents, if currency is ``Currency.ZAR`` currency: Any value from the ``Currency`` enum unlimited: Set to ``True`` if the product has unlimited stock. Leave as ``False`` if the product has limited stock quantity: Number of products in stock. Use if unlimited is ``False`` Returns: A named tuple containing the response gotten from paystack's server. Raises: InvalidDataError: When unlimited is set to True and quantity has a value. \"\"\" if unlimited is True and quantity is not None : raise InvalidDataError ( \"You can't have unlimited set to True and quantity have a value.\" ) url = self . _parse_url ( f \"/product/ { id } \" ) payload = { \"name\" : name , \"description\" : description , \"price\" : price , \"currency\" : currency , } optional_params = [ ( \"unlimited\" , unlimited ), ( \"quantity\" , quantity ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . PUT , url , payload )","title":"update()"},{"location":"reference/refunds/","text":"AsyncRefund Bases: BaseAsyncAPI Provides a wrapper for paystack Refunds API The Refunds API allows you to create and manage transaction refunds. https://paystack.com/docs/api/#refund Source code in pypaystack2/api/refunds.py 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 class AsyncRefund ( BaseAsyncAPI ): \"\"\"Provides a wrapper for paystack Refunds API The Refunds API allows you to create and manage transaction refunds. https://paystack.com/docs/api/#refund \"\"\" async def create ( self , transaction : str , amount : Optional [ int ] = None , currency : Optional [ Currency ] = None , customer_note : Optional [ str ] = None , merchant_note : Optional [ str ] = None , ) -> Response : \"\"\"Initiate a refund on your integration Args: transaction: Transaction reference or id amount: Amount ( in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR ) to be refunded to the customer. Amount is optional(defaults to original transaction amount) and cannot be more than the original transaction amount currency: Any value from the ``Currency`` enum customer_note: Customer reason merchant_note: Merchant reason Returns: A named tuple containing the response gotten from paystack's server. \"\"\" if amount is not None : amount = validate_amount ( amount ) url = self . _parse_url ( \"/refund\" ) payload = { \"transaction\" : transaction } optional_params = [ ( \"amount\" , amount ), ( \"currency\" , currency ), ( \"customer_note\" , customer_note ), ( \"merchant_note\" , merchant_note ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) async def get_refunds ( self , reference : Optional [ str ] = None , currency : Optional [ Currency ] = None , pagination : int = 50 , page : int = 1 , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , ) -> Response : \"\"\"Fetch refunds available on your integration. Args: reference: Identifier for transaction to be refunded currency: Any value from the ``Currency`` enum pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. page: Specifies exactly what refund you want to page. If not specified we use a default value of 1. start_date: A timestamp from which to start listing refund e.g. 2016-09-21 end_date: A timestamp at which to stop listing refund e.g. 2016-09-21 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/refund?perPage= { pagination } \" ) query_params = [ ( \"reference\" , reference ), ( \"currency\" , currency ), ( \"page\" , page ), ( \"start_date\" , start_date ), ( \"end_date\" , end_date ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url ) async def get_refund ( self , reference : str ) -> Response : \"\"\"Get details of a refund on your integration. Args: reference: Identifier for transaction to be refunded Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/refund/ { reference } \" ) return await self . _handle_request ( HTTPMethod . GET , url ) create ( transaction , amount = None , currency = None , customer_note = None , merchant_note = None ) async Initiate a refund on your integration Parameters: Name Type Description Default transaction str Transaction reference or id required amount Optional [ int ] Amount ( in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR ) to be refunded to the customer. Amount is optional(defaults to original transaction amount) and cannot be more than the original transaction amount None currency Optional [ Currency ] Any value from the Currency enum None customer_note Optional [ str ] Customer reason None merchant_note Optional [ str ] Merchant reason None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/refunds.py 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 async def create ( self , transaction : str , amount : Optional [ int ] = None , currency : Optional [ Currency ] = None , customer_note : Optional [ str ] = None , merchant_note : Optional [ str ] = None , ) -> Response : \"\"\"Initiate a refund on your integration Args: transaction: Transaction reference or id amount: Amount ( in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR ) to be refunded to the customer. Amount is optional(defaults to original transaction amount) and cannot be more than the original transaction amount currency: Any value from the ``Currency`` enum customer_note: Customer reason merchant_note: Merchant reason Returns: A named tuple containing the response gotten from paystack's server. \"\"\" if amount is not None : amount = validate_amount ( amount ) url = self . _parse_url ( \"/refund\" ) payload = { \"transaction\" : transaction } optional_params = [ ( \"amount\" , amount ), ( \"currency\" , currency ), ( \"customer_note\" , customer_note ), ( \"merchant_note\" , merchant_note ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) get_refund ( reference ) async Get details of a refund on your integration. Parameters: Name Type Description Default reference str Identifier for transaction to be refunded required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/refunds.py 190 191 192 193 194 195 196 197 198 199 200 201 async def get_refund ( self , reference : str ) -> Response : \"\"\"Get details of a refund on your integration. Args: reference: Identifier for transaction to be refunded Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/refund/ { reference } \" ) return await self . _handle_request ( HTTPMethod . GET , url ) get_refunds ( reference = None , currency = None , pagination = 50 , page = 1 , start_date = None , end_date = None ) async Fetch refunds available on your integration. Parameters: Name Type Description Default reference Optional [ str ] Identifier for transaction to be refunded None currency Optional [ Currency ] Any value from the Currency enum None pagination int Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. 50 page int Specifies exactly what refund you want to page. If not specified we use a default value of 1. 1 start_date Optional [ str ] A timestamp from which to start listing refund e.g. 2016-09-21 None end_date Optional [ str ] A timestamp at which to stop listing refund e.g. 2016-09-21 None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/refunds.py 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 async def get_refunds ( self , reference : Optional [ str ] = None , currency : Optional [ Currency ] = None , pagination : int = 50 , page : int = 1 , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , ) -> Response : \"\"\"Fetch refunds available on your integration. Args: reference: Identifier for transaction to be refunded currency: Any value from the ``Currency`` enum pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. page: Specifies exactly what refund you want to page. If not specified we use a default value of 1. start_date: A timestamp from which to start listing refund e.g. 2016-09-21 end_date: A timestamp at which to stop listing refund e.g. 2016-09-21 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/refund?perPage= { pagination } \" ) query_params = [ ( \"reference\" , reference ), ( \"currency\" , currency ), ( \"page\" , page ), ( \"start_date\" , start_date ), ( \"end_date\" , end_date ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url ) Refund Bases: BaseAPI Provides a wrapper for paystack Refunds API The Refunds API allows you to create and manage transaction refunds. https://paystack.com/docs/api/#refund Source code in pypaystack2/api/refunds.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 class Refund ( BaseAPI ): \"\"\"Provides a wrapper for paystack Refunds API The Refunds API allows you to create and manage transaction refunds. https://paystack.com/docs/api/#refund \"\"\" def create ( self , transaction : str , amount : Optional [ int ] = None , currency : Optional [ Currency ] = None , customer_note : Optional [ str ] = None , merchant_note : Optional [ str ] = None , ) -> Response : \"\"\"Initiate a refund on your integration Args: transaction: Transaction reference or id amount: Amount ( in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR ) to be refunded to the customer. Amount is optional(defaults to original transaction amount) and cannot be more than the original transaction amount currency: Any value from the ``Currency`` enum customer_note: Customer reason merchant_note: Merchant reason Returns: A named tuple containing the response gotten from paystack's server. \"\"\" if amount is not None : amount = validate_amount ( amount ) url = self . _parse_url ( \"/refund\" ) payload = { \"transaction\" : transaction } optional_params = [ ( \"amount\" , amount ), ( \"currency\" , currency ), ( \"customer_note\" , customer_note ), ( \"merchant_note\" , merchant_note ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . POST , url , payload ) def get_refunds ( self , reference : Optional [ str ] = None , currency : Optional [ Currency ] = None , pagination : int = 50 , page : int = 1 , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , ) -> Response : \"\"\"Fetch refunds available on your integration. Args: reference: Identifier for transaction to be refunded currency: Any value from the ``Currency`` enum pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. page: Specifies exactly what refund you want to page. If not specified we use a default value of 1. start_date: A timestamp from which to start listing refund e.g. 2016-09-21 end_date: A timestamp at which to stop listing refund e.g. 2016-09-21 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/refund?perPage= { pagination } \" ) query_params = [ ( \"reference\" , reference ), ( \"currency\" , currency ), ( \"page\" , page ), ( \"start_date\" , start_date ), ( \"end_date\" , end_date ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url ) def get_refund ( self , reference : str ) -> Response : \"\"\"Get details of a refund on your integration. Args: reference: Identifier for transaction to be refunded Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/refund/ { reference } \" ) return self . _handle_request ( HTTPMethod . GET , url ) create ( transaction , amount = None , currency = None , customer_note = None , merchant_note = None ) Initiate a refund on your integration Parameters: Name Type Description Default transaction str Transaction reference or id required amount Optional [ int ] Amount ( in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR ) to be refunded to the customer. Amount is optional(defaults to original transaction amount) and cannot be more than the original transaction amount None currency Optional [ Currency ] Any value from the Currency enum None customer_note Optional [ str ] Customer reason None merchant_note Optional [ str ] Merchant reason None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/refunds.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 def create ( self , transaction : str , amount : Optional [ int ] = None , currency : Optional [ Currency ] = None , customer_note : Optional [ str ] = None , merchant_note : Optional [ str ] = None , ) -> Response : \"\"\"Initiate a refund on your integration Args: transaction: Transaction reference or id amount: Amount ( in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR ) to be refunded to the customer. Amount is optional(defaults to original transaction amount) and cannot be more than the original transaction amount currency: Any value from the ``Currency`` enum customer_note: Customer reason merchant_note: Merchant reason Returns: A named tuple containing the response gotten from paystack's server. \"\"\" if amount is not None : amount = validate_amount ( amount ) url = self . _parse_url ( \"/refund\" ) payload = { \"transaction\" : transaction } optional_params = [ ( \"amount\" , amount ), ( \"currency\" , currency ), ( \"customer_note\" , customer_note ), ( \"merchant_note\" , merchant_note ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . POST , url , payload ) get_refund ( reference ) Get details of a refund on your integration. Parameters: Name Type Description Default reference str Identifier for transaction to be refunded required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/refunds.py 95 96 97 98 99 100 101 102 103 104 105 106 def get_refund ( self , reference : str ) -> Response : \"\"\"Get details of a refund on your integration. Args: reference: Identifier for transaction to be refunded Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/refund/ { reference } \" ) return self . _handle_request ( HTTPMethod . GET , url ) get_refunds ( reference = None , currency = None , pagination = 50 , page = 1 , start_date = None , end_date = None ) Fetch refunds available on your integration. Parameters: Name Type Description Default reference Optional [ str ] Identifier for transaction to be refunded None currency Optional [ Currency ] Any value from the Currency enum None pagination int Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. 50 page int Specifies exactly what refund you want to page. If not specified we use a default value of 1. 1 start_date Optional [ str ] A timestamp from which to start listing refund e.g. 2016-09-21 None end_date Optional [ str ] A timestamp at which to stop listing refund e.g. 2016-09-21 None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/refunds.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 def get_refunds ( self , reference : Optional [ str ] = None , currency : Optional [ Currency ] = None , pagination : int = 50 , page : int = 1 , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , ) -> Response : \"\"\"Fetch refunds available on your integration. Args: reference: Identifier for transaction to be refunded currency: Any value from the ``Currency`` enum pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. page: Specifies exactly what refund you want to page. If not specified we use a default value of 1. start_date: A timestamp from which to start listing refund e.g. 2016-09-21 end_date: A timestamp at which to stop listing refund e.g. 2016-09-21 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/refund?perPage= { pagination } \" ) query_params = [ ( \"reference\" , reference ), ( \"currency\" , currency ), ( \"page\" , page ), ( \"start_date\" , start_date ), ( \"end_date\" , end_date ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url )","title":"Refunds"},{"location":"reference/refunds/#pypaystack2.api.refunds.AsyncRefund","text":"Bases: BaseAsyncAPI Provides a wrapper for paystack Refunds API The Refunds API allows you to create and manage transaction refunds. https://paystack.com/docs/api/#refund Source code in pypaystack2/api/refunds.py 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 class AsyncRefund ( BaseAsyncAPI ): \"\"\"Provides a wrapper for paystack Refunds API The Refunds API allows you to create and manage transaction refunds. https://paystack.com/docs/api/#refund \"\"\" async def create ( self , transaction : str , amount : Optional [ int ] = None , currency : Optional [ Currency ] = None , customer_note : Optional [ str ] = None , merchant_note : Optional [ str ] = None , ) -> Response : \"\"\"Initiate a refund on your integration Args: transaction: Transaction reference or id amount: Amount ( in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR ) to be refunded to the customer. Amount is optional(defaults to original transaction amount) and cannot be more than the original transaction amount currency: Any value from the ``Currency`` enum customer_note: Customer reason merchant_note: Merchant reason Returns: A named tuple containing the response gotten from paystack's server. \"\"\" if amount is not None : amount = validate_amount ( amount ) url = self . _parse_url ( \"/refund\" ) payload = { \"transaction\" : transaction } optional_params = [ ( \"amount\" , amount ), ( \"currency\" , currency ), ( \"customer_note\" , customer_note ), ( \"merchant_note\" , merchant_note ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) async def get_refunds ( self , reference : Optional [ str ] = None , currency : Optional [ Currency ] = None , pagination : int = 50 , page : int = 1 , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , ) -> Response : \"\"\"Fetch refunds available on your integration. Args: reference: Identifier for transaction to be refunded currency: Any value from the ``Currency`` enum pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. page: Specifies exactly what refund you want to page. If not specified we use a default value of 1. start_date: A timestamp from which to start listing refund e.g. 2016-09-21 end_date: A timestamp at which to stop listing refund e.g. 2016-09-21 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/refund?perPage= { pagination } \" ) query_params = [ ( \"reference\" , reference ), ( \"currency\" , currency ), ( \"page\" , page ), ( \"start_date\" , start_date ), ( \"end_date\" , end_date ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url ) async def get_refund ( self , reference : str ) -> Response : \"\"\"Get details of a refund on your integration. Args: reference: Identifier for transaction to be refunded Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/refund/ { reference } \" ) return await self . _handle_request ( HTTPMethod . GET , url )","title":"AsyncRefund"},{"location":"reference/refunds/#pypaystack2.api.refunds.AsyncRefund.create","text":"Initiate a refund on your integration Parameters: Name Type Description Default transaction str Transaction reference or id required amount Optional [ int ] Amount ( in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR ) to be refunded to the customer. Amount is optional(defaults to original transaction amount) and cannot be more than the original transaction amount None currency Optional [ Currency ] Any value from the Currency enum None customer_note Optional [ str ] Customer reason None merchant_note Optional [ str ] Merchant reason None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/refunds.py 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 async def create ( self , transaction : str , amount : Optional [ int ] = None , currency : Optional [ Currency ] = None , customer_note : Optional [ str ] = None , merchant_note : Optional [ str ] = None , ) -> Response : \"\"\"Initiate a refund on your integration Args: transaction: Transaction reference or id amount: Amount ( in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR ) to be refunded to the customer. Amount is optional(defaults to original transaction amount) and cannot be more than the original transaction amount currency: Any value from the ``Currency`` enum customer_note: Customer reason merchant_note: Merchant reason Returns: A named tuple containing the response gotten from paystack's server. \"\"\" if amount is not None : amount = validate_amount ( amount ) url = self . _parse_url ( \"/refund\" ) payload = { \"transaction\" : transaction } optional_params = [ ( \"amount\" , amount ), ( \"currency\" , currency ), ( \"customer_note\" , customer_note ), ( \"merchant_note\" , merchant_note ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . POST , url , payload )","title":"create()"},{"location":"reference/refunds/#pypaystack2.api.refunds.AsyncRefund.get_refund","text":"Get details of a refund on your integration. Parameters: Name Type Description Default reference str Identifier for transaction to be refunded required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/refunds.py 190 191 192 193 194 195 196 197 198 199 200 201 async def get_refund ( self , reference : str ) -> Response : \"\"\"Get details of a refund on your integration. Args: reference: Identifier for transaction to be refunded Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/refund/ { reference } \" ) return await self . _handle_request ( HTTPMethod . GET , url )","title":"get_refund()"},{"location":"reference/refunds/#pypaystack2.api.refunds.AsyncRefund.get_refunds","text":"Fetch refunds available on your integration. Parameters: Name Type Description Default reference Optional [ str ] Identifier for transaction to be refunded None currency Optional [ Currency ] Any value from the Currency enum None pagination int Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. 50 page int Specifies exactly what refund you want to page. If not specified we use a default value of 1. 1 start_date Optional [ str ] A timestamp from which to start listing refund e.g. 2016-09-21 None end_date Optional [ str ] A timestamp at which to stop listing refund e.g. 2016-09-21 None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/refunds.py 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 async def get_refunds ( self , reference : Optional [ str ] = None , currency : Optional [ Currency ] = None , pagination : int = 50 , page : int = 1 , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , ) -> Response : \"\"\"Fetch refunds available on your integration. Args: reference: Identifier for transaction to be refunded currency: Any value from the ``Currency`` enum pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. page: Specifies exactly what refund you want to page. If not specified we use a default value of 1. start_date: A timestamp from which to start listing refund e.g. 2016-09-21 end_date: A timestamp at which to stop listing refund e.g. 2016-09-21 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/refund?perPage= { pagination } \" ) query_params = [ ( \"reference\" , reference ), ( \"currency\" , currency ), ( \"page\" , page ), ( \"start_date\" , start_date ), ( \"end_date\" , end_date ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url )","title":"get_refunds()"},{"location":"reference/refunds/#pypaystack2.api.refunds.Refund","text":"Bases: BaseAPI Provides a wrapper for paystack Refunds API The Refunds API allows you to create and manage transaction refunds. https://paystack.com/docs/api/#refund Source code in pypaystack2/api/refunds.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 class Refund ( BaseAPI ): \"\"\"Provides a wrapper for paystack Refunds API The Refunds API allows you to create and manage transaction refunds. https://paystack.com/docs/api/#refund \"\"\" def create ( self , transaction : str , amount : Optional [ int ] = None , currency : Optional [ Currency ] = None , customer_note : Optional [ str ] = None , merchant_note : Optional [ str ] = None , ) -> Response : \"\"\"Initiate a refund on your integration Args: transaction: Transaction reference or id amount: Amount ( in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR ) to be refunded to the customer. Amount is optional(defaults to original transaction amount) and cannot be more than the original transaction amount currency: Any value from the ``Currency`` enum customer_note: Customer reason merchant_note: Merchant reason Returns: A named tuple containing the response gotten from paystack's server. \"\"\" if amount is not None : amount = validate_amount ( amount ) url = self . _parse_url ( \"/refund\" ) payload = { \"transaction\" : transaction } optional_params = [ ( \"amount\" , amount ), ( \"currency\" , currency ), ( \"customer_note\" , customer_note ), ( \"merchant_note\" , merchant_note ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . POST , url , payload ) def get_refunds ( self , reference : Optional [ str ] = None , currency : Optional [ Currency ] = None , pagination : int = 50 , page : int = 1 , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , ) -> Response : \"\"\"Fetch refunds available on your integration. Args: reference: Identifier for transaction to be refunded currency: Any value from the ``Currency`` enum pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. page: Specifies exactly what refund you want to page. If not specified we use a default value of 1. start_date: A timestamp from which to start listing refund e.g. 2016-09-21 end_date: A timestamp at which to stop listing refund e.g. 2016-09-21 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/refund?perPage= { pagination } \" ) query_params = [ ( \"reference\" , reference ), ( \"currency\" , currency ), ( \"page\" , page ), ( \"start_date\" , start_date ), ( \"end_date\" , end_date ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url ) def get_refund ( self , reference : str ) -> Response : \"\"\"Get details of a refund on your integration. Args: reference: Identifier for transaction to be refunded Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/refund/ { reference } \" ) return self . _handle_request ( HTTPMethod . GET , url )","title":"Refund"},{"location":"reference/refunds/#pypaystack2.api.refunds.Refund.create","text":"Initiate a refund on your integration Parameters: Name Type Description Default transaction str Transaction reference or id required amount Optional [ int ] Amount ( in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR ) to be refunded to the customer. Amount is optional(defaults to original transaction amount) and cannot be more than the original transaction amount None currency Optional [ Currency ] Any value from the Currency enum None customer_note Optional [ str ] Customer reason None merchant_note Optional [ str ] Merchant reason None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/refunds.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 def create ( self , transaction : str , amount : Optional [ int ] = None , currency : Optional [ Currency ] = None , customer_note : Optional [ str ] = None , merchant_note : Optional [ str ] = None , ) -> Response : \"\"\"Initiate a refund on your integration Args: transaction: Transaction reference or id amount: Amount ( in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR ) to be refunded to the customer. Amount is optional(defaults to original transaction amount) and cannot be more than the original transaction amount currency: Any value from the ``Currency`` enum customer_note: Customer reason merchant_note: Merchant reason Returns: A named tuple containing the response gotten from paystack's server. \"\"\" if amount is not None : amount = validate_amount ( amount ) url = self . _parse_url ( \"/refund\" ) payload = { \"transaction\" : transaction } optional_params = [ ( \"amount\" , amount ), ( \"currency\" , currency ), ( \"customer_note\" , customer_note ), ( \"merchant_note\" , merchant_note ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . POST , url , payload )","title":"create()"},{"location":"reference/refunds/#pypaystack2.api.refunds.Refund.get_refund","text":"Get details of a refund on your integration. Parameters: Name Type Description Default reference str Identifier for transaction to be refunded required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/refunds.py 95 96 97 98 99 100 101 102 103 104 105 106 def get_refund ( self , reference : str ) -> Response : \"\"\"Get details of a refund on your integration. Args: reference: Identifier for transaction to be refunded Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/refund/ { reference } \" ) return self . _handle_request ( HTTPMethod . GET , url )","title":"get_refund()"},{"location":"reference/refunds/#pypaystack2.api.refunds.Refund.get_refunds","text":"Fetch refunds available on your integration. Parameters: Name Type Description Default reference Optional [ str ] Identifier for transaction to be refunded None currency Optional [ Currency ] Any value from the Currency enum None pagination int Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. 50 page int Specifies exactly what refund you want to page. If not specified we use a default value of 1. 1 start_date Optional [ str ] A timestamp from which to start listing refund e.g. 2016-09-21 None end_date Optional [ str ] A timestamp at which to stop listing refund e.g. 2016-09-21 None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/refunds.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 def get_refunds ( self , reference : Optional [ str ] = None , currency : Optional [ Currency ] = None , pagination : int = 50 , page : int = 1 , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , ) -> Response : \"\"\"Fetch refunds available on your integration. Args: reference: Identifier for transaction to be refunded currency: Any value from the ``Currency`` enum pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. page: Specifies exactly what refund you want to page. If not specified we use a default value of 1. start_date: A timestamp from which to start listing refund e.g. 2016-09-21 end_date: A timestamp at which to stop listing refund e.g. 2016-09-21 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/refund?perPage= { pagination } \" ) query_params = [ ( \"reference\" , reference ), ( \"currency\" , currency ), ( \"page\" , page ), ( \"start_date\" , start_date ), ( \"end_date\" , end_date ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url )","title":"get_refunds()"},{"location":"reference/settlements/","text":"AsyncSettlement Bases: BaseAsyncAPI Provides a wrapper for paystack Settlement API The Settlements API allows you gain insights into payouts made by Paystack to your bank account. https://paystack.com/docs/api/#settlement Source code in pypaystack2/api/settlements.py 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 class AsyncSettlement ( BaseAsyncAPI ): \"\"\"Provides a wrapper for paystack Settlement API The Settlements API allows you gain insights into payouts made by Paystack to your bank account. https://paystack.com/docs/api/#settlement \"\"\" async def get_settlements ( self , page : int = 1 , pagination : int = 50 , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , subaccount : Optional [ str ] = None , ) -> Response : \"\"\"Fetch settlements made to your settlement accounts. Args: page: Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. start_date: A timestamp from which to start listing settlements e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing settlements e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 subaccount: Provide a subaccount ID to export only settlements for that subaccount. Set to ``none`` to export only transactions for the account. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/settlement?perPage= { pagination } \" ) query_params = [ ( \"subaccount\" , subaccount ), ( \"page\" , page ), ( \"start_date\" , start_date ), ( \"end_date\" , end_date ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url ) async def get_settlement_transactions ( self , id : str , pagination : int = 50 , page : int = 1 , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , ) -> Response : \"\"\"Get the transactions that make up a particular settlement Args: id: The settlement ID in which you want to fetch its transactions pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. page: Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. start_date: A timestamp from which to start listing settlement transactions e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing settlement transactions e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/settlement/ { id } /transactions?perPage= { pagination } \" ) query_params = [ ( \"page\" , page ), ( \"start_date\" , start_date ), ( \"end_date\" , end_date ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url ) get_settlement_transactions ( id , pagination = 50 , page = 1 , start_date = None , end_date = None ) async Get the transactions that make up a particular settlement Parameters: Name Type Description Default id str The settlement ID in which you want to fetch its transactions required pagination int Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. 50 page int Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. 1 start_date Optional [ str ] A timestamp from which to start listing settlement transactions e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None end_date Optional [ str ] A timestamp at which to stop listing settlement transactions e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/settlements.py 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 async def get_settlement_transactions ( self , id : str , pagination : int = 50 , page : int = 1 , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , ) -> Response : \"\"\"Get the transactions that make up a particular settlement Args: id: The settlement ID in which you want to fetch its transactions pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. page: Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. start_date: A timestamp from which to start listing settlement transactions e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing settlement transactions e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/settlement/ { id } /transactions?perPage= { pagination } \" ) query_params = [ ( \"page\" , page ), ( \"start_date\" , start_date ), ( \"end_date\" , end_date ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url ) get_settlements ( page = 1 , pagination = 50 , start_date = None , end_date = None , subaccount = None ) async Fetch settlements made to your settlement accounts. Parameters: Name Type Description Default page int Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. 1 pagination int Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. 50 start_date Optional [ str ] A timestamp from which to start listing settlements e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None end_date Optional [ str ] A timestamp at which to stop listing settlements e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None subaccount Optional [ str ] Provide a subaccount ID to export only settlements for that subaccount. Set to none to export only transactions for the account. None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/settlements.py 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 async def get_settlements ( self , page : int = 1 , pagination : int = 50 , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , subaccount : Optional [ str ] = None , ) -> Response : \"\"\"Fetch settlements made to your settlement accounts. Args: page: Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. start_date: A timestamp from which to start listing settlements e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing settlements e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 subaccount: Provide a subaccount ID to export only settlements for that subaccount. Set to ``none`` to export only transactions for the account. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/settlement?perPage= { pagination } \" ) query_params = [ ( \"subaccount\" , subaccount ), ( \"page\" , page ), ( \"start_date\" , start_date ), ( \"end_date\" , end_date ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url ) Settlement Bases: BaseAPI Provides a wrapper for paystack Settlement API The Settlements API allows you gain insights into payouts made by Paystack to your bank account. https://paystack.com/docs/api/#settlement Source code in pypaystack2/api/settlements.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 class Settlement ( BaseAPI ): \"\"\"Provides a wrapper for paystack Settlement API The Settlements API allows you gain insights into payouts made by Paystack to your bank account. https://paystack.com/docs/api/#settlement \"\"\" def get_settlements ( self , page : int = 1 , pagination : int = 50 , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , subaccount : Optional [ str ] = None , ) -> Response : \"\"\"Fetch settlements made to your settlement accounts. Args: page: Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. start_date: A timestamp from which to start listing settlements e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing settlements e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 subaccount: Provide a subaccount ID to export only settlements for that subaccount. Set to ``none`` to export only transactions for the account. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/settlement?perPage= { pagination } \" ) query_params = [ ( \"subaccount\" , subaccount ), ( \"page\" , page ), ( \"start_date\" , start_date ), ( \"end_date\" , end_date ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url ) def get_settlement_transactions ( self , id : str , pagination : int = 50 , page : int = 1 , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , ) -> Response : \"\"\"Get the transactions that make up a particular settlement Args: id: The settlement ID in which you want to fetch its transactions pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. page: Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. start_date: A timestamp from which to start listing settlement transactions e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing settlement transactions e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/settlement/ { id } /transactions?perPage= { pagination } \" ) query_params = [ ( \"page\" , page ), ( \"start_date\" , start_date ), ( \"end_date\" , end_date ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url ) get_settlement_transactions ( id , pagination = 50 , page = 1 , start_date = None , end_date = None ) Get the transactions that make up a particular settlement Parameters: Name Type Description Default id str The settlement ID in which you want to fetch its transactions required pagination int Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. 50 page int Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. 1 start_date Optional [ str ] A timestamp from which to start listing settlement transactions e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None end_date Optional [ str ] A timestamp at which to stop listing settlement transactions e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/settlements.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 def get_settlement_transactions ( self , id : str , pagination : int = 50 , page : int = 1 , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , ) -> Response : \"\"\"Get the transactions that make up a particular settlement Args: id: The settlement ID in which you want to fetch its transactions pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. page: Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. start_date: A timestamp from which to start listing settlement transactions e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing settlement transactions e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/settlement/ { id } /transactions?perPage= { pagination } \" ) query_params = [ ( \"page\" , page ), ( \"start_date\" , start_date ), ( \"end_date\" , end_date ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url ) get_settlements ( page = 1 , pagination = 50 , start_date = None , end_date = None , subaccount = None ) Fetch settlements made to your settlement accounts. Parameters: Name Type Description Default page int Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. 1 pagination int Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. 50 start_date Optional [ str ] A timestamp from which to start listing settlements e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None end_date Optional [ str ] A timestamp at which to stop listing settlements e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None subaccount Optional [ str ] Provide a subaccount ID to export only settlements for that subaccount. Set to none to export only transactions for the account. None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/settlements.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 def get_settlements ( self , page : int = 1 , pagination : int = 50 , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , subaccount : Optional [ str ] = None , ) -> Response : \"\"\"Fetch settlements made to your settlement accounts. Args: page: Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. start_date: A timestamp from which to start listing settlements e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing settlements e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 subaccount: Provide a subaccount ID to export only settlements for that subaccount. Set to ``none`` to export only transactions for the account. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/settlement?perPage= { pagination } \" ) query_params = [ ( \"subaccount\" , subaccount ), ( \"page\" , page ), ( \"start_date\" , start_date ), ( \"end_date\" , end_date ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url )","title":"Settlements"},{"location":"reference/settlements/#pypaystack2.api.settlements.AsyncSettlement","text":"Bases: BaseAsyncAPI Provides a wrapper for paystack Settlement API The Settlements API allows you gain insights into payouts made by Paystack to your bank account. https://paystack.com/docs/api/#settlement Source code in pypaystack2/api/settlements.py 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 class AsyncSettlement ( BaseAsyncAPI ): \"\"\"Provides a wrapper for paystack Settlement API The Settlements API allows you gain insights into payouts made by Paystack to your bank account. https://paystack.com/docs/api/#settlement \"\"\" async def get_settlements ( self , page : int = 1 , pagination : int = 50 , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , subaccount : Optional [ str ] = None , ) -> Response : \"\"\"Fetch settlements made to your settlement accounts. Args: page: Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. start_date: A timestamp from which to start listing settlements e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing settlements e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 subaccount: Provide a subaccount ID to export only settlements for that subaccount. Set to ``none`` to export only transactions for the account. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/settlement?perPage= { pagination } \" ) query_params = [ ( \"subaccount\" , subaccount ), ( \"page\" , page ), ( \"start_date\" , start_date ), ( \"end_date\" , end_date ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url ) async def get_settlement_transactions ( self , id : str , pagination : int = 50 , page : int = 1 , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , ) -> Response : \"\"\"Get the transactions that make up a particular settlement Args: id: The settlement ID in which you want to fetch its transactions pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. page: Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. start_date: A timestamp from which to start listing settlement transactions e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing settlement transactions e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/settlement/ { id } /transactions?perPage= { pagination } \" ) query_params = [ ( \"page\" , page ), ( \"start_date\" , start_date ), ( \"end_date\" , end_date ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url )","title":"AsyncSettlement"},{"location":"reference/settlements/#pypaystack2.api.settlements.AsyncSettlement.get_settlement_transactions","text":"Get the transactions that make up a particular settlement Parameters: Name Type Description Default id str The settlement ID in which you want to fetch its transactions required pagination int Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. 50 page int Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. 1 start_date Optional [ str ] A timestamp from which to start listing settlement transactions e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None end_date Optional [ str ] A timestamp at which to stop listing settlement transactions e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/settlements.py 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 async def get_settlement_transactions ( self , id : str , pagination : int = 50 , page : int = 1 , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , ) -> Response : \"\"\"Get the transactions that make up a particular settlement Args: id: The settlement ID in which you want to fetch its transactions pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. page: Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. start_date: A timestamp from which to start listing settlement transactions e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing settlement transactions e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/settlement/ { id } /transactions?perPage= { pagination } \" ) query_params = [ ( \"page\" , page ), ( \"start_date\" , start_date ), ( \"end_date\" , end_date ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url )","title":"get_settlement_transactions()"},{"location":"reference/settlements/#pypaystack2.api.settlements.AsyncSettlement.get_settlements","text":"Fetch settlements made to your settlement accounts. Parameters: Name Type Description Default page int Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. 1 pagination int Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. 50 start_date Optional [ str ] A timestamp from which to start listing settlements e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None end_date Optional [ str ] A timestamp at which to stop listing settlements e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None subaccount Optional [ str ] Provide a subaccount ID to export only settlements for that subaccount. Set to none to export only transactions for the account. None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/settlements.py 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 async def get_settlements ( self , page : int = 1 , pagination : int = 50 , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , subaccount : Optional [ str ] = None , ) -> Response : \"\"\"Fetch settlements made to your settlement accounts. Args: page: Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. start_date: A timestamp from which to start listing settlements e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing settlements e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 subaccount: Provide a subaccount ID to export only settlements for that subaccount. Set to ``none`` to export only transactions for the account. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/settlement?perPage= { pagination } \" ) query_params = [ ( \"subaccount\" , subaccount ), ( \"page\" , page ), ( \"start_date\" , start_date ), ( \"end_date\" , end_date ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url )","title":"get_settlements()"},{"location":"reference/settlements/#pypaystack2.api.settlements.Settlement","text":"Bases: BaseAPI Provides a wrapper for paystack Settlement API The Settlements API allows you gain insights into payouts made by Paystack to your bank account. https://paystack.com/docs/api/#settlement Source code in pypaystack2/api/settlements.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 class Settlement ( BaseAPI ): \"\"\"Provides a wrapper for paystack Settlement API The Settlements API allows you gain insights into payouts made by Paystack to your bank account. https://paystack.com/docs/api/#settlement \"\"\" def get_settlements ( self , page : int = 1 , pagination : int = 50 , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , subaccount : Optional [ str ] = None , ) -> Response : \"\"\"Fetch settlements made to your settlement accounts. Args: page: Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. start_date: A timestamp from which to start listing settlements e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing settlements e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 subaccount: Provide a subaccount ID to export only settlements for that subaccount. Set to ``none`` to export only transactions for the account. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/settlement?perPage= { pagination } \" ) query_params = [ ( \"subaccount\" , subaccount ), ( \"page\" , page ), ( \"start_date\" , start_date ), ( \"end_date\" , end_date ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url ) def get_settlement_transactions ( self , id : str , pagination : int = 50 , page : int = 1 , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , ) -> Response : \"\"\"Get the transactions that make up a particular settlement Args: id: The settlement ID in which you want to fetch its transactions pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. page: Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. start_date: A timestamp from which to start listing settlement transactions e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing settlement transactions e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/settlement/ { id } /transactions?perPage= { pagination } \" ) query_params = [ ( \"page\" , page ), ( \"start_date\" , start_date ), ( \"end_date\" , end_date ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url )","title":"Settlement"},{"location":"reference/settlements/#pypaystack2.api.settlements.Settlement.get_settlement_transactions","text":"Get the transactions that make up a particular settlement Parameters: Name Type Description Default id str The settlement ID in which you want to fetch its transactions required pagination int Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. 50 page int Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. 1 start_date Optional [ str ] A timestamp from which to start listing settlement transactions e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None end_date Optional [ str ] A timestamp at which to stop listing settlement transactions e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/settlements.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 def get_settlement_transactions ( self , id : str , pagination : int = 50 , page : int = 1 , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , ) -> Response : \"\"\"Get the transactions that make up a particular settlement Args: id: The settlement ID in which you want to fetch its transactions pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. page: Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. start_date: A timestamp from which to start listing settlement transactions e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing settlement transactions e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/settlement/ { id } /transactions?perPage= { pagination } \" ) query_params = [ ( \"page\" , page ), ( \"start_date\" , start_date ), ( \"end_date\" , end_date ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url )","title":"get_settlement_transactions()"},{"location":"reference/settlements/#pypaystack2.api.settlements.Settlement.get_settlements","text":"Fetch settlements made to your settlement accounts. Parameters: Name Type Description Default page int Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. 1 pagination int Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. 50 start_date Optional [ str ] A timestamp from which to start listing settlements e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None end_date Optional [ str ] A timestamp at which to stop listing settlements e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None subaccount Optional [ str ] Provide a subaccount ID to export only settlements for that subaccount. Set to none to export only transactions for the account. None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/settlements.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 def get_settlements ( self , page : int = 1 , pagination : int = 50 , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , subaccount : Optional [ str ] = None , ) -> Response : \"\"\"Fetch settlements made to your settlement accounts. Args: page: Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. start_date: A timestamp from which to start listing settlements e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing settlements e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 subaccount: Provide a subaccount ID to export only settlements for that subaccount. Set to ``none`` to export only transactions for the account. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/settlement?perPage= { pagination } \" ) query_params = [ ( \"subaccount\" , subaccount ), ( \"page\" , page ), ( \"start_date\" , start_date ), ( \"end_date\" , end_date ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url )","title":"get_settlements()"},{"location":"reference/splits/","text":"AsyncTransactionSplit Bases: BaseAsyncAPI Provides a wrapper for paystack Transaction Splits API The Transaction Splits API enables merchants split the settlement for a transaction across their payout account, and one or more Subaccounts. https://paystack.com/docs/api/#split Source code in pypaystack2/api/splits.py 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 class AsyncTransactionSplit ( BaseAsyncAPI ): \"\"\"Provides a wrapper for paystack Transaction Splits API The Transaction Splits API enables merchants split the settlement for a transaction across their payout account, and one or more Subaccounts. https://paystack.com/docs/api/#split \"\"\" async def create ( self , name : str , type : TransactionSplit , currency : Currency , subaccounts : list [ SplitAccount ], bearer_type : Bearer , bearer_subaccount : str , ) -> Response : \"\"\"Create a split payment on your integration Args: name: Name of the transaction split type: The type of transaction split you want to create. Any value from the ``SplitType`` enum currency: Any value from the ``Currency`` enum subaccounts: A list of dictionaries containing subaccount code and number of shares: ``[{subaccount: 'ACT_xxxxxxxxxx', share: xxx},{...}]`` bearer_type: Any value from the ``Bearer`` enum bearer_subaccount: Subaccount code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" subaccounts = [ account . dict for account in subaccounts ] url = self . _parse_url ( \"/split\" ) payload = { \"name\" : name , \"type\" : type , \"currency\" : currency , \"subaccounts\" : subaccounts , \"bearer_type\" : bearer_type , \"bearer_subaccount\" : bearer_subaccount , } return await self . _handle_request ( HTTPMethod . POST , url , payload ) async def get_splits ( self , name : str , sort_by : Optional [ str ], page : Optional [ int ], start_date : Optional [ str ], end_date : Optional [ str ], active : bool = True , pagination : int = 50 , ) -> Response : \"\"\"Get/search for the transaction splits available on your integration. Args: name: The name of the split sort_by: Sort by name, defaults to createdAt date page: Page number to view. If not specify we use a default value of 1. start_date: A timestamp from which to start listing splits e.g. 2019-09-24T00:00:05.000Z, 2019-09-21 end_date: A timestamp at which to stop listing splits e.g. 2019-09-24T00:00:05.000Z, 2019-09-21 active: Flag to filter by active pagination: Number of splits per page. If not specified we use a default value of 50. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/split?perPage= { pagination } \" ) query_params = [ ( \"name\" , name ), ( \"sort_by\" , sort_by ), ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ( \"active\" , active ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url ) async def get_split ( self , id : str ) -> Response : \"\"\"Get details of a split on your integration. Args: id: The id of the split Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/split/ { id } /\" ) return await self . _handle_request ( HTTPMethod . GET , url ) async def update ( self , id : str , name : str , active : bool , bearer_type : Optional [ Bearer ], bearer_subaccount : Optional [ str ], ) -> Response : \"\"\"Update a transaction split details on your integration Args: id: Split ID name: Name of the transaction split active: Flag for active bearer_type: Any value from the Bearer enum bearer_subaccount: Subaccount code of a subaccount in the split group. This should be specified only if the bearer_type is ``Bearer.subaccount`` Returns: A named tuple containing the response gotten from paystack's server. \"\"\" if bearer_subaccount : if bearer_type != Bearer . SUB_ACCOUNT : raise InvalidDataError ( \"`bearer_subaccount` can only have a value if `bearer_type` is `Bearer.SUBACCOUNT`\" ) payload = { \"name\" : name , \"active\" : active , } optional_params = [ ( \"bearer_type\" , bearer_type ), ( \"bearer_subaccount\" , bearer_subaccount ), ] payload = add_to_payload ( optional_params , payload ) url = self . _parse_url ( f \"/split/ { id } /\" ) return await self . _handle_request ( HTTPMethod . PUT , url , payload ) async def add_or_update ( self , id : str , subaccount : str , share : int ) -> Response : \"\"\" Add a Subaccount to a Transaction Split, or update the share of an existing Subaccount in a Transaction Split Args: id: Split ID subaccount: This is the subaccount code share: This is the transaction share for the subaccount Returns: A named tuple containing the response gotten from paystack's server. \"\"\" share = validate_amount ( share ) payload = { \"subaccount\" : subaccount , \"share\" : share } url = self . _parse_url ( f \"/split/ { id } /subaccount/add\" ) return await self . _handle_request ( \"POST\" , url , payload ) async def remove ( self , id : str , subaccount : str ) -> Response : \"\"\"Remove a subaccount from a transaction split Args: id: Split ID subaccount: This is the subaccount code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"subaccount\" : subaccount } url = self . _parse_url ( f \"/split/ { id } /subaccount/remove\" ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) add_or_update ( id , subaccount , share ) async Add a Subaccount to a Transaction Split, or update the share of an existing Subaccount in a Transaction Split Parameters: Name Type Description Default id str Split ID required subaccount str This is the subaccount code required share int This is the transaction share for the subaccount required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/splits.py 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 async def add_or_update ( self , id : str , subaccount : str , share : int ) -> Response : \"\"\" Add a Subaccount to a Transaction Split, or update the share of an existing Subaccount in a Transaction Split Args: id: Split ID subaccount: This is the subaccount code share: This is the transaction share for the subaccount Returns: A named tuple containing the response gotten from paystack's server. \"\"\" share = validate_amount ( share ) payload = { \"subaccount\" : subaccount , \"share\" : share } url = self . _parse_url ( f \"/split/ { id } /subaccount/add\" ) return await self . _handle_request ( \"POST\" , url , payload ) create ( name , type , currency , subaccounts , bearer_type , bearer_subaccount ) async Create a split payment on your integration Parameters: Name Type Description Default name str Name of the transaction split required type TransactionSplit The type of transaction split you want to create. Any value from the SplitType enum required currency Currency Any value from the Currency enum required subaccounts list [ SplitAccount ] A list of dictionaries containing subaccount code and number of shares: [{subaccount: 'ACT_xxxxxxxxxx', share: xxx},{...}] required bearer_type Bearer Any value from the Bearer enum required bearer_subaccount str Subaccount code required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/splits.py 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 async def create ( self , name : str , type : TransactionSplit , currency : Currency , subaccounts : list [ SplitAccount ], bearer_type : Bearer , bearer_subaccount : str , ) -> Response : \"\"\"Create a split payment on your integration Args: name: Name of the transaction split type: The type of transaction split you want to create. Any value from the ``SplitType`` enum currency: Any value from the ``Currency`` enum subaccounts: A list of dictionaries containing subaccount code and number of shares: ``[{subaccount: 'ACT_xxxxxxxxxx', share: xxx},{...}]`` bearer_type: Any value from the ``Bearer`` enum bearer_subaccount: Subaccount code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" subaccounts = [ account . dict for account in subaccounts ] url = self . _parse_url ( \"/split\" ) payload = { \"name\" : name , \"type\" : type , \"currency\" : currency , \"subaccounts\" : subaccounts , \"bearer_type\" : bearer_type , \"bearer_subaccount\" : bearer_subaccount , } return await self . _handle_request ( HTTPMethod . POST , url , payload ) get_split ( id ) async Get details of a split on your integration. Parameters: Name Type Description Default id str The id of the split required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/splits.py 272 273 274 275 276 277 278 279 280 281 282 async def get_split ( self , id : str ) -> Response : \"\"\"Get details of a split on your integration. Args: id: The id of the split Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/split/ { id } /\" ) return await self . _handle_request ( HTTPMethod . GET , url ) get_splits ( name , sort_by , page , start_date , end_date , active = True , pagination = 50 ) async Get/search for the transaction splits available on your integration. Parameters: Name Type Description Default name str The name of the split required sort_by Optional [ str ] Sort by name, defaults to createdAt date required page Optional [ int ] Page number to view. If not specify we use a default value of 1. required start_date Optional [ str ] A timestamp from which to start listing splits e.g. 2019-09-24T00:00:05.000Z, 2019-09-21 required end_date Optional [ str ] A timestamp at which to stop listing splits e.g. 2019-09-24T00:00:05.000Z, 2019-09-21 required active bool Flag to filter by active True pagination int Number of splits per page. If not specified we use a default value of 50. 50 Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/splits.py 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 async def get_splits ( self , name : str , sort_by : Optional [ str ], page : Optional [ int ], start_date : Optional [ str ], end_date : Optional [ str ], active : bool = True , pagination : int = 50 , ) -> Response : \"\"\"Get/search for the transaction splits available on your integration. Args: name: The name of the split sort_by: Sort by name, defaults to createdAt date page: Page number to view. If not specify we use a default value of 1. start_date: A timestamp from which to start listing splits e.g. 2019-09-24T00:00:05.000Z, 2019-09-21 end_date: A timestamp at which to stop listing splits e.g. 2019-09-24T00:00:05.000Z, 2019-09-21 active: Flag to filter by active pagination: Number of splits per page. If not specified we use a default value of 50. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/split?perPage= { pagination } \" ) query_params = [ ( \"name\" , name ), ( \"sort_by\" , sort_by ), ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ( \"active\" , active ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url ) remove ( id , subaccount ) async Remove a subaccount from a transaction split Parameters: Name Type Description Default id str Split ID required subaccount str This is the subaccount code required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/splits.py 344 345 346 347 348 349 350 351 352 353 354 355 356 357 async def remove ( self , id : str , subaccount : str ) -> Response : \"\"\"Remove a subaccount from a transaction split Args: id: Split ID subaccount: This is the subaccount code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"subaccount\" : subaccount } url = self . _parse_url ( f \"/split/ { id } /subaccount/remove\" ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) update ( id , name , active , bearer_type , bearer_subaccount ) async Update a transaction split details on your integration Parameters: Name Type Description Default id str Split ID required name str Name of the transaction split required active bool Flag for active required bearer_type Optional [ Bearer ] Any value from the Bearer enum required bearer_subaccount Optional [ str ] Subaccount code of a subaccount in the split group. This should be specified only if the bearer_type is Bearer.subaccount required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/splits.py 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 async def update ( self , id : str , name : str , active : bool , bearer_type : Optional [ Bearer ], bearer_subaccount : Optional [ str ], ) -> Response : \"\"\"Update a transaction split details on your integration Args: id: Split ID name: Name of the transaction split active: Flag for active bearer_type: Any value from the Bearer enum bearer_subaccount: Subaccount code of a subaccount in the split group. This should be specified only if the bearer_type is ``Bearer.subaccount`` Returns: A named tuple containing the response gotten from paystack's server. \"\"\" if bearer_subaccount : if bearer_type != Bearer . SUB_ACCOUNT : raise InvalidDataError ( \"`bearer_subaccount` can only have a value if `bearer_type` is `Bearer.SUBACCOUNT`\" ) payload = { \"name\" : name , \"active\" : active , } optional_params = [ ( \"bearer_type\" , bearer_type ), ( \"bearer_subaccount\" , bearer_subaccount ), ] payload = add_to_payload ( optional_params , payload ) url = self . _parse_url ( f \"/split/ { id } /\" ) return await self . _handle_request ( HTTPMethod . PUT , url , payload ) TransactionSplit Bases: BaseAPI Provides a wrapper for paystack Transaction Splits API The Transaction Splits API enables merchants split the settlement for a transaction across their payout account, and one or more Subaccounts. https://paystack.com/docs/api/#split Source code in pypaystack2/api/splits.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 class TransactionSplit ( BaseAPI ): \"\"\"Provides a wrapper for paystack Transaction Splits API The Transaction Splits API enables merchants split the settlement for a transaction across their payout account, and one or more Subaccounts. https://paystack.com/docs/api/#split \"\"\" def create ( self , name : str , type : Split , currency : Currency , subaccounts : list [ SplitAccount ], bearer_type : Bearer , bearer_subaccount : str , ) -> Response : \"\"\"Create a split payment on your integration Args: name: Name of the transaction split type: The type of transaction split you want to create. Any value from the ``SplitType`` enum currency: Any value from the ``Currency`` enum subaccounts: A list of dictionaries containing subaccount code and number of shares: ``[{subaccount: 'ACT_xxxxxxxxxx', share: xxx},{...}]`` bearer_type: Any value from the ``Bearer`` enum bearer_subaccount: Subaccount code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" subaccounts = [ account . dict for account in subaccounts ] url = self . _parse_url ( \"/split\" ) payload = { \"name\" : name , \"type\" : type , \"currency\" : currency , \"subaccounts\" : subaccounts , \"bearer_type\" : bearer_type , \"bearer_subaccount\" : bearer_subaccount , } return self . _handle_request ( HTTPMethod . POST , url , payload ) def get_splits ( self , name : str , sort_by : Optional [ str ], page : Optional [ int ], start_date : Optional [ str ], end_date : Optional [ str ], active : bool = True , pagination : int = 50 , ) -> Response : \"\"\"Get/search for the transaction splits available on your integration. Args: name: The name of the split sort_by: Sort by name, defaults to createdAt date page: Page number to view. If not specify we use a default value of 1. start_date: A timestamp from which to start listing splits e.g. 2019-09-24T00:00:05.000Z, 2019-09-21 end_date: A timestamp at which to stop listing splits e.g. 2019-09-24T00:00:05.000Z, 2019-09-21 active: Flag to filter by active pagination: Number of splits per page. If not specified we use a default value of 50. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/split?perPage= { pagination } \" ) query_params = [ ( \"name\" , name ), ( \"sort_by\" , sort_by ), ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ( \"active\" , active ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url ) def get_split ( self , id : str ) -> Response : \"\"\"Get details of a split on your integration. Args: id: The id of the split Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/split/ { id } /\" ) return self . _handle_request ( HTTPMethod . GET , url ) def update ( self , id : str , name : str , active : bool , bearer_type : Optional [ Bearer ], bearer_subaccount : Optional [ str ], ) -> Response : \"\"\"Update a transaction split details on your integration Args: id: Split ID name: Name of the transaction split active: Flag for active bearer_type: Any value from the Bearer enum bearer_subaccount: Subaccount code of a subaccount in the split group. This should be specified only if the bearer_type is ``Bearer.subaccount`` Returns: A named tuple containing the response gotten from paystack's server. \"\"\" if bearer_subaccount : if bearer_type != Bearer . SUB_ACCOUNT : raise InvalidDataError ( \"`bearer_subaccount` can only have a value if `bearer_type` is `Bearer.SUBACCOUNT`\" ) payload = { \"name\" : name , \"active\" : active , } optional_params = [ ( \"bearer_type\" , bearer_type ), ( \"bearer_subaccount\" , bearer_subaccount ), ] payload = add_to_payload ( optional_params , payload ) url = self . _parse_url ( f \"/split/ { id } /\" ) return self . _handle_request ( HTTPMethod . PUT , url , payload ) def add_or_update ( self , id : str , subaccount : str , share : int ) -> Response : \"\"\" Add a Subaccount to a Transaction Split, or update the share of an existing Subaccount in a Transaction Split Args: id: Split ID subaccount: This is the subaccount code share: This is the transaction share for the subaccount Returns: A named tuple containing the response gotten from paystack's server. \"\"\" share = validate_amount ( share ) payload = { \"subaccount\" : subaccount , \"share\" : share } url = self . _parse_url ( f \"/split/ { id } /subaccount/add\" ) return self . _handle_request ( \"POST\" , url , payload ) def remove ( self , id : str , subaccount : str ) -> Response : \"\"\"Remove a subaccount from a transaction split Args: id: Split ID subaccount: This is the subaccount code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"subaccount\" : subaccount } url = self . _parse_url ( f \"/split/ { id } /subaccount/remove\" ) return self . _handle_request ( HTTPMethod . POST , url , payload ) add_or_update ( id , subaccount , share ) Add a Subaccount to a Transaction Split, or update the share of an existing Subaccount in a Transaction Split Parameters: Name Type Description Default id str Split ID required subaccount str This is the subaccount code required share int This is the transaction share for the subaccount required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/splits.py 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 def add_or_update ( self , id : str , subaccount : str , share : int ) -> Response : \"\"\" Add a Subaccount to a Transaction Split, or update the share of an existing Subaccount in a Transaction Split Args: id: Split ID subaccount: This is the subaccount code share: This is the transaction share for the subaccount Returns: A named tuple containing the response gotten from paystack's server. \"\"\" share = validate_amount ( share ) payload = { \"subaccount\" : subaccount , \"share\" : share } url = self . _parse_url ( f \"/split/ { id } /subaccount/add\" ) return self . _handle_request ( \"POST\" , url , payload ) create ( name , type , currency , subaccounts , bearer_type , bearer_subaccount ) Create a split payment on your integration Parameters: Name Type Description Default name str Name of the transaction split required type Split The type of transaction split you want to create. Any value from the SplitType enum required currency Currency Any value from the Currency enum required subaccounts list [ SplitAccount ] A list of dictionaries containing subaccount code and number of shares: [{subaccount: 'ACT_xxxxxxxxxx', share: xxx},{...}] required bearer_type Bearer Any value from the Bearer enum required bearer_subaccount str Subaccount code required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/splits.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 def create ( self , name : str , type : Split , currency : Currency , subaccounts : list [ SplitAccount ], bearer_type : Bearer , bearer_subaccount : str , ) -> Response : \"\"\"Create a split payment on your integration Args: name: Name of the transaction split type: The type of transaction split you want to create. Any value from the ``SplitType`` enum currency: Any value from the ``Currency`` enum subaccounts: A list of dictionaries containing subaccount code and number of shares: ``[{subaccount: 'ACT_xxxxxxxxxx', share: xxx},{...}]`` bearer_type: Any value from the ``Bearer`` enum bearer_subaccount: Subaccount code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" subaccounts = [ account . dict for account in subaccounts ] url = self . _parse_url ( \"/split\" ) payload = { \"name\" : name , \"type\" : type , \"currency\" : currency , \"subaccounts\" : subaccounts , \"bearer_type\" : bearer_type , \"bearer_subaccount\" : bearer_subaccount , } return self . _handle_request ( HTTPMethod . POST , url , payload ) get_split ( id ) Get details of a split on your integration. Parameters: Name Type Description Default id str The id of the split required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/splits.py 101 102 103 104 105 106 107 108 109 110 111 def get_split ( self , id : str ) -> Response : \"\"\"Get details of a split on your integration. Args: id: The id of the split Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/split/ { id } /\" ) return self . _handle_request ( HTTPMethod . GET , url ) get_splits ( name , sort_by , page , start_date , end_date , active = True , pagination = 50 ) Get/search for the transaction splits available on your integration. Parameters: Name Type Description Default name str The name of the split required sort_by Optional [ str ] Sort by name, defaults to createdAt date required page Optional [ int ] Page number to view. If not specify we use a default value of 1. required start_date Optional [ str ] A timestamp from which to start listing splits e.g. 2019-09-24T00:00:05.000Z, 2019-09-21 required end_date Optional [ str ] A timestamp at which to stop listing splits e.g. 2019-09-24T00:00:05.000Z, 2019-09-21 required active bool Flag to filter by active True pagination int Number of splits per page. If not specified we use a default value of 50. 50 Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/splits.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 def get_splits ( self , name : str , sort_by : Optional [ str ], page : Optional [ int ], start_date : Optional [ str ], end_date : Optional [ str ], active : bool = True , pagination : int = 50 , ) -> Response : \"\"\"Get/search for the transaction splits available on your integration. Args: name: The name of the split sort_by: Sort by name, defaults to createdAt date page: Page number to view. If not specify we use a default value of 1. start_date: A timestamp from which to start listing splits e.g. 2019-09-24T00:00:05.000Z, 2019-09-21 end_date: A timestamp at which to stop listing splits e.g. 2019-09-24T00:00:05.000Z, 2019-09-21 active: Flag to filter by active pagination: Number of splits per page. If not specified we use a default value of 50. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/split?perPage= { pagination } \" ) query_params = [ ( \"name\" , name ), ( \"sort_by\" , sort_by ), ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ( \"active\" , active ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url ) remove ( id , subaccount ) Remove a subaccount from a transaction split Parameters: Name Type Description Default id str Split ID required subaccount str This is the subaccount code required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/splits.py 173 174 175 176 177 178 179 180 181 182 183 184 185 186 def remove ( self , id : str , subaccount : str ) -> Response : \"\"\"Remove a subaccount from a transaction split Args: id: Split ID subaccount: This is the subaccount code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"subaccount\" : subaccount } url = self . _parse_url ( f \"/split/ { id } /subaccount/remove\" ) return self . _handle_request ( HTTPMethod . POST , url , payload ) update ( id , name , active , bearer_type , bearer_subaccount ) Update a transaction split details on your integration Parameters: Name Type Description Default id str Split ID required name str Name of the transaction split required active bool Flag for active required bearer_type Optional [ Bearer ] Any value from the Bearer enum required bearer_subaccount Optional [ str ] Subaccount code of a subaccount in the split group. This should be specified only if the bearer_type is Bearer.subaccount required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/splits.py 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 def update ( self , id : str , name : str , active : bool , bearer_type : Optional [ Bearer ], bearer_subaccount : Optional [ str ], ) -> Response : \"\"\"Update a transaction split details on your integration Args: id: Split ID name: Name of the transaction split active: Flag for active bearer_type: Any value from the Bearer enum bearer_subaccount: Subaccount code of a subaccount in the split group. This should be specified only if the bearer_type is ``Bearer.subaccount`` Returns: A named tuple containing the response gotten from paystack's server. \"\"\" if bearer_subaccount : if bearer_type != Bearer . SUB_ACCOUNT : raise InvalidDataError ( \"`bearer_subaccount` can only have a value if `bearer_type` is `Bearer.SUBACCOUNT`\" ) payload = { \"name\" : name , \"active\" : active , } optional_params = [ ( \"bearer_type\" , bearer_type ), ( \"bearer_subaccount\" , bearer_subaccount ), ] payload = add_to_payload ( optional_params , payload ) url = self . _parse_url ( f \"/split/ { id } /\" ) return self . _handle_request ( HTTPMethod . PUT , url , payload )","title":"Splits"},{"location":"reference/splits/#pypaystack2.api.splits.AsyncTransactionSplit","text":"Bases: BaseAsyncAPI Provides a wrapper for paystack Transaction Splits API The Transaction Splits API enables merchants split the settlement for a transaction across their payout account, and one or more Subaccounts. https://paystack.com/docs/api/#split Source code in pypaystack2/api/splits.py 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 class AsyncTransactionSplit ( BaseAsyncAPI ): \"\"\"Provides a wrapper for paystack Transaction Splits API The Transaction Splits API enables merchants split the settlement for a transaction across their payout account, and one or more Subaccounts. https://paystack.com/docs/api/#split \"\"\" async def create ( self , name : str , type : TransactionSplit , currency : Currency , subaccounts : list [ SplitAccount ], bearer_type : Bearer , bearer_subaccount : str , ) -> Response : \"\"\"Create a split payment on your integration Args: name: Name of the transaction split type: The type of transaction split you want to create. Any value from the ``SplitType`` enum currency: Any value from the ``Currency`` enum subaccounts: A list of dictionaries containing subaccount code and number of shares: ``[{subaccount: 'ACT_xxxxxxxxxx', share: xxx},{...}]`` bearer_type: Any value from the ``Bearer`` enum bearer_subaccount: Subaccount code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" subaccounts = [ account . dict for account in subaccounts ] url = self . _parse_url ( \"/split\" ) payload = { \"name\" : name , \"type\" : type , \"currency\" : currency , \"subaccounts\" : subaccounts , \"bearer_type\" : bearer_type , \"bearer_subaccount\" : bearer_subaccount , } return await self . _handle_request ( HTTPMethod . POST , url , payload ) async def get_splits ( self , name : str , sort_by : Optional [ str ], page : Optional [ int ], start_date : Optional [ str ], end_date : Optional [ str ], active : bool = True , pagination : int = 50 , ) -> Response : \"\"\"Get/search for the transaction splits available on your integration. Args: name: The name of the split sort_by: Sort by name, defaults to createdAt date page: Page number to view. If not specify we use a default value of 1. start_date: A timestamp from which to start listing splits e.g. 2019-09-24T00:00:05.000Z, 2019-09-21 end_date: A timestamp at which to stop listing splits e.g. 2019-09-24T00:00:05.000Z, 2019-09-21 active: Flag to filter by active pagination: Number of splits per page. If not specified we use a default value of 50. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/split?perPage= { pagination } \" ) query_params = [ ( \"name\" , name ), ( \"sort_by\" , sort_by ), ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ( \"active\" , active ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url ) async def get_split ( self , id : str ) -> Response : \"\"\"Get details of a split on your integration. Args: id: The id of the split Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/split/ { id } /\" ) return await self . _handle_request ( HTTPMethod . GET , url ) async def update ( self , id : str , name : str , active : bool , bearer_type : Optional [ Bearer ], bearer_subaccount : Optional [ str ], ) -> Response : \"\"\"Update a transaction split details on your integration Args: id: Split ID name: Name of the transaction split active: Flag for active bearer_type: Any value from the Bearer enum bearer_subaccount: Subaccount code of a subaccount in the split group. This should be specified only if the bearer_type is ``Bearer.subaccount`` Returns: A named tuple containing the response gotten from paystack's server. \"\"\" if bearer_subaccount : if bearer_type != Bearer . SUB_ACCOUNT : raise InvalidDataError ( \"`bearer_subaccount` can only have a value if `bearer_type` is `Bearer.SUBACCOUNT`\" ) payload = { \"name\" : name , \"active\" : active , } optional_params = [ ( \"bearer_type\" , bearer_type ), ( \"bearer_subaccount\" , bearer_subaccount ), ] payload = add_to_payload ( optional_params , payload ) url = self . _parse_url ( f \"/split/ { id } /\" ) return await self . _handle_request ( HTTPMethod . PUT , url , payload ) async def add_or_update ( self , id : str , subaccount : str , share : int ) -> Response : \"\"\" Add a Subaccount to a Transaction Split, or update the share of an existing Subaccount in a Transaction Split Args: id: Split ID subaccount: This is the subaccount code share: This is the transaction share for the subaccount Returns: A named tuple containing the response gotten from paystack's server. \"\"\" share = validate_amount ( share ) payload = { \"subaccount\" : subaccount , \"share\" : share } url = self . _parse_url ( f \"/split/ { id } /subaccount/add\" ) return await self . _handle_request ( \"POST\" , url , payload ) async def remove ( self , id : str , subaccount : str ) -> Response : \"\"\"Remove a subaccount from a transaction split Args: id: Split ID subaccount: This is the subaccount code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"subaccount\" : subaccount } url = self . _parse_url ( f \"/split/ { id } /subaccount/remove\" ) return await self . _handle_request ( HTTPMethod . POST , url , payload )","title":"AsyncTransactionSplit"},{"location":"reference/splits/#pypaystack2.api.splits.AsyncTransactionSplit.add_or_update","text":"Add a Subaccount to a Transaction Split, or update the share of an existing Subaccount in a Transaction Split Parameters: Name Type Description Default id str Split ID required subaccount str This is the subaccount code required share int This is the transaction share for the subaccount required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/splits.py 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 async def add_or_update ( self , id : str , subaccount : str , share : int ) -> Response : \"\"\" Add a Subaccount to a Transaction Split, or update the share of an existing Subaccount in a Transaction Split Args: id: Split ID subaccount: This is the subaccount code share: This is the transaction share for the subaccount Returns: A named tuple containing the response gotten from paystack's server. \"\"\" share = validate_amount ( share ) payload = { \"subaccount\" : subaccount , \"share\" : share } url = self . _parse_url ( f \"/split/ { id } /subaccount/add\" ) return await self . _handle_request ( \"POST\" , url , payload )","title":"add_or_update()"},{"location":"reference/splits/#pypaystack2.api.splits.AsyncTransactionSplit.create","text":"Create a split payment on your integration Parameters: Name Type Description Default name str Name of the transaction split required type TransactionSplit The type of transaction split you want to create. Any value from the SplitType enum required currency Currency Any value from the Currency enum required subaccounts list [ SplitAccount ] A list of dictionaries containing subaccount code and number of shares: [{subaccount: 'ACT_xxxxxxxxxx', share: xxx},{...}] required bearer_type Bearer Any value from the Bearer enum required bearer_subaccount str Subaccount code required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/splits.py 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 async def create ( self , name : str , type : TransactionSplit , currency : Currency , subaccounts : list [ SplitAccount ], bearer_type : Bearer , bearer_subaccount : str , ) -> Response : \"\"\"Create a split payment on your integration Args: name: Name of the transaction split type: The type of transaction split you want to create. Any value from the ``SplitType`` enum currency: Any value from the ``Currency`` enum subaccounts: A list of dictionaries containing subaccount code and number of shares: ``[{subaccount: 'ACT_xxxxxxxxxx', share: xxx},{...}]`` bearer_type: Any value from the ``Bearer`` enum bearer_subaccount: Subaccount code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" subaccounts = [ account . dict for account in subaccounts ] url = self . _parse_url ( \"/split\" ) payload = { \"name\" : name , \"type\" : type , \"currency\" : currency , \"subaccounts\" : subaccounts , \"bearer_type\" : bearer_type , \"bearer_subaccount\" : bearer_subaccount , } return await self . _handle_request ( HTTPMethod . POST , url , payload )","title":"create()"},{"location":"reference/splits/#pypaystack2.api.splits.AsyncTransactionSplit.get_split","text":"Get details of a split on your integration. Parameters: Name Type Description Default id str The id of the split required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/splits.py 272 273 274 275 276 277 278 279 280 281 282 async def get_split ( self , id : str ) -> Response : \"\"\"Get details of a split on your integration. Args: id: The id of the split Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/split/ { id } /\" ) return await self . _handle_request ( HTTPMethod . GET , url )","title":"get_split()"},{"location":"reference/splits/#pypaystack2.api.splits.AsyncTransactionSplit.get_splits","text":"Get/search for the transaction splits available on your integration. Parameters: Name Type Description Default name str The name of the split required sort_by Optional [ str ] Sort by name, defaults to createdAt date required page Optional [ int ] Page number to view. If not specify we use a default value of 1. required start_date Optional [ str ] A timestamp from which to start listing splits e.g. 2019-09-24T00:00:05.000Z, 2019-09-21 required end_date Optional [ str ] A timestamp at which to stop listing splits e.g. 2019-09-24T00:00:05.000Z, 2019-09-21 required active bool Flag to filter by active True pagination int Number of splits per page. If not specified we use a default value of 50. 50 Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/splits.py 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 async def get_splits ( self , name : str , sort_by : Optional [ str ], page : Optional [ int ], start_date : Optional [ str ], end_date : Optional [ str ], active : bool = True , pagination : int = 50 , ) -> Response : \"\"\"Get/search for the transaction splits available on your integration. Args: name: The name of the split sort_by: Sort by name, defaults to createdAt date page: Page number to view. If not specify we use a default value of 1. start_date: A timestamp from which to start listing splits e.g. 2019-09-24T00:00:05.000Z, 2019-09-21 end_date: A timestamp at which to stop listing splits e.g. 2019-09-24T00:00:05.000Z, 2019-09-21 active: Flag to filter by active pagination: Number of splits per page. If not specified we use a default value of 50. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/split?perPage= { pagination } \" ) query_params = [ ( \"name\" , name ), ( \"sort_by\" , sort_by ), ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ( \"active\" , active ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url )","title":"get_splits()"},{"location":"reference/splits/#pypaystack2.api.splits.AsyncTransactionSplit.remove","text":"Remove a subaccount from a transaction split Parameters: Name Type Description Default id str Split ID required subaccount str This is the subaccount code required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/splits.py 344 345 346 347 348 349 350 351 352 353 354 355 356 357 async def remove ( self , id : str , subaccount : str ) -> Response : \"\"\"Remove a subaccount from a transaction split Args: id: Split ID subaccount: This is the subaccount code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"subaccount\" : subaccount } url = self . _parse_url ( f \"/split/ { id } /subaccount/remove\" ) return await self . _handle_request ( HTTPMethod . POST , url , payload )","title":"remove()"},{"location":"reference/splits/#pypaystack2.api.splits.AsyncTransactionSplit.update","text":"Update a transaction split details on your integration Parameters: Name Type Description Default id str Split ID required name str Name of the transaction split required active bool Flag for active required bearer_type Optional [ Bearer ] Any value from the Bearer enum required bearer_subaccount Optional [ str ] Subaccount code of a subaccount in the split group. This should be specified only if the bearer_type is Bearer.subaccount required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/splits.py 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 async def update ( self , id : str , name : str , active : bool , bearer_type : Optional [ Bearer ], bearer_subaccount : Optional [ str ], ) -> Response : \"\"\"Update a transaction split details on your integration Args: id: Split ID name: Name of the transaction split active: Flag for active bearer_type: Any value from the Bearer enum bearer_subaccount: Subaccount code of a subaccount in the split group. This should be specified only if the bearer_type is ``Bearer.subaccount`` Returns: A named tuple containing the response gotten from paystack's server. \"\"\" if bearer_subaccount : if bearer_type != Bearer . SUB_ACCOUNT : raise InvalidDataError ( \"`bearer_subaccount` can only have a value if `bearer_type` is `Bearer.SUBACCOUNT`\" ) payload = { \"name\" : name , \"active\" : active , } optional_params = [ ( \"bearer_type\" , bearer_type ), ( \"bearer_subaccount\" , bearer_subaccount ), ] payload = add_to_payload ( optional_params , payload ) url = self . _parse_url ( f \"/split/ { id } /\" ) return await self . _handle_request ( HTTPMethod . PUT , url , payload )","title":"update()"},{"location":"reference/splits/#pypaystack2.api.splits.TransactionSplit","text":"Bases: BaseAPI Provides a wrapper for paystack Transaction Splits API The Transaction Splits API enables merchants split the settlement for a transaction across their payout account, and one or more Subaccounts. https://paystack.com/docs/api/#split Source code in pypaystack2/api/splits.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 class TransactionSplit ( BaseAPI ): \"\"\"Provides a wrapper for paystack Transaction Splits API The Transaction Splits API enables merchants split the settlement for a transaction across their payout account, and one or more Subaccounts. https://paystack.com/docs/api/#split \"\"\" def create ( self , name : str , type : Split , currency : Currency , subaccounts : list [ SplitAccount ], bearer_type : Bearer , bearer_subaccount : str , ) -> Response : \"\"\"Create a split payment on your integration Args: name: Name of the transaction split type: The type of transaction split you want to create. Any value from the ``SplitType`` enum currency: Any value from the ``Currency`` enum subaccounts: A list of dictionaries containing subaccount code and number of shares: ``[{subaccount: 'ACT_xxxxxxxxxx', share: xxx},{...}]`` bearer_type: Any value from the ``Bearer`` enum bearer_subaccount: Subaccount code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" subaccounts = [ account . dict for account in subaccounts ] url = self . _parse_url ( \"/split\" ) payload = { \"name\" : name , \"type\" : type , \"currency\" : currency , \"subaccounts\" : subaccounts , \"bearer_type\" : bearer_type , \"bearer_subaccount\" : bearer_subaccount , } return self . _handle_request ( HTTPMethod . POST , url , payload ) def get_splits ( self , name : str , sort_by : Optional [ str ], page : Optional [ int ], start_date : Optional [ str ], end_date : Optional [ str ], active : bool = True , pagination : int = 50 , ) -> Response : \"\"\"Get/search for the transaction splits available on your integration. Args: name: The name of the split sort_by: Sort by name, defaults to createdAt date page: Page number to view. If not specify we use a default value of 1. start_date: A timestamp from which to start listing splits e.g. 2019-09-24T00:00:05.000Z, 2019-09-21 end_date: A timestamp at which to stop listing splits e.g. 2019-09-24T00:00:05.000Z, 2019-09-21 active: Flag to filter by active pagination: Number of splits per page. If not specified we use a default value of 50. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/split?perPage= { pagination } \" ) query_params = [ ( \"name\" , name ), ( \"sort_by\" , sort_by ), ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ( \"active\" , active ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url ) def get_split ( self , id : str ) -> Response : \"\"\"Get details of a split on your integration. Args: id: The id of the split Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/split/ { id } /\" ) return self . _handle_request ( HTTPMethod . GET , url ) def update ( self , id : str , name : str , active : bool , bearer_type : Optional [ Bearer ], bearer_subaccount : Optional [ str ], ) -> Response : \"\"\"Update a transaction split details on your integration Args: id: Split ID name: Name of the transaction split active: Flag for active bearer_type: Any value from the Bearer enum bearer_subaccount: Subaccount code of a subaccount in the split group. This should be specified only if the bearer_type is ``Bearer.subaccount`` Returns: A named tuple containing the response gotten from paystack's server. \"\"\" if bearer_subaccount : if bearer_type != Bearer . SUB_ACCOUNT : raise InvalidDataError ( \"`bearer_subaccount` can only have a value if `bearer_type` is `Bearer.SUBACCOUNT`\" ) payload = { \"name\" : name , \"active\" : active , } optional_params = [ ( \"bearer_type\" , bearer_type ), ( \"bearer_subaccount\" , bearer_subaccount ), ] payload = add_to_payload ( optional_params , payload ) url = self . _parse_url ( f \"/split/ { id } /\" ) return self . _handle_request ( HTTPMethod . PUT , url , payload ) def add_or_update ( self , id : str , subaccount : str , share : int ) -> Response : \"\"\" Add a Subaccount to a Transaction Split, or update the share of an existing Subaccount in a Transaction Split Args: id: Split ID subaccount: This is the subaccount code share: This is the transaction share for the subaccount Returns: A named tuple containing the response gotten from paystack's server. \"\"\" share = validate_amount ( share ) payload = { \"subaccount\" : subaccount , \"share\" : share } url = self . _parse_url ( f \"/split/ { id } /subaccount/add\" ) return self . _handle_request ( \"POST\" , url , payload ) def remove ( self , id : str , subaccount : str ) -> Response : \"\"\"Remove a subaccount from a transaction split Args: id: Split ID subaccount: This is the subaccount code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"subaccount\" : subaccount } url = self . _parse_url ( f \"/split/ { id } /subaccount/remove\" ) return self . _handle_request ( HTTPMethod . POST , url , payload )","title":"TransactionSplit"},{"location":"reference/splits/#pypaystack2.api.splits.TransactionSplit.add_or_update","text":"Add a Subaccount to a Transaction Split, or update the share of an existing Subaccount in a Transaction Split Parameters: Name Type Description Default id str Split ID required subaccount str This is the subaccount code required share int This is the transaction share for the subaccount required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/splits.py 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 def add_or_update ( self , id : str , subaccount : str , share : int ) -> Response : \"\"\" Add a Subaccount to a Transaction Split, or update the share of an existing Subaccount in a Transaction Split Args: id: Split ID subaccount: This is the subaccount code share: This is the transaction share for the subaccount Returns: A named tuple containing the response gotten from paystack's server. \"\"\" share = validate_amount ( share ) payload = { \"subaccount\" : subaccount , \"share\" : share } url = self . _parse_url ( f \"/split/ { id } /subaccount/add\" ) return self . _handle_request ( \"POST\" , url , payload )","title":"add_or_update()"},{"location":"reference/splits/#pypaystack2.api.splits.TransactionSplit.create","text":"Create a split payment on your integration Parameters: Name Type Description Default name str Name of the transaction split required type Split The type of transaction split you want to create. Any value from the SplitType enum required currency Currency Any value from the Currency enum required subaccounts list [ SplitAccount ] A list of dictionaries containing subaccount code and number of shares: [{subaccount: 'ACT_xxxxxxxxxx', share: xxx},{...}] required bearer_type Bearer Any value from the Bearer enum required bearer_subaccount str Subaccount code required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/splits.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 def create ( self , name : str , type : Split , currency : Currency , subaccounts : list [ SplitAccount ], bearer_type : Bearer , bearer_subaccount : str , ) -> Response : \"\"\"Create a split payment on your integration Args: name: Name of the transaction split type: The type of transaction split you want to create. Any value from the ``SplitType`` enum currency: Any value from the ``Currency`` enum subaccounts: A list of dictionaries containing subaccount code and number of shares: ``[{subaccount: 'ACT_xxxxxxxxxx', share: xxx},{...}]`` bearer_type: Any value from the ``Bearer`` enum bearer_subaccount: Subaccount code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" subaccounts = [ account . dict for account in subaccounts ] url = self . _parse_url ( \"/split\" ) payload = { \"name\" : name , \"type\" : type , \"currency\" : currency , \"subaccounts\" : subaccounts , \"bearer_type\" : bearer_type , \"bearer_subaccount\" : bearer_subaccount , } return self . _handle_request ( HTTPMethod . POST , url , payload )","title":"create()"},{"location":"reference/splits/#pypaystack2.api.splits.TransactionSplit.get_split","text":"Get details of a split on your integration. Parameters: Name Type Description Default id str The id of the split required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/splits.py 101 102 103 104 105 106 107 108 109 110 111 def get_split ( self , id : str ) -> Response : \"\"\"Get details of a split on your integration. Args: id: The id of the split Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/split/ { id } /\" ) return self . _handle_request ( HTTPMethod . GET , url )","title":"get_split()"},{"location":"reference/splits/#pypaystack2.api.splits.TransactionSplit.get_splits","text":"Get/search for the transaction splits available on your integration. Parameters: Name Type Description Default name str The name of the split required sort_by Optional [ str ] Sort by name, defaults to createdAt date required page Optional [ int ] Page number to view. If not specify we use a default value of 1. required start_date Optional [ str ] A timestamp from which to start listing splits e.g. 2019-09-24T00:00:05.000Z, 2019-09-21 required end_date Optional [ str ] A timestamp at which to stop listing splits e.g. 2019-09-24T00:00:05.000Z, 2019-09-21 required active bool Flag to filter by active True pagination int Number of splits per page. If not specified we use a default value of 50. 50 Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/splits.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 def get_splits ( self , name : str , sort_by : Optional [ str ], page : Optional [ int ], start_date : Optional [ str ], end_date : Optional [ str ], active : bool = True , pagination : int = 50 , ) -> Response : \"\"\"Get/search for the transaction splits available on your integration. Args: name: The name of the split sort_by: Sort by name, defaults to createdAt date page: Page number to view. If not specify we use a default value of 1. start_date: A timestamp from which to start listing splits e.g. 2019-09-24T00:00:05.000Z, 2019-09-21 end_date: A timestamp at which to stop listing splits e.g. 2019-09-24T00:00:05.000Z, 2019-09-21 active: Flag to filter by active pagination: Number of splits per page. If not specified we use a default value of 50. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/split?perPage= { pagination } \" ) query_params = [ ( \"name\" , name ), ( \"sort_by\" , sort_by ), ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ( \"active\" , active ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url )","title":"get_splits()"},{"location":"reference/splits/#pypaystack2.api.splits.TransactionSplit.remove","text":"Remove a subaccount from a transaction split Parameters: Name Type Description Default id str Split ID required subaccount str This is the subaccount code required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/splits.py 173 174 175 176 177 178 179 180 181 182 183 184 185 186 def remove ( self , id : str , subaccount : str ) -> Response : \"\"\"Remove a subaccount from a transaction split Args: id: Split ID subaccount: This is the subaccount code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"subaccount\" : subaccount } url = self . _parse_url ( f \"/split/ { id } /subaccount/remove\" ) return self . _handle_request ( HTTPMethod . POST , url , payload )","title":"remove()"},{"location":"reference/splits/#pypaystack2.api.splits.TransactionSplit.update","text":"Update a transaction split details on your integration Parameters: Name Type Description Default id str Split ID required name str Name of the transaction split required active bool Flag for active required bearer_type Optional [ Bearer ] Any value from the Bearer enum required bearer_subaccount Optional [ str ] Subaccount code of a subaccount in the split group. This should be specified only if the bearer_type is Bearer.subaccount required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/splits.py 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 def update ( self , id : str , name : str , active : bool , bearer_type : Optional [ Bearer ], bearer_subaccount : Optional [ str ], ) -> Response : \"\"\"Update a transaction split details on your integration Args: id: Split ID name: Name of the transaction split active: Flag for active bearer_type: Any value from the Bearer enum bearer_subaccount: Subaccount code of a subaccount in the split group. This should be specified only if the bearer_type is ``Bearer.subaccount`` Returns: A named tuple containing the response gotten from paystack's server. \"\"\" if bearer_subaccount : if bearer_type != Bearer . SUB_ACCOUNT : raise InvalidDataError ( \"`bearer_subaccount` can only have a value if `bearer_type` is `Bearer.SUBACCOUNT`\" ) payload = { \"name\" : name , \"active\" : active , } optional_params = [ ( \"bearer_type\" , bearer_type ), ( \"bearer_subaccount\" , bearer_subaccount ), ] payload = add_to_payload ( optional_params , payload ) url = self . _parse_url ( f \"/split/ { id } /\" ) return self . _handle_request ( HTTPMethod . PUT , url , payload )","title":"update()"},{"location":"reference/subaccounts/","text":"AsyncSubAccount Bases: BaseAsyncAPI Provides a wrapper for paystack Subaccounts API The Subaccounts API allows you to create and manage subaccounts on your integration. Subaccounts can be used to split payment between two accounts (your main account and a sub account). https://paystack.com/docs/api/#subaccount Source code in pypaystack2/api/subaccounts.py 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 class AsyncSubAccount ( BaseAsyncAPI ): \"\"\"Provides a wrapper for paystack Subaccounts API The Subaccounts API allows you to create and manage subaccounts on your integration. Subaccounts can be used to split payment between two accounts (your main account and a sub account). https://paystack.com/docs/api/#subaccount \"\"\" async def create ( self , business_name : str , settlement_bank : str , account_number : str , percentage_charge : float , description : str , primary_contact_email : Optional [ str ] = None , primary_contact_name : Optional [ str ] = None , primary_contact_phone : Optional [ str ] = None , metadata : Optional [ dict ] = None , ) -> Response : \"\"\"Create a subacount on your integration. Args: business_name: Name of business for subaccount settlement_bank: Bank Code for the bank. You can get the list of Bank Codes by calling the ``.get_banks`` method from the Miscellaneous API wrapper account_number: Bank Account Number percentage_charge: The default percentage charged when receiving on behalf of this subaccount description: A description for this subaccount primary_contact_email: A contact email for the subaccount primary_contact_name: A name for the contact person for this subaccount primary_contact_phone: A phone number to call for this subaccount metadata: Add a custom_fields attribute which has a list of dictionaries if you would like the fields to be added to your transaction when displayed on the dashboard. Sample: ``{\"custom_fields\":[{\"display_name\":\"Cart ID\", \"variable_name\": \"cart_id\",\"value\": \"8393\"}]}`` Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/subaccount\" ) payload = { \"business_name\" : business_name , \"settlement_bank\" : settlement_bank , \"account_number\" : account_number , \"percentage_charge\" : percentage_charge , \"description\" : description , } optional_params = [ ( \"primary_contact_email\" , primary_contact_email ), ( \"primary_contact_name\" , primary_contact_name ), ( \"primary_contact_phone\" , primary_contact_phone ), ( \"metadata\" , metadata ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) async def get_subaccounts ( self , start_date : str , end_date : str , page : int = 1 , pagination : int = 50 ) -> Response : \"\"\"Fetch subaccounts available on your integration. Args: start_date: A timestamp from which to start listing subaccounts e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing subaccounts e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 page: Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/subaccount?perPage= { pagination } \" ) query_params = [ ( \"from\" , start_date ), ( \"to\" , end_date ), ( \"page\" , page ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url ) async def get_subaccount ( self , id_or_code : str ) -> Response : \"\"\"Get details of a subaccount on your integration. Args: id_or_code: The subaccount ``ID`` or ``code`` you want to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/subaccount/ { id_or_code } \" ) return await self . _handle_request ( HTTPMethod . GET , url ) async def update ( self , id_or_code : str , business_name : str , settlement_bank : str , account_number : Optional [ str ] = None , active : Optional [ bool ] = None , percentage_charge : Optional [ float ] = None , description : Optional [ str ] = None , primary_contact_email : Optional [ str ] = None , primary_contact_name : Optional [ str ] = None , primary_contact_phone : Optional [ str ] = None , settlement_schedule : Optional [ Schedule ] = None , metadata : Optional [ dict ] = None , ) -> Response : \"\"\"Update a subaccount details on your integration. Args: id_or_code: Subaccount's ID or code business_name: Name of business for subaccount settlement_bank: Bank Code for the bank. You can get the list of Bank Codes by calling the ``.get_banks`` method from the Miscellaneous API wrapper account_number: Bank Account Number active: Activate or deactivate a subaccount. percentage_charge: The default percentage charged when receiving on behalf of this subaccount description: A description for this subaccount primary_contact_email: A contact email for the subaccount primary_contact_name: A name for the contact person for this subaccount primary_contact_phone: A phone number to call for this subaccount settlement_schedule: ``Schedule.AUTO`` means payout is T+1 and manual means payout to the subaccount should only be made when requested. Defaults to ``Schedule.AUTO`` metadata: Add a custom_fields attribute which has a list of dictionaries if you would like the fields to be added to your transaction when displayed on the dashboard. Sample: ``{\"custom_fields\":[{\"display_name\":\"Cart ID\", \"variable_name\": \"cart_id\",\"value\": \"8393\"}]}`` Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"id_or_code\" : id_or_code , \"business_name\" : business_name , \"settlement_bank\" : settlement_bank , } optional_params = [ ( \"account_number\" , account_number ), ( \"active\" , active ), ( \"percentage_charge\" , percentage_charge ), ( \"description\" , description ), ( \"primary_contact_email\" , primary_contact_email ), ( \"primary_contact_name\" , primary_contact_name ), ( \"primary_contact_phone\" , primary_contact_phone ), ( \"settlement_schedule\" , settlement_schedule ), ( \"metadata\" , metadata ), ] payload = add_to_payload ( optional_params , payload ) url = self . _parse_url ( f \"/subaccount/ { id_or_code } \" ) return await self . _handle_request ( HTTPMethod . PUT , url , payload ) create ( business_name , settlement_bank , account_number , percentage_charge , description , primary_contact_email = None , primary_contact_name = None , primary_contact_phone = None , metadata = None ) async Create a subacount on your integration. Parameters: Name Type Description Default business_name str Name of business for subaccount required settlement_bank str Bank Code for the bank. You can get the list of Bank Codes by calling the .get_banks method from the Miscellaneous API wrapper required account_number str Bank Account Number required percentage_charge float The default percentage charged when receiving on behalf of this subaccount required description str A description for this subaccount required primary_contact_email Optional [ str ] A contact email for the subaccount None primary_contact_name Optional [ str ] A name for the contact person for this subaccount None primary_contact_phone Optional [ str ] A phone number to call for this subaccount None metadata Optional [ dict ] Add a custom_fields attribute which has a list of dictionaries if you would like the fields to be added to your transaction when displayed on the dashboard. Sample: {\"custom_fields\":[{\"display_name\":\"Cart ID\", \"variable_name\": \"cart_id\",\"value\": \"8393\"}]} None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/subaccounts.py 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 async def create ( self , business_name : str , settlement_bank : str , account_number : str , percentage_charge : float , description : str , primary_contact_email : Optional [ str ] = None , primary_contact_name : Optional [ str ] = None , primary_contact_phone : Optional [ str ] = None , metadata : Optional [ dict ] = None , ) -> Response : \"\"\"Create a subacount on your integration. Args: business_name: Name of business for subaccount settlement_bank: Bank Code for the bank. You can get the list of Bank Codes by calling the ``.get_banks`` method from the Miscellaneous API wrapper account_number: Bank Account Number percentage_charge: The default percentage charged when receiving on behalf of this subaccount description: A description for this subaccount primary_contact_email: A contact email for the subaccount primary_contact_name: A name for the contact person for this subaccount primary_contact_phone: A phone number to call for this subaccount metadata: Add a custom_fields attribute which has a list of dictionaries if you would like the fields to be added to your transaction when displayed on the dashboard. Sample: ``{\"custom_fields\":[{\"display_name\":\"Cart ID\", \"variable_name\": \"cart_id\",\"value\": \"8393\"}]}`` Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/subaccount\" ) payload = { \"business_name\" : business_name , \"settlement_bank\" : settlement_bank , \"account_number\" : account_number , \"percentage_charge\" : percentage_charge , \"description\" : description , } optional_params = [ ( \"primary_contact_email\" , primary_contact_email ), ( \"primary_contact_name\" , primary_contact_name ), ( \"primary_contact_phone\" , primary_contact_phone ), ( \"metadata\" , metadata ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) get_subaccount ( id_or_code ) async Get details of a subaccount on your integration. Parameters: Name Type Description Default id_or_code str The subaccount ID or code you want to fetch required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/subaccounts.py 260 261 262 263 264 265 266 267 268 269 270 271 async def get_subaccount ( self , id_or_code : str ) -> Response : \"\"\"Get details of a subaccount on your integration. Args: id_or_code: The subaccount ``ID`` or ``code`` you want to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/subaccount/ { id_or_code } \" ) return await self . _handle_request ( HTTPMethod . GET , url ) get_subaccounts ( start_date , end_date , page = 1 , pagination = 50 ) async Fetch subaccounts available on your integration. Parameters: Name Type Description Default start_date str A timestamp from which to start listing subaccounts e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 required end_date str A timestamp at which to stop listing subaccounts e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 required page int Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. 1 pagination int Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. 50 Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/subaccounts.py 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 async def get_subaccounts ( self , start_date : str , end_date : str , page : int = 1 , pagination : int = 50 ) -> Response : \"\"\"Fetch subaccounts available on your integration. Args: start_date: A timestamp from which to start listing subaccounts e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing subaccounts e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 page: Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/subaccount?perPage= { pagination } \" ) query_params = [ ( \"from\" , start_date ), ( \"to\" , end_date ), ( \"page\" , page ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url ) update ( id_or_code , business_name , settlement_bank , account_number = None , active = None , percentage_charge = None , description = None , primary_contact_email = None , primary_contact_name = None , primary_contact_phone = None , settlement_schedule = None , metadata = None ) async Update a subaccount details on your integration. Parameters: Name Type Description Default id_or_code str Subaccount's ID or code required business_name str Name of business for subaccount required settlement_bank str Bank Code for the bank. You can get the list of Bank Codes by calling the .get_banks method from the Miscellaneous API wrapper required account_number Optional [ str ] Bank Account Number None active Optional [ bool ] Activate or deactivate a subaccount. None percentage_charge Optional [ float ] The default percentage charged when receiving on behalf of this subaccount None description Optional [ str ] A description for this subaccount None primary_contact_email Optional [ str ] A contact email for the subaccount None primary_contact_name Optional [ str ] A name for the contact person for this subaccount None primary_contact_phone Optional [ str ] A phone number to call for this subaccount None settlement_schedule Optional [ Schedule ] Schedule.AUTO means payout is T+1 and manual means payout to the subaccount should only be made when requested. Defaults to Schedule.AUTO None metadata Optional [ dict ] Add a custom_fields attribute which has a list of dictionaries if you would like the fields to be added to your transaction when displayed on the dashboard. Sample: {\"custom_fields\":[{\"display_name\":\"Cart ID\", \"variable_name\": \"cart_id\",\"value\": \"8393\"}]} None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/subaccounts.py 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 async def update ( self , id_or_code : str , business_name : str , settlement_bank : str , account_number : Optional [ str ] = None , active : Optional [ bool ] = None , percentage_charge : Optional [ float ] = None , description : Optional [ str ] = None , primary_contact_email : Optional [ str ] = None , primary_contact_name : Optional [ str ] = None , primary_contact_phone : Optional [ str ] = None , settlement_schedule : Optional [ Schedule ] = None , metadata : Optional [ dict ] = None , ) -> Response : \"\"\"Update a subaccount details on your integration. Args: id_or_code: Subaccount's ID or code business_name: Name of business for subaccount settlement_bank: Bank Code for the bank. You can get the list of Bank Codes by calling the ``.get_banks`` method from the Miscellaneous API wrapper account_number: Bank Account Number active: Activate or deactivate a subaccount. percentage_charge: The default percentage charged when receiving on behalf of this subaccount description: A description for this subaccount primary_contact_email: A contact email for the subaccount primary_contact_name: A name for the contact person for this subaccount primary_contact_phone: A phone number to call for this subaccount settlement_schedule: ``Schedule.AUTO`` means payout is T+1 and manual means payout to the subaccount should only be made when requested. Defaults to ``Schedule.AUTO`` metadata: Add a custom_fields attribute which has a list of dictionaries if you would like the fields to be added to your transaction when displayed on the dashboard. Sample: ``{\"custom_fields\":[{\"display_name\":\"Cart ID\", \"variable_name\": \"cart_id\",\"value\": \"8393\"}]}`` Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"id_or_code\" : id_or_code , \"business_name\" : business_name , \"settlement_bank\" : settlement_bank , } optional_params = [ ( \"account_number\" , account_number ), ( \"active\" , active ), ( \"percentage_charge\" , percentage_charge ), ( \"description\" , description ), ( \"primary_contact_email\" , primary_contact_email ), ( \"primary_contact_name\" , primary_contact_name ), ( \"primary_contact_phone\" , primary_contact_phone ), ( \"settlement_schedule\" , settlement_schedule ), ( \"metadata\" , metadata ), ] payload = add_to_payload ( optional_params , payload ) url = self . _parse_url ( f \"/subaccount/ { id_or_code } \" ) return await self . _handle_request ( HTTPMethod . PUT , url , payload ) SubAccount Bases: BaseAPI Provides a wrapper for paystack Subaccounts API The Subaccounts API allows you to create and manage subaccounts on your integration. Subaccounts can be used to split payment between two accounts (your main account and a sub account). https://paystack.com/docs/api/#subaccount Source code in pypaystack2/api/subaccounts.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 class SubAccount ( BaseAPI ): \"\"\"Provides a wrapper for paystack Subaccounts API The Subaccounts API allows you to create and manage subaccounts on your integration. Subaccounts can be used to split payment between two accounts (your main account and a sub account). https://paystack.com/docs/api/#subaccount \"\"\" def create ( self , business_name : str , settlement_bank : str , account_number : str , percentage_charge : float , description : Optional [ str ] = None , primary_contact_email : Optional [ str ] = None , primary_contact_name : Optional [ str ] = None , primary_contact_phone : Optional [ str ] = None , metadata : Optional [ dict ] = None , ) -> Response : \"\"\"Create a subacount on your integration. Args: business_name: Name of business for subaccount settlement_bank: Bank Code for the bank. You can get the list of Bank Codes by calling the ``.get_banks`` method from the Miscellaneous API wrapper account_number: Bank Account Number percentage_charge: The default percentage charged when receiving on behalf of this subaccount description: A description for this subaccount primary_contact_email: A contact email for the subaccount primary_contact_name: A name for the contact person for this subaccount primary_contact_phone: A phone number to call for this subaccount metadata: Add a custom_fields attribute which has a list of dictionaries if you would like the fields to be added to your transaction when displayed on the dashboard. Sample: ``{\"custom_fields\":[{\"display_name\":\"Cart ID\", \"variable_name\": \"cart_id\",\"value\": \"8393\"}]}`` Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/subaccount\" ) payload = { \"business_name\" : business_name , \"settlement_bank\" : settlement_bank , \"account_number\" : account_number , \"percentage_charge\" : percentage_charge , \"description\" : description , } optional_params = [ ( \"primary_contact_email\" , primary_contact_email ), ( \"primary_contact_name\" , primary_contact_name ), ( \"primary_contact_phone\" , primary_contact_phone ), ( \"metadata\" , metadata ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . POST , url , payload ) def get_subaccounts ( self , start_date : str , end_date : str , page : int = 1 , pagination : int = 50 ) -> Response : \"\"\"Fetch subaccounts available on your integration. Args: start_date: A timestamp from which to start listing subaccounts e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing subaccounts e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 page: Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/subaccount?perPage= { pagination } \" ) query_params = [ ( \"from\" , start_date ), ( \"to\" , end_date ), ( \"page\" , page ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url ) def get_subaccount ( self , id_or_code : str ) -> Response : \"\"\"Get details of a subaccount on your integration. Args: id_or_code: The subaccount ``ID`` or ``code`` you want to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/subaccount/ { id_or_code } \" ) return self . _handle_request ( HTTPMethod . GET , url ) def update ( self , id_or_code : str , business_name : str , settlement_bank : str , account_number : Optional [ str ] = None , active : Optional [ bool ] = None , percentage_charge : Optional [ float ] = None , description : Optional [ str ] = None , primary_contact_email : Optional [ str ] = None , primary_contact_name : Optional [ str ] = None , primary_contact_phone : Optional [ str ] = None , settlement_schedule : Optional [ Schedule ] = None , metadata : Optional [ dict ] = None , ) -> Response : \"\"\"Update a subaccount details on your integration. Args: id_or_code: Subaccount's ID or code business_name: Name of business for subaccount settlement_bank: Bank Code for the bank. You can get the list of Bank Codes by calling the ``.get_banks`` method from the Miscellaneous API wrapper account_number: Bank Account Number active: Activate or deactivate a subaccount. percentage_charge: The default percentage charged when receiving on behalf of this subaccount description: A description for this subaccount primary_contact_email: A contact email for the subaccount primary_contact_name: A name for the contact person for this subaccount primary_contact_phone: A phone number to call for this subaccount settlement_schedule: ``Schedule.AUTO`` means payout is T+1 and manual means payout to the subaccount should only be made when requested. Defaults to ``Schedule.AUTO`` metadata: Add a custom_fields attribute which has a list of dictionaries if you would like the fields to be added to your transaction when displayed on the dashboard. Sample: ``{\"custom_fields\":[{\"display_name\":\"Cart ID\", \"variable_name\": \"cart_id\",\"value\": \"8393\"}]}`` Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"id_or_code\" : id_or_code , \"business_name\" : business_name , \"settlement_bank\" : settlement_bank , } optional_params = [ ( \"account_number\" , account_number ), ( \"active\" , active ), ( \"percentage_charge\" , percentage_charge ), ( \"description\" , description ), ( \"primary_contact_email\" , primary_contact_email ), ( \"primary_contact_name\" , primary_contact_name ), ( \"primary_contact_phone\" , primary_contact_phone ), ( \"settlement_schedule\" , settlement_schedule ), ( \"metadata\" , metadata ), ] payload = add_to_payload ( optional_params , payload ) url = self . _parse_url ( f \"/subaccount/ { id_or_code } \" ) return self . _handle_request ( HTTPMethod . PUT , url , payload ) create ( business_name , settlement_bank , account_number , percentage_charge , description = None , primary_contact_email = None , primary_contact_name = None , primary_contact_phone = None , metadata = None ) Create a subacount on your integration. Parameters: Name Type Description Default business_name str Name of business for subaccount required settlement_bank str Bank Code for the bank. You can get the list of Bank Codes by calling the .get_banks method from the Miscellaneous API wrapper required account_number str Bank Account Number required percentage_charge float The default percentage charged when receiving on behalf of this subaccount required description Optional [ str ] A description for this subaccount None primary_contact_email Optional [ str ] A contact email for the subaccount None primary_contact_name Optional [ str ] A name for the contact person for this subaccount None primary_contact_phone Optional [ str ] A phone number to call for this subaccount None metadata Optional [ dict ] Add a custom_fields attribute which has a list of dictionaries if you would like the fields to be added to your transaction when displayed on the dashboard. Sample: {\"custom_fields\":[{\"display_name\":\"Cart ID\", \"variable_name\": \"cart_id\",\"value\": \"8393\"}]} None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/subaccounts.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 def create ( self , business_name : str , settlement_bank : str , account_number : str , percentage_charge : float , description : Optional [ str ] = None , primary_contact_email : Optional [ str ] = None , primary_contact_name : Optional [ str ] = None , primary_contact_phone : Optional [ str ] = None , metadata : Optional [ dict ] = None , ) -> Response : \"\"\"Create a subacount on your integration. Args: business_name: Name of business for subaccount settlement_bank: Bank Code for the bank. You can get the list of Bank Codes by calling the ``.get_banks`` method from the Miscellaneous API wrapper account_number: Bank Account Number percentage_charge: The default percentage charged when receiving on behalf of this subaccount description: A description for this subaccount primary_contact_email: A contact email for the subaccount primary_contact_name: A name for the contact person for this subaccount primary_contact_phone: A phone number to call for this subaccount metadata: Add a custom_fields attribute which has a list of dictionaries if you would like the fields to be added to your transaction when displayed on the dashboard. Sample: ``{\"custom_fields\":[{\"display_name\":\"Cart ID\", \"variable_name\": \"cart_id\",\"value\": \"8393\"}]}`` Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/subaccount\" ) payload = { \"business_name\" : business_name , \"settlement_bank\" : settlement_bank , \"account_number\" : account_number , \"percentage_charge\" : percentage_charge , \"description\" : description , } optional_params = [ ( \"primary_contact_email\" , primary_contact_email ), ( \"primary_contact_name\" , primary_contact_name ), ( \"primary_contact_phone\" , primary_contact_phone ), ( \"metadata\" , metadata ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . POST , url , payload ) get_subaccount ( id_or_code ) Get details of a subaccount on your integration. Parameters: Name Type Description Default id_or_code str The subaccount ID or code you want to fetch required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/subaccounts.py 98 99 100 101 102 103 104 105 106 107 108 109 def get_subaccount ( self , id_or_code : str ) -> Response : \"\"\"Get details of a subaccount on your integration. Args: id_or_code: The subaccount ``ID`` or ``code`` you want to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/subaccount/ { id_or_code } \" ) return self . _handle_request ( HTTPMethod . GET , url ) get_subaccounts ( start_date , end_date , page = 1 , pagination = 50 ) Fetch subaccounts available on your integration. Parameters: Name Type Description Default start_date str A timestamp from which to start listing subaccounts e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 required end_date str A timestamp at which to stop listing subaccounts e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 required page int Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. 1 pagination int Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. 50 Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/subaccounts.py 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 def get_subaccounts ( self , start_date : str , end_date : str , page : int = 1 , pagination : int = 50 ) -> Response : \"\"\"Fetch subaccounts available on your integration. Args: start_date: A timestamp from which to start listing subaccounts e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing subaccounts e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 page: Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/subaccount?perPage= { pagination } \" ) query_params = [ ( \"from\" , start_date ), ( \"to\" , end_date ), ( \"page\" , page ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url ) update ( id_or_code , business_name , settlement_bank , account_number = None , active = None , percentage_charge = None , description = None , primary_contact_email = None , primary_contact_name = None , primary_contact_phone = None , settlement_schedule = None , metadata = None ) Update a subaccount details on your integration. Parameters: Name Type Description Default id_or_code str Subaccount's ID or code required business_name str Name of business for subaccount required settlement_bank str Bank Code for the bank. You can get the list of Bank Codes by calling the .get_banks method from the Miscellaneous API wrapper required account_number Optional [ str ] Bank Account Number None active Optional [ bool ] Activate or deactivate a subaccount. None percentage_charge Optional [ float ] The default percentage charged when receiving on behalf of this subaccount None description Optional [ str ] A description for this subaccount None primary_contact_email Optional [ str ] A contact email for the subaccount None primary_contact_name Optional [ str ] A name for the contact person for this subaccount None primary_contact_phone Optional [ str ] A phone number to call for this subaccount None settlement_schedule Optional [ Schedule ] Schedule.AUTO means payout is T+1 and manual means payout to the subaccount should only be made when requested. Defaults to Schedule.AUTO None metadata Optional [ dict ] Add a custom_fields attribute which has a list of dictionaries if you would like the fields to be added to your transaction when displayed on the dashboard. Sample: {\"custom_fields\":[{\"display_name\":\"Cart ID\", \"variable_name\": \"cart_id\",\"value\": \"8393\"}]} None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/subaccounts.py 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 def update ( self , id_or_code : str , business_name : str , settlement_bank : str , account_number : Optional [ str ] = None , active : Optional [ bool ] = None , percentage_charge : Optional [ float ] = None , description : Optional [ str ] = None , primary_contact_email : Optional [ str ] = None , primary_contact_name : Optional [ str ] = None , primary_contact_phone : Optional [ str ] = None , settlement_schedule : Optional [ Schedule ] = None , metadata : Optional [ dict ] = None , ) -> Response : \"\"\"Update a subaccount details on your integration. Args: id_or_code: Subaccount's ID or code business_name: Name of business for subaccount settlement_bank: Bank Code for the bank. You can get the list of Bank Codes by calling the ``.get_banks`` method from the Miscellaneous API wrapper account_number: Bank Account Number active: Activate or deactivate a subaccount. percentage_charge: The default percentage charged when receiving on behalf of this subaccount description: A description for this subaccount primary_contact_email: A contact email for the subaccount primary_contact_name: A name for the contact person for this subaccount primary_contact_phone: A phone number to call for this subaccount settlement_schedule: ``Schedule.AUTO`` means payout is T+1 and manual means payout to the subaccount should only be made when requested. Defaults to ``Schedule.AUTO`` metadata: Add a custom_fields attribute which has a list of dictionaries if you would like the fields to be added to your transaction when displayed on the dashboard. Sample: ``{\"custom_fields\":[{\"display_name\":\"Cart ID\", \"variable_name\": \"cart_id\",\"value\": \"8393\"}]}`` Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"id_or_code\" : id_or_code , \"business_name\" : business_name , \"settlement_bank\" : settlement_bank , } optional_params = [ ( \"account_number\" , account_number ), ( \"active\" , active ), ( \"percentage_charge\" , percentage_charge ), ( \"description\" , description ), ( \"primary_contact_email\" , primary_contact_email ), ( \"primary_contact_name\" , primary_contact_name ), ( \"primary_contact_phone\" , primary_contact_phone ), ( \"settlement_schedule\" , settlement_schedule ), ( \"metadata\" , metadata ), ] payload = add_to_payload ( optional_params , payload ) url = self . _parse_url ( f \"/subaccount/ { id_or_code } \" ) return self . _handle_request ( HTTPMethod . PUT , url , payload )","title":"Subaccounts"},{"location":"reference/subaccounts/#pypaystack2.api.subaccounts.AsyncSubAccount","text":"Bases: BaseAsyncAPI Provides a wrapper for paystack Subaccounts API The Subaccounts API allows you to create and manage subaccounts on your integration. Subaccounts can be used to split payment between two accounts (your main account and a sub account). https://paystack.com/docs/api/#subaccount Source code in pypaystack2/api/subaccounts.py 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 class AsyncSubAccount ( BaseAsyncAPI ): \"\"\"Provides a wrapper for paystack Subaccounts API The Subaccounts API allows you to create and manage subaccounts on your integration. Subaccounts can be used to split payment between two accounts (your main account and a sub account). https://paystack.com/docs/api/#subaccount \"\"\" async def create ( self , business_name : str , settlement_bank : str , account_number : str , percentage_charge : float , description : str , primary_contact_email : Optional [ str ] = None , primary_contact_name : Optional [ str ] = None , primary_contact_phone : Optional [ str ] = None , metadata : Optional [ dict ] = None , ) -> Response : \"\"\"Create a subacount on your integration. Args: business_name: Name of business for subaccount settlement_bank: Bank Code for the bank. You can get the list of Bank Codes by calling the ``.get_banks`` method from the Miscellaneous API wrapper account_number: Bank Account Number percentage_charge: The default percentage charged when receiving on behalf of this subaccount description: A description for this subaccount primary_contact_email: A contact email for the subaccount primary_contact_name: A name for the contact person for this subaccount primary_contact_phone: A phone number to call for this subaccount metadata: Add a custom_fields attribute which has a list of dictionaries if you would like the fields to be added to your transaction when displayed on the dashboard. Sample: ``{\"custom_fields\":[{\"display_name\":\"Cart ID\", \"variable_name\": \"cart_id\",\"value\": \"8393\"}]}`` Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/subaccount\" ) payload = { \"business_name\" : business_name , \"settlement_bank\" : settlement_bank , \"account_number\" : account_number , \"percentage_charge\" : percentage_charge , \"description\" : description , } optional_params = [ ( \"primary_contact_email\" , primary_contact_email ), ( \"primary_contact_name\" , primary_contact_name ), ( \"primary_contact_phone\" , primary_contact_phone ), ( \"metadata\" , metadata ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) async def get_subaccounts ( self , start_date : str , end_date : str , page : int = 1 , pagination : int = 50 ) -> Response : \"\"\"Fetch subaccounts available on your integration. Args: start_date: A timestamp from which to start listing subaccounts e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing subaccounts e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 page: Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/subaccount?perPage= { pagination } \" ) query_params = [ ( \"from\" , start_date ), ( \"to\" , end_date ), ( \"page\" , page ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url ) async def get_subaccount ( self , id_or_code : str ) -> Response : \"\"\"Get details of a subaccount on your integration. Args: id_or_code: The subaccount ``ID`` or ``code`` you want to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/subaccount/ { id_or_code } \" ) return await self . _handle_request ( HTTPMethod . GET , url ) async def update ( self , id_or_code : str , business_name : str , settlement_bank : str , account_number : Optional [ str ] = None , active : Optional [ bool ] = None , percentage_charge : Optional [ float ] = None , description : Optional [ str ] = None , primary_contact_email : Optional [ str ] = None , primary_contact_name : Optional [ str ] = None , primary_contact_phone : Optional [ str ] = None , settlement_schedule : Optional [ Schedule ] = None , metadata : Optional [ dict ] = None , ) -> Response : \"\"\"Update a subaccount details on your integration. Args: id_or_code: Subaccount's ID or code business_name: Name of business for subaccount settlement_bank: Bank Code for the bank. You can get the list of Bank Codes by calling the ``.get_banks`` method from the Miscellaneous API wrapper account_number: Bank Account Number active: Activate or deactivate a subaccount. percentage_charge: The default percentage charged when receiving on behalf of this subaccount description: A description for this subaccount primary_contact_email: A contact email for the subaccount primary_contact_name: A name for the contact person for this subaccount primary_contact_phone: A phone number to call for this subaccount settlement_schedule: ``Schedule.AUTO`` means payout is T+1 and manual means payout to the subaccount should only be made when requested. Defaults to ``Schedule.AUTO`` metadata: Add a custom_fields attribute which has a list of dictionaries if you would like the fields to be added to your transaction when displayed on the dashboard. Sample: ``{\"custom_fields\":[{\"display_name\":\"Cart ID\", \"variable_name\": \"cart_id\",\"value\": \"8393\"}]}`` Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"id_or_code\" : id_or_code , \"business_name\" : business_name , \"settlement_bank\" : settlement_bank , } optional_params = [ ( \"account_number\" , account_number ), ( \"active\" , active ), ( \"percentage_charge\" , percentage_charge ), ( \"description\" , description ), ( \"primary_contact_email\" , primary_contact_email ), ( \"primary_contact_name\" , primary_contact_name ), ( \"primary_contact_phone\" , primary_contact_phone ), ( \"settlement_schedule\" , settlement_schedule ), ( \"metadata\" , metadata ), ] payload = add_to_payload ( optional_params , payload ) url = self . _parse_url ( f \"/subaccount/ { id_or_code } \" ) return await self . _handle_request ( HTTPMethod . PUT , url , payload )","title":"AsyncSubAccount"},{"location":"reference/subaccounts/#pypaystack2.api.subaccounts.AsyncSubAccount.create","text":"Create a subacount on your integration. Parameters: Name Type Description Default business_name str Name of business for subaccount required settlement_bank str Bank Code for the bank. You can get the list of Bank Codes by calling the .get_banks method from the Miscellaneous API wrapper required account_number str Bank Account Number required percentage_charge float The default percentage charged when receiving on behalf of this subaccount required description str A description for this subaccount required primary_contact_email Optional [ str ] A contact email for the subaccount None primary_contact_name Optional [ str ] A name for the contact person for this subaccount None primary_contact_phone Optional [ str ] A phone number to call for this subaccount None metadata Optional [ dict ] Add a custom_fields attribute which has a list of dictionaries if you would like the fields to be added to your transaction when displayed on the dashboard. Sample: {\"custom_fields\":[{\"display_name\":\"Cart ID\", \"variable_name\": \"cart_id\",\"value\": \"8393\"}]} None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/subaccounts.py 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 async def create ( self , business_name : str , settlement_bank : str , account_number : str , percentage_charge : float , description : str , primary_contact_email : Optional [ str ] = None , primary_contact_name : Optional [ str ] = None , primary_contact_phone : Optional [ str ] = None , metadata : Optional [ dict ] = None , ) -> Response : \"\"\"Create a subacount on your integration. Args: business_name: Name of business for subaccount settlement_bank: Bank Code for the bank. You can get the list of Bank Codes by calling the ``.get_banks`` method from the Miscellaneous API wrapper account_number: Bank Account Number percentage_charge: The default percentage charged when receiving on behalf of this subaccount description: A description for this subaccount primary_contact_email: A contact email for the subaccount primary_contact_name: A name for the contact person for this subaccount primary_contact_phone: A phone number to call for this subaccount metadata: Add a custom_fields attribute which has a list of dictionaries if you would like the fields to be added to your transaction when displayed on the dashboard. Sample: ``{\"custom_fields\":[{\"display_name\":\"Cart ID\", \"variable_name\": \"cart_id\",\"value\": \"8393\"}]}`` Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/subaccount\" ) payload = { \"business_name\" : business_name , \"settlement_bank\" : settlement_bank , \"account_number\" : account_number , \"percentage_charge\" : percentage_charge , \"description\" : description , } optional_params = [ ( \"primary_contact_email\" , primary_contact_email ), ( \"primary_contact_name\" , primary_contact_name ), ( \"primary_contact_phone\" , primary_contact_phone ), ( \"metadata\" , metadata ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . POST , url , payload )","title":"create()"},{"location":"reference/subaccounts/#pypaystack2.api.subaccounts.AsyncSubAccount.get_subaccount","text":"Get details of a subaccount on your integration. Parameters: Name Type Description Default id_or_code str The subaccount ID or code you want to fetch required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/subaccounts.py 260 261 262 263 264 265 266 267 268 269 270 271 async def get_subaccount ( self , id_or_code : str ) -> Response : \"\"\"Get details of a subaccount on your integration. Args: id_or_code: The subaccount ``ID`` or ``code`` you want to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/subaccount/ { id_or_code } \" ) return await self . _handle_request ( HTTPMethod . GET , url )","title":"get_subaccount()"},{"location":"reference/subaccounts/#pypaystack2.api.subaccounts.AsyncSubAccount.get_subaccounts","text":"Fetch subaccounts available on your integration. Parameters: Name Type Description Default start_date str A timestamp from which to start listing subaccounts e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 required end_date str A timestamp at which to stop listing subaccounts e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 required page int Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. 1 pagination int Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. 50 Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/subaccounts.py 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 async def get_subaccounts ( self , start_date : str , end_date : str , page : int = 1 , pagination : int = 50 ) -> Response : \"\"\"Fetch subaccounts available on your integration. Args: start_date: A timestamp from which to start listing subaccounts e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing subaccounts e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 page: Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/subaccount?perPage= { pagination } \" ) query_params = [ ( \"from\" , start_date ), ( \"to\" , end_date ), ( \"page\" , page ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url )","title":"get_subaccounts()"},{"location":"reference/subaccounts/#pypaystack2.api.subaccounts.AsyncSubAccount.update","text":"Update a subaccount details on your integration. Parameters: Name Type Description Default id_or_code str Subaccount's ID or code required business_name str Name of business for subaccount required settlement_bank str Bank Code for the bank. You can get the list of Bank Codes by calling the .get_banks method from the Miscellaneous API wrapper required account_number Optional [ str ] Bank Account Number None active Optional [ bool ] Activate or deactivate a subaccount. None percentage_charge Optional [ float ] The default percentage charged when receiving on behalf of this subaccount None description Optional [ str ] A description for this subaccount None primary_contact_email Optional [ str ] A contact email for the subaccount None primary_contact_name Optional [ str ] A name for the contact person for this subaccount None primary_contact_phone Optional [ str ] A phone number to call for this subaccount None settlement_schedule Optional [ Schedule ] Schedule.AUTO means payout is T+1 and manual means payout to the subaccount should only be made when requested. Defaults to Schedule.AUTO None metadata Optional [ dict ] Add a custom_fields attribute which has a list of dictionaries if you would like the fields to be added to your transaction when displayed on the dashboard. Sample: {\"custom_fields\":[{\"display_name\":\"Cart ID\", \"variable_name\": \"cart_id\",\"value\": \"8393\"}]} None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/subaccounts.py 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 async def update ( self , id_or_code : str , business_name : str , settlement_bank : str , account_number : Optional [ str ] = None , active : Optional [ bool ] = None , percentage_charge : Optional [ float ] = None , description : Optional [ str ] = None , primary_contact_email : Optional [ str ] = None , primary_contact_name : Optional [ str ] = None , primary_contact_phone : Optional [ str ] = None , settlement_schedule : Optional [ Schedule ] = None , metadata : Optional [ dict ] = None , ) -> Response : \"\"\"Update a subaccount details on your integration. Args: id_or_code: Subaccount's ID or code business_name: Name of business for subaccount settlement_bank: Bank Code for the bank. You can get the list of Bank Codes by calling the ``.get_banks`` method from the Miscellaneous API wrapper account_number: Bank Account Number active: Activate or deactivate a subaccount. percentage_charge: The default percentage charged when receiving on behalf of this subaccount description: A description for this subaccount primary_contact_email: A contact email for the subaccount primary_contact_name: A name for the contact person for this subaccount primary_contact_phone: A phone number to call for this subaccount settlement_schedule: ``Schedule.AUTO`` means payout is T+1 and manual means payout to the subaccount should only be made when requested. Defaults to ``Schedule.AUTO`` metadata: Add a custom_fields attribute which has a list of dictionaries if you would like the fields to be added to your transaction when displayed on the dashboard. Sample: ``{\"custom_fields\":[{\"display_name\":\"Cart ID\", \"variable_name\": \"cart_id\",\"value\": \"8393\"}]}`` Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"id_or_code\" : id_or_code , \"business_name\" : business_name , \"settlement_bank\" : settlement_bank , } optional_params = [ ( \"account_number\" , account_number ), ( \"active\" , active ), ( \"percentage_charge\" , percentage_charge ), ( \"description\" , description ), ( \"primary_contact_email\" , primary_contact_email ), ( \"primary_contact_name\" , primary_contact_name ), ( \"primary_contact_phone\" , primary_contact_phone ), ( \"settlement_schedule\" , settlement_schedule ), ( \"metadata\" , metadata ), ] payload = add_to_payload ( optional_params , payload ) url = self . _parse_url ( f \"/subaccount/ { id_or_code } \" ) return await self . _handle_request ( HTTPMethod . PUT , url , payload )","title":"update()"},{"location":"reference/subaccounts/#pypaystack2.api.subaccounts.SubAccount","text":"Bases: BaseAPI Provides a wrapper for paystack Subaccounts API The Subaccounts API allows you to create and manage subaccounts on your integration. Subaccounts can be used to split payment between two accounts (your main account and a sub account). https://paystack.com/docs/api/#subaccount Source code in pypaystack2/api/subaccounts.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 class SubAccount ( BaseAPI ): \"\"\"Provides a wrapper for paystack Subaccounts API The Subaccounts API allows you to create and manage subaccounts on your integration. Subaccounts can be used to split payment between two accounts (your main account and a sub account). https://paystack.com/docs/api/#subaccount \"\"\" def create ( self , business_name : str , settlement_bank : str , account_number : str , percentage_charge : float , description : Optional [ str ] = None , primary_contact_email : Optional [ str ] = None , primary_contact_name : Optional [ str ] = None , primary_contact_phone : Optional [ str ] = None , metadata : Optional [ dict ] = None , ) -> Response : \"\"\"Create a subacount on your integration. Args: business_name: Name of business for subaccount settlement_bank: Bank Code for the bank. You can get the list of Bank Codes by calling the ``.get_banks`` method from the Miscellaneous API wrapper account_number: Bank Account Number percentage_charge: The default percentage charged when receiving on behalf of this subaccount description: A description for this subaccount primary_contact_email: A contact email for the subaccount primary_contact_name: A name for the contact person for this subaccount primary_contact_phone: A phone number to call for this subaccount metadata: Add a custom_fields attribute which has a list of dictionaries if you would like the fields to be added to your transaction when displayed on the dashboard. Sample: ``{\"custom_fields\":[{\"display_name\":\"Cart ID\", \"variable_name\": \"cart_id\",\"value\": \"8393\"}]}`` Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/subaccount\" ) payload = { \"business_name\" : business_name , \"settlement_bank\" : settlement_bank , \"account_number\" : account_number , \"percentage_charge\" : percentage_charge , \"description\" : description , } optional_params = [ ( \"primary_contact_email\" , primary_contact_email ), ( \"primary_contact_name\" , primary_contact_name ), ( \"primary_contact_phone\" , primary_contact_phone ), ( \"metadata\" , metadata ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . POST , url , payload ) def get_subaccounts ( self , start_date : str , end_date : str , page : int = 1 , pagination : int = 50 ) -> Response : \"\"\"Fetch subaccounts available on your integration. Args: start_date: A timestamp from which to start listing subaccounts e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing subaccounts e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 page: Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/subaccount?perPage= { pagination } \" ) query_params = [ ( \"from\" , start_date ), ( \"to\" , end_date ), ( \"page\" , page ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url ) def get_subaccount ( self , id_or_code : str ) -> Response : \"\"\"Get details of a subaccount on your integration. Args: id_or_code: The subaccount ``ID`` or ``code`` you want to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/subaccount/ { id_or_code } \" ) return self . _handle_request ( HTTPMethod . GET , url ) def update ( self , id_or_code : str , business_name : str , settlement_bank : str , account_number : Optional [ str ] = None , active : Optional [ bool ] = None , percentage_charge : Optional [ float ] = None , description : Optional [ str ] = None , primary_contact_email : Optional [ str ] = None , primary_contact_name : Optional [ str ] = None , primary_contact_phone : Optional [ str ] = None , settlement_schedule : Optional [ Schedule ] = None , metadata : Optional [ dict ] = None , ) -> Response : \"\"\"Update a subaccount details on your integration. Args: id_or_code: Subaccount's ID or code business_name: Name of business for subaccount settlement_bank: Bank Code for the bank. You can get the list of Bank Codes by calling the ``.get_banks`` method from the Miscellaneous API wrapper account_number: Bank Account Number active: Activate or deactivate a subaccount. percentage_charge: The default percentage charged when receiving on behalf of this subaccount description: A description for this subaccount primary_contact_email: A contact email for the subaccount primary_contact_name: A name for the contact person for this subaccount primary_contact_phone: A phone number to call for this subaccount settlement_schedule: ``Schedule.AUTO`` means payout is T+1 and manual means payout to the subaccount should only be made when requested. Defaults to ``Schedule.AUTO`` metadata: Add a custom_fields attribute which has a list of dictionaries if you would like the fields to be added to your transaction when displayed on the dashboard. Sample: ``{\"custom_fields\":[{\"display_name\":\"Cart ID\", \"variable_name\": \"cart_id\",\"value\": \"8393\"}]}`` Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"id_or_code\" : id_or_code , \"business_name\" : business_name , \"settlement_bank\" : settlement_bank , } optional_params = [ ( \"account_number\" , account_number ), ( \"active\" , active ), ( \"percentage_charge\" , percentage_charge ), ( \"description\" , description ), ( \"primary_contact_email\" , primary_contact_email ), ( \"primary_contact_name\" , primary_contact_name ), ( \"primary_contact_phone\" , primary_contact_phone ), ( \"settlement_schedule\" , settlement_schedule ), ( \"metadata\" , metadata ), ] payload = add_to_payload ( optional_params , payload ) url = self . _parse_url ( f \"/subaccount/ { id_or_code } \" ) return self . _handle_request ( HTTPMethod . PUT , url , payload )","title":"SubAccount"},{"location":"reference/subaccounts/#pypaystack2.api.subaccounts.SubAccount.create","text":"Create a subacount on your integration. Parameters: Name Type Description Default business_name str Name of business for subaccount required settlement_bank str Bank Code for the bank. You can get the list of Bank Codes by calling the .get_banks method from the Miscellaneous API wrapper required account_number str Bank Account Number required percentage_charge float The default percentage charged when receiving on behalf of this subaccount required description Optional [ str ] A description for this subaccount None primary_contact_email Optional [ str ] A contact email for the subaccount None primary_contact_name Optional [ str ] A name for the contact person for this subaccount None primary_contact_phone Optional [ str ] A phone number to call for this subaccount None metadata Optional [ dict ] Add a custom_fields attribute which has a list of dictionaries if you would like the fields to be added to your transaction when displayed on the dashboard. Sample: {\"custom_fields\":[{\"display_name\":\"Cart ID\", \"variable_name\": \"cart_id\",\"value\": \"8393\"}]} None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/subaccounts.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 def create ( self , business_name : str , settlement_bank : str , account_number : str , percentage_charge : float , description : Optional [ str ] = None , primary_contact_email : Optional [ str ] = None , primary_contact_name : Optional [ str ] = None , primary_contact_phone : Optional [ str ] = None , metadata : Optional [ dict ] = None , ) -> Response : \"\"\"Create a subacount on your integration. Args: business_name: Name of business for subaccount settlement_bank: Bank Code for the bank. You can get the list of Bank Codes by calling the ``.get_banks`` method from the Miscellaneous API wrapper account_number: Bank Account Number percentage_charge: The default percentage charged when receiving on behalf of this subaccount description: A description for this subaccount primary_contact_email: A contact email for the subaccount primary_contact_name: A name for the contact person for this subaccount primary_contact_phone: A phone number to call for this subaccount metadata: Add a custom_fields attribute which has a list of dictionaries if you would like the fields to be added to your transaction when displayed on the dashboard. Sample: ``{\"custom_fields\":[{\"display_name\":\"Cart ID\", \"variable_name\": \"cart_id\",\"value\": \"8393\"}]}`` Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/subaccount\" ) payload = { \"business_name\" : business_name , \"settlement_bank\" : settlement_bank , \"account_number\" : account_number , \"percentage_charge\" : percentage_charge , \"description\" : description , } optional_params = [ ( \"primary_contact_email\" , primary_contact_email ), ( \"primary_contact_name\" , primary_contact_name ), ( \"primary_contact_phone\" , primary_contact_phone ), ( \"metadata\" , metadata ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . POST , url , payload )","title":"create()"},{"location":"reference/subaccounts/#pypaystack2.api.subaccounts.SubAccount.get_subaccount","text":"Get details of a subaccount on your integration. Parameters: Name Type Description Default id_or_code str The subaccount ID or code you want to fetch required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/subaccounts.py 98 99 100 101 102 103 104 105 106 107 108 109 def get_subaccount ( self , id_or_code : str ) -> Response : \"\"\"Get details of a subaccount on your integration. Args: id_or_code: The subaccount ``ID`` or ``code`` you want to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/subaccount/ { id_or_code } \" ) return self . _handle_request ( HTTPMethod . GET , url )","title":"get_subaccount()"},{"location":"reference/subaccounts/#pypaystack2.api.subaccounts.SubAccount.get_subaccounts","text":"Fetch subaccounts available on your integration. Parameters: Name Type Description Default start_date str A timestamp from which to start listing subaccounts e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 required end_date str A timestamp at which to stop listing subaccounts e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 required page int Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. 1 pagination int Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. 50 Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/subaccounts.py 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 def get_subaccounts ( self , start_date : str , end_date : str , page : int = 1 , pagination : int = 50 ) -> Response : \"\"\"Fetch subaccounts available on your integration. Args: start_date: A timestamp from which to start listing subaccounts e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing subaccounts e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 page: Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/subaccount?perPage= { pagination } \" ) query_params = [ ( \"from\" , start_date ), ( \"to\" , end_date ), ( \"page\" , page ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url )","title":"get_subaccounts()"},{"location":"reference/subaccounts/#pypaystack2.api.subaccounts.SubAccount.update","text":"Update a subaccount details on your integration. Parameters: Name Type Description Default id_or_code str Subaccount's ID or code required business_name str Name of business for subaccount required settlement_bank str Bank Code for the bank. You can get the list of Bank Codes by calling the .get_banks method from the Miscellaneous API wrapper required account_number Optional [ str ] Bank Account Number None active Optional [ bool ] Activate or deactivate a subaccount. None percentage_charge Optional [ float ] The default percentage charged when receiving on behalf of this subaccount None description Optional [ str ] A description for this subaccount None primary_contact_email Optional [ str ] A contact email for the subaccount None primary_contact_name Optional [ str ] A name for the contact person for this subaccount None primary_contact_phone Optional [ str ] A phone number to call for this subaccount None settlement_schedule Optional [ Schedule ] Schedule.AUTO means payout is T+1 and manual means payout to the subaccount should only be made when requested. Defaults to Schedule.AUTO None metadata Optional [ dict ] Add a custom_fields attribute which has a list of dictionaries if you would like the fields to be added to your transaction when displayed on the dashboard. Sample: {\"custom_fields\":[{\"display_name\":\"Cart ID\", \"variable_name\": \"cart_id\",\"value\": \"8393\"}]} None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/subaccounts.py 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 def update ( self , id_or_code : str , business_name : str , settlement_bank : str , account_number : Optional [ str ] = None , active : Optional [ bool ] = None , percentage_charge : Optional [ float ] = None , description : Optional [ str ] = None , primary_contact_email : Optional [ str ] = None , primary_contact_name : Optional [ str ] = None , primary_contact_phone : Optional [ str ] = None , settlement_schedule : Optional [ Schedule ] = None , metadata : Optional [ dict ] = None , ) -> Response : \"\"\"Update a subaccount details on your integration. Args: id_or_code: Subaccount's ID or code business_name: Name of business for subaccount settlement_bank: Bank Code for the bank. You can get the list of Bank Codes by calling the ``.get_banks`` method from the Miscellaneous API wrapper account_number: Bank Account Number active: Activate or deactivate a subaccount. percentage_charge: The default percentage charged when receiving on behalf of this subaccount description: A description for this subaccount primary_contact_email: A contact email for the subaccount primary_contact_name: A name for the contact person for this subaccount primary_contact_phone: A phone number to call for this subaccount settlement_schedule: ``Schedule.AUTO`` means payout is T+1 and manual means payout to the subaccount should only be made when requested. Defaults to ``Schedule.AUTO`` metadata: Add a custom_fields attribute which has a list of dictionaries if you would like the fields to be added to your transaction when displayed on the dashboard. Sample: ``{\"custom_fields\":[{\"display_name\":\"Cart ID\", \"variable_name\": \"cart_id\",\"value\": \"8393\"}]}`` Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"id_or_code\" : id_or_code , \"business_name\" : business_name , \"settlement_bank\" : settlement_bank , } optional_params = [ ( \"account_number\" , account_number ), ( \"active\" , active ), ( \"percentage_charge\" , percentage_charge ), ( \"description\" , description ), ( \"primary_contact_email\" , primary_contact_email ), ( \"primary_contact_name\" , primary_contact_name ), ( \"primary_contact_phone\" , primary_contact_phone ), ( \"settlement_schedule\" , settlement_schedule ), ( \"metadata\" , metadata ), ] payload = add_to_payload ( optional_params , payload ) url = self . _parse_url ( f \"/subaccount/ { id_or_code } \" ) return self . _handle_request ( HTTPMethod . PUT , url , payload )","title":"update()"},{"location":"reference/subscriptions/","text":"AsyncSubscription Bases: BaseAsyncAPI Provides a wrapper for paystack Subscriptions API The Subscriptions API allows you to create and manage recurring payment on your integration. https://paystack.com/docs/api/#subscription Source code in pypaystack2/api/subscriptions.py 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 class AsyncSubscription ( BaseAsyncAPI ): \"\"\"Provides a wrapper for paystack Subscriptions API The Subscriptions API allows you to create and manage recurring payment on your integration. https://paystack.com/docs/api/#subscription \"\"\" async def create ( self , customer : str , plan : str , authorization : Optional [ str ] = None , start_date : Optional [ str ] = None , ) -> Response : \"\"\"Create a subscription on your integration Note: Email Token paystack creates an email token on each subscription to allow customers cancel their subscriptions from within the invoices sent to their mailboxes. Since they are not authorized, the email tokens are what we use to authenticate the requests over the API. Args: customer: Customer's email address or customer code plan: Plan code authorization: If customer has multiple authorizations, you can set the desired authorization you wish to use for this subscription here. If this is not supplied, the customer's most recent authorization would be used start_date: Set the date for the first debit. (ISO 8601 format) e.g. 2017-05-16T00:30:13+01:00 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/subscription\" ) payload = { \"customer\" : customer , \"plan\" : plan } optional_params = [ ( \"start_date\" , start_date ), ( \"authorization\" , authorization ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) async def get_subscriptions ( self , page : int = 1 , pagination : int = 50 , customer : Optional [ int ] = None , plan : Optional [ int ] = None , ) -> Response : \"\"\"Fetch subscriptions available on your integration. Args: page: Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. customer: Filter by Customer ID plan: Filter by Plan ID Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/subscription/?perPage=\" + str ( pagination )) query_params = [ ( \"page\" , page ), ( \"customer\" , customer ), ( \"plan\" , plan ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url ) async def get_subscription ( self , id_or_code : str ) -> Response : \"\"\"Fetch details of a subscription on your integration. Args: id_or_code: The subscription ``ID`` or ``code`` you want to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/subscription/ { id_or_code } \" ) return await self . _handle_request ( HTTPMethod . GET , url ) async def enable ( self , code : str , token : str ) -> Response : \"\"\"Enable a subscription on your integration Args: code: Subscription code token: Email token Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/subscription/enable\" ) payload = { \"code\" : code , \"token\" : token , } return await self . _handle_request ( HTTPMethod . POST , url , payload ) async def disable ( self , code : str , token : str ) -> Response : \"\"\"Disable a subscription on your integration Args: code: Subscription code token: Email token Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/subscription/disable\" ) payload = { \"code\" : code , \"token\" : token , } return await self . _handle_request ( HTTPMethod . POST , url , payload ) async def get_update_link ( self , code : str ) -> Response : \"\"\"Generate a link for updating the card on a subscription Args: code: Subscription code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/subscription/ { code } /manage/link/\" ) return await self . _handle_request ( HTTPMethod . GET , url ) async def send_update_link ( self , code : str ) -> Response : \"\"\"Email a customer a link for updating the card on their subscription Args: code: Subscription code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/subscription/ { code } /manage/email/\" ) payload = { \"code\" : \"code\" } return await self . _handle_request ( HTTPMethod . POST , url , payload ) create ( customer , plan , authorization = None , start_date = None ) async Create a subscription on your integration Note Email Token paystack creates an email token on each subscription to allow customers cancel their subscriptions from within the invoices sent to their mailboxes. Since they are not authorized, the email tokens are what we use to authenticate the requests over the API. Parameters: Name Type Description Default customer str Customer's email address or customer code required plan str Plan code required authorization Optional [ str ] If customer has multiple authorizations, you can set the desired authorization you wish to use for this subscription here. If this is not supplied, the customer's most recent authorization would be used None start_date Optional [ str ] Set the date for the first debit. (ISO 8601 format) e.g. 2017-05-16T00:30:13+01:00 None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/subscriptions.py 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 async def create ( self , customer : str , plan : str , authorization : Optional [ str ] = None , start_date : Optional [ str ] = None , ) -> Response : \"\"\"Create a subscription on your integration Note: Email Token paystack creates an email token on each subscription to allow customers cancel their subscriptions from within the invoices sent to their mailboxes. Since they are not authorized, the email tokens are what we use to authenticate the requests over the API. Args: customer: Customer's email address or customer code plan: Plan code authorization: If customer has multiple authorizations, you can set the desired authorization you wish to use for this subscription here. If this is not supplied, the customer's most recent authorization would be used start_date: Set the date for the first debit. (ISO 8601 format) e.g. 2017-05-16T00:30:13+01:00 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/subscription\" ) payload = { \"customer\" : customer , \"plan\" : plan } optional_params = [ ( \"start_date\" , start_date ), ( \"authorization\" , authorization ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) disable ( code , token ) async Disable a subscription on your integration Parameters: Name Type Description Default code str Subscription code required token str Email token required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/subscriptions.py 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 async def disable ( self , code : str , token : str ) -> Response : \"\"\"Disable a subscription on your integration Args: code: Subscription code token: Email token Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/subscription/disable\" ) payload = { \"code\" : code , \"token\" : token , } return await self . _handle_request ( HTTPMethod . POST , url , payload ) enable ( code , token ) async Enable a subscription on your integration Parameters: Name Type Description Default code str Subscription code required token str Email token required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/subscriptions.py 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 async def enable ( self , code : str , token : str ) -> Response : \"\"\"Enable a subscription on your integration Args: code: Subscription code token: Email token Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/subscription/enable\" ) payload = { \"code\" : code , \"token\" : token , } return await self . _handle_request ( HTTPMethod . POST , url , payload ) get_subscription ( id_or_code ) async Fetch details of a subscription on your integration. Parameters: Name Type Description Default id_or_code str The subscription ID or code you want to fetch required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/subscriptions.py 239 240 241 242 243 244 245 246 247 248 249 250 async def get_subscription ( self , id_or_code : str ) -> Response : \"\"\"Fetch details of a subscription on your integration. Args: id_or_code: The subscription ``ID`` or ``code`` you want to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/subscription/ { id_or_code } \" ) return await self . _handle_request ( HTTPMethod . GET , url ) get_subscriptions ( page = 1 , pagination = 50 , customer = None , plan = None ) async Fetch subscriptions available on your integration. Parameters: Name Type Description Default page int Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. 1 pagination int Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. 50 customer Optional [ int ] Filter by Customer ID None plan Optional [ int ] Filter by Plan ID None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/subscriptions.py 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 async def get_subscriptions ( self , page : int = 1 , pagination : int = 50 , customer : Optional [ int ] = None , plan : Optional [ int ] = None , ) -> Response : \"\"\"Fetch subscriptions available on your integration. Args: page: Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. customer: Filter by Customer ID plan: Filter by Plan ID Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/subscription/?perPage=\" + str ( pagination )) query_params = [ ( \"page\" , page ), ( \"customer\" , customer ), ( \"plan\" , plan ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url ) get_update_link ( code ) async Generate a link for updating the card on a subscription Parameters: Name Type Description Default code str Subscription code required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/subscriptions.py 287 288 289 290 291 292 293 294 295 296 297 298 async def get_update_link ( self , code : str ) -> Response : \"\"\"Generate a link for updating the card on a subscription Args: code: Subscription code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/subscription/ { code } /manage/link/\" ) return await self . _handle_request ( HTTPMethod . GET , url ) send_update_link ( code ) async Email a customer a link for updating the card on their subscription Parameters: Name Type Description Default code str Subscription code required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/subscriptions.py 300 301 302 303 304 305 306 307 308 309 310 311 312 async def send_update_link ( self , code : str ) -> Response : \"\"\"Email a customer a link for updating the card on their subscription Args: code: Subscription code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/subscription/ { code } /manage/email/\" ) payload = { \"code\" : \"code\" } return await self . _handle_request ( HTTPMethod . POST , url , payload ) Subscription Bases: BaseAPI Provides a wrapper for paystack Subscriptions API The Subscriptions API allows you to create and manage recurring payment on your integration. https://paystack.com/docs/api/#subscription Source code in pypaystack2/api/subscriptions.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 class Subscription ( BaseAPI ): \"\"\"Provides a wrapper for paystack Subscriptions API The Subscriptions API allows you to create and manage recurring payment on your integration. https://paystack.com/docs/api/#subscription \"\"\" def create ( self , customer : str , plan : str , authorization : Optional [ str ] = None , start_date : Optional [ str ] = None , ) -> Response : \"\"\"Create a subscription on your integration Note: Email Token paystack creates an email token on each subscription to allow customers cancel their subscriptions from within the invoices sent to their mailboxes. Since they are not authorized, the email tokens are what we use to authenticate the requests over the API. Args: customer: Customer's email address or customer code plan: Plan code authorization: If customer has multiple authorizations, you can set the desired authorization you wish to use for this subscription here. If this is not supplied, the customer's most recent authorization would be used start_date: Set the date for the first debit. (ISO 8601 format) e.g. 2017-05-16T00:30:13+01:00 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/subscription\" ) payload = { \"customer\" : customer , \"plan\" : plan } optional_params = [ ( \"start_date\" , start_date ), ( \"authorization\" , authorization ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . POST , url , payload ) def get_subscriptions ( self , page : int = 1 , pagination : int = 50 , customer : Optional [ int ] = None , plan : Optional [ int ] = None , ) -> Response : \"\"\"Fetch subscriptions available on your integration. Args: page: Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. customer: Filter by Customer ID plan: Filter by Plan ID Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/subscription/?perPage=\" + str ( pagination )) query_params = [ ( \"page\" , page ), ( \"customer\" , customer ), ( \"plan\" , plan ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url ) def get_subscription ( self , id_or_code : str ) -> Response : \"\"\"Fetch details of a subscription on your integration. Args: id_or_code: The subscription ``ID`` or ``code`` you want to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/subscription/ { id_or_code } \" ) return self . _handle_request ( HTTPMethod . GET , url ) def enable ( self , code : str , token : str ) -> Response : \"\"\"Enable a subscription on your integration Args: code: Subscription code token: Email token Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/subscription/enable\" ) payload = { \"code\" : code , \"token\" : token , } return self . _handle_request ( HTTPMethod . POST , url , payload ) def disable ( self , code : str , token : str ) -> Response : \"\"\"Disable a subscription on your integration Args: code: Subscription code token: Email token Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/subscription/disable\" ) payload = { \"code\" : code , \"token\" : token , } return self . _handle_request ( HTTPMethod . POST , url , payload ) def get_update_link ( self , code : str ) -> Response : \"\"\"Generate a link for updating the card on a subscription Args: code: Subscription code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/subscription/ { code } /manage/link/\" ) return self . _handle_request ( HTTPMethod . GET , url ) def send_update_link ( self , code : str ) -> Response : \"\"\"Email a customer a link for updating the card on their subscription Args: code: Subscription code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/subscription/ { code } /manage/email/\" ) payload = { \"code\" : \"code\" } return self . _handle_request ( HTTPMethod . POST , url , payload ) create ( customer , plan , authorization = None , start_date = None ) Create a subscription on your integration Note Email Token paystack creates an email token on each subscription to allow customers cancel their subscriptions from within the invoices sent to their mailboxes. Since they are not authorized, the email tokens are what we use to authenticate the requests over the API. Parameters: Name Type Description Default customer str Customer's email address or customer code required plan str Plan code required authorization Optional [ str ] If customer has multiple authorizations, you can set the desired authorization you wish to use for this subscription here. If this is not supplied, the customer's most recent authorization would be used None start_date Optional [ str ] Set the date for the first debit. (ISO 8601 format) e.g. 2017-05-16T00:30:13+01:00 None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/subscriptions.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 def create ( self , customer : str , plan : str , authorization : Optional [ str ] = None , start_date : Optional [ str ] = None , ) -> Response : \"\"\"Create a subscription on your integration Note: Email Token paystack creates an email token on each subscription to allow customers cancel their subscriptions from within the invoices sent to their mailboxes. Since they are not authorized, the email tokens are what we use to authenticate the requests over the API. Args: customer: Customer's email address or customer code plan: Plan code authorization: If customer has multiple authorizations, you can set the desired authorization you wish to use for this subscription here. If this is not supplied, the customer's most recent authorization would be used start_date: Set the date for the first debit. (ISO 8601 format) e.g. 2017-05-16T00:30:13+01:00 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/subscription\" ) payload = { \"customer\" : customer , \"plan\" : plan } optional_params = [ ( \"start_date\" , start_date ), ( \"authorization\" , authorization ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . POST , url , payload ) disable ( code , token ) Disable a subscription on your integration Parameters: Name Type Description Default code str Subscription code required token str Email token required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/subscriptions.py 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 def disable ( self , code : str , token : str ) -> Response : \"\"\"Disable a subscription on your integration Args: code: Subscription code token: Email token Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/subscription/disable\" ) payload = { \"code\" : code , \"token\" : token , } return self . _handle_request ( HTTPMethod . POST , url , payload ) enable ( code , token ) Enable a subscription on your integration Parameters: Name Type Description Default code str Subscription code required token str Email token required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/subscriptions.py 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 def enable ( self , code : str , token : str ) -> Response : \"\"\"Enable a subscription on your integration Args: code: Subscription code token: Email token Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/subscription/enable\" ) payload = { \"code\" : code , \"token\" : token , } return self . _handle_request ( HTTPMethod . POST , url , payload ) get_subscription ( id_or_code ) Fetch details of a subscription on your integration. Parameters: Name Type Description Default id_or_code str The subscription ID or code you want to fetch required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/subscriptions.py 85 86 87 88 89 90 91 92 93 94 95 96 def get_subscription ( self , id_or_code : str ) -> Response : \"\"\"Fetch details of a subscription on your integration. Args: id_or_code: The subscription ``ID`` or ``code`` you want to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/subscription/ { id_or_code } \" ) return self . _handle_request ( HTTPMethod . GET , url ) get_subscriptions ( page = 1 , pagination = 50 , customer = None , plan = None ) Fetch subscriptions available on your integration. Parameters: Name Type Description Default page int Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. 1 pagination int Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. 50 customer Optional [ int ] Filter by Customer ID None plan Optional [ int ] Filter by Plan ID None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/subscriptions.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 def get_subscriptions ( self , page : int = 1 , pagination : int = 50 , customer : Optional [ int ] = None , plan : Optional [ int ] = None , ) -> Response : \"\"\"Fetch subscriptions available on your integration. Args: page: Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. customer: Filter by Customer ID plan: Filter by Plan ID Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/subscription/?perPage=\" + str ( pagination )) query_params = [ ( \"page\" , page ), ( \"customer\" , customer ), ( \"plan\" , plan ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url ) get_update_link ( code ) Generate a link for updating the card on a subscription Parameters: Name Type Description Default code str Subscription code required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/subscriptions.py 133 134 135 136 137 138 139 140 141 142 143 144 def get_update_link ( self , code : str ) -> Response : \"\"\"Generate a link for updating the card on a subscription Args: code: Subscription code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/subscription/ { code } /manage/link/\" ) return self . _handle_request ( HTTPMethod . GET , url ) send_update_link ( code ) Email a customer a link for updating the card on their subscription Parameters: Name Type Description Default code str Subscription code required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/subscriptions.py 146 147 148 149 150 151 152 153 154 155 156 157 158 def send_update_link ( self , code : str ) -> Response : \"\"\"Email a customer a link for updating the card on their subscription Args: code: Subscription code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/subscription/ { code } /manage/email/\" ) payload = { \"code\" : \"code\" } return self . _handle_request ( HTTPMethod . POST , url , payload )","title":"Subscriptions"},{"location":"reference/subscriptions/#pypaystack2.api.subscriptions.AsyncSubscription","text":"Bases: BaseAsyncAPI Provides a wrapper for paystack Subscriptions API The Subscriptions API allows you to create and manage recurring payment on your integration. https://paystack.com/docs/api/#subscription Source code in pypaystack2/api/subscriptions.py 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 class AsyncSubscription ( BaseAsyncAPI ): \"\"\"Provides a wrapper for paystack Subscriptions API The Subscriptions API allows you to create and manage recurring payment on your integration. https://paystack.com/docs/api/#subscription \"\"\" async def create ( self , customer : str , plan : str , authorization : Optional [ str ] = None , start_date : Optional [ str ] = None , ) -> Response : \"\"\"Create a subscription on your integration Note: Email Token paystack creates an email token on each subscription to allow customers cancel their subscriptions from within the invoices sent to their mailboxes. Since they are not authorized, the email tokens are what we use to authenticate the requests over the API. Args: customer: Customer's email address or customer code plan: Plan code authorization: If customer has multiple authorizations, you can set the desired authorization you wish to use for this subscription here. If this is not supplied, the customer's most recent authorization would be used start_date: Set the date for the first debit. (ISO 8601 format) e.g. 2017-05-16T00:30:13+01:00 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/subscription\" ) payload = { \"customer\" : customer , \"plan\" : plan } optional_params = [ ( \"start_date\" , start_date ), ( \"authorization\" , authorization ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) async def get_subscriptions ( self , page : int = 1 , pagination : int = 50 , customer : Optional [ int ] = None , plan : Optional [ int ] = None , ) -> Response : \"\"\"Fetch subscriptions available on your integration. Args: page: Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. customer: Filter by Customer ID plan: Filter by Plan ID Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/subscription/?perPage=\" + str ( pagination )) query_params = [ ( \"page\" , page ), ( \"customer\" , customer ), ( \"plan\" , plan ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url ) async def get_subscription ( self , id_or_code : str ) -> Response : \"\"\"Fetch details of a subscription on your integration. Args: id_or_code: The subscription ``ID`` or ``code`` you want to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/subscription/ { id_or_code } \" ) return await self . _handle_request ( HTTPMethod . GET , url ) async def enable ( self , code : str , token : str ) -> Response : \"\"\"Enable a subscription on your integration Args: code: Subscription code token: Email token Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/subscription/enable\" ) payload = { \"code\" : code , \"token\" : token , } return await self . _handle_request ( HTTPMethod . POST , url , payload ) async def disable ( self , code : str , token : str ) -> Response : \"\"\"Disable a subscription on your integration Args: code: Subscription code token: Email token Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/subscription/disable\" ) payload = { \"code\" : code , \"token\" : token , } return await self . _handle_request ( HTTPMethod . POST , url , payload ) async def get_update_link ( self , code : str ) -> Response : \"\"\"Generate a link for updating the card on a subscription Args: code: Subscription code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/subscription/ { code } /manage/link/\" ) return await self . _handle_request ( HTTPMethod . GET , url ) async def send_update_link ( self , code : str ) -> Response : \"\"\"Email a customer a link for updating the card on their subscription Args: code: Subscription code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/subscription/ { code } /manage/email/\" ) payload = { \"code\" : \"code\" } return await self . _handle_request ( HTTPMethod . POST , url , payload )","title":"AsyncSubscription"},{"location":"reference/subscriptions/#pypaystack2.api.subscriptions.AsyncSubscription.create","text":"Create a subscription on your integration Note Email Token paystack creates an email token on each subscription to allow customers cancel their subscriptions from within the invoices sent to their mailboxes. Since they are not authorized, the email tokens are what we use to authenticate the requests over the API. Parameters: Name Type Description Default customer str Customer's email address or customer code required plan str Plan code required authorization Optional [ str ] If customer has multiple authorizations, you can set the desired authorization you wish to use for this subscription here. If this is not supplied, the customer's most recent authorization would be used None start_date Optional [ str ] Set the date for the first debit. (ISO 8601 format) e.g. 2017-05-16T00:30:13+01:00 None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/subscriptions.py 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 async def create ( self , customer : str , plan : str , authorization : Optional [ str ] = None , start_date : Optional [ str ] = None , ) -> Response : \"\"\"Create a subscription on your integration Note: Email Token paystack creates an email token on each subscription to allow customers cancel their subscriptions from within the invoices sent to their mailboxes. Since they are not authorized, the email tokens are what we use to authenticate the requests over the API. Args: customer: Customer's email address or customer code plan: Plan code authorization: If customer has multiple authorizations, you can set the desired authorization you wish to use for this subscription here. If this is not supplied, the customer's most recent authorization would be used start_date: Set the date for the first debit. (ISO 8601 format) e.g. 2017-05-16T00:30:13+01:00 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/subscription\" ) payload = { \"customer\" : customer , \"plan\" : plan } optional_params = [ ( \"start_date\" , start_date ), ( \"authorization\" , authorization ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . POST , url , payload )","title":"create()"},{"location":"reference/subscriptions/#pypaystack2.api.subscriptions.AsyncSubscription.disable","text":"Disable a subscription on your integration Parameters: Name Type Description Default code str Subscription code required token str Email token required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/subscriptions.py 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 async def disable ( self , code : str , token : str ) -> Response : \"\"\"Disable a subscription on your integration Args: code: Subscription code token: Email token Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/subscription/disable\" ) payload = { \"code\" : code , \"token\" : token , } return await self . _handle_request ( HTTPMethod . POST , url , payload )","title":"disable()"},{"location":"reference/subscriptions/#pypaystack2.api.subscriptions.AsyncSubscription.enable","text":"Enable a subscription on your integration Parameters: Name Type Description Default code str Subscription code required token str Email token required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/subscriptions.py 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 async def enable ( self , code : str , token : str ) -> Response : \"\"\"Enable a subscription on your integration Args: code: Subscription code token: Email token Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/subscription/enable\" ) payload = { \"code\" : code , \"token\" : token , } return await self . _handle_request ( HTTPMethod . POST , url , payload )","title":"enable()"},{"location":"reference/subscriptions/#pypaystack2.api.subscriptions.AsyncSubscription.get_subscription","text":"Fetch details of a subscription on your integration. Parameters: Name Type Description Default id_or_code str The subscription ID or code you want to fetch required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/subscriptions.py 239 240 241 242 243 244 245 246 247 248 249 250 async def get_subscription ( self , id_or_code : str ) -> Response : \"\"\"Fetch details of a subscription on your integration. Args: id_or_code: The subscription ``ID`` or ``code`` you want to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/subscription/ { id_or_code } \" ) return await self . _handle_request ( HTTPMethod . GET , url )","title":"get_subscription()"},{"location":"reference/subscriptions/#pypaystack2.api.subscriptions.AsyncSubscription.get_subscriptions","text":"Fetch subscriptions available on your integration. Parameters: Name Type Description Default page int Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. 1 pagination int Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. 50 customer Optional [ int ] Filter by Customer ID None plan Optional [ int ] Filter by Plan ID None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/subscriptions.py 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 async def get_subscriptions ( self , page : int = 1 , pagination : int = 50 , customer : Optional [ int ] = None , plan : Optional [ int ] = None , ) -> Response : \"\"\"Fetch subscriptions available on your integration. Args: page: Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. customer: Filter by Customer ID plan: Filter by Plan ID Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/subscription/?perPage=\" + str ( pagination )) query_params = [ ( \"page\" , page ), ( \"customer\" , customer ), ( \"plan\" , plan ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url )","title":"get_subscriptions()"},{"location":"reference/subscriptions/#pypaystack2.api.subscriptions.AsyncSubscription.get_update_link","text":"Generate a link for updating the card on a subscription Parameters: Name Type Description Default code str Subscription code required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/subscriptions.py 287 288 289 290 291 292 293 294 295 296 297 298 async def get_update_link ( self , code : str ) -> Response : \"\"\"Generate a link for updating the card on a subscription Args: code: Subscription code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/subscription/ { code } /manage/link/\" ) return await self . _handle_request ( HTTPMethod . GET , url )","title":"get_update_link()"},{"location":"reference/subscriptions/#pypaystack2.api.subscriptions.AsyncSubscription.send_update_link","text":"Email a customer a link for updating the card on their subscription Parameters: Name Type Description Default code str Subscription code required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/subscriptions.py 300 301 302 303 304 305 306 307 308 309 310 311 312 async def send_update_link ( self , code : str ) -> Response : \"\"\"Email a customer a link for updating the card on their subscription Args: code: Subscription code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/subscription/ { code } /manage/email/\" ) payload = { \"code\" : \"code\" } return await self . _handle_request ( HTTPMethod . POST , url , payload )","title":"send_update_link()"},{"location":"reference/subscriptions/#pypaystack2.api.subscriptions.Subscription","text":"Bases: BaseAPI Provides a wrapper for paystack Subscriptions API The Subscriptions API allows you to create and manage recurring payment on your integration. https://paystack.com/docs/api/#subscription Source code in pypaystack2/api/subscriptions.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 class Subscription ( BaseAPI ): \"\"\"Provides a wrapper for paystack Subscriptions API The Subscriptions API allows you to create and manage recurring payment on your integration. https://paystack.com/docs/api/#subscription \"\"\" def create ( self , customer : str , plan : str , authorization : Optional [ str ] = None , start_date : Optional [ str ] = None , ) -> Response : \"\"\"Create a subscription on your integration Note: Email Token paystack creates an email token on each subscription to allow customers cancel their subscriptions from within the invoices sent to their mailboxes. Since they are not authorized, the email tokens are what we use to authenticate the requests over the API. Args: customer: Customer's email address or customer code plan: Plan code authorization: If customer has multiple authorizations, you can set the desired authorization you wish to use for this subscription here. If this is not supplied, the customer's most recent authorization would be used start_date: Set the date for the first debit. (ISO 8601 format) e.g. 2017-05-16T00:30:13+01:00 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/subscription\" ) payload = { \"customer\" : customer , \"plan\" : plan } optional_params = [ ( \"start_date\" , start_date ), ( \"authorization\" , authorization ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . POST , url , payload ) def get_subscriptions ( self , page : int = 1 , pagination : int = 50 , customer : Optional [ int ] = None , plan : Optional [ int ] = None , ) -> Response : \"\"\"Fetch subscriptions available on your integration. Args: page: Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. customer: Filter by Customer ID plan: Filter by Plan ID Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/subscription/?perPage=\" + str ( pagination )) query_params = [ ( \"page\" , page ), ( \"customer\" , customer ), ( \"plan\" , plan ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url ) def get_subscription ( self , id_or_code : str ) -> Response : \"\"\"Fetch details of a subscription on your integration. Args: id_or_code: The subscription ``ID`` or ``code`` you want to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/subscription/ { id_or_code } \" ) return self . _handle_request ( HTTPMethod . GET , url ) def enable ( self , code : str , token : str ) -> Response : \"\"\"Enable a subscription on your integration Args: code: Subscription code token: Email token Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/subscription/enable\" ) payload = { \"code\" : code , \"token\" : token , } return self . _handle_request ( HTTPMethod . POST , url , payload ) def disable ( self , code : str , token : str ) -> Response : \"\"\"Disable a subscription on your integration Args: code: Subscription code token: Email token Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/subscription/disable\" ) payload = { \"code\" : code , \"token\" : token , } return self . _handle_request ( HTTPMethod . POST , url , payload ) def get_update_link ( self , code : str ) -> Response : \"\"\"Generate a link for updating the card on a subscription Args: code: Subscription code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/subscription/ { code } /manage/link/\" ) return self . _handle_request ( HTTPMethod . GET , url ) def send_update_link ( self , code : str ) -> Response : \"\"\"Email a customer a link for updating the card on their subscription Args: code: Subscription code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/subscription/ { code } /manage/email/\" ) payload = { \"code\" : \"code\" } return self . _handle_request ( HTTPMethod . POST , url , payload )","title":"Subscription"},{"location":"reference/subscriptions/#pypaystack2.api.subscriptions.Subscription.create","text":"Create a subscription on your integration Note Email Token paystack creates an email token on each subscription to allow customers cancel their subscriptions from within the invoices sent to their mailboxes. Since they are not authorized, the email tokens are what we use to authenticate the requests over the API. Parameters: Name Type Description Default customer str Customer's email address or customer code required plan str Plan code required authorization Optional [ str ] If customer has multiple authorizations, you can set the desired authorization you wish to use for this subscription here. If this is not supplied, the customer's most recent authorization would be used None start_date Optional [ str ] Set the date for the first debit. (ISO 8601 format) e.g. 2017-05-16T00:30:13+01:00 None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/subscriptions.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 def create ( self , customer : str , plan : str , authorization : Optional [ str ] = None , start_date : Optional [ str ] = None , ) -> Response : \"\"\"Create a subscription on your integration Note: Email Token paystack creates an email token on each subscription to allow customers cancel their subscriptions from within the invoices sent to their mailboxes. Since they are not authorized, the email tokens are what we use to authenticate the requests over the API. Args: customer: Customer's email address or customer code plan: Plan code authorization: If customer has multiple authorizations, you can set the desired authorization you wish to use for this subscription here. If this is not supplied, the customer's most recent authorization would be used start_date: Set the date for the first debit. (ISO 8601 format) e.g. 2017-05-16T00:30:13+01:00 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/subscription\" ) payload = { \"customer\" : customer , \"plan\" : plan } optional_params = [ ( \"start_date\" , start_date ), ( \"authorization\" , authorization ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . POST , url , payload )","title":"create()"},{"location":"reference/subscriptions/#pypaystack2.api.subscriptions.Subscription.disable","text":"Disable a subscription on your integration Parameters: Name Type Description Default code str Subscription code required token str Email token required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/subscriptions.py 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 def disable ( self , code : str , token : str ) -> Response : \"\"\"Disable a subscription on your integration Args: code: Subscription code token: Email token Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/subscription/disable\" ) payload = { \"code\" : code , \"token\" : token , } return self . _handle_request ( HTTPMethod . POST , url , payload )","title":"disable()"},{"location":"reference/subscriptions/#pypaystack2.api.subscriptions.Subscription.enable","text":"Enable a subscription on your integration Parameters: Name Type Description Default code str Subscription code required token str Email token required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/subscriptions.py 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 def enable ( self , code : str , token : str ) -> Response : \"\"\"Enable a subscription on your integration Args: code: Subscription code token: Email token Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/subscription/enable\" ) payload = { \"code\" : code , \"token\" : token , } return self . _handle_request ( HTTPMethod . POST , url , payload )","title":"enable()"},{"location":"reference/subscriptions/#pypaystack2.api.subscriptions.Subscription.get_subscription","text":"Fetch details of a subscription on your integration. Parameters: Name Type Description Default id_or_code str The subscription ID or code you want to fetch required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/subscriptions.py 85 86 87 88 89 90 91 92 93 94 95 96 def get_subscription ( self , id_or_code : str ) -> Response : \"\"\"Fetch details of a subscription on your integration. Args: id_or_code: The subscription ``ID`` or ``code`` you want to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/subscription/ { id_or_code } \" ) return self . _handle_request ( HTTPMethod . GET , url )","title":"get_subscription()"},{"location":"reference/subscriptions/#pypaystack2.api.subscriptions.Subscription.get_subscriptions","text":"Fetch subscriptions available on your integration. Parameters: Name Type Description Default page int Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. 1 pagination int Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. 50 customer Optional [ int ] Filter by Customer ID None plan Optional [ int ] Filter by Plan ID None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/subscriptions.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 def get_subscriptions ( self , page : int = 1 , pagination : int = 50 , customer : Optional [ int ] = None , plan : Optional [ int ] = None , ) -> Response : \"\"\"Fetch subscriptions available on your integration. Args: page: Specifies exactly what page you want to retrieve. If not specified we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. customer: Filter by Customer ID plan: Filter by Plan ID Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/subscription/?perPage=\" + str ( pagination )) query_params = [ ( \"page\" , page ), ( \"customer\" , customer ), ( \"plan\" , plan ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url )","title":"get_subscriptions()"},{"location":"reference/subscriptions/#pypaystack2.api.subscriptions.Subscription.get_update_link","text":"Generate a link for updating the card on a subscription Parameters: Name Type Description Default code str Subscription code required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/subscriptions.py 133 134 135 136 137 138 139 140 141 142 143 144 def get_update_link ( self , code : str ) -> Response : \"\"\"Generate a link for updating the card on a subscription Args: code: Subscription code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/subscription/ { code } /manage/link/\" ) return self . _handle_request ( HTTPMethod . GET , url )","title":"get_update_link()"},{"location":"reference/subscriptions/#pypaystack2.api.subscriptions.Subscription.send_update_link","text":"Email a customer a link for updating the card on their subscription Parameters: Name Type Description Default code str Subscription code required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/subscriptions.py 146 147 148 149 150 151 152 153 154 155 156 157 158 def send_update_link ( self , code : str ) -> Response : \"\"\"Email a customer a link for updating the card on their subscription Args: code: Subscription code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/subscription/ { code } /manage/email/\" ) payload = { \"code\" : \"code\" } return self . _handle_request ( HTTPMethod . POST , url , payload )","title":"send_update_link()"},{"location":"reference/terminals/","text":"AsyncTerminal Bases: BaseAsyncAPI Provides a wrapper for paystack Terminal API The Terminal API allows you to create and manage recurring payment on your integration. https://paystack.com/docs/api/#terminal Source code in pypaystack2/api/terminals.py 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 class AsyncTerminal ( BaseAsyncAPI ): \"\"\"Provides a wrapper for paystack Terminal API The Terminal API allows you to create and manage recurring payment on your integration. https://paystack.com/docs/api/#terminal \"\"\" async def send_event ( self , terminal_id : str , type : TerminalEvent , action : TerminalEventAction , data : dict , ) -> Response : \"\"\"Send an event from your application to the Paystack Terminal Args: terminal_id: The ID of the Terminal the event should be sent to. type: The type of event to push. Paystack currently supports `TerminalEventType.INVOICE` and `TerminalEventType.TRANSACTION`. action: The action the Terminal needs to perform. For the `TerminalEventType.INVOICE` type, the action can either be `TerminalEventAction.PROCESS` or TerminalEventAction.VIEW. For the `TerminalEventType.TRANSACTION` type, the action can either be `TerminalEventAction.PROCESS` or `TerminalEventAction.PRINT`. data: The parameters needed to perform the specified action. For the invoice type, you need to pass the invoice id and offline reference: {id: invoice_id, reference: offline_reference}. For the transaction type, you can pass the transaction id: {id: transaction_id} Returns: A named tuple containing the response gotten from paystack's server. \"\"\" supported_actions_mapping = { TerminalEvent . TRANSACTION : { TerminalEventAction . PROCESS , TerminalEventAction . PRINT , }, TerminalEvent . INVOICE : { TerminalEventAction . PROCESS , TerminalEventAction . VIEW , }, } if action not in supported_actions_mapping [ type ]: raise InvalidDataError ( f \"Terminal Event: { type } does not support Terminal Event Action: { action } \" ) url = self . _parse_url ( f \"/terminal/ { terminal_id } /event\" ) payload = { \"type\" : type , \"action\" : action , \"data\" : data , } return await self . _handle_request ( HTTPMethod . POST , url , payload ) async def get_event_status ( self , terminal_id : str , event_id : str ) -> Response : \"\"\"Check the status of an event sent to the Terminal Args: terminal_id: The ID of the Terminal the event was sent to. event_id: The ID of the event that was sent to the Terminal Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/terminal/ { terminal_id } /event/ { event_id } \" ) return await self . _handle_request ( HTTPMethod . GET , url ) async def get_terminal_status ( self , terminal_id : str ) -> Response : \"\"\"Check the availability of a Terminal before sending an event to it. Args: terminal_id: The ID of the Terminal you want to check Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/terminal/ { terminal_id } /presence\" ) return await self . _handle_request ( HTTPMethod . GET , url ) async def get_terminals ( self , pagination : int = 50 , next : Optional [ str ] = None , previous : Optional [ str ] = None , ) -> Response : \"\"\"List the Terminals available on your integration Args: pagination: Specifies how many records you want to retrieve per page. If not specified, it defaults to 50. next: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. previous: A cursor that indicates your place in the list. It should be used to fetch the previous page of the list after an initial next request Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/terminal?perPage= { pagination } \" ) query_params = [ ( \"next\" , next ), ( \"previous\" , previous ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url ) async def get_terminal ( self , terminal_id : str ) -> Response : \"\"\"Get the details of a Terminal Args: terminal_id: The ID of the Terminal the event was sent to. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/terminal/ { terminal_id } /\" ) return await self . _handle_request ( HTTPMethod . GET , url ) async def updated_terminal ( self , terminal_id : str , name : str , address : str ) -> Response : \"\"\"Update the details of a Terminal Args: terminal_id: The ID of the Terminal you want to update name: Name of the terminal address: The address of the Terminal Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/terminal/ { terminal_id } \" ) payload = { \"name\" : name , \"address\" : address } return await self . _handle_request ( HTTPMethod . PUT , url , payload ) async def commission_terminal ( self , serial_number : str ) -> Response : \"\"\"Activate your debug device by linking it to your integration Args: serial_number: Device Serial Number Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/terminal/commission_device\" ) payload = { \"serial_number\" : serial_number , } return await self . _handle_request ( \"POST\" , url , payload ) async def decommission_terminal ( self , serial_number : str ) -> Response : \"\"\"Unlink your debug device from your integration Args: serial_number: Device Serial Number Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/terminal/decommission_device\" ) payload = { \"serial_number\" : serial_number , } return await self . _handle_request ( HTTPMethod . POST , url , payload ) commission_terminal ( serial_number ) async Activate your debug device by linking it to your integration Parameters: Name Type Description Default serial_number str Device Serial Number required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/terminals.py 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 async def commission_terminal ( self , serial_number : str ) -> Response : \"\"\"Activate your debug device by linking it to your integration Args: serial_number: Device Serial Number Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/terminal/commission_device\" ) payload = { \"serial_number\" : serial_number , } return await self . _handle_request ( \"POST\" , url , payload ) decommission_terminal ( serial_number ) async Unlink your debug device from your integration Parameters: Name Type Description Default serial_number str Device Serial Number required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/terminals.py 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 async def decommission_terminal ( self , serial_number : str ) -> Response : \"\"\"Unlink your debug device from your integration Args: serial_number: Device Serial Number Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/terminal/decommission_device\" ) payload = { \"serial_number\" : serial_number , } return await self . _handle_request ( HTTPMethod . POST , url , payload ) get_event_status ( terminal_id , event_id ) async Check the status of an event sent to the Terminal Parameters: Name Type Description Default terminal_id str The ID of the Terminal the event was sent to. required event_id str The ID of the event that was sent to the Terminal required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/terminals.py 239 240 241 242 243 244 245 246 247 248 249 250 async def get_event_status ( self , terminal_id : str , event_id : str ) -> Response : \"\"\"Check the status of an event sent to the Terminal Args: terminal_id: The ID of the Terminal the event was sent to. event_id: The ID of the event that was sent to the Terminal Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/terminal/ { terminal_id } /event/ { event_id } \" ) return await self . _handle_request ( HTTPMethod . GET , url ) get_terminal ( terminal_id ) async Get the details of a Terminal Parameters: Name Type Description Default terminal_id str The ID of the Terminal the event was sent to. required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/terminals.py 290 291 292 293 294 295 296 297 298 299 300 async def get_terminal ( self , terminal_id : str ) -> Response : \"\"\"Get the details of a Terminal Args: terminal_id: The ID of the Terminal the event was sent to. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/terminal/ { terminal_id } /\" ) return await self . _handle_request ( HTTPMethod . GET , url ) get_terminal_status ( terminal_id ) async Check the availability of a Terminal before sending an event to it. Parameters: Name Type Description Default terminal_id str The ID of the Terminal you want to check required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/terminals.py 252 253 254 255 256 257 258 259 260 261 262 async def get_terminal_status ( self , terminal_id : str ) -> Response : \"\"\"Check the availability of a Terminal before sending an event to it. Args: terminal_id: The ID of the Terminal you want to check Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/terminal/ { terminal_id } /presence\" ) return await self . _handle_request ( HTTPMethod . GET , url ) get_terminals ( pagination = 50 , next = None , previous = None ) async List the Terminals available on your integration Parameters: Name Type Description Default pagination int Specifies how many records you want to retrieve per page. If not specified, it defaults to 50. 50 next Optional [ str ] Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. None previous Optional [ str ] A cursor that indicates your place in the list. It should be used to fetch the previous page of the list after an initial next request None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/terminals.py 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 async def get_terminals ( self , pagination : int = 50 , next : Optional [ str ] = None , previous : Optional [ str ] = None , ) -> Response : \"\"\"List the Terminals available on your integration Args: pagination: Specifies how many records you want to retrieve per page. If not specified, it defaults to 50. next: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. previous: A cursor that indicates your place in the list. It should be used to fetch the previous page of the list after an initial next request Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/terminal?perPage= { pagination } \" ) query_params = [ ( \"next\" , next ), ( \"previous\" , previous ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url ) send_event ( terminal_id , type , action , data ) async Send an event from your application to the Paystack Terminal Parameters: Name Type Description Default terminal_id str The ID of the Terminal the event should be sent to. required type TerminalEvent The type of event to push. Paystack currently supports TerminalEventType.INVOICE and TerminalEventType.TRANSACTION . required action TerminalEventAction The action the Terminal needs to perform. For the TerminalEventType.INVOICE type, the action can either be TerminalEventAction.PROCESS or TerminalEventAction.VIEW. For the TerminalEventType.TRANSACTION type, the action can either be TerminalEventAction.PROCESS or TerminalEventAction.PRINT . required data dict The parameters needed to perform the specified action. For the invoice type, you need to pass the invoice id and offline reference: {id: invoice_id, reference: offline_reference}. For the transaction type, you can pass the transaction id: {id: transaction_id} required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/terminals.py 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 async def send_event ( self , terminal_id : str , type : TerminalEvent , action : TerminalEventAction , data : dict , ) -> Response : \"\"\"Send an event from your application to the Paystack Terminal Args: terminal_id: The ID of the Terminal the event should be sent to. type: The type of event to push. Paystack currently supports `TerminalEventType.INVOICE` and `TerminalEventType.TRANSACTION`. action: The action the Terminal needs to perform. For the `TerminalEventType.INVOICE` type, the action can either be `TerminalEventAction.PROCESS` or TerminalEventAction.VIEW. For the `TerminalEventType.TRANSACTION` type, the action can either be `TerminalEventAction.PROCESS` or `TerminalEventAction.PRINT`. data: The parameters needed to perform the specified action. For the invoice type, you need to pass the invoice id and offline reference: {id: invoice_id, reference: offline_reference}. For the transaction type, you can pass the transaction id: {id: transaction_id} Returns: A named tuple containing the response gotten from paystack's server. \"\"\" supported_actions_mapping = { TerminalEvent . TRANSACTION : { TerminalEventAction . PROCESS , TerminalEventAction . PRINT , }, TerminalEvent . INVOICE : { TerminalEventAction . PROCESS , TerminalEventAction . VIEW , }, } if action not in supported_actions_mapping [ type ]: raise InvalidDataError ( f \"Terminal Event: { type } does not support Terminal Event Action: { action } \" ) url = self . _parse_url ( f \"/terminal/ { terminal_id } /event\" ) payload = { \"type\" : type , \"action\" : action , \"data\" : data , } return await self . _handle_request ( HTTPMethod . POST , url , payload ) updated_terminal ( terminal_id , name , address ) async Update the details of a Terminal Parameters: Name Type Description Default terminal_id str The ID of the Terminal you want to update required name str Name of the terminal required address str The address of the Terminal required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/terminals.py 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 async def updated_terminal ( self , terminal_id : str , name : str , address : str ) -> Response : \"\"\"Update the details of a Terminal Args: terminal_id: The ID of the Terminal you want to update name: Name of the terminal address: The address of the Terminal Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/terminal/ { terminal_id } \" ) payload = { \"name\" : name , \"address\" : address } return await self . _handle_request ( HTTPMethod . PUT , url , payload ) Terminal Bases: BaseAPI Provides a wrapper for paystack Terminal API The Terminal API allows you to create and manage recurring payment on your integration. https://paystack.com/docs/api/#terminal Source code in pypaystack2/api/terminals.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 class Terminal ( BaseAPI ): \"\"\"Provides a wrapper for paystack Terminal API The Terminal API allows you to create and manage recurring payment on your integration. https://paystack.com/docs/api/#terminal \"\"\" def send_event ( self , terminal_id : str , type : TerminalEvent , action : TerminalEventAction , data : dict , ) -> Response : \"\"\"Send an event from your application to the Paystack Terminal Args: terminal_id: The ID of the Terminal the event should be sent to. type: The type of event to push. Paystack currently supports `TerminalEventType.INVOICE` and `TerminalEventType.TRANSACTION`. action: The action the Terminal needs to perform. For the `TerminalEventType.INVOICE` type, the action can either be `TerminalEventAction.PROCESS` or TerminalEventAction.VIEW. For the `TerminalEventType.TRANSACTION` type, the action can either be `TerminalEventAction.PROCESS` or `TerminalEventAction.PRINT`. data: The parameters needed to perform the specified action. For the invoice type, you need to pass the invoice id and offline reference: {id: invoice_id, reference: offline_reference}. For the transaction type, you can pass the transaction id: {id: transaction_id} Returns: A named tuple containing the response gotten from paystack's server. \"\"\" supported_actions_mapping = { TerminalEvent . TRANSACTION : { TerminalEventAction . PROCESS , TerminalEventAction . PRINT , }, TerminalEvent . INVOICE : { TerminalEventAction . PROCESS , TerminalEventAction . VIEW , }, } if action not in supported_actions_mapping [ type ]: raise InvalidDataError ( f \"Terminal Event: { type } does not support Terminal Event Action: { action } \" ) url = self . _parse_url ( f \"/terminal/ { terminal_id } /event\" ) payload = { \"type\" : type , \"action\" : action , \"data\" : data , } return self . _handle_request ( HTTPMethod . POST , url , payload ) def get_event_status ( self , terminal_id : str , event_id : str ) -> Response : \"\"\"Check the status of an event sent to the Terminal Args: terminal_id: The ID of the Terminal the event was sent to. event_id: The ID of the event that was sent to the Terminal Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/terminal/ { terminal_id } /event/ { event_id } \" ) return self . _handle_request ( HTTPMethod . GET , url ) def get_terminal_status ( self , terminal_id : str ) -> Response : \"\"\"Check the availability of a Terminal before sending an event to it. Args: terminal_id: The ID of the Terminal you want to check Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/terminal/ { terminal_id } /presence\" ) return self . _handle_request ( HTTPMethod . GET , url ) def get_terminals ( self , pagination : int = 50 , next : Optional [ str ] = None , previous : Optional [ str ] = None , ) -> Response : \"\"\"List the Terminals available on your integration Args: pagination: Specifies how many records you want to retrieve per page. If not specified, it defaults to 50. next: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. previous: A cursor that indicates your place in the list. It should be used to fetch the previous page of the list after an initial next request Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/terminal?perPage= { pagination } \" ) query_params = [ ( \"next\" , next ), ( \"previous\" , previous ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url ) def get_terminal ( self , terminal_id : str ) -> Response : \"\"\"Get the details of a Terminal Args: terminal_id: The ID of the Terminal the event was sent to. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/terminal/ { terminal_id } /\" ) return self . _handle_request ( HTTPMethod . GET , url ) def updated_terminal ( self , terminal_id : str , name : str , address : str ) -> Response : \"\"\"Update the details of a Terminal Args: terminal_id: The ID of the Terminal you want to update name: Name of the terminal address: The address of the Terminal Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/terminal/ { terminal_id } \" ) payload = { \"name\" : name , \"address\" : address } return self . _handle_request ( HTTPMethod . PUT , url , payload ) def commission_terminal ( self , serial_number : str ) -> Response : \"\"\"Activate your debug device by linking it to your integration Args: serial_number: Device Serial Number Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/terminal/commission_device\" ) payload = { \"serial_number\" : serial_number , } return self . _handle_request ( \"POST\" , url , payload ) def decommission_terminal ( self , serial_number : str ) -> Response : \"\"\"Unlink your debug device from your integration Args: serial_number: Device Serial Number Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/terminal/decommission_device\" ) payload = { \"serial_number\" : serial_number , } return self . _handle_request ( HTTPMethod . POST , url , payload ) commission_terminal ( serial_number ) Activate your debug device by linking it to your integration Parameters: Name Type Description Default serial_number str Device Serial Number required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/terminals.py 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 def commission_terminal ( self , serial_number : str ) -> Response : \"\"\"Activate your debug device by linking it to your integration Args: serial_number: Device Serial Number Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/terminal/commission_device\" ) payload = { \"serial_number\" : serial_number , } return self . _handle_request ( \"POST\" , url , payload ) decommission_terminal ( serial_number ) Unlink your debug device from your integration Parameters: Name Type Description Default serial_number str Device Serial Number required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/terminals.py 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 def decommission_terminal ( self , serial_number : str ) -> Response : \"\"\"Unlink your debug device from your integration Args: serial_number: Device Serial Number Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/terminal/decommission_device\" ) payload = { \"serial_number\" : serial_number , } return self . _handle_request ( HTTPMethod . POST , url , payload ) get_event_status ( terminal_id , event_id ) Check the status of an event sent to the Terminal Parameters: Name Type Description Default terminal_id str The ID of the Terminal the event was sent to. required event_id str The ID of the event that was sent to the Terminal required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/terminals.py 70 71 72 73 74 75 76 77 78 79 80 81 def get_event_status ( self , terminal_id : str , event_id : str ) -> Response : \"\"\"Check the status of an event sent to the Terminal Args: terminal_id: The ID of the Terminal the event was sent to. event_id: The ID of the event that was sent to the Terminal Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/terminal/ { terminal_id } /event/ { event_id } \" ) return self . _handle_request ( HTTPMethod . GET , url ) get_terminal ( terminal_id ) Get the details of a Terminal Parameters: Name Type Description Default terminal_id str The ID of the Terminal the event was sent to. required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/terminals.py 121 122 123 124 125 126 127 128 129 130 131 def get_terminal ( self , terminal_id : str ) -> Response : \"\"\"Get the details of a Terminal Args: terminal_id: The ID of the Terminal the event was sent to. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/terminal/ { terminal_id } /\" ) return self . _handle_request ( HTTPMethod . GET , url ) get_terminal_status ( terminal_id ) Check the availability of a Terminal before sending an event to it. Parameters: Name Type Description Default terminal_id str The ID of the Terminal you want to check required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/terminals.py 83 84 85 86 87 88 89 90 91 92 93 def get_terminal_status ( self , terminal_id : str ) -> Response : \"\"\"Check the availability of a Terminal before sending an event to it. Args: terminal_id: The ID of the Terminal you want to check Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/terminal/ { terminal_id } /presence\" ) return self . _handle_request ( HTTPMethod . GET , url ) get_terminals ( pagination = 50 , next = None , previous = None ) List the Terminals available on your integration Parameters: Name Type Description Default pagination int Specifies how many records you want to retrieve per page. If not specified, it defaults to 50. 50 next Optional [ str ] Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. None previous Optional [ str ] A cursor that indicates your place in the list. It should be used to fetch the previous page of the list after an initial next request None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/terminals.py 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 def get_terminals ( self , pagination : int = 50 , next : Optional [ str ] = None , previous : Optional [ str ] = None , ) -> Response : \"\"\"List the Terminals available on your integration Args: pagination: Specifies how many records you want to retrieve per page. If not specified, it defaults to 50. next: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. previous: A cursor that indicates your place in the list. It should be used to fetch the previous page of the list after an initial next request Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/terminal?perPage= { pagination } \" ) query_params = [ ( \"next\" , next ), ( \"previous\" , previous ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url ) send_event ( terminal_id , type , action , data ) Send an event from your application to the Paystack Terminal Parameters: Name Type Description Default terminal_id str The ID of the Terminal the event should be sent to. required type TerminalEvent The type of event to push. Paystack currently supports TerminalEventType.INVOICE and TerminalEventType.TRANSACTION . required action TerminalEventAction The action the Terminal needs to perform. For the TerminalEventType.INVOICE type, the action can either be TerminalEventAction.PROCESS or TerminalEventAction.VIEW. For the TerminalEventType.TRANSACTION type, the action can either be TerminalEventAction.PROCESS or TerminalEventAction.PRINT . required data dict The parameters needed to perform the specified action. For the invoice type, you need to pass the invoice id and offline reference: {id: invoice_id, reference: offline_reference}. For the transaction type, you can pass the transaction id: {id: transaction_id} required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/terminals.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def send_event ( self , terminal_id : str , type : TerminalEvent , action : TerminalEventAction , data : dict , ) -> Response : \"\"\"Send an event from your application to the Paystack Terminal Args: terminal_id: The ID of the Terminal the event should be sent to. type: The type of event to push. Paystack currently supports `TerminalEventType.INVOICE` and `TerminalEventType.TRANSACTION`. action: The action the Terminal needs to perform. For the `TerminalEventType.INVOICE` type, the action can either be `TerminalEventAction.PROCESS` or TerminalEventAction.VIEW. For the `TerminalEventType.TRANSACTION` type, the action can either be `TerminalEventAction.PROCESS` or `TerminalEventAction.PRINT`. data: The parameters needed to perform the specified action. For the invoice type, you need to pass the invoice id and offline reference: {id: invoice_id, reference: offline_reference}. For the transaction type, you can pass the transaction id: {id: transaction_id} Returns: A named tuple containing the response gotten from paystack's server. \"\"\" supported_actions_mapping = { TerminalEvent . TRANSACTION : { TerminalEventAction . PROCESS , TerminalEventAction . PRINT , }, TerminalEvent . INVOICE : { TerminalEventAction . PROCESS , TerminalEventAction . VIEW , }, } if action not in supported_actions_mapping [ type ]: raise InvalidDataError ( f \"Terminal Event: { type } does not support Terminal Event Action: { action } \" ) url = self . _parse_url ( f \"/terminal/ { terminal_id } /event\" ) payload = { \"type\" : type , \"action\" : action , \"data\" : data , } return self . _handle_request ( HTTPMethod . POST , url , payload ) updated_terminal ( terminal_id , name , address ) Update the details of a Terminal Parameters: Name Type Description Default terminal_id str The ID of the Terminal you want to update required name str Name of the terminal required address str The address of the Terminal required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/terminals.py 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 def updated_terminal ( self , terminal_id : str , name : str , address : str ) -> Response : \"\"\"Update the details of a Terminal Args: terminal_id: The ID of the Terminal you want to update name: Name of the terminal address: The address of the Terminal Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/terminal/ { terminal_id } \" ) payload = { \"name\" : name , \"address\" : address } return self . _handle_request ( HTTPMethod . PUT , url , payload )","title":"Terminals"},{"location":"reference/terminals/#pypaystack2.api.terminals.AsyncTerminal","text":"Bases: BaseAsyncAPI Provides a wrapper for paystack Terminal API The Terminal API allows you to create and manage recurring payment on your integration. https://paystack.com/docs/api/#terminal Source code in pypaystack2/api/terminals.py 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 class AsyncTerminal ( BaseAsyncAPI ): \"\"\"Provides a wrapper for paystack Terminal API The Terminal API allows you to create and manage recurring payment on your integration. https://paystack.com/docs/api/#terminal \"\"\" async def send_event ( self , terminal_id : str , type : TerminalEvent , action : TerminalEventAction , data : dict , ) -> Response : \"\"\"Send an event from your application to the Paystack Terminal Args: terminal_id: The ID of the Terminal the event should be sent to. type: The type of event to push. Paystack currently supports `TerminalEventType.INVOICE` and `TerminalEventType.TRANSACTION`. action: The action the Terminal needs to perform. For the `TerminalEventType.INVOICE` type, the action can either be `TerminalEventAction.PROCESS` or TerminalEventAction.VIEW. For the `TerminalEventType.TRANSACTION` type, the action can either be `TerminalEventAction.PROCESS` or `TerminalEventAction.PRINT`. data: The parameters needed to perform the specified action. For the invoice type, you need to pass the invoice id and offline reference: {id: invoice_id, reference: offline_reference}. For the transaction type, you can pass the transaction id: {id: transaction_id} Returns: A named tuple containing the response gotten from paystack's server. \"\"\" supported_actions_mapping = { TerminalEvent . TRANSACTION : { TerminalEventAction . PROCESS , TerminalEventAction . PRINT , }, TerminalEvent . INVOICE : { TerminalEventAction . PROCESS , TerminalEventAction . VIEW , }, } if action not in supported_actions_mapping [ type ]: raise InvalidDataError ( f \"Terminal Event: { type } does not support Terminal Event Action: { action } \" ) url = self . _parse_url ( f \"/terminal/ { terminal_id } /event\" ) payload = { \"type\" : type , \"action\" : action , \"data\" : data , } return await self . _handle_request ( HTTPMethod . POST , url , payload ) async def get_event_status ( self , terminal_id : str , event_id : str ) -> Response : \"\"\"Check the status of an event sent to the Terminal Args: terminal_id: The ID of the Terminal the event was sent to. event_id: The ID of the event that was sent to the Terminal Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/terminal/ { terminal_id } /event/ { event_id } \" ) return await self . _handle_request ( HTTPMethod . GET , url ) async def get_terminal_status ( self , terminal_id : str ) -> Response : \"\"\"Check the availability of a Terminal before sending an event to it. Args: terminal_id: The ID of the Terminal you want to check Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/terminal/ { terminal_id } /presence\" ) return await self . _handle_request ( HTTPMethod . GET , url ) async def get_terminals ( self , pagination : int = 50 , next : Optional [ str ] = None , previous : Optional [ str ] = None , ) -> Response : \"\"\"List the Terminals available on your integration Args: pagination: Specifies how many records you want to retrieve per page. If not specified, it defaults to 50. next: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. previous: A cursor that indicates your place in the list. It should be used to fetch the previous page of the list after an initial next request Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/terminal?perPage= { pagination } \" ) query_params = [ ( \"next\" , next ), ( \"previous\" , previous ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url ) async def get_terminal ( self , terminal_id : str ) -> Response : \"\"\"Get the details of a Terminal Args: terminal_id: The ID of the Terminal the event was sent to. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/terminal/ { terminal_id } /\" ) return await self . _handle_request ( HTTPMethod . GET , url ) async def updated_terminal ( self , terminal_id : str , name : str , address : str ) -> Response : \"\"\"Update the details of a Terminal Args: terminal_id: The ID of the Terminal you want to update name: Name of the terminal address: The address of the Terminal Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/terminal/ { terminal_id } \" ) payload = { \"name\" : name , \"address\" : address } return await self . _handle_request ( HTTPMethod . PUT , url , payload ) async def commission_terminal ( self , serial_number : str ) -> Response : \"\"\"Activate your debug device by linking it to your integration Args: serial_number: Device Serial Number Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/terminal/commission_device\" ) payload = { \"serial_number\" : serial_number , } return await self . _handle_request ( \"POST\" , url , payload ) async def decommission_terminal ( self , serial_number : str ) -> Response : \"\"\"Unlink your debug device from your integration Args: serial_number: Device Serial Number Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/terminal/decommission_device\" ) payload = { \"serial_number\" : serial_number , } return await self . _handle_request ( HTTPMethod . POST , url , payload )","title":"AsyncTerminal"},{"location":"reference/terminals/#pypaystack2.api.terminals.AsyncTerminal.commission_terminal","text":"Activate your debug device by linking it to your integration Parameters: Name Type Description Default serial_number str Device Serial Number required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/terminals.py 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 async def commission_terminal ( self , serial_number : str ) -> Response : \"\"\"Activate your debug device by linking it to your integration Args: serial_number: Device Serial Number Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/terminal/commission_device\" ) payload = { \"serial_number\" : serial_number , } return await self . _handle_request ( \"POST\" , url , payload )","title":"commission_terminal()"},{"location":"reference/terminals/#pypaystack2.api.terminals.AsyncTerminal.decommission_terminal","text":"Unlink your debug device from your integration Parameters: Name Type Description Default serial_number str Device Serial Number required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/terminals.py 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 async def decommission_terminal ( self , serial_number : str ) -> Response : \"\"\"Unlink your debug device from your integration Args: serial_number: Device Serial Number Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/terminal/decommission_device\" ) payload = { \"serial_number\" : serial_number , } return await self . _handle_request ( HTTPMethod . POST , url , payload )","title":"decommission_terminal()"},{"location":"reference/terminals/#pypaystack2.api.terminals.AsyncTerminal.get_event_status","text":"Check the status of an event sent to the Terminal Parameters: Name Type Description Default terminal_id str The ID of the Terminal the event was sent to. required event_id str The ID of the event that was sent to the Terminal required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/terminals.py 239 240 241 242 243 244 245 246 247 248 249 250 async def get_event_status ( self , terminal_id : str , event_id : str ) -> Response : \"\"\"Check the status of an event sent to the Terminal Args: terminal_id: The ID of the Terminal the event was sent to. event_id: The ID of the event that was sent to the Terminal Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/terminal/ { terminal_id } /event/ { event_id } \" ) return await self . _handle_request ( HTTPMethod . GET , url )","title":"get_event_status()"},{"location":"reference/terminals/#pypaystack2.api.terminals.AsyncTerminal.get_terminal","text":"Get the details of a Terminal Parameters: Name Type Description Default terminal_id str The ID of the Terminal the event was sent to. required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/terminals.py 290 291 292 293 294 295 296 297 298 299 300 async def get_terminal ( self , terminal_id : str ) -> Response : \"\"\"Get the details of a Terminal Args: terminal_id: The ID of the Terminal the event was sent to. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/terminal/ { terminal_id } /\" ) return await self . _handle_request ( HTTPMethod . GET , url )","title":"get_terminal()"},{"location":"reference/terminals/#pypaystack2.api.terminals.AsyncTerminal.get_terminal_status","text":"Check the availability of a Terminal before sending an event to it. Parameters: Name Type Description Default terminal_id str The ID of the Terminal you want to check required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/terminals.py 252 253 254 255 256 257 258 259 260 261 262 async def get_terminal_status ( self , terminal_id : str ) -> Response : \"\"\"Check the availability of a Terminal before sending an event to it. Args: terminal_id: The ID of the Terminal you want to check Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/terminal/ { terminal_id } /presence\" ) return await self . _handle_request ( HTTPMethod . GET , url )","title":"get_terminal_status()"},{"location":"reference/terminals/#pypaystack2.api.terminals.AsyncTerminal.get_terminals","text":"List the Terminals available on your integration Parameters: Name Type Description Default pagination int Specifies how many records you want to retrieve per page. If not specified, it defaults to 50. 50 next Optional [ str ] Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. None previous Optional [ str ] A cursor that indicates your place in the list. It should be used to fetch the previous page of the list after an initial next request None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/terminals.py 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 async def get_terminals ( self , pagination : int = 50 , next : Optional [ str ] = None , previous : Optional [ str ] = None , ) -> Response : \"\"\"List the Terminals available on your integration Args: pagination: Specifies how many records you want to retrieve per page. If not specified, it defaults to 50. next: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. previous: A cursor that indicates your place in the list. It should be used to fetch the previous page of the list after an initial next request Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/terminal?perPage= { pagination } \" ) query_params = [ ( \"next\" , next ), ( \"previous\" , previous ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url )","title":"get_terminals()"},{"location":"reference/terminals/#pypaystack2.api.terminals.AsyncTerminal.send_event","text":"Send an event from your application to the Paystack Terminal Parameters: Name Type Description Default terminal_id str The ID of the Terminal the event should be sent to. required type TerminalEvent The type of event to push. Paystack currently supports TerminalEventType.INVOICE and TerminalEventType.TRANSACTION . required action TerminalEventAction The action the Terminal needs to perform. For the TerminalEventType.INVOICE type, the action can either be TerminalEventAction.PROCESS or TerminalEventAction.VIEW. For the TerminalEventType.TRANSACTION type, the action can either be TerminalEventAction.PROCESS or TerminalEventAction.PRINT . required data dict The parameters needed to perform the specified action. For the invoice type, you need to pass the invoice id and offline reference: {id: invoice_id, reference: offline_reference}. For the transaction type, you can pass the transaction id: {id: transaction_id} required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/terminals.py 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 async def send_event ( self , terminal_id : str , type : TerminalEvent , action : TerminalEventAction , data : dict , ) -> Response : \"\"\"Send an event from your application to the Paystack Terminal Args: terminal_id: The ID of the Terminal the event should be sent to. type: The type of event to push. Paystack currently supports `TerminalEventType.INVOICE` and `TerminalEventType.TRANSACTION`. action: The action the Terminal needs to perform. For the `TerminalEventType.INVOICE` type, the action can either be `TerminalEventAction.PROCESS` or TerminalEventAction.VIEW. For the `TerminalEventType.TRANSACTION` type, the action can either be `TerminalEventAction.PROCESS` or `TerminalEventAction.PRINT`. data: The parameters needed to perform the specified action. For the invoice type, you need to pass the invoice id and offline reference: {id: invoice_id, reference: offline_reference}. For the transaction type, you can pass the transaction id: {id: transaction_id} Returns: A named tuple containing the response gotten from paystack's server. \"\"\" supported_actions_mapping = { TerminalEvent . TRANSACTION : { TerminalEventAction . PROCESS , TerminalEventAction . PRINT , }, TerminalEvent . INVOICE : { TerminalEventAction . PROCESS , TerminalEventAction . VIEW , }, } if action not in supported_actions_mapping [ type ]: raise InvalidDataError ( f \"Terminal Event: { type } does not support Terminal Event Action: { action } \" ) url = self . _parse_url ( f \"/terminal/ { terminal_id } /event\" ) payload = { \"type\" : type , \"action\" : action , \"data\" : data , } return await self . _handle_request ( HTTPMethod . POST , url , payload )","title":"send_event()"},{"location":"reference/terminals/#pypaystack2.api.terminals.AsyncTerminal.updated_terminal","text":"Update the details of a Terminal Parameters: Name Type Description Default terminal_id str The ID of the Terminal you want to update required name str Name of the terminal required address str The address of the Terminal required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/terminals.py 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 async def updated_terminal ( self , terminal_id : str , name : str , address : str ) -> Response : \"\"\"Update the details of a Terminal Args: terminal_id: The ID of the Terminal you want to update name: Name of the terminal address: The address of the Terminal Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/terminal/ { terminal_id } \" ) payload = { \"name\" : name , \"address\" : address } return await self . _handle_request ( HTTPMethod . PUT , url , payload )","title":"updated_terminal()"},{"location":"reference/terminals/#pypaystack2.api.terminals.Terminal","text":"Bases: BaseAPI Provides a wrapper for paystack Terminal API The Terminal API allows you to create and manage recurring payment on your integration. https://paystack.com/docs/api/#terminal Source code in pypaystack2/api/terminals.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 class Terminal ( BaseAPI ): \"\"\"Provides a wrapper for paystack Terminal API The Terminal API allows you to create and manage recurring payment on your integration. https://paystack.com/docs/api/#terminal \"\"\" def send_event ( self , terminal_id : str , type : TerminalEvent , action : TerminalEventAction , data : dict , ) -> Response : \"\"\"Send an event from your application to the Paystack Terminal Args: terminal_id: The ID of the Terminal the event should be sent to. type: The type of event to push. Paystack currently supports `TerminalEventType.INVOICE` and `TerminalEventType.TRANSACTION`. action: The action the Terminal needs to perform. For the `TerminalEventType.INVOICE` type, the action can either be `TerminalEventAction.PROCESS` or TerminalEventAction.VIEW. For the `TerminalEventType.TRANSACTION` type, the action can either be `TerminalEventAction.PROCESS` or `TerminalEventAction.PRINT`. data: The parameters needed to perform the specified action. For the invoice type, you need to pass the invoice id and offline reference: {id: invoice_id, reference: offline_reference}. For the transaction type, you can pass the transaction id: {id: transaction_id} Returns: A named tuple containing the response gotten from paystack's server. \"\"\" supported_actions_mapping = { TerminalEvent . TRANSACTION : { TerminalEventAction . PROCESS , TerminalEventAction . PRINT , }, TerminalEvent . INVOICE : { TerminalEventAction . PROCESS , TerminalEventAction . VIEW , }, } if action not in supported_actions_mapping [ type ]: raise InvalidDataError ( f \"Terminal Event: { type } does not support Terminal Event Action: { action } \" ) url = self . _parse_url ( f \"/terminal/ { terminal_id } /event\" ) payload = { \"type\" : type , \"action\" : action , \"data\" : data , } return self . _handle_request ( HTTPMethod . POST , url , payload ) def get_event_status ( self , terminal_id : str , event_id : str ) -> Response : \"\"\"Check the status of an event sent to the Terminal Args: terminal_id: The ID of the Terminal the event was sent to. event_id: The ID of the event that was sent to the Terminal Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/terminal/ { terminal_id } /event/ { event_id } \" ) return self . _handle_request ( HTTPMethod . GET , url ) def get_terminal_status ( self , terminal_id : str ) -> Response : \"\"\"Check the availability of a Terminal before sending an event to it. Args: terminal_id: The ID of the Terminal you want to check Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/terminal/ { terminal_id } /presence\" ) return self . _handle_request ( HTTPMethod . GET , url ) def get_terminals ( self , pagination : int = 50 , next : Optional [ str ] = None , previous : Optional [ str ] = None , ) -> Response : \"\"\"List the Terminals available on your integration Args: pagination: Specifies how many records you want to retrieve per page. If not specified, it defaults to 50. next: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. previous: A cursor that indicates your place in the list. It should be used to fetch the previous page of the list after an initial next request Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/terminal?perPage= { pagination } \" ) query_params = [ ( \"next\" , next ), ( \"previous\" , previous ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url ) def get_terminal ( self , terminal_id : str ) -> Response : \"\"\"Get the details of a Terminal Args: terminal_id: The ID of the Terminal the event was sent to. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/terminal/ { terminal_id } /\" ) return self . _handle_request ( HTTPMethod . GET , url ) def updated_terminal ( self , terminal_id : str , name : str , address : str ) -> Response : \"\"\"Update the details of a Terminal Args: terminal_id: The ID of the Terminal you want to update name: Name of the terminal address: The address of the Terminal Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/terminal/ { terminal_id } \" ) payload = { \"name\" : name , \"address\" : address } return self . _handle_request ( HTTPMethod . PUT , url , payload ) def commission_terminal ( self , serial_number : str ) -> Response : \"\"\"Activate your debug device by linking it to your integration Args: serial_number: Device Serial Number Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/terminal/commission_device\" ) payload = { \"serial_number\" : serial_number , } return self . _handle_request ( \"POST\" , url , payload ) def decommission_terminal ( self , serial_number : str ) -> Response : \"\"\"Unlink your debug device from your integration Args: serial_number: Device Serial Number Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/terminal/decommission_device\" ) payload = { \"serial_number\" : serial_number , } return self . _handle_request ( HTTPMethod . POST , url , payload )","title":"Terminal"},{"location":"reference/terminals/#pypaystack2.api.terminals.Terminal.commission_terminal","text":"Activate your debug device by linking it to your integration Parameters: Name Type Description Default serial_number str Device Serial Number required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/terminals.py 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 def commission_terminal ( self , serial_number : str ) -> Response : \"\"\"Activate your debug device by linking it to your integration Args: serial_number: Device Serial Number Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/terminal/commission_device\" ) payload = { \"serial_number\" : serial_number , } return self . _handle_request ( \"POST\" , url , payload )","title":"commission_terminal()"},{"location":"reference/terminals/#pypaystack2.api.terminals.Terminal.decommission_terminal","text":"Unlink your debug device from your integration Parameters: Name Type Description Default serial_number str Device Serial Number required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/terminals.py 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 def decommission_terminal ( self , serial_number : str ) -> Response : \"\"\"Unlink your debug device from your integration Args: serial_number: Device Serial Number Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/terminal/decommission_device\" ) payload = { \"serial_number\" : serial_number , } return self . _handle_request ( HTTPMethod . POST , url , payload )","title":"decommission_terminal()"},{"location":"reference/terminals/#pypaystack2.api.terminals.Terminal.get_event_status","text":"Check the status of an event sent to the Terminal Parameters: Name Type Description Default terminal_id str The ID of the Terminal the event was sent to. required event_id str The ID of the event that was sent to the Terminal required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/terminals.py 70 71 72 73 74 75 76 77 78 79 80 81 def get_event_status ( self , terminal_id : str , event_id : str ) -> Response : \"\"\"Check the status of an event sent to the Terminal Args: terminal_id: The ID of the Terminal the event was sent to. event_id: The ID of the event that was sent to the Terminal Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/terminal/ { terminal_id } /event/ { event_id } \" ) return self . _handle_request ( HTTPMethod . GET , url )","title":"get_event_status()"},{"location":"reference/terminals/#pypaystack2.api.terminals.Terminal.get_terminal","text":"Get the details of a Terminal Parameters: Name Type Description Default terminal_id str The ID of the Terminal the event was sent to. required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/terminals.py 121 122 123 124 125 126 127 128 129 130 131 def get_terminal ( self , terminal_id : str ) -> Response : \"\"\"Get the details of a Terminal Args: terminal_id: The ID of the Terminal the event was sent to. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/terminal/ { terminal_id } /\" ) return self . _handle_request ( HTTPMethod . GET , url )","title":"get_terminal()"},{"location":"reference/terminals/#pypaystack2.api.terminals.Terminal.get_terminal_status","text":"Check the availability of a Terminal before sending an event to it. Parameters: Name Type Description Default terminal_id str The ID of the Terminal you want to check required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/terminals.py 83 84 85 86 87 88 89 90 91 92 93 def get_terminal_status ( self , terminal_id : str ) -> Response : \"\"\"Check the availability of a Terminal before sending an event to it. Args: terminal_id: The ID of the Terminal you want to check Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/terminal/ { terminal_id } /presence\" ) return self . _handle_request ( HTTPMethod . GET , url )","title":"get_terminal_status()"},{"location":"reference/terminals/#pypaystack2.api.terminals.Terminal.get_terminals","text":"List the Terminals available on your integration Parameters: Name Type Description Default pagination int Specifies how many records you want to retrieve per page. If not specified, it defaults to 50. 50 next Optional [ str ] Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. None previous Optional [ str ] A cursor that indicates your place in the list. It should be used to fetch the previous page of the list after an initial next request None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/terminals.py 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 def get_terminals ( self , pagination : int = 50 , next : Optional [ str ] = None , previous : Optional [ str ] = None , ) -> Response : \"\"\"List the Terminals available on your integration Args: pagination: Specifies how many records you want to retrieve per page. If not specified, it defaults to 50. next: Specifies how many records you want to retrieve per page. If not specified we use a default value of 50. previous: A cursor that indicates your place in the list. It should be used to fetch the previous page of the list after an initial next request Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/terminal?perPage= { pagination } \" ) query_params = [ ( \"next\" , next ), ( \"previous\" , previous ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url )","title":"get_terminals()"},{"location":"reference/terminals/#pypaystack2.api.terminals.Terminal.send_event","text":"Send an event from your application to the Paystack Terminal Parameters: Name Type Description Default terminal_id str The ID of the Terminal the event should be sent to. required type TerminalEvent The type of event to push. Paystack currently supports TerminalEventType.INVOICE and TerminalEventType.TRANSACTION . required action TerminalEventAction The action the Terminal needs to perform. For the TerminalEventType.INVOICE type, the action can either be TerminalEventAction.PROCESS or TerminalEventAction.VIEW. For the TerminalEventType.TRANSACTION type, the action can either be TerminalEventAction.PROCESS or TerminalEventAction.PRINT . required data dict The parameters needed to perform the specified action. For the invoice type, you need to pass the invoice id and offline reference: {id: invoice_id, reference: offline_reference}. For the transaction type, you can pass the transaction id: {id: transaction_id} required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/terminals.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def send_event ( self , terminal_id : str , type : TerminalEvent , action : TerminalEventAction , data : dict , ) -> Response : \"\"\"Send an event from your application to the Paystack Terminal Args: terminal_id: The ID of the Terminal the event should be sent to. type: The type of event to push. Paystack currently supports `TerminalEventType.INVOICE` and `TerminalEventType.TRANSACTION`. action: The action the Terminal needs to perform. For the `TerminalEventType.INVOICE` type, the action can either be `TerminalEventAction.PROCESS` or TerminalEventAction.VIEW. For the `TerminalEventType.TRANSACTION` type, the action can either be `TerminalEventAction.PROCESS` or `TerminalEventAction.PRINT`. data: The parameters needed to perform the specified action. For the invoice type, you need to pass the invoice id and offline reference: {id: invoice_id, reference: offline_reference}. For the transaction type, you can pass the transaction id: {id: transaction_id} Returns: A named tuple containing the response gotten from paystack's server. \"\"\" supported_actions_mapping = { TerminalEvent . TRANSACTION : { TerminalEventAction . PROCESS , TerminalEventAction . PRINT , }, TerminalEvent . INVOICE : { TerminalEventAction . PROCESS , TerminalEventAction . VIEW , }, } if action not in supported_actions_mapping [ type ]: raise InvalidDataError ( f \"Terminal Event: { type } does not support Terminal Event Action: { action } \" ) url = self . _parse_url ( f \"/terminal/ { terminal_id } /event\" ) payload = { \"type\" : type , \"action\" : action , \"data\" : data , } return self . _handle_request ( HTTPMethod . POST , url , payload )","title":"send_event()"},{"location":"reference/terminals/#pypaystack2.api.terminals.Terminal.updated_terminal","text":"Update the details of a Terminal Parameters: Name Type Description Default terminal_id str The ID of the Terminal you want to update required name str Name of the terminal required address str The address of the Terminal required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/terminals.py 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 def updated_terminal ( self , terminal_id : str , name : str , address : str ) -> Response : \"\"\"Update the details of a Terminal Args: terminal_id: The ID of the Terminal you want to update name: Name of the terminal address: The address of the Terminal Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/terminal/ { terminal_id } \" ) payload = { \"name\" : name , \"address\" : address } return self . _handle_request ( HTTPMethod . PUT , url , payload )","title":"updated_terminal()"},{"location":"reference/transactions/","text":"AsyncTransaction Bases: BaseAsyncAPI Provides a wrapper for paystack Transactions API The Transactions API allows you to create and manage payments on your integration. https://paystack.com/docs/api/#transaction Source code in pypaystack2/api/transactions.py 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 class AsyncTransaction ( BaseAsyncAPI ): \"\"\"Provides a wrapper for paystack Transactions API The Transactions API allows you to create and manage payments on your integration. https://paystack.com/docs/api/#transaction \"\"\" async def initialize ( self , amount : int , email : str , currency : Optional [ Currency ] = None , reference : Optional [ str ] = None , callback_url : Optional [ str ] = None , plan : Optional [ str ] = None , invoice_limit : Optional [ int ] = None , metadata : Optional [ dict ] = None , channels : Optional [ list [ Channel ]] = None , split_code : Optional [ str ] = None , subaccount : Optional [ str ] = None , transfer_charge : Optional [ int ] = None , bearer : Optional [ Bearer ] = None , ) -> Response : \"\"\"Initialize a transaction from your backend Args: amount: Amount should be in kobo if currency is ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR`` email: Customer's email address currency: Any value from the ``Currency`` enum. reference: Unique transaction reference. Only ``-, ., =`` and alphanumeric characters allowed. callback_url: Fully qualified url, e.g. ``https://example.com/`` . Use this to override the callback url provided on the dashboard for this transaction plan: If transaction is to create a subscription to a predefined plan, provide plan code here. This would invalidate the value provided in ``amount`` invoice_limit: Number of times to charge customer during subscription to plan metadata: A dictionary of additional info. check out this link for more information. https://paystack.com/docs/payments/metadata channels: A list of ``Channel`` enum values to control what channels you want to make available to the user to make a payment with split_code: The split code of the transaction split. e.g. SPL_98WF13Eb3w subaccount: The code for the subaccount that owns the payment. e.g. ACCT_8f4s1eq7ml6rlzj transfer_charge: An amount used to override the split configuration for a single split payment. If set, the amount specified goes to the main account regardless of the split configuration. bearer: Any value from the ``Bearer`` enum. Who bears Paystack charges? Returns: A named tuple containing the response gotten from paystack's server. Raises: InvalidDataError: When email is not provided. \"\"\" amount = validate_amount ( amount ) if not email : raise InvalidDataError ( \"Customer's Email is required for initialization\" ) url = self . _parse_url ( \"/transaction/initialize\" ) payload = { \"email\" : email , \"amount\" : amount , } optional_params = [ ( \"currency\" , currency ), ( \"reference\" , reference ), ( \"callback_url\" , callback_url ), ( \"plan\" , plan ), ( \"invoice_limit\" , invoice_limit ), ( \"metadata\" , metadata ), ( \"channels\" , channels ), ( \"split_code\" , split_code ), ( \"subaccount\" , subaccount ), ( \"transfer_charge\" , transfer_charge ), ( \"bearer\" , bearer ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) async def verify ( self , reference : str ) -> Response : \"\"\"Confirm the status of a transaction Args: reference: The transaction reference used to intiate the transaction Returns: A named tuple containing the response gotten from paystack's server. \"\"\" reference = str ( reference ) url = self . _parse_url ( f \"/transaction/verify/ { reference } \" ) return await self . _handle_request ( HTTPMethod . GET , url ) async def get_transactions ( self , customer : Optional [ int ] = None , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , status : Optional [ TransactionStatus ] = None , page : Optional [ int ] = None , amount : Optional [ int ] = None , pagination : int = 50 , ) -> Response : \"\"\"Fetch transactions carried out on your integration. Args: customer: Specify an ID for the customer whose transactions you want to retrieve start_date: A timestamp from which to start listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 status: Filter transactions by status. any value from the ``TransactionStatus`` enum page: Specify exactly what page you want to retrieve. If not specified, we use a default value of 1. amount: Optional[int] Filter transactions by amount. Specify the amount (in kobo if currency is ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR``) pagination: Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transaction/?perPage= { pagination } \" ) query_params = [ ( \"page\" , page ), ( \"customer\" , customer ), ( \"status\" , status ), ( \"from\" , start_date ), ( \"to\" , end_date ), ( \"amount\" , amount ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url ) async def get_transaction ( self , id : str ) -> Response : \"\"\"Get details of a transaction carried out on your integration. Args: id: An ID for the transaction to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transaction/ { id } /\" ) return await self . _handle_request ( HTTPMethod . GET , url ) async def charge ( self , amount : int , email : str , auth_code : str , reference : Optional [ str ] = None , currency : Optional [ Currency ] = None , metadata : Optional [ dict ] = None , channels : Optional [ list [ Channel ]] = None , subaccount : Optional [ str ] = None , transaction_charge : Optional [ int ] = None , bearer : Optional [ Bearer ] = None , queue : bool = False , ) -> Response : \"\"\" All authorizations marked as reusable can be charged with this endpoint whenever you need to receive payments. Args: amount: amount to charge. email: Customer's email address auth_code: Valid authorization code to charge reference: Unique transaction reference. Only ``-, ., =`` and alphanumeric characters allowed. currency: Currency in which amount should be charged. Any value from the ``Currency`` enum. metadata: Add a custom_fields attribute which has an array of objects if you would like the fields to be added to your transaction when displayed on the dashboard. Sample: ``{\"custom_fields\":[{\"display_name\":\"Cart ID\", \"variable_name\": \"cart_id\",\"value\": \"8393\"}]}`` channels: A list of ``Channel`` enum values to control what channels you want to make available to the user to make a payment with subaccount: The code for the subaccount that owns the payment. e.g. ACCT_8f4s1eq7ml6rlzj transaction_charge: A flat fee to charge the subaccount for this transaction (in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR). This overrides the split percentage set when the subaccount was created. Ideally, you will need to use this if you are splitting in flat rates (since subaccount creation only allows for percentage split). e.g., 7000 for a 70 naira bearer: Who bears Paystack charges? any value from the ``Beaer`` enum queue: If you are making a scheduled charge call, it is a good idea to queue them so the processing system does not get overloaded causing transaction processing errors. Set ``queue=True`` to take advantage of our queued charging. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" amount = validate_amount ( amount ) if not email : raise InvalidDataError ( \"Customer's Email is required to charge\" ) if not auth_code : raise InvalidDataError ( \"Customer's Auth code is required to charge\" ) url = self . _parse_url ( \"/transaction/charge_authorization\" ) payload = { \"authorization_code\" : auth_code , \"email\" : email , \"amount\" : amount , } optional_params = [ ( \"reference\" , reference ), ( \"currency\" , currency ), ( \"metadata\" , metadata ), ( \"channels\" , channels ), ( \"subaccount\" , subaccount ), ( \"transaction_charge\" , transaction_charge ), ( \"bearer\" , bearer ), ( \"queue\" , queue ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) async def get_timeline ( self , id_or_ref : str ) -> Response : \"\"\"View the timeline of a transaction Args: id_or_ref: The ID or the reference of the transaction Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transaction/timeline/ { id_or_ref } \" ) return await self . _handle_request ( HTTPMethod . GET , url ) async def totals ( self , page : Optional [ int ] = None , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , pagination : int = 50 , ) -> Response : \"\"\"Total amount received on your account Args: page: Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1. start_date: A timestamp from which to start listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 pagination: Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transaction/totals/?perPage= { pagination } \" ) query_params = [ ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url ) async def export ( self , page : Optional [ int ] = None , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , customer : Optional [ int ] = None , status : Optional [ TransactionStatus ] = None , currency : Optional [ Currency ] = None , amount : Optional [ int ] = None , settled : Optional [ bool ] = None , settlement : Optional [ int ] = None , payment_page : Optional [ int ] = None , pagination : int = 50 , ) -> Response : \"\"\"Fetch transactions carried out on your integration. Args: page: Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1. start_date: A timestamp from which to start listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 customer: Specify an ID for the customer whose transactions you want to retrieve status: Filter transactions by status. Any value from the ``TransactionStatus`` enum currency: Specify the transaction currency to export. Any value from the ``Currency`` enum amount: Filter transactions by amount. Specify the amount, in kobo if currency is ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR`` settled: Set to ``True`` to export only settled transactions. ``False`` for pending transactions. Leave undefined to export all transaction settlement: An ID for the settlement whose transactions we should export payment_page: Optional[int] Specify a payment page's id to export only transactions conducted on said page pagination: int Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" if amount : amount = validate_amount ( amount ) url = self . _parse_url ( f \"/transaction/export/?perPage= { pagination } \" ) query_params = [ ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ( \"customer\" , customer ), ( \"status\" , status ), ( \"currency\" , currency ), ( \"settled\" , settled ), ( \"settlement\" , settlement ), ( \"payment_page\" , payment_page ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url ) async def partial_debit ( self , auth_code : str , currency : Currency , amount : int , email : str , reference : Optional [ str ] = None , at_least : Optional [ int ] = None , ) -> Response : \"\"\"Retrieve part of a payment from a customer Args: auth_code: Authorization Code currency: Specify the currency you want to debit. Any value from the ``Currency`` enum. amount: Amount should be in kobo if currency is ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR`` email: Customer's email address (attached to the authorization code) reference: Unique transaction reference. Only `-, ., =` and alphanumeric characters allowed. at_least: Minimum amount to charge Returns: A named tuple containing the response gotten from paystack's server. Raises: InvalidDataError: When Customer's email is not provided. When Customer's auth code is not provided. \"\"\" amount = validate_amount ( amount ) if at_least : at_least = validate_amount ( at_least ) if not email : raise InvalidDataError ( \"Customer's Email is required to charge\" ) if not auth_code : raise InvalidDataError ( \"Customer's Auth code is required to charge\" ) url = self . _parse_url ( \"/transaction/partial_debit\" ) payload = { \"authorization_code\" : auth_code , \"currency\" : currency , \"amount\" : amount , \"email\" : email , } optional_params = [( \"reference\" , reference ), ( \"at_least\" , at_least )] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) charge ( amount , email , auth_code , reference = None , currency = None , metadata = None , channels = None , subaccount = None , transaction_charge = None , bearer = None , queue = False ) async All authorizations marked as reusable can be charged with this endpoint whenever you need to receive payments. Parameters: Name Type Description Default amount int amount to charge. required email str Customer's email address required auth_code str Valid authorization code to charge required reference Optional [ str ] Unique transaction reference. Only -, ., = and alphanumeric characters allowed. None currency Optional [ Currency ] Currency in which amount should be charged. Any value from the Currency enum. None metadata Optional [ dict ] Add a custom_fields attribute which has an array of objects if you would like the fields to be added to your transaction when displayed on the dashboard. Sample: {\"custom_fields\":[{\"display_name\":\"Cart ID\", \"variable_name\": \"cart_id\",\"value\": \"8393\"}]} None channels Optional [ list [ Channel ]] A list of Channel enum values to control what channels you want to make available to the user to make a payment with None subaccount Optional [ str ] The code for the subaccount that owns the payment. e.g. ACCT_8f4s1eq7ml6rlzj None transaction_charge Optional [ int ] A flat fee to charge the subaccount for this transaction (in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR). This overrides the split percentage set when the subaccount was created. Ideally, you will need to use this if you are splitting in flat rates (since subaccount creation only allows for percentage split). e.g., 7000 for a 70 naira None bearer Optional [ Bearer ] Who bears Paystack charges? any value from the Beaer enum None queue bool If you are making a scheduled charge call, it is a good idea to queue them so the processing system does not get overloaded causing transaction processing errors. Set queue=True to take advantage of our queued charging. False Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transactions.py 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 async def charge ( self , amount : int , email : str , auth_code : str , reference : Optional [ str ] = None , currency : Optional [ Currency ] = None , metadata : Optional [ dict ] = None , channels : Optional [ list [ Channel ]] = None , subaccount : Optional [ str ] = None , transaction_charge : Optional [ int ] = None , bearer : Optional [ Bearer ] = None , queue : bool = False , ) -> Response : \"\"\" All authorizations marked as reusable can be charged with this endpoint whenever you need to receive payments. Args: amount: amount to charge. email: Customer's email address auth_code: Valid authorization code to charge reference: Unique transaction reference. Only ``-, ., =`` and alphanumeric characters allowed. currency: Currency in which amount should be charged. Any value from the ``Currency`` enum. metadata: Add a custom_fields attribute which has an array of objects if you would like the fields to be added to your transaction when displayed on the dashboard. Sample: ``{\"custom_fields\":[{\"display_name\":\"Cart ID\", \"variable_name\": \"cart_id\",\"value\": \"8393\"}]}`` channels: A list of ``Channel`` enum values to control what channels you want to make available to the user to make a payment with subaccount: The code for the subaccount that owns the payment. e.g. ACCT_8f4s1eq7ml6rlzj transaction_charge: A flat fee to charge the subaccount for this transaction (in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR). This overrides the split percentage set when the subaccount was created. Ideally, you will need to use this if you are splitting in flat rates (since subaccount creation only allows for percentage split). e.g., 7000 for a 70 naira bearer: Who bears Paystack charges? any value from the ``Beaer`` enum queue: If you are making a scheduled charge call, it is a good idea to queue them so the processing system does not get overloaded causing transaction processing errors. Set ``queue=True`` to take advantage of our queued charging. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" amount = validate_amount ( amount ) if not email : raise InvalidDataError ( \"Customer's Email is required to charge\" ) if not auth_code : raise InvalidDataError ( \"Customer's Auth code is required to charge\" ) url = self . _parse_url ( \"/transaction/charge_authorization\" ) payload = { \"authorization_code\" : auth_code , \"email\" : email , \"amount\" : amount , } optional_params = [ ( \"reference\" , reference ), ( \"currency\" , currency ), ( \"metadata\" , metadata ), ( \"channels\" , channels ), ( \"subaccount\" , subaccount ), ( \"transaction_charge\" , transaction_charge ), ( \"bearer\" , bearer ), ( \"queue\" , queue ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) export ( page = None , start_date = None , end_date = None , customer = None , status = None , currency = None , amount = None , settled = None , settlement = None , payment_page = None , pagination = 50 ) async Fetch transactions carried out on your integration. Parameters: Name Type Description Default page Optional [ int ] Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1. None start_date Optional [ str ] A timestamp from which to start listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None end_date Optional [ str ] A timestamp at which to stop listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None customer Optional [ int ] Specify an ID for the customer whose transactions you want to retrieve None status Optional [ TransactionStatus ] Filter transactions by status. Any value from the TransactionStatus enum None currency Optional [ Currency ] Specify the transaction currency to export. Any value from the Currency enum None amount Optional [ int ] Filter transactions by amount. Specify the amount, in kobo if currency is Currency.NGN , pesewas, if currency is Currency.GHS , and cents, if currency is Currency.ZAR None settled Optional [ bool ] Set to True to export only settled transactions. False for pending transactions. Leave undefined to export all transaction None settlement Optional [ int ] An ID for the settlement whose transactions we should export None payment_page Optional [ int ] Optional[int] Specify a payment page's id to export only transactions conducted on said page None pagination int int Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50. 50 Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transactions.py 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 async def export ( self , page : Optional [ int ] = None , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , customer : Optional [ int ] = None , status : Optional [ TransactionStatus ] = None , currency : Optional [ Currency ] = None , amount : Optional [ int ] = None , settled : Optional [ bool ] = None , settlement : Optional [ int ] = None , payment_page : Optional [ int ] = None , pagination : int = 50 , ) -> Response : \"\"\"Fetch transactions carried out on your integration. Args: page: Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1. start_date: A timestamp from which to start listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 customer: Specify an ID for the customer whose transactions you want to retrieve status: Filter transactions by status. Any value from the ``TransactionStatus`` enum currency: Specify the transaction currency to export. Any value from the ``Currency`` enum amount: Filter transactions by amount. Specify the amount, in kobo if currency is ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR`` settled: Set to ``True`` to export only settled transactions. ``False`` for pending transactions. Leave undefined to export all transaction settlement: An ID for the settlement whose transactions we should export payment_page: Optional[int] Specify a payment page's id to export only transactions conducted on said page pagination: int Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" if amount : amount = validate_amount ( amount ) url = self . _parse_url ( f \"/transaction/export/?perPage= { pagination } \" ) query_params = [ ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ( \"customer\" , customer ), ( \"status\" , status ), ( \"currency\" , currency ), ( \"settled\" , settled ), ( \"settlement\" , settlement ), ( \"payment_page\" , payment_page ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url ) get_timeline ( id_or_ref ) async View the timeline of a transaction Parameters: Name Type Description Default id_or_ref str The ID or the reference of the transaction required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transactions.py 621 622 623 624 625 626 627 628 629 630 631 632 async def get_timeline ( self , id_or_ref : str ) -> Response : \"\"\"View the timeline of a transaction Args: id_or_ref: The ID or the reference of the transaction Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transaction/timeline/ { id_or_ref } \" ) return await self . _handle_request ( HTTPMethod . GET , url ) get_transaction ( id ) async Get details of a transaction carried out on your integration. Parameters: Name Type Description Default id str An ID for the transaction to fetch required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transactions.py 532 533 534 535 536 537 538 539 540 541 542 543 async def get_transaction ( self , id : str ) -> Response : \"\"\"Get details of a transaction carried out on your integration. Args: id: An ID for the transaction to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transaction/ { id } /\" ) return await self . _handle_request ( HTTPMethod . GET , url ) get_transactions ( customer = None , start_date = None , end_date = None , status = None , page = None , amount = None , pagination = 50 ) async Fetch transactions carried out on your integration. Parameters: Name Type Description Default customer Optional [ int ] Specify an ID for the customer whose transactions you want to retrieve None start_date Optional [ str ] A timestamp from which to start listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None end_date Optional [ str ] A timestamp at which to stop listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None status Optional [ TransactionStatus ] Filter transactions by status. any value from the TransactionStatus enum None page Optional [ int ] Specify exactly what page you want to retrieve. If not specified, we use a default value of 1. None amount Optional [ int ] Optional[int] Filter transactions by amount. Specify the amount (in kobo if currency is Currency.NGN , pesewas, if currency is Currency.GHS , and cents, if currency is Currency.ZAR ) None pagination int Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50. 50 Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transactions.py 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 async def get_transactions ( self , customer : Optional [ int ] = None , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , status : Optional [ TransactionStatus ] = None , page : Optional [ int ] = None , amount : Optional [ int ] = None , pagination : int = 50 , ) -> Response : \"\"\"Fetch transactions carried out on your integration. Args: customer: Specify an ID for the customer whose transactions you want to retrieve start_date: A timestamp from which to start listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 status: Filter transactions by status. any value from the ``TransactionStatus`` enum page: Specify exactly what page you want to retrieve. If not specified, we use a default value of 1. amount: Optional[int] Filter transactions by amount. Specify the amount (in kobo if currency is ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR``) pagination: Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transaction/?perPage= { pagination } \" ) query_params = [ ( \"page\" , page ), ( \"customer\" , customer ), ( \"status\" , status ), ( \"from\" , start_date ), ( \"to\" , end_date ), ( \"amount\" , amount ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url ) initialize ( amount , email , currency = None , reference = None , callback_url = None , plan = None , invoice_limit = None , metadata = None , channels = None , split_code = None , subaccount = None , transfer_charge = None , bearer = None ) async Initialize a transaction from your backend Parameters: Name Type Description Default amount int Amount should be in kobo if currency is Currency.NGN , pesewas, if currency is Currency.GHS , and cents, if currency is Currency.ZAR required email str Customer's email address required currency Optional [ Currency ] Any value from the Currency enum. None reference Optional [ str ] Unique transaction reference. Only -, ., = and alphanumeric characters allowed. None callback_url Optional [ str ] Fully qualified url, e.g. https://example.com/ . Use this to override the callback url provided on the dashboard for this transaction None plan Optional [ str ] If transaction is to create a subscription to a predefined plan, provide plan code here. This would invalidate the value provided in amount None invoice_limit Optional [ int ] Number of times to charge customer during subscription to plan None metadata Optional [ dict ] A dictionary of additional info. check out this link for more information. https://paystack.com/docs/payments/metadata None channels Optional [ list [ Channel ]] A list of Channel enum values to control what channels you want to make available to the user to make a payment with None split_code Optional [ str ] The split code of the transaction split. e.g. SPL_98WF13Eb3w None subaccount Optional [ str ] The code for the subaccount that owns the payment. e.g. ACCT_8f4s1eq7ml6rlzj None transfer_charge Optional [ int ] An amount used to override the split configuration for a single split payment. If set, the amount specified goes to the main account regardless of the split configuration. None bearer Optional [ Bearer ] Any value from the Bearer enum. Who bears Paystack charges? None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Raises: Type Description InvalidDataError When email is not provided. Source code in pypaystack2/api/transactions.py 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 async def initialize ( self , amount : int , email : str , currency : Optional [ Currency ] = None , reference : Optional [ str ] = None , callback_url : Optional [ str ] = None , plan : Optional [ str ] = None , invoice_limit : Optional [ int ] = None , metadata : Optional [ dict ] = None , channels : Optional [ list [ Channel ]] = None , split_code : Optional [ str ] = None , subaccount : Optional [ str ] = None , transfer_charge : Optional [ int ] = None , bearer : Optional [ Bearer ] = None , ) -> Response : \"\"\"Initialize a transaction from your backend Args: amount: Amount should be in kobo if currency is ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR`` email: Customer's email address currency: Any value from the ``Currency`` enum. reference: Unique transaction reference. Only ``-, ., =`` and alphanumeric characters allowed. callback_url: Fully qualified url, e.g. ``https://example.com/`` . Use this to override the callback url provided on the dashboard for this transaction plan: If transaction is to create a subscription to a predefined plan, provide plan code here. This would invalidate the value provided in ``amount`` invoice_limit: Number of times to charge customer during subscription to plan metadata: A dictionary of additional info. check out this link for more information. https://paystack.com/docs/payments/metadata channels: A list of ``Channel`` enum values to control what channels you want to make available to the user to make a payment with split_code: The split code of the transaction split. e.g. SPL_98WF13Eb3w subaccount: The code for the subaccount that owns the payment. e.g. ACCT_8f4s1eq7ml6rlzj transfer_charge: An amount used to override the split configuration for a single split payment. If set, the amount specified goes to the main account regardless of the split configuration. bearer: Any value from the ``Bearer`` enum. Who bears Paystack charges? Returns: A named tuple containing the response gotten from paystack's server. Raises: InvalidDataError: When email is not provided. \"\"\" amount = validate_amount ( amount ) if not email : raise InvalidDataError ( \"Customer's Email is required for initialization\" ) url = self . _parse_url ( \"/transaction/initialize\" ) payload = { \"email\" : email , \"amount\" : amount , } optional_params = [ ( \"currency\" , currency ), ( \"reference\" , reference ), ( \"callback_url\" , callback_url ), ( \"plan\" , plan ), ( \"invoice_limit\" , invoice_limit ), ( \"metadata\" , metadata ), ( \"channels\" , channels ), ( \"split_code\" , split_code ), ( \"subaccount\" , subaccount ), ( \"transfer_charge\" , transfer_charge ), ( \"bearer\" , bearer ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) partial_debit ( auth_code , currency , amount , email , reference = None , at_least = None ) async Retrieve part of a payment from a customer Parameters: Name Type Description Default auth_code str Authorization Code required currency Currency Specify the currency you want to debit. Any value from the Currency enum. required amount int Amount should be in kobo if currency is Currency.NGN , pesewas, if currency is Currency.GHS , and cents, if currency is Currency.ZAR required email str Customer's email address (attached to the authorization code) required reference Optional [ str ] Unique transaction reference. Only -, ., = and alphanumeric characters allowed. None at_least Optional [ int ] Minimum amount to charge None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Raises: Type Description InvalidDataError When Customer's email is not provided. When Customer's auth code is not provided. Source code in pypaystack2/api/transactions.py 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 async def partial_debit ( self , auth_code : str , currency : Currency , amount : int , email : str , reference : Optional [ str ] = None , at_least : Optional [ int ] = None , ) -> Response : \"\"\"Retrieve part of a payment from a customer Args: auth_code: Authorization Code currency: Specify the currency you want to debit. Any value from the ``Currency`` enum. amount: Amount should be in kobo if currency is ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR`` email: Customer's email address (attached to the authorization code) reference: Unique transaction reference. Only `-, ., =` and alphanumeric characters allowed. at_least: Minimum amount to charge Returns: A named tuple containing the response gotten from paystack's server. Raises: InvalidDataError: When Customer's email is not provided. When Customer's auth code is not provided. \"\"\" amount = validate_amount ( amount ) if at_least : at_least = validate_amount ( at_least ) if not email : raise InvalidDataError ( \"Customer's Email is required to charge\" ) if not auth_code : raise InvalidDataError ( \"Customer's Auth code is required to charge\" ) url = self . _parse_url ( \"/transaction/partial_debit\" ) payload = { \"authorization_code\" : auth_code , \"currency\" : currency , \"amount\" : amount , \"email\" : email , } optional_params = [( \"reference\" , reference ), ( \"at_least\" , at_least )] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) totals ( page = None , start_date = None , end_date = None , pagination = 50 ) async Total amount received on your account Parameters: Name Type Description Default page Optional [ int ] Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1. None start_date Optional [ str ] A timestamp from which to start listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None end_date Optional [ str ] A timestamp at which to stop listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None pagination int Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50. 50 Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transactions.py 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 async def totals ( self , page : Optional [ int ] = None , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , pagination : int = 50 , ) -> Response : \"\"\"Total amount received on your account Args: page: Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1. start_date: A timestamp from which to start listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 pagination: Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transaction/totals/?perPage= { pagination } \" ) query_params = [ ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url ) verify ( reference ) async Confirm the status of a transaction Parameters: Name Type Description Default reference str The transaction reference used to intiate the transaction required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transactions.py 475 476 477 478 479 480 481 482 483 484 485 486 487 async def verify ( self , reference : str ) -> Response : \"\"\"Confirm the status of a transaction Args: reference: The transaction reference used to intiate the transaction Returns: A named tuple containing the response gotten from paystack's server. \"\"\" reference = str ( reference ) url = self . _parse_url ( f \"/transaction/verify/ { reference } \" ) return await self . _handle_request ( HTTPMethod . GET , url ) Transaction Bases: BaseAPI Provides a wrapper for paystack Transactions API The Transactions API allows you to create and manage payments on your integration. https://paystack.com/docs/api/#transaction Source code in pypaystack2/api/transactions.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 class Transaction ( BaseAPI ): \"\"\"Provides a wrapper for paystack Transactions API The Transactions API allows you to create and manage payments on your integration. https://paystack.com/docs/api/#transaction \"\"\" def initialize ( self , amount : int , email : str , currency : Optional [ Currency ] = None , reference : Optional [ str ] = None , callback_url : Optional [ str ] = None , plan : Optional [ str ] = None , invoice_limit : Optional [ int ] = None , metadata : Optional [ dict ] = None , channels : Optional [ list [ Channel ]] = None , split_code : Optional [ str ] = None , subaccount : Optional [ str ] = None , transfer_charge : Optional [ int ] = None , bearer : Optional [ Bearer ] = None , ) -> Response : \"\"\"Initialize a transaction from your backend Args: amount: Amount should be in kobo if currency is ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR`` email: Customer's email address currency: Any value from the ``Currency`` enum. reference: Unique transaction reference. Only ``-, ., =`` and alphanumeric characters allowed. callback_url: Fully qualified url, e.g. ``https://example.com/`` . Use this to override the callback url provided on the dashboard for this transaction plan: If transaction is to create a subscription to a predefined plan, provide plan code here. This would invalidate the value provided in ``amount`` invoice_limit: Number of times to charge customer during subscription to plan metadata: A dictionary of additional info. check out this link for more information. https://paystack.com/docs/payments/metadata channels: A list of ``Channel`` enum values to control what channels you want to make available to the user to make a payment with split_code: The split code of the transaction split. e.g. SPL_98WF13Eb3w subaccount: The code for the subaccount that owns the payment. e.g. ACCT_8f4s1eq7ml6rlzj transfer_charge: An amount used to override the split configuration for a single split payment. If set, the amount specified goes to the main account regardless of the split configuration. bearer: Any value from the ``Bearer`` enum. Who bears Paystack charges? Returns: A named tuple containing the response gotten from paystack's server. Raises: InvalidDataError: When email is not provided. \"\"\" amount = validate_amount ( amount ) if not email : raise InvalidDataError ( \"Customer's Email is required for initialization\" ) url = self . _parse_url ( \"/transaction/initialize\" ) payload = { \"email\" : email , \"amount\" : amount , } optional_params = [ ( \"currency\" , currency ), ( \"reference\" , reference ), ( \"callback_url\" , callback_url ), ( \"plan\" , plan ), ( \"invoice_limit\" , invoice_limit ), ( \"metadata\" , metadata ), ( \"channels\" , channels ), ( \"split_code\" , split_code ), ( \"subaccount\" , subaccount ), ( \"transfer_charge\" , transfer_charge ), ( \"bearer\" , bearer ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . POST , url , payload ) def verify ( self , reference : str ) -> Response : \"\"\"Confirm the status of a transaction Args: reference: The transaction reference used to intiate the transaction Returns: A named tuple containing the response gotten from paystack's server. \"\"\" reference = str ( reference ) url = self . _parse_url ( f \"/transaction/verify/ { reference } \" ) return self . _handle_request ( HTTPMethod . GET , url ) def get_transactions ( self , customer : Optional [ int ] = None , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , status : Optional [ TransactionStatus ] = None , page : Optional [ int ] = None , amount : Optional [ int ] = None , pagination : int = 50 , ) -> Response : \"\"\"Fetch transactions carried out on your integration. Args: customer: Specify an ID for the customer whose transactions you want to retrieve start_date: A timestamp from which to start listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 status: Filter transactions by status. any value from the ``TransactionStatus`` enum page: Specify exactly what page you want to retrieve. If not specified, we use a default value of 1. amount: Optional[int] Filter transactions by amount. Specify the amount (in kobo if currency is ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR``) pagination: Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transaction/?perPage= { pagination } \" ) query_params = [ ( \"page\" , page ), ( \"customer\" , customer ), ( \"status\" , status ), ( \"from\" , start_date ), ( \"to\" , end_date ), ( \"amount\" , amount ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url ) def get_transaction ( self , id : str ) -> Response : \"\"\"Get details of a transaction carried out on your integration. Args: id: An ID for the transaction to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transaction/ { id } /\" ) return self . _handle_request ( HTTPMethod . GET , url ) def charge ( self , amount : int , email : str , auth_code : str , reference : Optional [ str ] = None , currency : Optional [ Currency ] = None , metadata : Optional [ dict ] = None , channels : Optional [ list [ Channel ]] = None , subaccount : Optional [ str ] = None , transaction_charge : Optional [ int ] = None , bearer : Optional [ Bearer ] = None , queue : bool = False , ) -> Response : \"\"\" All authorizations marked as reusable can be charged with this endpoint whenever you need to receive payments. Args: amount: amount to charge. email: Customer's email address auth_code: Valid authorization code to charge reference: Unique transaction reference. Only ``-, ., =`` and alphanumeric characters allowed. currency: Currency in which amount should be charged. Any value from the ``Currency`` enum. metadata: Add a custom_fields attribute which has an array of objects if you would like the fields to be added to your transaction when displayed on the dashboard. Sample: ``{\"custom_fields\":[{\"display_name\":\"Cart ID\", \"variable_name\": \"cart_id\",\"value\": \"8393\"}]}`` channels: A list of ``Channel`` enum values to control what channels you want to make available to the user to make a payment with subaccount: The code for the subaccount that owns the payment. e.g. ACCT_8f4s1eq7ml6rlzj transaction_charge: A flat fee to charge the subaccount for this transaction (in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR). This overrides the split percentage set when the subaccount was created. Ideally, you will need to use this if you are splitting in flat rates (since subaccount creation only allows for percentage split). e.g., 7000 for a 70 naira bearer: Who bears Paystack charges? any value from the ``Beaer`` enum queue: If you are making a scheduled charge call, it is a good idea to queue them so the processing system does not get overloaded causing transaction processing errors. Set ``queue=True`` to take advantage of our queued charging. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" amount = validate_amount ( amount ) if not email : raise InvalidDataError ( \"Customer's Email is required to charge\" ) if not auth_code : raise InvalidDataError ( \"Customer's Auth code is required to charge\" ) url = self . _parse_url ( \"/transaction/charge_authorization\" ) payload = { \"authorization_code\" : auth_code , \"email\" : email , \"amount\" : amount , } optional_params = [ ( \"reference\" , reference ), ( \"currency\" , currency ), ( \"metadata\" , metadata ), ( \"channels\" , channels ), ( \"subaccount\" , subaccount ), ( \"transaction_charge\" , transaction_charge ), ( \"bearer\" , bearer ), ( \"queue\" , queue ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . POST , url , payload ) def get_timeline ( self , id_or_ref : str ) -> Response : \"\"\"View the timeline of a transaction Args: id_or_ref: The ID or the reference of the transaction Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transaction/timeline/ { id_or_ref } \" ) return self . _handle_request ( HTTPMethod . GET , url ) def totals ( self , page : Optional [ int ] = None , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , pagination : int = 50 , ) -> Response : \"\"\"Total amount received on your account Args: page: Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1. start_date: A timestamp from which to start listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 pagination: Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transaction/totals/?perPage= { pagination } \" ) query_params = [ ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url ) def export ( self , page : Optional [ int ] = None , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , customer : Optional [ int ] = None , status : Optional [ TransactionStatus ] = None , currency : Optional [ Currency ] = None , amount : Optional [ int ] = None , settled : Optional [ bool ] = None , settlement : Optional [ int ] = None , payment_page : Optional [ int ] = None , pagination : int = 50 , ) -> Response : \"\"\"Fetch transactions carried out on your integration. Args: page: Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1. start_date: A timestamp from which to start listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 customer: Specify an ID for the customer whose transactions you want to retrieve status: Filter transactions by status. Any value from the ``TransactionStatus`` enum currency: Specify the transaction currency to export. Any value from the ``Currency`` enum amount: Filter transactions by amount. Specify the amount, in kobo if currency is ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR`` settled: Set to ``True`` to export only settled transactions. ``False`` for pending transactions. Leave undefined to export all transaction settlement: An ID for the settlement whose transactions we should export payment_page: Optional[int] Specify a payment page's id to export only transactions conducted on said page pagination: int Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" if amount : amount = validate_amount ( amount ) url = self . _parse_url ( f \"/transaction/export/?perPage= { pagination } \" ) query_params = [ ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ( \"customer\" , customer ), ( \"status\" , status ), ( \"currency\" , currency ), ( \"settled\" , settled ), ( \"settlement\" , settlement ), ( \"payment_page\" , payment_page ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url ) def partial_debit ( self , auth_code : str , currency : Currency , amount : int , email : str , reference : Optional [ str ] = None , at_least : Optional [ int ] = None , ) -> Response : \"\"\"Retrieve part of a payment from a customer Args: auth_code: Authorization Code currency: Specify the currency you want to debit. Any value from the ``Currency`` enum. amount: Amount should be in kobo if currency is ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR`` email: Customer's email address (attached to the authorization code) reference: Unique transaction reference. Only `-, ., =` and alphanumeric characters allowed. at_least: Minimum amount to charge Returns: A named tuple containing the response gotten from paystack's server. Raises: InvalidDataError: When Customer's email is not provided. When Customer's auth code is not provided. \"\"\" amount = validate_amount ( amount ) if at_least : at_least = validate_amount ( at_least ) if not email : raise InvalidDataError ( \"Customer's Email is required to charge\" ) if not auth_code : raise InvalidDataError ( \"Customer's Auth code is required to charge\" ) url = self . _parse_url ( \"/transaction/partial_debit\" ) payload = { \"authorization_code\" : auth_code , \"currency\" : currency , \"amount\" : amount , \"email\" : email , } optional_params = [( \"reference\" , reference ), ( \"at_least\" , at_least )] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . POST , url , payload ) charge ( amount , email , auth_code , reference = None , currency = None , metadata = None , channels = None , subaccount = None , transaction_charge = None , bearer = None , queue = False ) All authorizations marked as reusable can be charged with this endpoint whenever you need to receive payments. Parameters: Name Type Description Default amount int amount to charge. required email str Customer's email address required auth_code str Valid authorization code to charge required reference Optional [ str ] Unique transaction reference. Only -, ., = and alphanumeric characters allowed. None currency Optional [ Currency ] Currency in which amount should be charged. Any value from the Currency enum. None metadata Optional [ dict ] Add a custom_fields attribute which has an array of objects if you would like the fields to be added to your transaction when displayed on the dashboard. Sample: {\"custom_fields\":[{\"display_name\":\"Cart ID\", \"variable_name\": \"cart_id\",\"value\": \"8393\"}]} None channels Optional [ list [ Channel ]] A list of Channel enum values to control what channels you want to make available to the user to make a payment with None subaccount Optional [ str ] The code for the subaccount that owns the payment. e.g. ACCT_8f4s1eq7ml6rlzj None transaction_charge Optional [ int ] A flat fee to charge the subaccount for this transaction (in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR). This overrides the split percentage set when the subaccount was created. Ideally, you will need to use this if you are splitting in flat rates (since subaccount creation only allows for percentage split). e.g., 7000 for a 70 naira None bearer Optional [ Bearer ] Who bears Paystack charges? any value from the Beaer enum None queue bool If you are making a scheduled charge call, it is a good idea to queue them so the processing system does not get overloaded causing transaction processing errors. Set queue=True to take advantage of our queued charging. False Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transactions.py 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 def charge ( self , amount : int , email : str , auth_code : str , reference : Optional [ str ] = None , currency : Optional [ Currency ] = None , metadata : Optional [ dict ] = None , channels : Optional [ list [ Channel ]] = None , subaccount : Optional [ str ] = None , transaction_charge : Optional [ int ] = None , bearer : Optional [ Bearer ] = None , queue : bool = False , ) -> Response : \"\"\" All authorizations marked as reusable can be charged with this endpoint whenever you need to receive payments. Args: amount: amount to charge. email: Customer's email address auth_code: Valid authorization code to charge reference: Unique transaction reference. Only ``-, ., =`` and alphanumeric characters allowed. currency: Currency in which amount should be charged. Any value from the ``Currency`` enum. metadata: Add a custom_fields attribute which has an array of objects if you would like the fields to be added to your transaction when displayed on the dashboard. Sample: ``{\"custom_fields\":[{\"display_name\":\"Cart ID\", \"variable_name\": \"cart_id\",\"value\": \"8393\"}]}`` channels: A list of ``Channel`` enum values to control what channels you want to make available to the user to make a payment with subaccount: The code for the subaccount that owns the payment. e.g. ACCT_8f4s1eq7ml6rlzj transaction_charge: A flat fee to charge the subaccount for this transaction (in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR). This overrides the split percentage set when the subaccount was created. Ideally, you will need to use this if you are splitting in flat rates (since subaccount creation only allows for percentage split). e.g., 7000 for a 70 naira bearer: Who bears Paystack charges? any value from the ``Beaer`` enum queue: If you are making a scheduled charge call, it is a good idea to queue them so the processing system does not get overloaded causing transaction processing errors. Set ``queue=True`` to take advantage of our queued charging. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" amount = validate_amount ( amount ) if not email : raise InvalidDataError ( \"Customer's Email is required to charge\" ) if not auth_code : raise InvalidDataError ( \"Customer's Auth code is required to charge\" ) url = self . _parse_url ( \"/transaction/charge_authorization\" ) payload = { \"authorization_code\" : auth_code , \"email\" : email , \"amount\" : amount , } optional_params = [ ( \"reference\" , reference ), ( \"currency\" , currency ), ( \"metadata\" , metadata ), ( \"channels\" , channels ), ( \"subaccount\" , subaccount ), ( \"transaction_charge\" , transaction_charge ), ( \"bearer\" , bearer ), ( \"queue\" , queue ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . POST , url , payload ) export ( page = None , start_date = None , end_date = None , customer = None , status = None , currency = None , amount = None , settled = None , settlement = None , payment_page = None , pagination = 50 ) Fetch transactions carried out on your integration. Parameters: Name Type Description Default page Optional [ int ] Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1. None start_date Optional [ str ] A timestamp from which to start listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None end_date Optional [ str ] A timestamp at which to stop listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None customer Optional [ int ] Specify an ID for the customer whose transactions you want to retrieve None status Optional [ TransactionStatus ] Filter transactions by status. Any value from the TransactionStatus enum None currency Optional [ Currency ] Specify the transaction currency to export. Any value from the Currency enum None amount Optional [ int ] Filter transactions by amount. Specify the amount, in kobo if currency is Currency.NGN , pesewas, if currency is Currency.GHS , and cents, if currency is Currency.ZAR None settled Optional [ bool ] Set to True to export only settled transactions. False for pending transactions. Leave undefined to export all transaction None settlement Optional [ int ] An ID for the settlement whose transactions we should export None payment_page Optional [ int ] Optional[int] Specify a payment page's id to export only transactions conducted on said page None pagination int int Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50. 50 Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transactions.py 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 def export ( self , page : Optional [ int ] = None , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , customer : Optional [ int ] = None , status : Optional [ TransactionStatus ] = None , currency : Optional [ Currency ] = None , amount : Optional [ int ] = None , settled : Optional [ bool ] = None , settlement : Optional [ int ] = None , payment_page : Optional [ int ] = None , pagination : int = 50 , ) -> Response : \"\"\"Fetch transactions carried out on your integration. Args: page: Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1. start_date: A timestamp from which to start listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 customer: Specify an ID for the customer whose transactions you want to retrieve status: Filter transactions by status. Any value from the ``TransactionStatus`` enum currency: Specify the transaction currency to export. Any value from the ``Currency`` enum amount: Filter transactions by amount. Specify the amount, in kobo if currency is ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR`` settled: Set to ``True`` to export only settled transactions. ``False`` for pending transactions. Leave undefined to export all transaction settlement: An ID for the settlement whose transactions we should export payment_page: Optional[int] Specify a payment page's id to export only transactions conducted on said page pagination: int Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" if amount : amount = validate_amount ( amount ) url = self . _parse_url ( f \"/transaction/export/?perPage= { pagination } \" ) query_params = [ ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ( \"customer\" , customer ), ( \"status\" , status ), ( \"currency\" , currency ), ( \"settled\" , settled ), ( \"settlement\" , settlement ), ( \"payment_page\" , payment_page ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url ) get_timeline ( id_or_ref ) View the timeline of a transaction Parameters: Name Type Description Default id_or_ref str The ID or the reference of the transaction required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transactions.py 244 245 246 247 248 249 250 251 252 253 254 255 def get_timeline ( self , id_or_ref : str ) -> Response : \"\"\"View the timeline of a transaction Args: id_or_ref: The ID or the reference of the transaction Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transaction/timeline/ { id_or_ref } \" ) return self . _handle_request ( HTTPMethod . GET , url ) get_transaction ( id ) Get details of a transaction carried out on your integration. Parameters: Name Type Description Default id str An ID for the transaction to fetch required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transactions.py 155 156 157 158 159 160 161 162 163 164 165 166 def get_transaction ( self , id : str ) -> Response : \"\"\"Get details of a transaction carried out on your integration. Args: id: An ID for the transaction to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transaction/ { id } /\" ) return self . _handle_request ( HTTPMethod . GET , url ) get_transactions ( customer = None , start_date = None , end_date = None , status = None , page = None , amount = None , pagination = 50 ) Fetch transactions carried out on your integration. Parameters: Name Type Description Default customer Optional [ int ] Specify an ID for the customer whose transactions you want to retrieve None start_date Optional [ str ] A timestamp from which to start listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None end_date Optional [ str ] A timestamp at which to stop listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None status Optional [ TransactionStatus ] Filter transactions by status. any value from the TransactionStatus enum None page Optional [ int ] Specify exactly what page you want to retrieve. If not specified, we use a default value of 1. None amount Optional [ int ] Optional[int] Filter transactions by amount. Specify the amount (in kobo if currency is Currency.NGN , pesewas, if currency is Currency.GHS , and cents, if currency is Currency.ZAR ) None pagination int Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50. 50 Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transactions.py 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 def get_transactions ( self , customer : Optional [ int ] = None , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , status : Optional [ TransactionStatus ] = None , page : Optional [ int ] = None , amount : Optional [ int ] = None , pagination : int = 50 , ) -> Response : \"\"\"Fetch transactions carried out on your integration. Args: customer: Specify an ID for the customer whose transactions you want to retrieve start_date: A timestamp from which to start listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 status: Filter transactions by status. any value from the ``TransactionStatus`` enum page: Specify exactly what page you want to retrieve. If not specified, we use a default value of 1. amount: Optional[int] Filter transactions by amount. Specify the amount (in kobo if currency is ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR``) pagination: Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transaction/?perPage= { pagination } \" ) query_params = [ ( \"page\" , page ), ( \"customer\" , customer ), ( \"status\" , status ), ( \"from\" , start_date ), ( \"to\" , end_date ), ( \"amount\" , amount ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url ) initialize ( amount , email , currency = None , reference = None , callback_url = None , plan = None , invoice_limit = None , metadata = None , channels = None , split_code = None , subaccount = None , transfer_charge = None , bearer = None ) Initialize a transaction from your backend Parameters: Name Type Description Default amount int Amount should be in kobo if currency is Currency.NGN , pesewas, if currency is Currency.GHS , and cents, if currency is Currency.ZAR required email str Customer's email address required currency Optional [ Currency ] Any value from the Currency enum. None reference Optional [ str ] Unique transaction reference. Only -, ., = and alphanumeric characters allowed. None callback_url Optional [ str ] Fully qualified url, e.g. https://example.com/ . Use this to override the callback url provided on the dashboard for this transaction None plan Optional [ str ] If transaction is to create a subscription to a predefined plan, provide plan code here. This would invalidate the value provided in amount None invoice_limit Optional [ int ] Number of times to charge customer during subscription to plan None metadata Optional [ dict ] A dictionary of additional info. check out this link for more information. https://paystack.com/docs/payments/metadata None channels Optional [ list [ Channel ]] A list of Channel enum values to control what channels you want to make available to the user to make a payment with None split_code Optional [ str ] The split code of the transaction split. e.g. SPL_98WF13Eb3w None subaccount Optional [ str ] The code for the subaccount that owns the payment. e.g. ACCT_8f4s1eq7ml6rlzj None transfer_charge Optional [ int ] An amount used to override the split configuration for a single split payment. If set, the amount specified goes to the main account regardless of the split configuration. None bearer Optional [ Bearer ] Any value from the Bearer enum. Who bears Paystack charges? None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Raises: Type Description InvalidDataError When email is not provided. Source code in pypaystack2/api/transactions.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 def initialize ( self , amount : int , email : str , currency : Optional [ Currency ] = None , reference : Optional [ str ] = None , callback_url : Optional [ str ] = None , plan : Optional [ str ] = None , invoice_limit : Optional [ int ] = None , metadata : Optional [ dict ] = None , channels : Optional [ list [ Channel ]] = None , split_code : Optional [ str ] = None , subaccount : Optional [ str ] = None , transfer_charge : Optional [ int ] = None , bearer : Optional [ Bearer ] = None , ) -> Response : \"\"\"Initialize a transaction from your backend Args: amount: Amount should be in kobo if currency is ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR`` email: Customer's email address currency: Any value from the ``Currency`` enum. reference: Unique transaction reference. Only ``-, ., =`` and alphanumeric characters allowed. callback_url: Fully qualified url, e.g. ``https://example.com/`` . Use this to override the callback url provided on the dashboard for this transaction plan: If transaction is to create a subscription to a predefined plan, provide plan code here. This would invalidate the value provided in ``amount`` invoice_limit: Number of times to charge customer during subscription to plan metadata: A dictionary of additional info. check out this link for more information. https://paystack.com/docs/payments/metadata channels: A list of ``Channel`` enum values to control what channels you want to make available to the user to make a payment with split_code: The split code of the transaction split. e.g. SPL_98WF13Eb3w subaccount: The code for the subaccount that owns the payment. e.g. ACCT_8f4s1eq7ml6rlzj transfer_charge: An amount used to override the split configuration for a single split payment. If set, the amount specified goes to the main account regardless of the split configuration. bearer: Any value from the ``Bearer`` enum. Who bears Paystack charges? Returns: A named tuple containing the response gotten from paystack's server. Raises: InvalidDataError: When email is not provided. \"\"\" amount = validate_amount ( amount ) if not email : raise InvalidDataError ( \"Customer's Email is required for initialization\" ) url = self . _parse_url ( \"/transaction/initialize\" ) payload = { \"email\" : email , \"amount\" : amount , } optional_params = [ ( \"currency\" , currency ), ( \"reference\" , reference ), ( \"callback_url\" , callback_url ), ( \"plan\" , plan ), ( \"invoice_limit\" , invoice_limit ), ( \"metadata\" , metadata ), ( \"channels\" , channels ), ( \"split_code\" , split_code ), ( \"subaccount\" , subaccount ), ( \"transfer_charge\" , transfer_charge ), ( \"bearer\" , bearer ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . POST , url , payload ) partial_debit ( auth_code , currency , amount , email , reference = None , at_least = None ) Retrieve part of a payment from a customer Parameters: Name Type Description Default auth_code str Authorization Code required currency Currency Specify the currency you want to debit. Any value from the Currency enum. required amount int Amount should be in kobo if currency is Currency.NGN , pesewas, if currency is Currency.GHS , and cents, if currency is Currency.ZAR required email str Customer's email address (attached to the authorization code) required reference Optional [ str ] Unique transaction reference. Only -, ., = and alphanumeric characters allowed. None at_least Optional [ int ] Minimum amount to charge None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Raises: Type Description InvalidDataError When Customer's email is not provided. When Customer's auth code is not provided. Source code in pypaystack2/api/transactions.py 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 def partial_debit ( self , auth_code : str , currency : Currency , amount : int , email : str , reference : Optional [ str ] = None , at_least : Optional [ int ] = None , ) -> Response : \"\"\"Retrieve part of a payment from a customer Args: auth_code: Authorization Code currency: Specify the currency you want to debit. Any value from the ``Currency`` enum. amount: Amount should be in kobo if currency is ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR`` email: Customer's email address (attached to the authorization code) reference: Unique transaction reference. Only `-, ., =` and alphanumeric characters allowed. at_least: Minimum amount to charge Returns: A named tuple containing the response gotten from paystack's server. Raises: InvalidDataError: When Customer's email is not provided. When Customer's auth code is not provided. \"\"\" amount = validate_amount ( amount ) if at_least : at_least = validate_amount ( at_least ) if not email : raise InvalidDataError ( \"Customer's Email is required to charge\" ) if not auth_code : raise InvalidDataError ( \"Customer's Auth code is required to charge\" ) url = self . _parse_url ( \"/transaction/partial_debit\" ) payload = { \"authorization_code\" : auth_code , \"currency\" : currency , \"amount\" : amount , \"email\" : email , } optional_params = [( \"reference\" , reference ), ( \"at_least\" , at_least )] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . POST , url , payload ) totals ( page = None , start_date = None , end_date = None , pagination = 50 ) Total amount received on your account Parameters: Name Type Description Default page Optional [ int ] Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1. None start_date Optional [ str ] A timestamp from which to start listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None end_date Optional [ str ] A timestamp at which to stop listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None pagination int Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50. 50 Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transactions.py 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 def totals ( self , page : Optional [ int ] = None , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , pagination : int = 50 , ) -> Response : \"\"\"Total amount received on your account Args: page: Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1. start_date: A timestamp from which to start listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 pagination: Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transaction/totals/?perPage= { pagination } \" ) query_params = [ ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url ) verify ( reference ) Confirm the status of a transaction Parameters: Name Type Description Default reference str The transaction reference used to intiate the transaction required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transactions.py 98 99 100 101 102 103 104 105 106 107 108 109 110 def verify ( self , reference : str ) -> Response : \"\"\"Confirm the status of a transaction Args: reference: The transaction reference used to intiate the transaction Returns: A named tuple containing the response gotten from paystack's server. \"\"\" reference = str ( reference ) url = self . _parse_url ( f \"/transaction/verify/ { reference } \" ) return self . _handle_request ( HTTPMethod . GET , url )","title":"Transactions"},{"location":"reference/transactions/#pypaystack2.api.transactions.AsyncTransaction","text":"Bases: BaseAsyncAPI Provides a wrapper for paystack Transactions API The Transactions API allows you to create and manage payments on your integration. https://paystack.com/docs/api/#transaction Source code in pypaystack2/api/transactions.py 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 class AsyncTransaction ( BaseAsyncAPI ): \"\"\"Provides a wrapper for paystack Transactions API The Transactions API allows you to create and manage payments on your integration. https://paystack.com/docs/api/#transaction \"\"\" async def initialize ( self , amount : int , email : str , currency : Optional [ Currency ] = None , reference : Optional [ str ] = None , callback_url : Optional [ str ] = None , plan : Optional [ str ] = None , invoice_limit : Optional [ int ] = None , metadata : Optional [ dict ] = None , channels : Optional [ list [ Channel ]] = None , split_code : Optional [ str ] = None , subaccount : Optional [ str ] = None , transfer_charge : Optional [ int ] = None , bearer : Optional [ Bearer ] = None , ) -> Response : \"\"\"Initialize a transaction from your backend Args: amount: Amount should be in kobo if currency is ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR`` email: Customer's email address currency: Any value from the ``Currency`` enum. reference: Unique transaction reference. Only ``-, ., =`` and alphanumeric characters allowed. callback_url: Fully qualified url, e.g. ``https://example.com/`` . Use this to override the callback url provided on the dashboard for this transaction plan: If transaction is to create a subscription to a predefined plan, provide plan code here. This would invalidate the value provided in ``amount`` invoice_limit: Number of times to charge customer during subscription to plan metadata: A dictionary of additional info. check out this link for more information. https://paystack.com/docs/payments/metadata channels: A list of ``Channel`` enum values to control what channels you want to make available to the user to make a payment with split_code: The split code of the transaction split. e.g. SPL_98WF13Eb3w subaccount: The code for the subaccount that owns the payment. e.g. ACCT_8f4s1eq7ml6rlzj transfer_charge: An amount used to override the split configuration for a single split payment. If set, the amount specified goes to the main account regardless of the split configuration. bearer: Any value from the ``Bearer`` enum. Who bears Paystack charges? Returns: A named tuple containing the response gotten from paystack's server. Raises: InvalidDataError: When email is not provided. \"\"\" amount = validate_amount ( amount ) if not email : raise InvalidDataError ( \"Customer's Email is required for initialization\" ) url = self . _parse_url ( \"/transaction/initialize\" ) payload = { \"email\" : email , \"amount\" : amount , } optional_params = [ ( \"currency\" , currency ), ( \"reference\" , reference ), ( \"callback_url\" , callback_url ), ( \"plan\" , plan ), ( \"invoice_limit\" , invoice_limit ), ( \"metadata\" , metadata ), ( \"channels\" , channels ), ( \"split_code\" , split_code ), ( \"subaccount\" , subaccount ), ( \"transfer_charge\" , transfer_charge ), ( \"bearer\" , bearer ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) async def verify ( self , reference : str ) -> Response : \"\"\"Confirm the status of a transaction Args: reference: The transaction reference used to intiate the transaction Returns: A named tuple containing the response gotten from paystack's server. \"\"\" reference = str ( reference ) url = self . _parse_url ( f \"/transaction/verify/ { reference } \" ) return await self . _handle_request ( HTTPMethod . GET , url ) async def get_transactions ( self , customer : Optional [ int ] = None , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , status : Optional [ TransactionStatus ] = None , page : Optional [ int ] = None , amount : Optional [ int ] = None , pagination : int = 50 , ) -> Response : \"\"\"Fetch transactions carried out on your integration. Args: customer: Specify an ID for the customer whose transactions you want to retrieve start_date: A timestamp from which to start listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 status: Filter transactions by status. any value from the ``TransactionStatus`` enum page: Specify exactly what page you want to retrieve. If not specified, we use a default value of 1. amount: Optional[int] Filter transactions by amount. Specify the amount (in kobo if currency is ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR``) pagination: Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transaction/?perPage= { pagination } \" ) query_params = [ ( \"page\" , page ), ( \"customer\" , customer ), ( \"status\" , status ), ( \"from\" , start_date ), ( \"to\" , end_date ), ( \"amount\" , amount ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url ) async def get_transaction ( self , id : str ) -> Response : \"\"\"Get details of a transaction carried out on your integration. Args: id: An ID for the transaction to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transaction/ { id } /\" ) return await self . _handle_request ( HTTPMethod . GET , url ) async def charge ( self , amount : int , email : str , auth_code : str , reference : Optional [ str ] = None , currency : Optional [ Currency ] = None , metadata : Optional [ dict ] = None , channels : Optional [ list [ Channel ]] = None , subaccount : Optional [ str ] = None , transaction_charge : Optional [ int ] = None , bearer : Optional [ Bearer ] = None , queue : bool = False , ) -> Response : \"\"\" All authorizations marked as reusable can be charged with this endpoint whenever you need to receive payments. Args: amount: amount to charge. email: Customer's email address auth_code: Valid authorization code to charge reference: Unique transaction reference. Only ``-, ., =`` and alphanumeric characters allowed. currency: Currency in which amount should be charged. Any value from the ``Currency`` enum. metadata: Add a custom_fields attribute which has an array of objects if you would like the fields to be added to your transaction when displayed on the dashboard. Sample: ``{\"custom_fields\":[{\"display_name\":\"Cart ID\", \"variable_name\": \"cart_id\",\"value\": \"8393\"}]}`` channels: A list of ``Channel`` enum values to control what channels you want to make available to the user to make a payment with subaccount: The code for the subaccount that owns the payment. e.g. ACCT_8f4s1eq7ml6rlzj transaction_charge: A flat fee to charge the subaccount for this transaction (in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR). This overrides the split percentage set when the subaccount was created. Ideally, you will need to use this if you are splitting in flat rates (since subaccount creation only allows for percentage split). e.g., 7000 for a 70 naira bearer: Who bears Paystack charges? any value from the ``Beaer`` enum queue: If you are making a scheduled charge call, it is a good idea to queue them so the processing system does not get overloaded causing transaction processing errors. Set ``queue=True`` to take advantage of our queued charging. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" amount = validate_amount ( amount ) if not email : raise InvalidDataError ( \"Customer's Email is required to charge\" ) if not auth_code : raise InvalidDataError ( \"Customer's Auth code is required to charge\" ) url = self . _parse_url ( \"/transaction/charge_authorization\" ) payload = { \"authorization_code\" : auth_code , \"email\" : email , \"amount\" : amount , } optional_params = [ ( \"reference\" , reference ), ( \"currency\" , currency ), ( \"metadata\" , metadata ), ( \"channels\" , channels ), ( \"subaccount\" , subaccount ), ( \"transaction_charge\" , transaction_charge ), ( \"bearer\" , bearer ), ( \"queue\" , queue ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) async def get_timeline ( self , id_or_ref : str ) -> Response : \"\"\"View the timeline of a transaction Args: id_or_ref: The ID or the reference of the transaction Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transaction/timeline/ { id_or_ref } \" ) return await self . _handle_request ( HTTPMethod . GET , url ) async def totals ( self , page : Optional [ int ] = None , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , pagination : int = 50 , ) -> Response : \"\"\"Total amount received on your account Args: page: Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1. start_date: A timestamp from which to start listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 pagination: Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transaction/totals/?perPage= { pagination } \" ) query_params = [ ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url ) async def export ( self , page : Optional [ int ] = None , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , customer : Optional [ int ] = None , status : Optional [ TransactionStatus ] = None , currency : Optional [ Currency ] = None , amount : Optional [ int ] = None , settled : Optional [ bool ] = None , settlement : Optional [ int ] = None , payment_page : Optional [ int ] = None , pagination : int = 50 , ) -> Response : \"\"\"Fetch transactions carried out on your integration. Args: page: Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1. start_date: A timestamp from which to start listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 customer: Specify an ID for the customer whose transactions you want to retrieve status: Filter transactions by status. Any value from the ``TransactionStatus`` enum currency: Specify the transaction currency to export. Any value from the ``Currency`` enum amount: Filter transactions by amount. Specify the amount, in kobo if currency is ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR`` settled: Set to ``True`` to export only settled transactions. ``False`` for pending transactions. Leave undefined to export all transaction settlement: An ID for the settlement whose transactions we should export payment_page: Optional[int] Specify a payment page's id to export only transactions conducted on said page pagination: int Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" if amount : amount = validate_amount ( amount ) url = self . _parse_url ( f \"/transaction/export/?perPage= { pagination } \" ) query_params = [ ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ( \"customer\" , customer ), ( \"status\" , status ), ( \"currency\" , currency ), ( \"settled\" , settled ), ( \"settlement\" , settlement ), ( \"payment_page\" , payment_page ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url ) async def partial_debit ( self , auth_code : str , currency : Currency , amount : int , email : str , reference : Optional [ str ] = None , at_least : Optional [ int ] = None , ) -> Response : \"\"\"Retrieve part of a payment from a customer Args: auth_code: Authorization Code currency: Specify the currency you want to debit. Any value from the ``Currency`` enum. amount: Amount should be in kobo if currency is ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR`` email: Customer's email address (attached to the authorization code) reference: Unique transaction reference. Only `-, ., =` and alphanumeric characters allowed. at_least: Minimum amount to charge Returns: A named tuple containing the response gotten from paystack's server. Raises: InvalidDataError: When Customer's email is not provided. When Customer's auth code is not provided. \"\"\" amount = validate_amount ( amount ) if at_least : at_least = validate_amount ( at_least ) if not email : raise InvalidDataError ( \"Customer's Email is required to charge\" ) if not auth_code : raise InvalidDataError ( \"Customer's Auth code is required to charge\" ) url = self . _parse_url ( \"/transaction/partial_debit\" ) payload = { \"authorization_code\" : auth_code , \"currency\" : currency , \"amount\" : amount , \"email\" : email , } optional_params = [( \"reference\" , reference ), ( \"at_least\" , at_least )] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . POST , url , payload )","title":"AsyncTransaction"},{"location":"reference/transactions/#pypaystack2.api.transactions.AsyncTransaction.charge","text":"All authorizations marked as reusable can be charged with this endpoint whenever you need to receive payments. Parameters: Name Type Description Default amount int amount to charge. required email str Customer's email address required auth_code str Valid authorization code to charge required reference Optional [ str ] Unique transaction reference. Only -, ., = and alphanumeric characters allowed. None currency Optional [ Currency ] Currency in which amount should be charged. Any value from the Currency enum. None metadata Optional [ dict ] Add a custom_fields attribute which has an array of objects if you would like the fields to be added to your transaction when displayed on the dashboard. Sample: {\"custom_fields\":[{\"display_name\":\"Cart ID\", \"variable_name\": \"cart_id\",\"value\": \"8393\"}]} None channels Optional [ list [ Channel ]] A list of Channel enum values to control what channels you want to make available to the user to make a payment with None subaccount Optional [ str ] The code for the subaccount that owns the payment. e.g. ACCT_8f4s1eq7ml6rlzj None transaction_charge Optional [ int ] A flat fee to charge the subaccount for this transaction (in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR). This overrides the split percentage set when the subaccount was created. Ideally, you will need to use this if you are splitting in flat rates (since subaccount creation only allows for percentage split). e.g., 7000 for a 70 naira None bearer Optional [ Bearer ] Who bears Paystack charges? any value from the Beaer enum None queue bool If you are making a scheduled charge call, it is a good idea to queue them so the processing system does not get overloaded causing transaction processing errors. Set queue=True to take advantage of our queued charging. False Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transactions.py 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 async def charge ( self , amount : int , email : str , auth_code : str , reference : Optional [ str ] = None , currency : Optional [ Currency ] = None , metadata : Optional [ dict ] = None , channels : Optional [ list [ Channel ]] = None , subaccount : Optional [ str ] = None , transaction_charge : Optional [ int ] = None , bearer : Optional [ Bearer ] = None , queue : bool = False , ) -> Response : \"\"\" All authorizations marked as reusable can be charged with this endpoint whenever you need to receive payments. Args: amount: amount to charge. email: Customer's email address auth_code: Valid authorization code to charge reference: Unique transaction reference. Only ``-, ., =`` and alphanumeric characters allowed. currency: Currency in which amount should be charged. Any value from the ``Currency`` enum. metadata: Add a custom_fields attribute which has an array of objects if you would like the fields to be added to your transaction when displayed on the dashboard. Sample: ``{\"custom_fields\":[{\"display_name\":\"Cart ID\", \"variable_name\": \"cart_id\",\"value\": \"8393\"}]}`` channels: A list of ``Channel`` enum values to control what channels you want to make available to the user to make a payment with subaccount: The code for the subaccount that owns the payment. e.g. ACCT_8f4s1eq7ml6rlzj transaction_charge: A flat fee to charge the subaccount for this transaction (in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR). This overrides the split percentage set when the subaccount was created. Ideally, you will need to use this if you are splitting in flat rates (since subaccount creation only allows for percentage split). e.g., 7000 for a 70 naira bearer: Who bears Paystack charges? any value from the ``Beaer`` enum queue: If you are making a scheduled charge call, it is a good idea to queue them so the processing system does not get overloaded causing transaction processing errors. Set ``queue=True`` to take advantage of our queued charging. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" amount = validate_amount ( amount ) if not email : raise InvalidDataError ( \"Customer's Email is required to charge\" ) if not auth_code : raise InvalidDataError ( \"Customer's Auth code is required to charge\" ) url = self . _parse_url ( \"/transaction/charge_authorization\" ) payload = { \"authorization_code\" : auth_code , \"email\" : email , \"amount\" : amount , } optional_params = [ ( \"reference\" , reference ), ( \"currency\" , currency ), ( \"metadata\" , metadata ), ( \"channels\" , channels ), ( \"subaccount\" , subaccount ), ( \"transaction_charge\" , transaction_charge ), ( \"bearer\" , bearer ), ( \"queue\" , queue ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . POST , url , payload )","title":"charge()"},{"location":"reference/transactions/#pypaystack2.api.transactions.AsyncTransaction.export","text":"Fetch transactions carried out on your integration. Parameters: Name Type Description Default page Optional [ int ] Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1. None start_date Optional [ str ] A timestamp from which to start listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None end_date Optional [ str ] A timestamp at which to stop listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None customer Optional [ int ] Specify an ID for the customer whose transactions you want to retrieve None status Optional [ TransactionStatus ] Filter transactions by status. Any value from the TransactionStatus enum None currency Optional [ Currency ] Specify the transaction currency to export. Any value from the Currency enum None amount Optional [ int ] Filter transactions by amount. Specify the amount, in kobo if currency is Currency.NGN , pesewas, if currency is Currency.GHS , and cents, if currency is Currency.ZAR None settled Optional [ bool ] Set to True to export only settled transactions. False for pending transactions. Leave undefined to export all transaction None settlement Optional [ int ] An ID for the settlement whose transactions we should export None payment_page Optional [ int ] Optional[int] Specify a payment page's id to export only transactions conducted on said page None pagination int int Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50. 50 Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transactions.py 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 async def export ( self , page : Optional [ int ] = None , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , customer : Optional [ int ] = None , status : Optional [ TransactionStatus ] = None , currency : Optional [ Currency ] = None , amount : Optional [ int ] = None , settled : Optional [ bool ] = None , settlement : Optional [ int ] = None , payment_page : Optional [ int ] = None , pagination : int = 50 , ) -> Response : \"\"\"Fetch transactions carried out on your integration. Args: page: Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1. start_date: A timestamp from which to start listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 customer: Specify an ID for the customer whose transactions you want to retrieve status: Filter transactions by status. Any value from the ``TransactionStatus`` enum currency: Specify the transaction currency to export. Any value from the ``Currency`` enum amount: Filter transactions by amount. Specify the amount, in kobo if currency is ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR`` settled: Set to ``True`` to export only settled transactions. ``False`` for pending transactions. Leave undefined to export all transaction settlement: An ID for the settlement whose transactions we should export payment_page: Optional[int] Specify a payment page's id to export only transactions conducted on said page pagination: int Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" if amount : amount = validate_amount ( amount ) url = self . _parse_url ( f \"/transaction/export/?perPage= { pagination } \" ) query_params = [ ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ( \"customer\" , customer ), ( \"status\" , status ), ( \"currency\" , currency ), ( \"settled\" , settled ), ( \"settlement\" , settlement ), ( \"payment_page\" , payment_page ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url )","title":"export()"},{"location":"reference/transactions/#pypaystack2.api.transactions.AsyncTransaction.get_timeline","text":"View the timeline of a transaction Parameters: Name Type Description Default id_or_ref str The ID or the reference of the transaction required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transactions.py 621 622 623 624 625 626 627 628 629 630 631 632 async def get_timeline ( self , id_or_ref : str ) -> Response : \"\"\"View the timeline of a transaction Args: id_or_ref: The ID or the reference of the transaction Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transaction/timeline/ { id_or_ref } \" ) return await self . _handle_request ( HTTPMethod . GET , url )","title":"get_timeline()"},{"location":"reference/transactions/#pypaystack2.api.transactions.AsyncTransaction.get_transaction","text":"Get details of a transaction carried out on your integration. Parameters: Name Type Description Default id str An ID for the transaction to fetch required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transactions.py 532 533 534 535 536 537 538 539 540 541 542 543 async def get_transaction ( self , id : str ) -> Response : \"\"\"Get details of a transaction carried out on your integration. Args: id: An ID for the transaction to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transaction/ { id } /\" ) return await self . _handle_request ( HTTPMethod . GET , url )","title":"get_transaction()"},{"location":"reference/transactions/#pypaystack2.api.transactions.AsyncTransaction.get_transactions","text":"Fetch transactions carried out on your integration. Parameters: Name Type Description Default customer Optional [ int ] Specify an ID for the customer whose transactions you want to retrieve None start_date Optional [ str ] A timestamp from which to start listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None end_date Optional [ str ] A timestamp at which to stop listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None status Optional [ TransactionStatus ] Filter transactions by status. any value from the TransactionStatus enum None page Optional [ int ] Specify exactly what page you want to retrieve. If not specified, we use a default value of 1. None amount Optional [ int ] Optional[int] Filter transactions by amount. Specify the amount (in kobo if currency is Currency.NGN , pesewas, if currency is Currency.GHS , and cents, if currency is Currency.ZAR ) None pagination int Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50. 50 Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transactions.py 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 async def get_transactions ( self , customer : Optional [ int ] = None , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , status : Optional [ TransactionStatus ] = None , page : Optional [ int ] = None , amount : Optional [ int ] = None , pagination : int = 50 , ) -> Response : \"\"\"Fetch transactions carried out on your integration. Args: customer: Specify an ID for the customer whose transactions you want to retrieve start_date: A timestamp from which to start listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 status: Filter transactions by status. any value from the ``TransactionStatus`` enum page: Specify exactly what page you want to retrieve. If not specified, we use a default value of 1. amount: Optional[int] Filter transactions by amount. Specify the amount (in kobo if currency is ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR``) pagination: Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transaction/?perPage= { pagination } \" ) query_params = [ ( \"page\" , page ), ( \"customer\" , customer ), ( \"status\" , status ), ( \"from\" , start_date ), ( \"to\" , end_date ), ( \"amount\" , amount ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url )","title":"get_transactions()"},{"location":"reference/transactions/#pypaystack2.api.transactions.AsyncTransaction.initialize","text":"Initialize a transaction from your backend Parameters: Name Type Description Default amount int Amount should be in kobo if currency is Currency.NGN , pesewas, if currency is Currency.GHS , and cents, if currency is Currency.ZAR required email str Customer's email address required currency Optional [ Currency ] Any value from the Currency enum. None reference Optional [ str ] Unique transaction reference. Only -, ., = and alphanumeric characters allowed. None callback_url Optional [ str ] Fully qualified url, e.g. https://example.com/ . Use this to override the callback url provided on the dashboard for this transaction None plan Optional [ str ] If transaction is to create a subscription to a predefined plan, provide plan code here. This would invalidate the value provided in amount None invoice_limit Optional [ int ] Number of times to charge customer during subscription to plan None metadata Optional [ dict ] A dictionary of additional info. check out this link for more information. https://paystack.com/docs/payments/metadata None channels Optional [ list [ Channel ]] A list of Channel enum values to control what channels you want to make available to the user to make a payment with None split_code Optional [ str ] The split code of the transaction split. e.g. SPL_98WF13Eb3w None subaccount Optional [ str ] The code for the subaccount that owns the payment. e.g. ACCT_8f4s1eq7ml6rlzj None transfer_charge Optional [ int ] An amount used to override the split configuration for a single split payment. If set, the amount specified goes to the main account regardless of the split configuration. None bearer Optional [ Bearer ] Any value from the Bearer enum. Who bears Paystack charges? None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Raises: Type Description InvalidDataError When email is not provided. Source code in pypaystack2/api/transactions.py 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 async def initialize ( self , amount : int , email : str , currency : Optional [ Currency ] = None , reference : Optional [ str ] = None , callback_url : Optional [ str ] = None , plan : Optional [ str ] = None , invoice_limit : Optional [ int ] = None , metadata : Optional [ dict ] = None , channels : Optional [ list [ Channel ]] = None , split_code : Optional [ str ] = None , subaccount : Optional [ str ] = None , transfer_charge : Optional [ int ] = None , bearer : Optional [ Bearer ] = None , ) -> Response : \"\"\"Initialize a transaction from your backend Args: amount: Amount should be in kobo if currency is ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR`` email: Customer's email address currency: Any value from the ``Currency`` enum. reference: Unique transaction reference. Only ``-, ., =`` and alphanumeric characters allowed. callback_url: Fully qualified url, e.g. ``https://example.com/`` . Use this to override the callback url provided on the dashboard for this transaction plan: If transaction is to create a subscription to a predefined plan, provide plan code here. This would invalidate the value provided in ``amount`` invoice_limit: Number of times to charge customer during subscription to plan metadata: A dictionary of additional info. check out this link for more information. https://paystack.com/docs/payments/metadata channels: A list of ``Channel`` enum values to control what channels you want to make available to the user to make a payment with split_code: The split code of the transaction split. e.g. SPL_98WF13Eb3w subaccount: The code for the subaccount that owns the payment. e.g. ACCT_8f4s1eq7ml6rlzj transfer_charge: An amount used to override the split configuration for a single split payment. If set, the amount specified goes to the main account regardless of the split configuration. bearer: Any value from the ``Bearer`` enum. Who bears Paystack charges? Returns: A named tuple containing the response gotten from paystack's server. Raises: InvalidDataError: When email is not provided. \"\"\" amount = validate_amount ( amount ) if not email : raise InvalidDataError ( \"Customer's Email is required for initialization\" ) url = self . _parse_url ( \"/transaction/initialize\" ) payload = { \"email\" : email , \"amount\" : amount , } optional_params = [ ( \"currency\" , currency ), ( \"reference\" , reference ), ( \"callback_url\" , callback_url ), ( \"plan\" , plan ), ( \"invoice_limit\" , invoice_limit ), ( \"metadata\" , metadata ), ( \"channels\" , channels ), ( \"split_code\" , split_code ), ( \"subaccount\" , subaccount ), ( \"transfer_charge\" , transfer_charge ), ( \"bearer\" , bearer ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . POST , url , payload )","title":"initialize()"},{"location":"reference/transactions/#pypaystack2.api.transactions.AsyncTransaction.partial_debit","text":"Retrieve part of a payment from a customer Parameters: Name Type Description Default auth_code str Authorization Code required currency Currency Specify the currency you want to debit. Any value from the Currency enum. required amount int Amount should be in kobo if currency is Currency.NGN , pesewas, if currency is Currency.GHS , and cents, if currency is Currency.ZAR required email str Customer's email address (attached to the authorization code) required reference Optional [ str ] Unique transaction reference. Only -, ., = and alphanumeric characters allowed. None at_least Optional [ int ] Minimum amount to charge None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Raises: Type Description InvalidDataError When Customer's email is not provided. When Customer's auth code is not provided. Source code in pypaystack2/api/transactions.py 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 async def partial_debit ( self , auth_code : str , currency : Currency , amount : int , email : str , reference : Optional [ str ] = None , at_least : Optional [ int ] = None , ) -> Response : \"\"\"Retrieve part of a payment from a customer Args: auth_code: Authorization Code currency: Specify the currency you want to debit. Any value from the ``Currency`` enum. amount: Amount should be in kobo if currency is ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR`` email: Customer's email address (attached to the authorization code) reference: Unique transaction reference. Only `-, ., =` and alphanumeric characters allowed. at_least: Minimum amount to charge Returns: A named tuple containing the response gotten from paystack's server. Raises: InvalidDataError: When Customer's email is not provided. When Customer's auth code is not provided. \"\"\" amount = validate_amount ( amount ) if at_least : at_least = validate_amount ( at_least ) if not email : raise InvalidDataError ( \"Customer's Email is required to charge\" ) if not auth_code : raise InvalidDataError ( \"Customer's Auth code is required to charge\" ) url = self . _parse_url ( \"/transaction/partial_debit\" ) payload = { \"authorization_code\" : auth_code , \"currency\" : currency , \"amount\" : amount , \"email\" : email , } optional_params = [( \"reference\" , reference ), ( \"at_least\" , at_least )] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . POST , url , payload )","title":"partial_debit()"},{"location":"reference/transactions/#pypaystack2.api.transactions.AsyncTransaction.totals","text":"Total amount received on your account Parameters: Name Type Description Default page Optional [ int ] Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1. None start_date Optional [ str ] A timestamp from which to start listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None end_date Optional [ str ] A timestamp at which to stop listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None pagination int Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50. 50 Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transactions.py 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 async def totals ( self , page : Optional [ int ] = None , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , pagination : int = 50 , ) -> Response : \"\"\"Total amount received on your account Args: page: Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1. start_date: A timestamp from which to start listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 pagination: Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transaction/totals/?perPage= { pagination } \" ) query_params = [ ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url )","title":"totals()"},{"location":"reference/transactions/#pypaystack2.api.transactions.AsyncTransaction.verify","text":"Confirm the status of a transaction Parameters: Name Type Description Default reference str The transaction reference used to intiate the transaction required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transactions.py 475 476 477 478 479 480 481 482 483 484 485 486 487 async def verify ( self , reference : str ) -> Response : \"\"\"Confirm the status of a transaction Args: reference: The transaction reference used to intiate the transaction Returns: A named tuple containing the response gotten from paystack's server. \"\"\" reference = str ( reference ) url = self . _parse_url ( f \"/transaction/verify/ { reference } \" ) return await self . _handle_request ( HTTPMethod . GET , url )","title":"verify()"},{"location":"reference/transactions/#pypaystack2.api.transactions.Transaction","text":"Bases: BaseAPI Provides a wrapper for paystack Transactions API The Transactions API allows you to create and manage payments on your integration. https://paystack.com/docs/api/#transaction Source code in pypaystack2/api/transactions.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 class Transaction ( BaseAPI ): \"\"\"Provides a wrapper for paystack Transactions API The Transactions API allows you to create and manage payments on your integration. https://paystack.com/docs/api/#transaction \"\"\" def initialize ( self , amount : int , email : str , currency : Optional [ Currency ] = None , reference : Optional [ str ] = None , callback_url : Optional [ str ] = None , plan : Optional [ str ] = None , invoice_limit : Optional [ int ] = None , metadata : Optional [ dict ] = None , channels : Optional [ list [ Channel ]] = None , split_code : Optional [ str ] = None , subaccount : Optional [ str ] = None , transfer_charge : Optional [ int ] = None , bearer : Optional [ Bearer ] = None , ) -> Response : \"\"\"Initialize a transaction from your backend Args: amount: Amount should be in kobo if currency is ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR`` email: Customer's email address currency: Any value from the ``Currency`` enum. reference: Unique transaction reference. Only ``-, ., =`` and alphanumeric characters allowed. callback_url: Fully qualified url, e.g. ``https://example.com/`` . Use this to override the callback url provided on the dashboard for this transaction plan: If transaction is to create a subscription to a predefined plan, provide plan code here. This would invalidate the value provided in ``amount`` invoice_limit: Number of times to charge customer during subscription to plan metadata: A dictionary of additional info. check out this link for more information. https://paystack.com/docs/payments/metadata channels: A list of ``Channel`` enum values to control what channels you want to make available to the user to make a payment with split_code: The split code of the transaction split. e.g. SPL_98WF13Eb3w subaccount: The code for the subaccount that owns the payment. e.g. ACCT_8f4s1eq7ml6rlzj transfer_charge: An amount used to override the split configuration for a single split payment. If set, the amount specified goes to the main account regardless of the split configuration. bearer: Any value from the ``Bearer`` enum. Who bears Paystack charges? Returns: A named tuple containing the response gotten from paystack's server. Raises: InvalidDataError: When email is not provided. \"\"\" amount = validate_amount ( amount ) if not email : raise InvalidDataError ( \"Customer's Email is required for initialization\" ) url = self . _parse_url ( \"/transaction/initialize\" ) payload = { \"email\" : email , \"amount\" : amount , } optional_params = [ ( \"currency\" , currency ), ( \"reference\" , reference ), ( \"callback_url\" , callback_url ), ( \"plan\" , plan ), ( \"invoice_limit\" , invoice_limit ), ( \"metadata\" , metadata ), ( \"channels\" , channels ), ( \"split_code\" , split_code ), ( \"subaccount\" , subaccount ), ( \"transfer_charge\" , transfer_charge ), ( \"bearer\" , bearer ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . POST , url , payload ) def verify ( self , reference : str ) -> Response : \"\"\"Confirm the status of a transaction Args: reference: The transaction reference used to intiate the transaction Returns: A named tuple containing the response gotten from paystack's server. \"\"\" reference = str ( reference ) url = self . _parse_url ( f \"/transaction/verify/ { reference } \" ) return self . _handle_request ( HTTPMethod . GET , url ) def get_transactions ( self , customer : Optional [ int ] = None , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , status : Optional [ TransactionStatus ] = None , page : Optional [ int ] = None , amount : Optional [ int ] = None , pagination : int = 50 , ) -> Response : \"\"\"Fetch transactions carried out on your integration. Args: customer: Specify an ID for the customer whose transactions you want to retrieve start_date: A timestamp from which to start listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 status: Filter transactions by status. any value from the ``TransactionStatus`` enum page: Specify exactly what page you want to retrieve. If not specified, we use a default value of 1. amount: Optional[int] Filter transactions by amount. Specify the amount (in kobo if currency is ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR``) pagination: Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transaction/?perPage= { pagination } \" ) query_params = [ ( \"page\" , page ), ( \"customer\" , customer ), ( \"status\" , status ), ( \"from\" , start_date ), ( \"to\" , end_date ), ( \"amount\" , amount ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url ) def get_transaction ( self , id : str ) -> Response : \"\"\"Get details of a transaction carried out on your integration. Args: id: An ID for the transaction to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transaction/ { id } /\" ) return self . _handle_request ( HTTPMethod . GET , url ) def charge ( self , amount : int , email : str , auth_code : str , reference : Optional [ str ] = None , currency : Optional [ Currency ] = None , metadata : Optional [ dict ] = None , channels : Optional [ list [ Channel ]] = None , subaccount : Optional [ str ] = None , transaction_charge : Optional [ int ] = None , bearer : Optional [ Bearer ] = None , queue : bool = False , ) -> Response : \"\"\" All authorizations marked as reusable can be charged with this endpoint whenever you need to receive payments. Args: amount: amount to charge. email: Customer's email address auth_code: Valid authorization code to charge reference: Unique transaction reference. Only ``-, ., =`` and alphanumeric characters allowed. currency: Currency in which amount should be charged. Any value from the ``Currency`` enum. metadata: Add a custom_fields attribute which has an array of objects if you would like the fields to be added to your transaction when displayed on the dashboard. Sample: ``{\"custom_fields\":[{\"display_name\":\"Cart ID\", \"variable_name\": \"cart_id\",\"value\": \"8393\"}]}`` channels: A list of ``Channel`` enum values to control what channels you want to make available to the user to make a payment with subaccount: The code for the subaccount that owns the payment. e.g. ACCT_8f4s1eq7ml6rlzj transaction_charge: A flat fee to charge the subaccount for this transaction (in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR). This overrides the split percentage set when the subaccount was created. Ideally, you will need to use this if you are splitting in flat rates (since subaccount creation only allows for percentage split). e.g., 7000 for a 70 naira bearer: Who bears Paystack charges? any value from the ``Beaer`` enum queue: If you are making a scheduled charge call, it is a good idea to queue them so the processing system does not get overloaded causing transaction processing errors. Set ``queue=True`` to take advantage of our queued charging. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" amount = validate_amount ( amount ) if not email : raise InvalidDataError ( \"Customer's Email is required to charge\" ) if not auth_code : raise InvalidDataError ( \"Customer's Auth code is required to charge\" ) url = self . _parse_url ( \"/transaction/charge_authorization\" ) payload = { \"authorization_code\" : auth_code , \"email\" : email , \"amount\" : amount , } optional_params = [ ( \"reference\" , reference ), ( \"currency\" , currency ), ( \"metadata\" , metadata ), ( \"channels\" , channels ), ( \"subaccount\" , subaccount ), ( \"transaction_charge\" , transaction_charge ), ( \"bearer\" , bearer ), ( \"queue\" , queue ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . POST , url , payload ) def get_timeline ( self , id_or_ref : str ) -> Response : \"\"\"View the timeline of a transaction Args: id_or_ref: The ID or the reference of the transaction Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transaction/timeline/ { id_or_ref } \" ) return self . _handle_request ( HTTPMethod . GET , url ) def totals ( self , page : Optional [ int ] = None , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , pagination : int = 50 , ) -> Response : \"\"\"Total amount received on your account Args: page: Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1. start_date: A timestamp from which to start listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 pagination: Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transaction/totals/?perPage= { pagination } \" ) query_params = [ ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url ) def export ( self , page : Optional [ int ] = None , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , customer : Optional [ int ] = None , status : Optional [ TransactionStatus ] = None , currency : Optional [ Currency ] = None , amount : Optional [ int ] = None , settled : Optional [ bool ] = None , settlement : Optional [ int ] = None , payment_page : Optional [ int ] = None , pagination : int = 50 , ) -> Response : \"\"\"Fetch transactions carried out on your integration. Args: page: Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1. start_date: A timestamp from which to start listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 customer: Specify an ID for the customer whose transactions you want to retrieve status: Filter transactions by status. Any value from the ``TransactionStatus`` enum currency: Specify the transaction currency to export. Any value from the ``Currency`` enum amount: Filter transactions by amount. Specify the amount, in kobo if currency is ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR`` settled: Set to ``True`` to export only settled transactions. ``False`` for pending transactions. Leave undefined to export all transaction settlement: An ID for the settlement whose transactions we should export payment_page: Optional[int] Specify a payment page's id to export only transactions conducted on said page pagination: int Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" if amount : amount = validate_amount ( amount ) url = self . _parse_url ( f \"/transaction/export/?perPage= { pagination } \" ) query_params = [ ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ( \"customer\" , customer ), ( \"status\" , status ), ( \"currency\" , currency ), ( \"settled\" , settled ), ( \"settlement\" , settlement ), ( \"payment_page\" , payment_page ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url ) def partial_debit ( self , auth_code : str , currency : Currency , amount : int , email : str , reference : Optional [ str ] = None , at_least : Optional [ int ] = None , ) -> Response : \"\"\"Retrieve part of a payment from a customer Args: auth_code: Authorization Code currency: Specify the currency you want to debit. Any value from the ``Currency`` enum. amount: Amount should be in kobo if currency is ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR`` email: Customer's email address (attached to the authorization code) reference: Unique transaction reference. Only `-, ., =` and alphanumeric characters allowed. at_least: Minimum amount to charge Returns: A named tuple containing the response gotten from paystack's server. Raises: InvalidDataError: When Customer's email is not provided. When Customer's auth code is not provided. \"\"\" amount = validate_amount ( amount ) if at_least : at_least = validate_amount ( at_least ) if not email : raise InvalidDataError ( \"Customer's Email is required to charge\" ) if not auth_code : raise InvalidDataError ( \"Customer's Auth code is required to charge\" ) url = self . _parse_url ( \"/transaction/partial_debit\" ) payload = { \"authorization_code\" : auth_code , \"currency\" : currency , \"amount\" : amount , \"email\" : email , } optional_params = [( \"reference\" , reference ), ( \"at_least\" , at_least )] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . POST , url , payload )","title":"Transaction"},{"location":"reference/transactions/#pypaystack2.api.transactions.Transaction.charge","text":"All authorizations marked as reusable can be charged with this endpoint whenever you need to receive payments. Parameters: Name Type Description Default amount int amount to charge. required email str Customer's email address required auth_code str Valid authorization code to charge required reference Optional [ str ] Unique transaction reference. Only -, ., = and alphanumeric characters allowed. None currency Optional [ Currency ] Currency in which amount should be charged. Any value from the Currency enum. None metadata Optional [ dict ] Add a custom_fields attribute which has an array of objects if you would like the fields to be added to your transaction when displayed on the dashboard. Sample: {\"custom_fields\":[{\"display_name\":\"Cart ID\", \"variable_name\": \"cart_id\",\"value\": \"8393\"}]} None channels Optional [ list [ Channel ]] A list of Channel enum values to control what channels you want to make available to the user to make a payment with None subaccount Optional [ str ] The code for the subaccount that owns the payment. e.g. ACCT_8f4s1eq7ml6rlzj None transaction_charge Optional [ int ] A flat fee to charge the subaccount for this transaction (in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR). This overrides the split percentage set when the subaccount was created. Ideally, you will need to use this if you are splitting in flat rates (since subaccount creation only allows for percentage split). e.g., 7000 for a 70 naira None bearer Optional [ Bearer ] Who bears Paystack charges? any value from the Beaer enum None queue bool If you are making a scheduled charge call, it is a good idea to queue them so the processing system does not get overloaded causing transaction processing errors. Set queue=True to take advantage of our queued charging. False Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transactions.py 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 def charge ( self , amount : int , email : str , auth_code : str , reference : Optional [ str ] = None , currency : Optional [ Currency ] = None , metadata : Optional [ dict ] = None , channels : Optional [ list [ Channel ]] = None , subaccount : Optional [ str ] = None , transaction_charge : Optional [ int ] = None , bearer : Optional [ Bearer ] = None , queue : bool = False , ) -> Response : \"\"\" All authorizations marked as reusable can be charged with this endpoint whenever you need to receive payments. Args: amount: amount to charge. email: Customer's email address auth_code: Valid authorization code to charge reference: Unique transaction reference. Only ``-, ., =`` and alphanumeric characters allowed. currency: Currency in which amount should be charged. Any value from the ``Currency`` enum. metadata: Add a custom_fields attribute which has an array of objects if you would like the fields to be added to your transaction when displayed on the dashboard. Sample: ``{\"custom_fields\":[{\"display_name\":\"Cart ID\", \"variable_name\": \"cart_id\",\"value\": \"8393\"}]}`` channels: A list of ``Channel`` enum values to control what channels you want to make available to the user to make a payment with subaccount: The code for the subaccount that owns the payment. e.g. ACCT_8f4s1eq7ml6rlzj transaction_charge: A flat fee to charge the subaccount for this transaction (in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR). This overrides the split percentage set when the subaccount was created. Ideally, you will need to use this if you are splitting in flat rates (since subaccount creation only allows for percentage split). e.g., 7000 for a 70 naira bearer: Who bears Paystack charges? any value from the ``Beaer`` enum queue: If you are making a scheduled charge call, it is a good idea to queue them so the processing system does not get overloaded causing transaction processing errors. Set ``queue=True`` to take advantage of our queued charging. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" amount = validate_amount ( amount ) if not email : raise InvalidDataError ( \"Customer's Email is required to charge\" ) if not auth_code : raise InvalidDataError ( \"Customer's Auth code is required to charge\" ) url = self . _parse_url ( \"/transaction/charge_authorization\" ) payload = { \"authorization_code\" : auth_code , \"email\" : email , \"amount\" : amount , } optional_params = [ ( \"reference\" , reference ), ( \"currency\" , currency ), ( \"metadata\" , metadata ), ( \"channels\" , channels ), ( \"subaccount\" , subaccount ), ( \"transaction_charge\" , transaction_charge ), ( \"bearer\" , bearer ), ( \"queue\" , queue ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . POST , url , payload )","title":"charge()"},{"location":"reference/transactions/#pypaystack2.api.transactions.Transaction.export","text":"Fetch transactions carried out on your integration. Parameters: Name Type Description Default page Optional [ int ] Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1. None start_date Optional [ str ] A timestamp from which to start listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None end_date Optional [ str ] A timestamp at which to stop listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None customer Optional [ int ] Specify an ID for the customer whose transactions you want to retrieve None status Optional [ TransactionStatus ] Filter transactions by status. Any value from the TransactionStatus enum None currency Optional [ Currency ] Specify the transaction currency to export. Any value from the Currency enum None amount Optional [ int ] Filter transactions by amount. Specify the amount, in kobo if currency is Currency.NGN , pesewas, if currency is Currency.GHS , and cents, if currency is Currency.ZAR None settled Optional [ bool ] Set to True to export only settled transactions. False for pending transactions. Leave undefined to export all transaction None settlement Optional [ int ] An ID for the settlement whose transactions we should export None payment_page Optional [ int ] Optional[int] Specify a payment page's id to export only transactions conducted on said page None pagination int int Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50. 50 Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transactions.py 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 def export ( self , page : Optional [ int ] = None , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , customer : Optional [ int ] = None , status : Optional [ TransactionStatus ] = None , currency : Optional [ Currency ] = None , amount : Optional [ int ] = None , settled : Optional [ bool ] = None , settlement : Optional [ int ] = None , payment_page : Optional [ int ] = None , pagination : int = 50 , ) -> Response : \"\"\"Fetch transactions carried out on your integration. Args: page: Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1. start_date: A timestamp from which to start listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 customer: Specify an ID for the customer whose transactions you want to retrieve status: Filter transactions by status. Any value from the ``TransactionStatus`` enum currency: Specify the transaction currency to export. Any value from the ``Currency`` enum amount: Filter transactions by amount. Specify the amount, in kobo if currency is ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR`` settled: Set to ``True`` to export only settled transactions. ``False`` for pending transactions. Leave undefined to export all transaction settlement: An ID for the settlement whose transactions we should export payment_page: Optional[int] Specify a payment page's id to export only transactions conducted on said page pagination: int Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" if amount : amount = validate_amount ( amount ) url = self . _parse_url ( f \"/transaction/export/?perPage= { pagination } \" ) query_params = [ ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ( \"customer\" , customer ), ( \"status\" , status ), ( \"currency\" , currency ), ( \"settled\" , settled ), ( \"settlement\" , settlement ), ( \"payment_page\" , payment_page ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url )","title":"export()"},{"location":"reference/transactions/#pypaystack2.api.transactions.Transaction.get_timeline","text":"View the timeline of a transaction Parameters: Name Type Description Default id_or_ref str The ID or the reference of the transaction required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transactions.py 244 245 246 247 248 249 250 251 252 253 254 255 def get_timeline ( self , id_or_ref : str ) -> Response : \"\"\"View the timeline of a transaction Args: id_or_ref: The ID or the reference of the transaction Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transaction/timeline/ { id_or_ref } \" ) return self . _handle_request ( HTTPMethod . GET , url )","title":"get_timeline()"},{"location":"reference/transactions/#pypaystack2.api.transactions.Transaction.get_transaction","text":"Get details of a transaction carried out on your integration. Parameters: Name Type Description Default id str An ID for the transaction to fetch required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transactions.py 155 156 157 158 159 160 161 162 163 164 165 166 def get_transaction ( self , id : str ) -> Response : \"\"\"Get details of a transaction carried out on your integration. Args: id: An ID for the transaction to fetch Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transaction/ { id } /\" ) return self . _handle_request ( HTTPMethod . GET , url )","title":"get_transaction()"},{"location":"reference/transactions/#pypaystack2.api.transactions.Transaction.get_transactions","text":"Fetch transactions carried out on your integration. Parameters: Name Type Description Default customer Optional [ int ] Specify an ID for the customer whose transactions you want to retrieve None start_date Optional [ str ] A timestamp from which to start listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None end_date Optional [ str ] A timestamp at which to stop listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None status Optional [ TransactionStatus ] Filter transactions by status. any value from the TransactionStatus enum None page Optional [ int ] Specify exactly what page you want to retrieve. If not specified, we use a default value of 1. None amount Optional [ int ] Optional[int] Filter transactions by amount. Specify the amount (in kobo if currency is Currency.NGN , pesewas, if currency is Currency.GHS , and cents, if currency is Currency.ZAR ) None pagination int Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50. 50 Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transactions.py 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 def get_transactions ( self , customer : Optional [ int ] = None , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , status : Optional [ TransactionStatus ] = None , page : Optional [ int ] = None , amount : Optional [ int ] = None , pagination : int = 50 , ) -> Response : \"\"\"Fetch transactions carried out on your integration. Args: customer: Specify an ID for the customer whose transactions you want to retrieve start_date: A timestamp from which to start listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 status: Filter transactions by status. any value from the ``TransactionStatus`` enum page: Specify exactly what page you want to retrieve. If not specified, we use a default value of 1. amount: Optional[int] Filter transactions by amount. Specify the amount (in kobo if currency is ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR``) pagination: Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transaction/?perPage= { pagination } \" ) query_params = [ ( \"page\" , page ), ( \"customer\" , customer ), ( \"status\" , status ), ( \"from\" , start_date ), ( \"to\" , end_date ), ( \"amount\" , amount ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url )","title":"get_transactions()"},{"location":"reference/transactions/#pypaystack2.api.transactions.Transaction.initialize","text":"Initialize a transaction from your backend Parameters: Name Type Description Default amount int Amount should be in kobo if currency is Currency.NGN , pesewas, if currency is Currency.GHS , and cents, if currency is Currency.ZAR required email str Customer's email address required currency Optional [ Currency ] Any value from the Currency enum. None reference Optional [ str ] Unique transaction reference. Only -, ., = and alphanumeric characters allowed. None callback_url Optional [ str ] Fully qualified url, e.g. https://example.com/ . Use this to override the callback url provided on the dashboard for this transaction None plan Optional [ str ] If transaction is to create a subscription to a predefined plan, provide plan code here. This would invalidate the value provided in amount None invoice_limit Optional [ int ] Number of times to charge customer during subscription to plan None metadata Optional [ dict ] A dictionary of additional info. check out this link for more information. https://paystack.com/docs/payments/metadata None channels Optional [ list [ Channel ]] A list of Channel enum values to control what channels you want to make available to the user to make a payment with None split_code Optional [ str ] The split code of the transaction split. e.g. SPL_98WF13Eb3w None subaccount Optional [ str ] The code for the subaccount that owns the payment. e.g. ACCT_8f4s1eq7ml6rlzj None transfer_charge Optional [ int ] An amount used to override the split configuration for a single split payment. If set, the amount specified goes to the main account regardless of the split configuration. None bearer Optional [ Bearer ] Any value from the Bearer enum. Who bears Paystack charges? None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Raises: Type Description InvalidDataError When email is not provided. Source code in pypaystack2/api/transactions.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 def initialize ( self , amount : int , email : str , currency : Optional [ Currency ] = None , reference : Optional [ str ] = None , callback_url : Optional [ str ] = None , plan : Optional [ str ] = None , invoice_limit : Optional [ int ] = None , metadata : Optional [ dict ] = None , channels : Optional [ list [ Channel ]] = None , split_code : Optional [ str ] = None , subaccount : Optional [ str ] = None , transfer_charge : Optional [ int ] = None , bearer : Optional [ Bearer ] = None , ) -> Response : \"\"\"Initialize a transaction from your backend Args: amount: Amount should be in kobo if currency is ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR`` email: Customer's email address currency: Any value from the ``Currency`` enum. reference: Unique transaction reference. Only ``-, ., =`` and alphanumeric characters allowed. callback_url: Fully qualified url, e.g. ``https://example.com/`` . Use this to override the callback url provided on the dashboard for this transaction plan: If transaction is to create a subscription to a predefined plan, provide plan code here. This would invalidate the value provided in ``amount`` invoice_limit: Number of times to charge customer during subscription to plan metadata: A dictionary of additional info. check out this link for more information. https://paystack.com/docs/payments/metadata channels: A list of ``Channel`` enum values to control what channels you want to make available to the user to make a payment with split_code: The split code of the transaction split. e.g. SPL_98WF13Eb3w subaccount: The code for the subaccount that owns the payment. e.g. ACCT_8f4s1eq7ml6rlzj transfer_charge: An amount used to override the split configuration for a single split payment. If set, the amount specified goes to the main account regardless of the split configuration. bearer: Any value from the ``Bearer`` enum. Who bears Paystack charges? Returns: A named tuple containing the response gotten from paystack's server. Raises: InvalidDataError: When email is not provided. \"\"\" amount = validate_amount ( amount ) if not email : raise InvalidDataError ( \"Customer's Email is required for initialization\" ) url = self . _parse_url ( \"/transaction/initialize\" ) payload = { \"email\" : email , \"amount\" : amount , } optional_params = [ ( \"currency\" , currency ), ( \"reference\" , reference ), ( \"callback_url\" , callback_url ), ( \"plan\" , plan ), ( \"invoice_limit\" , invoice_limit ), ( \"metadata\" , metadata ), ( \"channels\" , channels ), ( \"split_code\" , split_code ), ( \"subaccount\" , subaccount ), ( \"transfer_charge\" , transfer_charge ), ( \"bearer\" , bearer ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . POST , url , payload )","title":"initialize()"},{"location":"reference/transactions/#pypaystack2.api.transactions.Transaction.partial_debit","text":"Retrieve part of a payment from a customer Parameters: Name Type Description Default auth_code str Authorization Code required currency Currency Specify the currency you want to debit. Any value from the Currency enum. required amount int Amount should be in kobo if currency is Currency.NGN , pesewas, if currency is Currency.GHS , and cents, if currency is Currency.ZAR required email str Customer's email address (attached to the authorization code) required reference Optional [ str ] Unique transaction reference. Only -, ., = and alphanumeric characters allowed. None at_least Optional [ int ] Minimum amount to charge None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Raises: Type Description InvalidDataError When Customer's email is not provided. When Customer's auth code is not provided. Source code in pypaystack2/api/transactions.py 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 def partial_debit ( self , auth_code : str , currency : Currency , amount : int , email : str , reference : Optional [ str ] = None , at_least : Optional [ int ] = None , ) -> Response : \"\"\"Retrieve part of a payment from a customer Args: auth_code: Authorization Code currency: Specify the currency you want to debit. Any value from the ``Currency`` enum. amount: Amount should be in kobo if currency is ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR`` email: Customer's email address (attached to the authorization code) reference: Unique transaction reference. Only `-, ., =` and alphanumeric characters allowed. at_least: Minimum amount to charge Returns: A named tuple containing the response gotten from paystack's server. Raises: InvalidDataError: When Customer's email is not provided. When Customer's auth code is not provided. \"\"\" amount = validate_amount ( amount ) if at_least : at_least = validate_amount ( at_least ) if not email : raise InvalidDataError ( \"Customer's Email is required to charge\" ) if not auth_code : raise InvalidDataError ( \"Customer's Auth code is required to charge\" ) url = self . _parse_url ( \"/transaction/partial_debit\" ) payload = { \"authorization_code\" : auth_code , \"currency\" : currency , \"amount\" : amount , \"email\" : email , } optional_params = [( \"reference\" , reference ), ( \"at_least\" , at_least )] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . POST , url , payload )","title":"partial_debit()"},{"location":"reference/transactions/#pypaystack2.api.transactions.Transaction.totals","text":"Total amount received on your account Parameters: Name Type Description Default page Optional [ int ] Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1. None start_date Optional [ str ] A timestamp from which to start listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None end_date Optional [ str ] A timestamp at which to stop listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None pagination int Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50. 50 Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transactions.py 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 def totals ( self , page : Optional [ int ] = None , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , pagination : int = 50 , ) -> Response : \"\"\"Total amount received on your account Args: page: Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1. start_date: A timestamp from which to start listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 pagination: Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transaction/totals/?perPage= { pagination } \" ) query_params = [ ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url )","title":"totals()"},{"location":"reference/transactions/#pypaystack2.api.transactions.Transaction.verify","text":"Confirm the status of a transaction Parameters: Name Type Description Default reference str The transaction reference used to intiate the transaction required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transactions.py 98 99 100 101 102 103 104 105 106 107 108 109 110 def verify ( self , reference : str ) -> Response : \"\"\"Confirm the status of a transaction Args: reference: The transaction reference used to intiate the transaction Returns: A named tuple containing the response gotten from paystack's server. \"\"\" reference = str ( reference ) url = self . _parse_url ( f \"/transaction/verify/ { reference } \" ) return self . _handle_request ( HTTPMethod . GET , url )","title":"verify()"},{"location":"reference/transfer_recipients/","text":"AsyncTransferRecipient Bases: BaseAsyncAPI Provides a wrapper for paystack Transfer Receipts API The Transfer Recipients API allows you to create and manage beneficiaries that you send money to. https://paystack.com/docs/api/#transfer-recipient Note Feature Availability This feature is only available to businesses in Nigeria and Ghana. Source code in pypaystack2/api/transfer_recipients.py 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 class AsyncTransferRecipient ( BaseAsyncAPI ): \"\"\"Provides a wrapper for paystack Transfer Receipts API The Transfer Recipients API allows you to create and manage beneficiaries that you send money to. https://paystack.com/docs/api/#transfer-recipient Note: Feature Availability This feature is only available to businesses in Nigeria and Ghana. \"\"\" async def create ( self , type : TransferRecipient , name : str , account_number : str , bank_code : Optional [ str ] = None , description : Optional [ str ] = None , currency : Optional [ Currency ] = None , auth_code : Optional [ str ] = None , metadata : Optional [ dict ] = None , ) -> Response : \"\"\" Creates a new recipient. A duplicate account number will lead to the retrieval of the existing record. Args: type: Recipient Type. any value from the ``TRType`` enum name: A name for the recipient account_number: Required if ``type`` is ``TRType.NUBAN`` or ``TRType.BASA`` bank_code: Required if ``type`` is ``TRType.NUBAN`` or ``TRType.BASA``. You can get the list of Bank Codes by calling the ``.get_banks`` method from the Miscellaneous API wrapper. description: description currency: currency auth_code: auth code metadata: metadata Returns: A named tuple containing the response gotten from paystack's server. \"\"\" # FIXME: type is a keyword arg, might replace # if it raises issues. if type == RecipientType . NUBAN or type == RecipientType . BASA : if bank_code is None : raise InvalidDataError ( \"`bank_code` is required if type is `TRType.NUBAN` or `TRType.BASA`\" ) url = self . _parse_url ( \"/transferrecipient\" ) payload = { \"type\" : type , \"name\" : name , \"account_number\" : account_number , } optional_params = [ ( \"bank_code\" , bank_code ), ( \"description\" , description ), ( \"currency\" , currency ), ( \"authorization_code\" , auth_code ), ( \"metadata\" , metadata ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) async def bulk_create ( self , batch : list [ Recipient ]) -> Response : # TODO: create a pydantic model # for batch using the fields below. # type: RecipientType, # name: str, # account_number: str, # bank_code: Optional[str] = None, # description: Optional[str] = None, # currency: Optional[utils.Currency] = None, # auth_code: Optional[str] = None, # metadata: Optional[Mapping] = None, \"\"\" Create multiple transfer recipients in batches. A duplicate account number will lead to the retrieval of the existing record. Ars: batch: A list of dictionaries of transfer recipients. Each dictionary should contain ``type``, ``name``, and ``bank_code``. Any Create Transfer Recipient param can also be passed. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" # FIXME: type is a keyword arg, might replace # if it raises issues. batch = [ item . dict for item in batch ] url = self . _parse_url ( \"/transferrecipient/bulk\" ) payload = { \"batch\" : batch , } return await self . _handle_request ( HTTPMethod . POST , url , payload ) async def get_transfer_recipients ( self , page : int = 1 , pagination : int = 50 , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , ) -> Response : \"\"\"Fetch transfer recipients available on your integration Args: page: Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50. start_date: A timestamp from which to start listing transfer recipients e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing transfer recipients e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transferrecipient?perPage= { pagination } \" ) query_params = [ ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url ) async def get_transfer_recipient ( self , id_or_code : str ) -> Response : \"\"\"Fetch the details of a transfer recipient Args: id_or_code: An ID or code for the recipient whose details you want to receive. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transferrecipient/ { id_or_code } \" ) return await self . _handle_request ( HTTPMethod . GET , url ) async def update ( self , id_or_code : str , name : str , email : Optional [ str ] = None ) -> Response : \"\"\" Update an existing recipient. An duplicate account number will lead to the retrieval of the existing record. Args: id_or_code: Transfer Recipient's ID or code name: A name for the recipient email: Email address of the recipient Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transferrecipient/ { id_or_code } \" ) payload = { \"name\" : name } optional_params = [( \"email\" , email )] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . PUT , url , payload ) async def delete ( self , id_or_code : str ) -> Response : \"\"\"Deletes a transfer recipient (sets the transfer recipient to inactive) Args: id_or_code: An ID or code for the recipient who you want to delete. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transferrecipient/ { id_or_code } \" ) return await self . _handle_request ( HTTPMethod . DELETE , url ) bulk_create ( batch ) async Create multiple transfer recipients in batches. A duplicate account number will lead to the retrieval of the existing record. Ars batch: A list of dictionaries of transfer recipients. Each dictionary should contain type , name , and bank_code . Any Create Transfer Recipient param can also be passed. Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transfer_recipients.py 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 async def bulk_create ( self , batch : list [ Recipient ]) -> Response : # TODO: create a pydantic model # for batch using the fields below. # type: RecipientType, # name: str, # account_number: str, # bank_code: Optional[str] = None, # description: Optional[str] = None, # currency: Optional[utils.Currency] = None, # auth_code: Optional[str] = None, # metadata: Optional[Mapping] = None, \"\"\" Create multiple transfer recipients in batches. A duplicate account number will lead to the retrieval of the existing record. Ars: batch: A list of dictionaries of transfer recipients. Each dictionary should contain ``type``, ``name``, and ``bank_code``. Any Create Transfer Recipient param can also be passed. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" # FIXME: type is a keyword arg, might replace # if it raises issues. batch = [ item . dict for item in batch ] url = self . _parse_url ( \"/transferrecipient/bulk\" ) payload = { \"batch\" : batch , } return await self . _handle_request ( HTTPMethod . POST , url , payload ) create ( type , name , account_number , bank_code = None , description = None , currency = None , auth_code = None , metadata = None ) async Creates a new recipient. A duplicate account number will lead to the retrieval of the existing record. Parameters: Name Type Description Default type TransferRecipient Recipient Type. any value from the TRType enum required name str A name for the recipient required account_number str Required if type is TRType.NUBAN or TRType.BASA required bank_code Optional [ str ] Required if type is TRType.NUBAN or TRType.BASA . You can get the list of Bank Codes by calling the .get_banks method from the Miscellaneous API wrapper. None description Optional [ str ] description None currency Optional [ Currency ] currency None auth_code Optional [ str ] auth code None metadata Optional [ dict ] metadata None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transfer_recipients.py 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 async def create ( self , type : TransferRecipient , name : str , account_number : str , bank_code : Optional [ str ] = None , description : Optional [ str ] = None , currency : Optional [ Currency ] = None , auth_code : Optional [ str ] = None , metadata : Optional [ dict ] = None , ) -> Response : \"\"\" Creates a new recipient. A duplicate account number will lead to the retrieval of the existing record. Args: type: Recipient Type. any value from the ``TRType`` enum name: A name for the recipient account_number: Required if ``type`` is ``TRType.NUBAN`` or ``TRType.BASA`` bank_code: Required if ``type`` is ``TRType.NUBAN`` or ``TRType.BASA``. You can get the list of Bank Codes by calling the ``.get_banks`` method from the Miscellaneous API wrapper. description: description currency: currency auth_code: auth code metadata: metadata Returns: A named tuple containing the response gotten from paystack's server. \"\"\" # FIXME: type is a keyword arg, might replace # if it raises issues. if type == RecipientType . NUBAN or type == RecipientType . BASA : if bank_code is None : raise InvalidDataError ( \"`bank_code` is required if type is `TRType.NUBAN` or `TRType.BASA`\" ) url = self . _parse_url ( \"/transferrecipient\" ) payload = { \"type\" : type , \"name\" : name , \"account_number\" : account_number , } optional_params = [ ( \"bank_code\" , bank_code ), ( \"description\" , description ), ( \"currency\" , currency ), ( \"authorization_code\" , auth_code ), ( \"metadata\" , metadata ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) delete ( id_or_code ) async Deletes a transfer recipient (sets the transfer recipient to inactive) Parameters: Name Type Description Default id_or_code str An ID or code for the recipient who you want to delete. required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transfer_recipients.py 357 358 359 360 361 362 363 364 365 366 367 368 async def delete ( self , id_or_code : str ) -> Response : \"\"\"Deletes a transfer recipient (sets the transfer recipient to inactive) Args: id_or_code: An ID or code for the recipient who you want to delete. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transferrecipient/ { id_or_code } \" ) return await self . _handle_request ( HTTPMethod . DELETE , url ) get_transfer_recipient ( id_or_code ) async Fetch the details of a transfer recipient Parameters: Name Type Description Default id_or_code str An ID or code for the recipient whose details you want to receive. required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transfer_recipients.py 323 324 325 326 327 328 329 330 331 332 333 async def get_transfer_recipient ( self , id_or_code : str ) -> Response : \"\"\"Fetch the details of a transfer recipient Args: id_or_code: An ID or code for the recipient whose details you want to receive. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transferrecipient/ { id_or_code } \" ) return await self . _handle_request ( HTTPMethod . GET , url ) get_transfer_recipients ( page = 1 , pagination = 50 , start_date = None , end_date = None ) async Fetch transfer recipients available on your integration Parameters: Name Type Description Default page int Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1. 1 pagination int Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50. 50 start_date Optional [ str ] A timestamp from which to start listing transfer recipients e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None end_date Optional [ str ] A timestamp at which to stop listing transfer recipients e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transfer_recipients.py 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 async def get_transfer_recipients ( self , page : int = 1 , pagination : int = 50 , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , ) -> Response : \"\"\"Fetch transfer recipients available on your integration Args: page: Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50. start_date: A timestamp from which to start listing transfer recipients e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing transfer recipients e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transferrecipient?perPage= { pagination } \" ) query_params = [ ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url ) update ( id_or_code , name , email = None ) async Update an existing recipient. An duplicate account number will lead to the retrieval of the existing record. Parameters: Name Type Description Default id_or_code str Transfer Recipient's ID or code required name str A name for the recipient required email Optional [ str ] Email address of the recipient None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transfer_recipients.py 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 async def update ( self , id_or_code : str , name : str , email : Optional [ str ] = None ) -> Response : \"\"\" Update an existing recipient. An duplicate account number will lead to the retrieval of the existing record. Args: id_or_code: Transfer Recipient's ID or code name: A name for the recipient email: Email address of the recipient Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transferrecipient/ { id_or_code } \" ) payload = { \"name\" : name } optional_params = [( \"email\" , email )] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . PUT , url , payload ) TransferRecipient Bases: BaseAPI Provides a wrapper for paystack Transfer Receipts API The Transfer Recipients API allows you to create and manage beneficiaries that you send money to. https://paystack.com/docs/api/#transfer-recipient Note Feature Availability This feature is only available to businesses in Nigeria and Ghana. Source code in pypaystack2/api/transfer_recipients.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 class TransferRecipient ( BaseAPI ): \"\"\"Provides a wrapper for paystack Transfer Receipts API The Transfer Recipients API allows you to create and manage beneficiaries that you send money to. https://paystack.com/docs/api/#transfer-recipient Note: Feature Availability This feature is only available to businesses in Nigeria and Ghana. \"\"\" def create ( self , type : RecipientType , name : str , account_number : str , bank_code : Optional [ str ] = None , description : Optional [ str ] = None , currency : Optional [ Currency ] = None , auth_code : Optional [ str ] = None , metadata : Optional [ dict ] = None , ) -> Response : \"\"\" Creates a new recipient. A duplicate account number will lead to the retrieval of the existing record. Args: type: Recipient Type. any value from the ``TRType`` enum name: A name for the recipient account_number: Required if ``type`` is ``TRType.NUBAN`` or ``TRType.BASA`` bank_code: Required if ``type`` is ``TRType.NUBAN`` or ``TRType.BASA``. You can get the list of Bank Codes by calling the ``.get_banks`` method from the Miscellaneous API wrapper. description: description currency: currency auth_code: auth code metadata: metadata Returns: A named tuple containing the response gotten from paystack's server. \"\"\" # FIXME: type is a keyword arg, might replace # if it raises issues. if type == RecipientType . NUBAN or type == RecipientType . BASA : if bank_code is None : raise InvalidDataError ( \"`bank_code` is required if type is `TRType.NUBAN` or `TRType.BASA`\" ) url = self . _parse_url ( \"/transferrecipient\" ) payload = { \"type\" : type , \"name\" : name , \"account_number\" : account_number , } optional_params = [ ( \"bank_code\" , bank_code ), ( \"description\" , description ), ( \"currency\" , currency ), ( \"authorization_code\" , auth_code ), ( \"metadata\" , metadata ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . POST , url , payload ) def bulk_create ( self , batch : list [ Recipient ]) -> Response : # TODO: create a pydantic model # for batch using the fields below. # type: RecipientType, # name: str, # account_number: str, # bank_code: Optional[str] = None, # description: Optional[str] = None, # currency: Optional[utils.Currency] = None, # auth_code: Optional[str] = None, # metadata: Optional[Mapping] = None, \"\"\" Create multiple transfer recipients in batches. A duplicate account number will lead to the retrieval of the existing record. Ars: batch: A list of dictionaries of transfer recipients. Each dictionary should contain ``type``, ``name``, and ``bank_code``. Any Create Transfer Recipient param can also be passed. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" batch = [ item . dict for item in batch ] url = self . _parse_url ( \"/transferrecipient/bulk\" ) payload = { \"batch\" : batch , } return self . _handle_request ( HTTPMethod . POST , url , payload ) def get_transfer_recipients ( self , page : int = 1 , pagination : int = 50 , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , ) -> Response : \"\"\"Fetch transfer recipients available on your integration Args: page: Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50. start_date: A timestamp from which to start listing transfer recipients e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing transfer recipients e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transferrecipient?perPage= { pagination } \" ) query_params = [ ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url ) def get_transfer_recipient ( self , id_or_code : str ) -> Response : \"\"\"Fetch the details of a transfer recipient Args: id_or_code: An ID or code for the recipient whose details you want to receive. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transferrecipient/ { id_or_code } \" ) return self . _handle_request ( HTTPMethod . GET , url ) def update ( self , id_or_code : str , name : str , email : Optional [ str ] = None ) -> Response : \"\"\" Update an existing recipient. An duplicate account number will lead to the retrieval of the existing record. Args: id_or_code: Transfer Recipient's ID or code name: A name for the recipient email: Email address of the recipient Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transferrecipient/ { id_or_code } \" ) payload = { \"name\" : name } optional_params = [( \"email\" , email )] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . PUT , url , payload ) def delete ( self , id_or_code : str ) -> Response : \"\"\"Deletes a transfer recipient (sets the transfer recipient to inactive) Args: id_or_code: An ID or code for the recipient who you want to delete. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transferrecipient/ { id_or_code } \" ) return self . _handle_request ( HTTPMethod . DELETE , url ) bulk_create ( batch ) Create multiple transfer recipients in batches. A duplicate account number will lead to the retrieval of the existing record. Ars batch: A list of dictionaries of transfer recipients. Each dictionary should contain type , name , and bank_code . Any Create Transfer Recipient param can also be passed. Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transfer_recipients.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 def bulk_create ( self , batch : list [ Recipient ]) -> Response : # TODO: create a pydantic model # for batch using the fields below. # type: RecipientType, # name: str, # account_number: str, # bank_code: Optional[str] = None, # description: Optional[str] = None, # currency: Optional[utils.Currency] = None, # auth_code: Optional[str] = None, # metadata: Optional[Mapping] = None, \"\"\" Create multiple transfer recipients in batches. A duplicate account number will lead to the retrieval of the existing record. Ars: batch: A list of dictionaries of transfer recipients. Each dictionary should contain ``type``, ``name``, and ``bank_code``. Any Create Transfer Recipient param can also be passed. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" batch = [ item . dict for item in batch ] url = self . _parse_url ( \"/transferrecipient/bulk\" ) payload = { \"batch\" : batch , } return self . _handle_request ( HTTPMethod . POST , url , payload ) create ( type , name , account_number , bank_code = None , description = None , currency = None , auth_code = None , metadata = None ) Creates a new recipient. A duplicate account number will lead to the retrieval of the existing record. Parameters: Name Type Description Default type RecipientType Recipient Type. any value from the TRType enum required name str A name for the recipient required account_number str Required if type is TRType.NUBAN or TRType.BASA required bank_code Optional [ str ] Required if type is TRType.NUBAN or TRType.BASA . You can get the list of Bank Codes by calling the .get_banks method from the Miscellaneous API wrapper. None description Optional [ str ] description None currency Optional [ Currency ] currency None auth_code Optional [ str ] auth code None metadata Optional [ dict ] metadata None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transfer_recipients.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 def create ( self , type : RecipientType , name : str , account_number : str , bank_code : Optional [ str ] = None , description : Optional [ str ] = None , currency : Optional [ Currency ] = None , auth_code : Optional [ str ] = None , metadata : Optional [ dict ] = None , ) -> Response : \"\"\" Creates a new recipient. A duplicate account number will lead to the retrieval of the existing record. Args: type: Recipient Type. any value from the ``TRType`` enum name: A name for the recipient account_number: Required if ``type`` is ``TRType.NUBAN`` or ``TRType.BASA`` bank_code: Required if ``type`` is ``TRType.NUBAN`` or ``TRType.BASA``. You can get the list of Bank Codes by calling the ``.get_banks`` method from the Miscellaneous API wrapper. description: description currency: currency auth_code: auth code metadata: metadata Returns: A named tuple containing the response gotten from paystack's server. \"\"\" # FIXME: type is a keyword arg, might replace # if it raises issues. if type == RecipientType . NUBAN or type == RecipientType . BASA : if bank_code is None : raise InvalidDataError ( \"`bank_code` is required if type is `TRType.NUBAN` or `TRType.BASA`\" ) url = self . _parse_url ( \"/transferrecipient\" ) payload = { \"type\" : type , \"name\" : name , \"account_number\" : account_number , } optional_params = [ ( \"bank_code\" , bank_code ), ( \"description\" , description ), ( \"currency\" , currency ), ( \"authorization_code\" , auth_code ), ( \"metadata\" , metadata ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . POST , url , payload ) delete ( id_or_code ) Deletes a transfer recipient (sets the transfer recipient to inactive) Parameters: Name Type Description Default id_or_code str An ID or code for the recipient who you want to delete. required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transfer_recipients.py 178 179 180 181 182 183 184 185 186 187 188 189 def delete ( self , id_or_code : str ) -> Response : \"\"\"Deletes a transfer recipient (sets the transfer recipient to inactive) Args: id_or_code: An ID or code for the recipient who you want to delete. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transferrecipient/ { id_or_code } \" ) return self . _handle_request ( HTTPMethod . DELETE , url ) get_transfer_recipient ( id_or_code ) Fetch the details of a transfer recipient Parameters: Name Type Description Default id_or_code str An ID or code for the recipient whose details you want to receive. required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transfer_recipients.py 144 145 146 147 148 149 150 151 152 153 154 def get_transfer_recipient ( self , id_or_code : str ) -> Response : \"\"\"Fetch the details of a transfer recipient Args: id_or_code: An ID or code for the recipient whose details you want to receive. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transferrecipient/ { id_or_code } \" ) return self . _handle_request ( HTTPMethod . GET , url ) get_transfer_recipients ( page = 1 , pagination = 50 , start_date = None , end_date = None ) Fetch transfer recipients available on your integration Parameters: Name Type Description Default page int Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1. 1 pagination int Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50. 50 start_date Optional [ str ] A timestamp from which to start listing transfer recipients e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None end_date Optional [ str ] A timestamp at which to stop listing transfer recipients e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transfer_recipients.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 def get_transfer_recipients ( self , page : int = 1 , pagination : int = 50 , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , ) -> Response : \"\"\"Fetch transfer recipients available on your integration Args: page: Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50. start_date: A timestamp from which to start listing transfer recipients e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing transfer recipients e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transferrecipient?perPage= { pagination } \" ) query_params = [ ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url ) update ( id_or_code , name , email = None ) Update an existing recipient. An duplicate account number will lead to the retrieval of the existing record. Parameters: Name Type Description Default id_or_code str Transfer Recipient's ID or code required name str A name for the recipient required email Optional [ str ] Email address of the recipient None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transfer_recipients.py 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 def update ( self , id_or_code : str , name : str , email : Optional [ str ] = None ) -> Response : \"\"\" Update an existing recipient. An duplicate account number will lead to the retrieval of the existing record. Args: id_or_code: Transfer Recipient's ID or code name: A name for the recipient email: Email address of the recipient Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transferrecipient/ { id_or_code } \" ) payload = { \"name\" : name } optional_params = [( \"email\" , email )] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . PUT , url , payload )","title":"Transfer recipients"},{"location":"reference/transfer_recipients/#pypaystack2.api.transfer_recipients.AsyncTransferRecipient","text":"Bases: BaseAsyncAPI Provides a wrapper for paystack Transfer Receipts API The Transfer Recipients API allows you to create and manage beneficiaries that you send money to. https://paystack.com/docs/api/#transfer-recipient Note Feature Availability This feature is only available to businesses in Nigeria and Ghana. Source code in pypaystack2/api/transfer_recipients.py 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 class AsyncTransferRecipient ( BaseAsyncAPI ): \"\"\"Provides a wrapper for paystack Transfer Receipts API The Transfer Recipients API allows you to create and manage beneficiaries that you send money to. https://paystack.com/docs/api/#transfer-recipient Note: Feature Availability This feature is only available to businesses in Nigeria and Ghana. \"\"\" async def create ( self , type : TransferRecipient , name : str , account_number : str , bank_code : Optional [ str ] = None , description : Optional [ str ] = None , currency : Optional [ Currency ] = None , auth_code : Optional [ str ] = None , metadata : Optional [ dict ] = None , ) -> Response : \"\"\" Creates a new recipient. A duplicate account number will lead to the retrieval of the existing record. Args: type: Recipient Type. any value from the ``TRType`` enum name: A name for the recipient account_number: Required if ``type`` is ``TRType.NUBAN`` or ``TRType.BASA`` bank_code: Required if ``type`` is ``TRType.NUBAN`` or ``TRType.BASA``. You can get the list of Bank Codes by calling the ``.get_banks`` method from the Miscellaneous API wrapper. description: description currency: currency auth_code: auth code metadata: metadata Returns: A named tuple containing the response gotten from paystack's server. \"\"\" # FIXME: type is a keyword arg, might replace # if it raises issues. if type == RecipientType . NUBAN or type == RecipientType . BASA : if bank_code is None : raise InvalidDataError ( \"`bank_code` is required if type is `TRType.NUBAN` or `TRType.BASA`\" ) url = self . _parse_url ( \"/transferrecipient\" ) payload = { \"type\" : type , \"name\" : name , \"account_number\" : account_number , } optional_params = [ ( \"bank_code\" , bank_code ), ( \"description\" , description ), ( \"currency\" , currency ), ( \"authorization_code\" , auth_code ), ( \"metadata\" , metadata ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) async def bulk_create ( self , batch : list [ Recipient ]) -> Response : # TODO: create a pydantic model # for batch using the fields below. # type: RecipientType, # name: str, # account_number: str, # bank_code: Optional[str] = None, # description: Optional[str] = None, # currency: Optional[utils.Currency] = None, # auth_code: Optional[str] = None, # metadata: Optional[Mapping] = None, \"\"\" Create multiple transfer recipients in batches. A duplicate account number will lead to the retrieval of the existing record. Ars: batch: A list of dictionaries of transfer recipients. Each dictionary should contain ``type``, ``name``, and ``bank_code``. Any Create Transfer Recipient param can also be passed. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" # FIXME: type is a keyword arg, might replace # if it raises issues. batch = [ item . dict for item in batch ] url = self . _parse_url ( \"/transferrecipient/bulk\" ) payload = { \"batch\" : batch , } return await self . _handle_request ( HTTPMethod . POST , url , payload ) async def get_transfer_recipients ( self , page : int = 1 , pagination : int = 50 , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , ) -> Response : \"\"\"Fetch transfer recipients available on your integration Args: page: Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50. start_date: A timestamp from which to start listing transfer recipients e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing transfer recipients e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transferrecipient?perPage= { pagination } \" ) query_params = [ ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url ) async def get_transfer_recipient ( self , id_or_code : str ) -> Response : \"\"\"Fetch the details of a transfer recipient Args: id_or_code: An ID or code for the recipient whose details you want to receive. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transferrecipient/ { id_or_code } \" ) return await self . _handle_request ( HTTPMethod . GET , url ) async def update ( self , id_or_code : str , name : str , email : Optional [ str ] = None ) -> Response : \"\"\" Update an existing recipient. An duplicate account number will lead to the retrieval of the existing record. Args: id_or_code: Transfer Recipient's ID or code name: A name for the recipient email: Email address of the recipient Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transferrecipient/ { id_or_code } \" ) payload = { \"name\" : name } optional_params = [( \"email\" , email )] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . PUT , url , payload ) async def delete ( self , id_or_code : str ) -> Response : \"\"\"Deletes a transfer recipient (sets the transfer recipient to inactive) Args: id_or_code: An ID or code for the recipient who you want to delete. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transferrecipient/ { id_or_code } \" ) return await self . _handle_request ( HTTPMethod . DELETE , url )","title":"AsyncTransferRecipient"},{"location":"reference/transfer_recipients/#pypaystack2.api.transfer_recipients.AsyncTransferRecipient.bulk_create","text":"Create multiple transfer recipients in batches. A duplicate account number will lead to the retrieval of the existing record. Ars batch: A list of dictionaries of transfer recipients. Each dictionary should contain type , name , and bank_code . Any Create Transfer Recipient param can also be passed. Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transfer_recipients.py 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 async def bulk_create ( self , batch : list [ Recipient ]) -> Response : # TODO: create a pydantic model # for batch using the fields below. # type: RecipientType, # name: str, # account_number: str, # bank_code: Optional[str] = None, # description: Optional[str] = None, # currency: Optional[utils.Currency] = None, # auth_code: Optional[str] = None, # metadata: Optional[Mapping] = None, \"\"\" Create multiple transfer recipients in batches. A duplicate account number will lead to the retrieval of the existing record. Ars: batch: A list of dictionaries of transfer recipients. Each dictionary should contain ``type``, ``name``, and ``bank_code``. Any Create Transfer Recipient param can also be passed. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" # FIXME: type is a keyword arg, might replace # if it raises issues. batch = [ item . dict for item in batch ] url = self . _parse_url ( \"/transferrecipient/bulk\" ) payload = { \"batch\" : batch , } return await self . _handle_request ( HTTPMethod . POST , url , payload )","title":"bulk_create()"},{"location":"reference/transfer_recipients/#pypaystack2.api.transfer_recipients.AsyncTransferRecipient.create","text":"Creates a new recipient. A duplicate account number will lead to the retrieval of the existing record. Parameters: Name Type Description Default type TransferRecipient Recipient Type. any value from the TRType enum required name str A name for the recipient required account_number str Required if type is TRType.NUBAN or TRType.BASA required bank_code Optional [ str ] Required if type is TRType.NUBAN or TRType.BASA . You can get the list of Bank Codes by calling the .get_banks method from the Miscellaneous API wrapper. None description Optional [ str ] description None currency Optional [ Currency ] currency None auth_code Optional [ str ] auth code None metadata Optional [ dict ] metadata None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transfer_recipients.py 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 async def create ( self , type : TransferRecipient , name : str , account_number : str , bank_code : Optional [ str ] = None , description : Optional [ str ] = None , currency : Optional [ Currency ] = None , auth_code : Optional [ str ] = None , metadata : Optional [ dict ] = None , ) -> Response : \"\"\" Creates a new recipient. A duplicate account number will lead to the retrieval of the existing record. Args: type: Recipient Type. any value from the ``TRType`` enum name: A name for the recipient account_number: Required if ``type`` is ``TRType.NUBAN`` or ``TRType.BASA`` bank_code: Required if ``type`` is ``TRType.NUBAN`` or ``TRType.BASA``. You can get the list of Bank Codes by calling the ``.get_banks`` method from the Miscellaneous API wrapper. description: description currency: currency auth_code: auth code metadata: metadata Returns: A named tuple containing the response gotten from paystack's server. \"\"\" # FIXME: type is a keyword arg, might replace # if it raises issues. if type == RecipientType . NUBAN or type == RecipientType . BASA : if bank_code is None : raise InvalidDataError ( \"`bank_code` is required if type is `TRType.NUBAN` or `TRType.BASA`\" ) url = self . _parse_url ( \"/transferrecipient\" ) payload = { \"type\" : type , \"name\" : name , \"account_number\" : account_number , } optional_params = [ ( \"bank_code\" , bank_code ), ( \"description\" , description ), ( \"currency\" , currency ), ( \"authorization_code\" , auth_code ), ( \"metadata\" , metadata ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . POST , url , payload )","title":"create()"},{"location":"reference/transfer_recipients/#pypaystack2.api.transfer_recipients.AsyncTransferRecipient.delete","text":"Deletes a transfer recipient (sets the transfer recipient to inactive) Parameters: Name Type Description Default id_or_code str An ID or code for the recipient who you want to delete. required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transfer_recipients.py 357 358 359 360 361 362 363 364 365 366 367 368 async def delete ( self , id_or_code : str ) -> Response : \"\"\"Deletes a transfer recipient (sets the transfer recipient to inactive) Args: id_or_code: An ID or code for the recipient who you want to delete. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transferrecipient/ { id_or_code } \" ) return await self . _handle_request ( HTTPMethod . DELETE , url )","title":"delete()"},{"location":"reference/transfer_recipients/#pypaystack2.api.transfer_recipients.AsyncTransferRecipient.get_transfer_recipient","text":"Fetch the details of a transfer recipient Parameters: Name Type Description Default id_or_code str An ID or code for the recipient whose details you want to receive. required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transfer_recipients.py 323 324 325 326 327 328 329 330 331 332 333 async def get_transfer_recipient ( self , id_or_code : str ) -> Response : \"\"\"Fetch the details of a transfer recipient Args: id_or_code: An ID or code for the recipient whose details you want to receive. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transferrecipient/ { id_or_code } \" ) return await self . _handle_request ( HTTPMethod . GET , url )","title":"get_transfer_recipient()"},{"location":"reference/transfer_recipients/#pypaystack2.api.transfer_recipients.AsyncTransferRecipient.get_transfer_recipients","text":"Fetch transfer recipients available on your integration Parameters: Name Type Description Default page int Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1. 1 pagination int Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50. 50 start_date Optional [ str ] A timestamp from which to start listing transfer recipients e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None end_date Optional [ str ] A timestamp at which to stop listing transfer recipients e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transfer_recipients.py 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 async def get_transfer_recipients ( self , page : int = 1 , pagination : int = 50 , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , ) -> Response : \"\"\"Fetch transfer recipients available on your integration Args: page: Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50. start_date: A timestamp from which to start listing transfer recipients e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing transfer recipients e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transferrecipient?perPage= { pagination } \" ) query_params = [ ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url )","title":"get_transfer_recipients()"},{"location":"reference/transfer_recipients/#pypaystack2.api.transfer_recipients.AsyncTransferRecipient.update","text":"Update an existing recipient. An duplicate account number will lead to the retrieval of the existing record. Parameters: Name Type Description Default id_or_code str Transfer Recipient's ID or code required name str A name for the recipient required email Optional [ str ] Email address of the recipient None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transfer_recipients.py 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 async def update ( self , id_or_code : str , name : str , email : Optional [ str ] = None ) -> Response : \"\"\" Update an existing recipient. An duplicate account number will lead to the retrieval of the existing record. Args: id_or_code: Transfer Recipient's ID or code name: A name for the recipient email: Email address of the recipient Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transferrecipient/ { id_or_code } \" ) payload = { \"name\" : name } optional_params = [( \"email\" , email )] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . PUT , url , payload )","title":"update()"},{"location":"reference/transfer_recipients/#pypaystack2.api.transfer_recipients.TransferRecipient","text":"Bases: BaseAPI Provides a wrapper for paystack Transfer Receipts API The Transfer Recipients API allows you to create and manage beneficiaries that you send money to. https://paystack.com/docs/api/#transfer-recipient Note Feature Availability This feature is only available to businesses in Nigeria and Ghana. Source code in pypaystack2/api/transfer_recipients.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 class TransferRecipient ( BaseAPI ): \"\"\"Provides a wrapper for paystack Transfer Receipts API The Transfer Recipients API allows you to create and manage beneficiaries that you send money to. https://paystack.com/docs/api/#transfer-recipient Note: Feature Availability This feature is only available to businesses in Nigeria and Ghana. \"\"\" def create ( self , type : RecipientType , name : str , account_number : str , bank_code : Optional [ str ] = None , description : Optional [ str ] = None , currency : Optional [ Currency ] = None , auth_code : Optional [ str ] = None , metadata : Optional [ dict ] = None , ) -> Response : \"\"\" Creates a new recipient. A duplicate account number will lead to the retrieval of the existing record. Args: type: Recipient Type. any value from the ``TRType`` enum name: A name for the recipient account_number: Required if ``type`` is ``TRType.NUBAN`` or ``TRType.BASA`` bank_code: Required if ``type`` is ``TRType.NUBAN`` or ``TRType.BASA``. You can get the list of Bank Codes by calling the ``.get_banks`` method from the Miscellaneous API wrapper. description: description currency: currency auth_code: auth code metadata: metadata Returns: A named tuple containing the response gotten from paystack's server. \"\"\" # FIXME: type is a keyword arg, might replace # if it raises issues. if type == RecipientType . NUBAN or type == RecipientType . BASA : if bank_code is None : raise InvalidDataError ( \"`bank_code` is required if type is `TRType.NUBAN` or `TRType.BASA`\" ) url = self . _parse_url ( \"/transferrecipient\" ) payload = { \"type\" : type , \"name\" : name , \"account_number\" : account_number , } optional_params = [ ( \"bank_code\" , bank_code ), ( \"description\" , description ), ( \"currency\" , currency ), ( \"authorization_code\" , auth_code ), ( \"metadata\" , metadata ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . POST , url , payload ) def bulk_create ( self , batch : list [ Recipient ]) -> Response : # TODO: create a pydantic model # for batch using the fields below. # type: RecipientType, # name: str, # account_number: str, # bank_code: Optional[str] = None, # description: Optional[str] = None, # currency: Optional[utils.Currency] = None, # auth_code: Optional[str] = None, # metadata: Optional[Mapping] = None, \"\"\" Create multiple transfer recipients in batches. A duplicate account number will lead to the retrieval of the existing record. Ars: batch: A list of dictionaries of transfer recipients. Each dictionary should contain ``type``, ``name``, and ``bank_code``. Any Create Transfer Recipient param can also be passed. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" batch = [ item . dict for item in batch ] url = self . _parse_url ( \"/transferrecipient/bulk\" ) payload = { \"batch\" : batch , } return self . _handle_request ( HTTPMethod . POST , url , payload ) def get_transfer_recipients ( self , page : int = 1 , pagination : int = 50 , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , ) -> Response : \"\"\"Fetch transfer recipients available on your integration Args: page: Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50. start_date: A timestamp from which to start listing transfer recipients e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing transfer recipients e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transferrecipient?perPage= { pagination } \" ) query_params = [ ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url ) def get_transfer_recipient ( self , id_or_code : str ) -> Response : \"\"\"Fetch the details of a transfer recipient Args: id_or_code: An ID or code for the recipient whose details you want to receive. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transferrecipient/ { id_or_code } \" ) return self . _handle_request ( HTTPMethod . GET , url ) def update ( self , id_or_code : str , name : str , email : Optional [ str ] = None ) -> Response : \"\"\" Update an existing recipient. An duplicate account number will lead to the retrieval of the existing record. Args: id_or_code: Transfer Recipient's ID or code name: A name for the recipient email: Email address of the recipient Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transferrecipient/ { id_or_code } \" ) payload = { \"name\" : name } optional_params = [( \"email\" , email )] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . PUT , url , payload ) def delete ( self , id_or_code : str ) -> Response : \"\"\"Deletes a transfer recipient (sets the transfer recipient to inactive) Args: id_or_code: An ID or code for the recipient who you want to delete. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transferrecipient/ { id_or_code } \" ) return self . _handle_request ( HTTPMethod . DELETE , url )","title":"TransferRecipient"},{"location":"reference/transfer_recipients/#pypaystack2.api.transfer_recipients.TransferRecipient.bulk_create","text":"Create multiple transfer recipients in batches. A duplicate account number will lead to the retrieval of the existing record. Ars batch: A list of dictionaries of transfer recipients. Each dictionary should contain type , name , and bank_code . Any Create Transfer Recipient param can also be passed. Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transfer_recipients.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 def bulk_create ( self , batch : list [ Recipient ]) -> Response : # TODO: create a pydantic model # for batch using the fields below. # type: RecipientType, # name: str, # account_number: str, # bank_code: Optional[str] = None, # description: Optional[str] = None, # currency: Optional[utils.Currency] = None, # auth_code: Optional[str] = None, # metadata: Optional[Mapping] = None, \"\"\" Create multiple transfer recipients in batches. A duplicate account number will lead to the retrieval of the existing record. Ars: batch: A list of dictionaries of transfer recipients. Each dictionary should contain ``type``, ``name``, and ``bank_code``. Any Create Transfer Recipient param can also be passed. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" batch = [ item . dict for item in batch ] url = self . _parse_url ( \"/transferrecipient/bulk\" ) payload = { \"batch\" : batch , } return self . _handle_request ( HTTPMethod . POST , url , payload )","title":"bulk_create()"},{"location":"reference/transfer_recipients/#pypaystack2.api.transfer_recipients.TransferRecipient.create","text":"Creates a new recipient. A duplicate account number will lead to the retrieval of the existing record. Parameters: Name Type Description Default type RecipientType Recipient Type. any value from the TRType enum required name str A name for the recipient required account_number str Required if type is TRType.NUBAN or TRType.BASA required bank_code Optional [ str ] Required if type is TRType.NUBAN or TRType.BASA . You can get the list of Bank Codes by calling the .get_banks method from the Miscellaneous API wrapper. None description Optional [ str ] description None currency Optional [ Currency ] currency None auth_code Optional [ str ] auth code None metadata Optional [ dict ] metadata None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transfer_recipients.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 def create ( self , type : RecipientType , name : str , account_number : str , bank_code : Optional [ str ] = None , description : Optional [ str ] = None , currency : Optional [ Currency ] = None , auth_code : Optional [ str ] = None , metadata : Optional [ dict ] = None , ) -> Response : \"\"\" Creates a new recipient. A duplicate account number will lead to the retrieval of the existing record. Args: type: Recipient Type. any value from the ``TRType`` enum name: A name for the recipient account_number: Required if ``type`` is ``TRType.NUBAN`` or ``TRType.BASA`` bank_code: Required if ``type`` is ``TRType.NUBAN`` or ``TRType.BASA``. You can get the list of Bank Codes by calling the ``.get_banks`` method from the Miscellaneous API wrapper. description: description currency: currency auth_code: auth code metadata: metadata Returns: A named tuple containing the response gotten from paystack's server. \"\"\" # FIXME: type is a keyword arg, might replace # if it raises issues. if type == RecipientType . NUBAN or type == RecipientType . BASA : if bank_code is None : raise InvalidDataError ( \"`bank_code` is required if type is `TRType.NUBAN` or `TRType.BASA`\" ) url = self . _parse_url ( \"/transferrecipient\" ) payload = { \"type\" : type , \"name\" : name , \"account_number\" : account_number , } optional_params = [ ( \"bank_code\" , bank_code ), ( \"description\" , description ), ( \"currency\" , currency ), ( \"authorization_code\" , auth_code ), ( \"metadata\" , metadata ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . POST , url , payload )","title":"create()"},{"location":"reference/transfer_recipients/#pypaystack2.api.transfer_recipients.TransferRecipient.delete","text":"Deletes a transfer recipient (sets the transfer recipient to inactive) Parameters: Name Type Description Default id_or_code str An ID or code for the recipient who you want to delete. required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transfer_recipients.py 178 179 180 181 182 183 184 185 186 187 188 189 def delete ( self , id_or_code : str ) -> Response : \"\"\"Deletes a transfer recipient (sets the transfer recipient to inactive) Args: id_or_code: An ID or code for the recipient who you want to delete. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transferrecipient/ { id_or_code } \" ) return self . _handle_request ( HTTPMethod . DELETE , url )","title":"delete()"},{"location":"reference/transfer_recipients/#pypaystack2.api.transfer_recipients.TransferRecipient.get_transfer_recipient","text":"Fetch the details of a transfer recipient Parameters: Name Type Description Default id_or_code str An ID or code for the recipient whose details you want to receive. required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transfer_recipients.py 144 145 146 147 148 149 150 151 152 153 154 def get_transfer_recipient ( self , id_or_code : str ) -> Response : \"\"\"Fetch the details of a transfer recipient Args: id_or_code: An ID or code for the recipient whose details you want to receive. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transferrecipient/ { id_or_code } \" ) return self . _handle_request ( HTTPMethod . GET , url )","title":"get_transfer_recipient()"},{"location":"reference/transfer_recipients/#pypaystack2.api.transfer_recipients.TransferRecipient.get_transfer_recipients","text":"Fetch transfer recipients available on your integration Parameters: Name Type Description Default page int Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1. 1 pagination int Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50. 50 start_date Optional [ str ] A timestamp from which to start listing transfer recipients e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None end_date Optional [ str ] A timestamp at which to stop listing transfer recipients e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transfer_recipients.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 def get_transfer_recipients ( self , page : int = 1 , pagination : int = 50 , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , ) -> Response : \"\"\"Fetch transfer recipients available on your integration Args: page: Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50. start_date: A timestamp from which to start listing transfer recipients e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 end_date: A timestamp at which to stop listing transfer recipients e.g. 2016-09-24T00:00:05.000Z, 2016-09-21 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transferrecipient?perPage= { pagination } \" ) query_params = [ ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url )","title":"get_transfer_recipients()"},{"location":"reference/transfer_recipients/#pypaystack2.api.transfer_recipients.TransferRecipient.update","text":"Update an existing recipient. An duplicate account number will lead to the retrieval of the existing record. Parameters: Name Type Description Default id_or_code str Transfer Recipient's ID or code required name str A name for the recipient required email Optional [ str ] Email address of the recipient None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transfer_recipients.py 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 def update ( self , id_or_code : str , name : str , email : Optional [ str ] = None ) -> Response : \"\"\" Update an existing recipient. An duplicate account number will lead to the retrieval of the existing record. Args: id_or_code: Transfer Recipient's ID or code name: A name for the recipient email: Email address of the recipient Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transferrecipient/ { id_or_code } \" ) payload = { \"name\" : name } optional_params = [( \"email\" , email )] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . PUT , url , payload )","title":"update()"},{"location":"reference/transfers/","text":"AsyncTransfer Bases: BaseAsyncAPI Provides a wrapper for paystack Transfers API The Transfers API allows you to automate sending money on your integration https://paystack.com/docs/api/#transfer Note This feature is only available to businesses in Nigeria and Ghana. Source code in pypaystack2/api/transfers.py 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 class AsyncTransfer ( BaseAsyncAPI ): \"\"\"Provides a wrapper for paystack Transfers API The Transfers API allows you to automate sending money on your integration https://paystack.com/docs/api/#transfer Note ---- This feature is only available to businesses in Nigeria and Ghana. \"\"\" async def initiate ( self , amount : int , recipient : str , reason : Optional [ str ] = None , currency : Optional [ Currency ] = None , reference : Optional [ str ] = None , source : str = \"balance\" , ) -> Response : \"\"\"Initiate transfer Args: amount: amount to transfer recipient: the beneficiary of the transfer reason: narration of the transfer currency: transfer currency reference: reference id source: transfer source Returns: A named tuple containing the response gotten from paystack's server. \"\"\" amount = validate_amount ( amount ) url = self . _parse_url ( \"/transfer\" ) payload = { \"amount\" : amount , \"recipient\" : recipient , \"source\" : source , } optional_params = [ ( \"reason\" , reason ), ( \"reference\" , reference ), ( \"currency\" , currency ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) async def finalize ( self , transfer_code : str , otp : str , ) -> Response : \"\"\"Finalize transfer Args: transfer_code: The code for transfer. otp: One time password. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/transfer/finalize_transfer\" ) payload = { \"transfer_code\" : transfer_code , \"otp\" : otp , } return await self . _handle_request ( HTTPMethod . POST , url , payload ) async def bulk_transfer ( self , transfers : list [ TransferInstruction ], source : str = \"balance\" ) -> Response : \"\"\"Transfer in bulk Args: transfers: list of transfer instructions source: source of the funds to transfer Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/transfer/bulk\" ) payload = { \"transfers\" : [ tx . dict for tx in transfers ], \"source\" : source , } return await self . _handle_request ( HTTPMethod . POST , url , payload ) async def get_transfers ( self , page : int = 1 , pagination : int = 50 , customer : Optional [ str ] = None , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , ) -> Response : \"\"\"Retrieve transfers made to a customer Args: customer: customer id page: Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50. start_date: A timestamp from which to start listing refund e.g. 2016-09-21 end_date: A timestamp at which to stop listing refund e.g. 2016-09-21 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transfer?perPage= { pagination } \" ) query_params = [ ( \"customer\" , customer ), ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url ) async def get_transfer ( self , id_or_code : str , ) -> Response : \"\"\"Retrieve a transfer Args: id_or_code: transfer ID or code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transfer/ { id_or_code } \" ) return await self . _handle_request ( HTTPMethod . GET , url ) async def verify ( self , reference : str , ) -> Response : \"\"\"Verify a transfer Args: reference: str Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transfer/verify/ { reference } \" ) return await self . _handle_request ( HTTPMethod . GET , url ) bulk_transfer ( transfers , source = 'balance' ) async Transfer in bulk Parameters: Name Type Description Default transfers list [ TransferInstruction ] list of transfer instructions required source str source of the funds to transfer 'balance' Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transfers.py 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 async def bulk_transfer ( self , transfers : list [ TransferInstruction ], source : str = \"balance\" ) -> Response : \"\"\"Transfer in bulk Args: transfers: list of transfer instructions source: source of the funds to transfer Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/transfer/bulk\" ) payload = { \"transfers\" : [ tx . dict for tx in transfers ], \"source\" : source , } return await self . _handle_request ( HTTPMethod . POST , url , payload ) finalize ( transfer_code , otp ) async Finalize transfer Parameters: Name Type Description Default transfer_code str The code for transfer. required otp str One time password. required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transfers.py 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 async def finalize ( self , transfer_code : str , otp : str , ) -> Response : \"\"\"Finalize transfer Args: transfer_code: The code for transfer. otp: One time password. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/transfer/finalize_transfer\" ) payload = { \"transfer_code\" : transfer_code , \"otp\" : otp , } return await self . _handle_request ( HTTPMethod . POST , url , payload ) get_transfer ( id_or_code ) async Retrieve a transfer Parameters: Name Type Description Default id_or_code str transfer ID or code required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transfers.py 298 299 300 301 302 303 304 305 306 307 308 309 310 311 async def get_transfer ( self , id_or_code : str , ) -> Response : \"\"\"Retrieve a transfer Args: id_or_code: transfer ID or code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transfer/ { id_or_code } \" ) return await self . _handle_request ( HTTPMethod . GET , url ) get_transfers ( page = 1 , pagination = 50 , customer = None , start_date = None , end_date = None ) async Retrieve transfers made to a customer Parameters: Name Type Description Default customer Optional [ str ] customer id None page int Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1. 1 pagination int Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50. 50 start_date Optional [ str ] A timestamp from which to start listing refund e.g. 2016-09-21 None end_date Optional [ str ] A timestamp at which to stop listing refund e.g. 2016-09-21 None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transfers.py 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 async def get_transfers ( self , page : int = 1 , pagination : int = 50 , customer : Optional [ str ] = None , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , ) -> Response : \"\"\"Retrieve transfers made to a customer Args: customer: customer id page: Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50. start_date: A timestamp from which to start listing refund e.g. 2016-09-21 end_date: A timestamp at which to stop listing refund e.g. 2016-09-21 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transfer?perPage= { pagination } \" ) query_params = [ ( \"customer\" , customer ), ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url ) initiate ( amount , recipient , reason = None , currency = None , reference = None , source = 'balance' ) async Initiate transfer Parameters: Name Type Description Default amount int amount to transfer required recipient str the beneficiary of the transfer required reason Optional [ str ] narration of the transfer None currency Optional [ Currency ] transfer currency None reference Optional [ str ] reference id None source str transfer source 'balance' Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transfers.py 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 async def initiate ( self , amount : int , recipient : str , reason : Optional [ str ] = None , currency : Optional [ Currency ] = None , reference : Optional [ str ] = None , source : str = \"balance\" , ) -> Response : \"\"\"Initiate transfer Args: amount: amount to transfer recipient: the beneficiary of the transfer reason: narration of the transfer currency: transfer currency reference: reference id source: transfer source Returns: A named tuple containing the response gotten from paystack's server. \"\"\" amount = validate_amount ( amount ) url = self . _parse_url ( \"/transfer\" ) payload = { \"amount\" : amount , \"recipient\" : recipient , \"source\" : source , } optional_params = [ ( \"reason\" , reason ), ( \"reference\" , reference ), ( \"currency\" , currency ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) verify ( reference ) async Verify a transfer Parameters: Name Type Description Default reference str str required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transfers.py 313 314 315 316 317 318 319 320 321 322 323 324 325 326 async def verify ( self , reference : str , ) -> Response : \"\"\"Verify a transfer Args: reference: str Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transfer/verify/ { reference } \" ) return await self . _handle_request ( HTTPMethod . GET , url ) Transfer Bases: BaseAPI Provides a wrapper for paystack Transfers API The Transfers API allows you to automate sending money on your integration https://paystack.com/docs/api/#transfer Note This feature is only available to businesses in Nigeria and Ghana. Source code in pypaystack2/api/transfers.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 class Transfer ( BaseAPI ): \"\"\"Provides a wrapper for paystack Transfers API The Transfers API allows you to automate sending money on your integration https://paystack.com/docs/api/#transfer Note ---- This feature is only available to businesses in Nigeria and Ghana. \"\"\" def initiate ( self , amount : int , recipient : str , reason : Optional [ str ] = None , currency : Optional [ Currency ] = None , reference : Optional [ str ] = None , source : str = \"balance\" , ) -> Response : \"\"\"Initiate transfer Args: amount: amount to transfer recipient: the beneficiary of the transfer reason: narration of the transfer currency: transfer currency reference: reference id source: transfer source Returns: A named tuple containing the response gotten from paystack's server. \"\"\" amount = validate_amount ( amount ) url = self . _parse_url ( \"/transfer\" ) payload = { \"amount\" : amount , \"recipient\" : recipient , \"source\" : source , } optional_params = [ ( \"reason\" , reason ), ( \"reference\" , reference ), ( \"currency\" , currency ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . POST , url , payload ) def finalize ( self , transfer_code : str , otp : str , ) -> Response : \"\"\"Finalize transfer Args: transfer_code: The code for transfer. otp: One time password. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/transfer/finalize_transfer\" ) payload = { \"transfer_code\" : transfer_code , \"otp\" : otp , } return self . _handle_request ( HTTPMethod . POST , url , payload ) def bulk_transfer ( self , transfers : list [ TransferInstruction ], source : str = \"balance\" ) -> Response : \"\"\"Transfer in bulk Args: transfers: list of transfer instructions source: source of the funds to transfer Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/transfer/bulk\" ) payload = { \"transfers\" : [ tx . dict for tx in transfers ], \"source\" : source , } return self . _handle_request ( HTTPMethod . POST , url , payload ) def get_transfers ( self , page : int = 1 , pagination : int = 50 , customer : Optional [ str ] = None , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , ) -> Response : \"\"\"Retrieve transfers made to a customer Args: customer: customer id page: Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50. start_date: A timestamp from which to start listing refund e.g. 2016-09-21 end_date: A timestamp at which to stop listing refund e.g. 2016-09-21 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transfer?perPage= { pagination } \" ) query_params = [ ( \"customer\" , customer ), ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url ) def get_transfer ( self , id_or_code : str , ) -> Response : \"\"\"Retrieve a transfer Args: id_or_code: transfer ID or code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transfer/ { id_or_code } \" ) return self . _handle_request ( HTTPMethod . GET , url ) def verify ( self , reference : str , ) -> Response : \"\"\"Verify a transfer Args: reference: str Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transfer/verify/ { reference } \" ) return self . _handle_request ( HTTPMethod . GET , url ) bulk_transfer ( transfers , source = 'balance' ) Transfer in bulk Parameters: Name Type Description Default transfers list [ TransferInstruction ] list of transfer instructions required source str source of the funds to transfer 'balance' Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transfers.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 def bulk_transfer ( self , transfers : list [ TransferInstruction ], source : str = \"balance\" ) -> Response : \"\"\"Transfer in bulk Args: transfers: list of transfer instructions source: source of the funds to transfer Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/transfer/bulk\" ) payload = { \"transfers\" : [ tx . dict for tx in transfers ], \"source\" : source , } return self . _handle_request ( HTTPMethod . POST , url , payload ) finalize ( transfer_code , otp ) Finalize transfer Parameters: Name Type Description Default transfer_code str The code for transfer. required otp str One time password. required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transfers.py 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 def finalize ( self , transfer_code : str , otp : str , ) -> Response : \"\"\"Finalize transfer Args: transfer_code: The code for transfer. otp: One time password. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/transfer/finalize_transfer\" ) payload = { \"transfer_code\" : transfer_code , \"otp\" : otp , } return self . _handle_request ( HTTPMethod . POST , url , payload ) get_transfer ( id_or_code ) Retrieve a transfer Parameters: Name Type Description Default id_or_code str transfer ID or code required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transfers.py 141 142 143 144 145 146 147 148 149 150 151 152 153 154 def get_transfer ( self , id_or_code : str , ) -> Response : \"\"\"Retrieve a transfer Args: id_or_code: transfer ID or code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transfer/ { id_or_code } \" ) return self . _handle_request ( HTTPMethod . GET , url ) get_transfers ( page = 1 , pagination = 50 , customer = None , start_date = None , end_date = None ) Retrieve transfers made to a customer Parameters: Name Type Description Default customer Optional [ str ] customer id None page int Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1. 1 pagination int Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50. 50 start_date Optional [ str ] A timestamp from which to start listing refund e.g. 2016-09-21 None end_date Optional [ str ] A timestamp at which to stop listing refund e.g. 2016-09-21 None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transfers.py 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 def get_transfers ( self , page : int = 1 , pagination : int = 50 , customer : Optional [ str ] = None , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , ) -> Response : \"\"\"Retrieve transfers made to a customer Args: customer: customer id page: Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50. start_date: A timestamp from which to start listing refund e.g. 2016-09-21 end_date: A timestamp at which to stop listing refund e.g. 2016-09-21 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transfer?perPage= { pagination } \" ) query_params = [ ( \"customer\" , customer ), ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url ) initiate ( amount , recipient , reason = None , currency = None , reference = None , source = 'balance' ) Initiate transfer Parameters: Name Type Description Default amount int amount to transfer required recipient str the beneficiary of the transfer required reason Optional [ str ] narration of the transfer None currency Optional [ Currency ] transfer currency None reference Optional [ str ] reference id None source str transfer source 'balance' Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transfers.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 def initiate ( self , amount : int , recipient : str , reason : Optional [ str ] = None , currency : Optional [ Currency ] = None , reference : Optional [ str ] = None , source : str = \"balance\" , ) -> Response : \"\"\"Initiate transfer Args: amount: amount to transfer recipient: the beneficiary of the transfer reason: narration of the transfer currency: transfer currency reference: reference id source: transfer source Returns: A named tuple containing the response gotten from paystack's server. \"\"\" amount = validate_amount ( amount ) url = self . _parse_url ( \"/transfer\" ) payload = { \"amount\" : amount , \"recipient\" : recipient , \"source\" : source , } optional_params = [ ( \"reason\" , reason ), ( \"reference\" , reference ), ( \"currency\" , currency ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . POST , url , payload ) verify ( reference ) Verify a transfer Parameters: Name Type Description Default reference str str required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transfers.py 156 157 158 159 160 161 162 163 164 165 166 167 168 169 def verify ( self , reference : str , ) -> Response : \"\"\"Verify a transfer Args: reference: str Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transfer/verify/ { reference } \" ) return self . _handle_request ( HTTPMethod . GET , url )","title":"Transfers"},{"location":"reference/transfers/#pypaystack2.api.transfers.AsyncTransfer","text":"Bases: BaseAsyncAPI Provides a wrapper for paystack Transfers API The Transfers API allows you to automate sending money on your integration https://paystack.com/docs/api/#transfer","title":"AsyncTransfer"},{"location":"reference/transfers/#pypaystack2.api.transfers.AsyncTransfer--note","text":"This feature is only available to businesses in Nigeria and Ghana. Source code in pypaystack2/api/transfers.py 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 class AsyncTransfer ( BaseAsyncAPI ): \"\"\"Provides a wrapper for paystack Transfers API The Transfers API allows you to automate sending money on your integration https://paystack.com/docs/api/#transfer Note ---- This feature is only available to businesses in Nigeria and Ghana. \"\"\" async def initiate ( self , amount : int , recipient : str , reason : Optional [ str ] = None , currency : Optional [ Currency ] = None , reference : Optional [ str ] = None , source : str = \"balance\" , ) -> Response : \"\"\"Initiate transfer Args: amount: amount to transfer recipient: the beneficiary of the transfer reason: narration of the transfer currency: transfer currency reference: reference id source: transfer source Returns: A named tuple containing the response gotten from paystack's server. \"\"\" amount = validate_amount ( amount ) url = self . _parse_url ( \"/transfer\" ) payload = { \"amount\" : amount , \"recipient\" : recipient , \"source\" : source , } optional_params = [ ( \"reason\" , reason ), ( \"reference\" , reference ), ( \"currency\" , currency ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) async def finalize ( self , transfer_code : str , otp : str , ) -> Response : \"\"\"Finalize transfer Args: transfer_code: The code for transfer. otp: One time password. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/transfer/finalize_transfer\" ) payload = { \"transfer_code\" : transfer_code , \"otp\" : otp , } return await self . _handle_request ( HTTPMethod . POST , url , payload ) async def bulk_transfer ( self , transfers : list [ TransferInstruction ], source : str = \"balance\" ) -> Response : \"\"\"Transfer in bulk Args: transfers: list of transfer instructions source: source of the funds to transfer Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/transfer/bulk\" ) payload = { \"transfers\" : [ tx . dict for tx in transfers ], \"source\" : source , } return await self . _handle_request ( HTTPMethod . POST , url , payload ) async def get_transfers ( self , page : int = 1 , pagination : int = 50 , customer : Optional [ str ] = None , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , ) -> Response : \"\"\"Retrieve transfers made to a customer Args: customer: customer id page: Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50. start_date: A timestamp from which to start listing refund e.g. 2016-09-21 end_date: A timestamp at which to stop listing refund e.g. 2016-09-21 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transfer?perPage= { pagination } \" ) query_params = [ ( \"customer\" , customer ), ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url ) async def get_transfer ( self , id_or_code : str , ) -> Response : \"\"\"Retrieve a transfer Args: id_or_code: transfer ID or code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transfer/ { id_or_code } \" ) return await self . _handle_request ( HTTPMethod . GET , url ) async def verify ( self , reference : str , ) -> Response : \"\"\"Verify a transfer Args: reference: str Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transfer/verify/ { reference } \" ) return await self . _handle_request ( HTTPMethod . GET , url )","title":"Note"},{"location":"reference/transfers/#pypaystack2.api.transfers.AsyncTransfer.bulk_transfer","text":"Transfer in bulk Parameters: Name Type Description Default transfers list [ TransferInstruction ] list of transfer instructions required source str source of the funds to transfer 'balance' Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transfers.py 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 async def bulk_transfer ( self , transfers : list [ TransferInstruction ], source : str = \"balance\" ) -> Response : \"\"\"Transfer in bulk Args: transfers: list of transfer instructions source: source of the funds to transfer Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/transfer/bulk\" ) payload = { \"transfers\" : [ tx . dict for tx in transfers ], \"source\" : source , } return await self . _handle_request ( HTTPMethod . POST , url , payload )","title":"bulk_transfer()"},{"location":"reference/transfers/#pypaystack2.api.transfers.AsyncTransfer.finalize","text":"Finalize transfer Parameters: Name Type Description Default transfer_code str The code for transfer. required otp str One time password. required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transfers.py 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 async def finalize ( self , transfer_code : str , otp : str , ) -> Response : \"\"\"Finalize transfer Args: transfer_code: The code for transfer. otp: One time password. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/transfer/finalize_transfer\" ) payload = { \"transfer_code\" : transfer_code , \"otp\" : otp , } return await self . _handle_request ( HTTPMethod . POST , url , payload )","title":"finalize()"},{"location":"reference/transfers/#pypaystack2.api.transfers.AsyncTransfer.get_transfer","text":"Retrieve a transfer Parameters: Name Type Description Default id_or_code str transfer ID or code required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transfers.py 298 299 300 301 302 303 304 305 306 307 308 309 310 311 async def get_transfer ( self , id_or_code : str , ) -> Response : \"\"\"Retrieve a transfer Args: id_or_code: transfer ID or code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transfer/ { id_or_code } \" ) return await self . _handle_request ( HTTPMethod . GET , url )","title":"get_transfer()"},{"location":"reference/transfers/#pypaystack2.api.transfers.AsyncTransfer.get_transfers","text":"Retrieve transfers made to a customer Parameters: Name Type Description Default customer Optional [ str ] customer id None page int Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1. 1 pagination int Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50. 50 start_date Optional [ str ] A timestamp from which to start listing refund e.g. 2016-09-21 None end_date Optional [ str ] A timestamp at which to stop listing refund e.g. 2016-09-21 None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transfers.py 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 async def get_transfers ( self , page : int = 1 , pagination : int = 50 , customer : Optional [ str ] = None , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , ) -> Response : \"\"\"Retrieve transfers made to a customer Args: customer: customer id page: Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50. start_date: A timestamp from which to start listing refund e.g. 2016-09-21 end_date: A timestamp at which to stop listing refund e.g. 2016-09-21 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transfer?perPage= { pagination } \" ) query_params = [ ( \"customer\" , customer ), ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ] url = append_query_params ( query_params , url ) return await self . _handle_request ( HTTPMethod . GET , url )","title":"get_transfers()"},{"location":"reference/transfers/#pypaystack2.api.transfers.AsyncTransfer.initiate","text":"Initiate transfer Parameters: Name Type Description Default amount int amount to transfer required recipient str the beneficiary of the transfer required reason Optional [ str ] narration of the transfer None currency Optional [ Currency ] transfer currency None reference Optional [ str ] reference id None source str transfer source 'balance' Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transfers.py 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 async def initiate ( self , amount : int , recipient : str , reason : Optional [ str ] = None , currency : Optional [ Currency ] = None , reference : Optional [ str ] = None , source : str = \"balance\" , ) -> Response : \"\"\"Initiate transfer Args: amount: amount to transfer recipient: the beneficiary of the transfer reason: narration of the transfer currency: transfer currency reference: reference id source: transfer source Returns: A named tuple containing the response gotten from paystack's server. \"\"\" amount = validate_amount ( amount ) url = self . _parse_url ( \"/transfer\" ) payload = { \"amount\" : amount , \"recipient\" : recipient , \"source\" : source , } optional_params = [ ( \"reason\" , reason ), ( \"reference\" , reference ), ( \"currency\" , currency ), ] payload = add_to_payload ( optional_params , payload ) return await self . _handle_request ( HTTPMethod . POST , url , payload )","title":"initiate()"},{"location":"reference/transfers/#pypaystack2.api.transfers.AsyncTransfer.verify","text":"Verify a transfer Parameters: Name Type Description Default reference str str required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transfers.py 313 314 315 316 317 318 319 320 321 322 323 324 325 326 async def verify ( self , reference : str , ) -> Response : \"\"\"Verify a transfer Args: reference: str Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transfer/verify/ { reference } \" ) return await self . _handle_request ( HTTPMethod . GET , url )","title":"verify()"},{"location":"reference/transfers/#pypaystack2.api.transfers.Transfer","text":"Bases: BaseAPI Provides a wrapper for paystack Transfers API The Transfers API allows you to automate sending money on your integration https://paystack.com/docs/api/#transfer","title":"Transfer"},{"location":"reference/transfers/#pypaystack2.api.transfers.Transfer--note","text":"This feature is only available to businesses in Nigeria and Ghana. Source code in pypaystack2/api/transfers.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 class Transfer ( BaseAPI ): \"\"\"Provides a wrapper for paystack Transfers API The Transfers API allows you to automate sending money on your integration https://paystack.com/docs/api/#transfer Note ---- This feature is only available to businesses in Nigeria and Ghana. \"\"\" def initiate ( self , amount : int , recipient : str , reason : Optional [ str ] = None , currency : Optional [ Currency ] = None , reference : Optional [ str ] = None , source : str = \"balance\" , ) -> Response : \"\"\"Initiate transfer Args: amount: amount to transfer recipient: the beneficiary of the transfer reason: narration of the transfer currency: transfer currency reference: reference id source: transfer source Returns: A named tuple containing the response gotten from paystack's server. \"\"\" amount = validate_amount ( amount ) url = self . _parse_url ( \"/transfer\" ) payload = { \"amount\" : amount , \"recipient\" : recipient , \"source\" : source , } optional_params = [ ( \"reason\" , reason ), ( \"reference\" , reference ), ( \"currency\" , currency ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . POST , url , payload ) def finalize ( self , transfer_code : str , otp : str , ) -> Response : \"\"\"Finalize transfer Args: transfer_code: The code for transfer. otp: One time password. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/transfer/finalize_transfer\" ) payload = { \"transfer_code\" : transfer_code , \"otp\" : otp , } return self . _handle_request ( HTTPMethod . POST , url , payload ) def bulk_transfer ( self , transfers : list [ TransferInstruction ], source : str = \"balance\" ) -> Response : \"\"\"Transfer in bulk Args: transfers: list of transfer instructions source: source of the funds to transfer Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/transfer/bulk\" ) payload = { \"transfers\" : [ tx . dict for tx in transfers ], \"source\" : source , } return self . _handle_request ( HTTPMethod . POST , url , payload ) def get_transfers ( self , page : int = 1 , pagination : int = 50 , customer : Optional [ str ] = None , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , ) -> Response : \"\"\"Retrieve transfers made to a customer Args: customer: customer id page: Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50. start_date: A timestamp from which to start listing refund e.g. 2016-09-21 end_date: A timestamp at which to stop listing refund e.g. 2016-09-21 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transfer?perPage= { pagination } \" ) query_params = [ ( \"customer\" , customer ), ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url ) def get_transfer ( self , id_or_code : str , ) -> Response : \"\"\"Retrieve a transfer Args: id_or_code: transfer ID or code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transfer/ { id_or_code } \" ) return self . _handle_request ( HTTPMethod . GET , url ) def verify ( self , reference : str , ) -> Response : \"\"\"Verify a transfer Args: reference: str Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transfer/verify/ { reference } \" ) return self . _handle_request ( HTTPMethod . GET , url )","title":"Note"},{"location":"reference/transfers/#pypaystack2.api.transfers.Transfer.bulk_transfer","text":"Transfer in bulk Parameters: Name Type Description Default transfers list [ TransferInstruction ] list of transfer instructions required source str source of the funds to transfer 'balance' Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transfers.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 def bulk_transfer ( self , transfers : list [ TransferInstruction ], source : str = \"balance\" ) -> Response : \"\"\"Transfer in bulk Args: transfers: list of transfer instructions source: source of the funds to transfer Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/transfer/bulk\" ) payload = { \"transfers\" : [ tx . dict for tx in transfers ], \"source\" : source , } return self . _handle_request ( HTTPMethod . POST , url , payload )","title":"bulk_transfer()"},{"location":"reference/transfers/#pypaystack2.api.transfers.Transfer.finalize","text":"Finalize transfer Parameters: Name Type Description Default transfer_code str The code for transfer. required otp str One time password. required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transfers.py 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 def finalize ( self , transfer_code : str , otp : str , ) -> Response : \"\"\"Finalize transfer Args: transfer_code: The code for transfer. otp: One time password. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/transfer/finalize_transfer\" ) payload = { \"transfer_code\" : transfer_code , \"otp\" : otp , } return self . _handle_request ( HTTPMethod . POST , url , payload )","title":"finalize()"},{"location":"reference/transfers/#pypaystack2.api.transfers.Transfer.get_transfer","text":"Retrieve a transfer Parameters: Name Type Description Default id_or_code str transfer ID or code required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transfers.py 141 142 143 144 145 146 147 148 149 150 151 152 153 154 def get_transfer ( self , id_or_code : str , ) -> Response : \"\"\"Retrieve a transfer Args: id_or_code: transfer ID or code Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transfer/ { id_or_code } \" ) return self . _handle_request ( HTTPMethod . GET , url )","title":"get_transfer()"},{"location":"reference/transfers/#pypaystack2.api.transfers.Transfer.get_transfers","text":"Retrieve transfers made to a customer Parameters: Name Type Description Default customer Optional [ str ] customer id None page int Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1. 1 pagination int Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50. 50 start_date Optional [ str ] A timestamp from which to start listing refund e.g. 2016-09-21 None end_date Optional [ str ] A timestamp at which to stop listing refund e.g. 2016-09-21 None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transfers.py 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 def get_transfers ( self , page : int = 1 , pagination : int = 50 , customer : Optional [ str ] = None , start_date : Optional [ str ] = None , end_date : Optional [ str ] = None , ) -> Response : \"\"\"Retrieve transfers made to a customer Args: customer: customer id page: Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1. pagination: Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50. start_date: A timestamp from which to start listing refund e.g. 2016-09-21 end_date: A timestamp at which to stop listing refund e.g. 2016-09-21 Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transfer?perPage= { pagination } \" ) query_params = [ ( \"customer\" , customer ), ( \"page\" , page ), ( \"from\" , start_date ), ( \"to\" , end_date ), ] url = append_query_params ( query_params , url ) return self . _handle_request ( HTTPMethod . GET , url )","title":"get_transfers()"},{"location":"reference/transfers/#pypaystack2.api.transfers.Transfer.initiate","text":"Initiate transfer Parameters: Name Type Description Default amount int amount to transfer required recipient str the beneficiary of the transfer required reason Optional [ str ] narration of the transfer None currency Optional [ Currency ] transfer currency None reference Optional [ str ] reference id None source str transfer source 'balance' Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transfers.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 def initiate ( self , amount : int , recipient : str , reason : Optional [ str ] = None , currency : Optional [ Currency ] = None , reference : Optional [ str ] = None , source : str = \"balance\" , ) -> Response : \"\"\"Initiate transfer Args: amount: amount to transfer recipient: the beneficiary of the transfer reason: narration of the transfer currency: transfer currency reference: reference id source: transfer source Returns: A named tuple containing the response gotten from paystack's server. \"\"\" amount = validate_amount ( amount ) url = self . _parse_url ( \"/transfer\" ) payload = { \"amount\" : amount , \"recipient\" : recipient , \"source\" : source , } optional_params = [ ( \"reason\" , reason ), ( \"reference\" , reference ), ( \"currency\" , currency ), ] payload = add_to_payload ( optional_params , payload ) return self . _handle_request ( HTTPMethod . POST , url , payload )","title":"initiate()"},{"location":"reference/transfers/#pypaystack2.api.transfers.Transfer.verify","text":"Verify a transfer Parameters: Name Type Description Default reference str str required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transfers.py 156 157 158 159 160 161 162 163 164 165 166 167 168 169 def verify ( self , reference : str , ) -> Response : \"\"\"Verify a transfer Args: reference: str Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/transfer/verify/ { reference } \" ) return self . _handle_request ( HTTPMethod . GET , url )","title":"verify()"},{"location":"reference/transfers_control/","text":"AsyncTransferControl Bases: BaseAsyncAPI Provides a wrapper for paystack Transfers Control API The Transfer Control API allows you to manage settings of your transfers. https://paystack.com/docs/api/#transfer-control Source code in pypaystack2/api/transfers_control.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 class AsyncTransferControl ( BaseAsyncAPI ): \"\"\"Provides a wrapper for paystack Transfers Control API The Transfer Control API allows you to manage settings of your transfers. https://paystack.com/docs/api/#transfer-control \"\"\" async def check_balance ( self ) -> Response : \"\"\"Fetch the available balance on your integration Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/balance\" ) return await self . _handle_request ( HTTPMethod . GET , url ) async def get_balance_ledger ( self ) -> Response : \"\"\"Fetch all pay-ins and pay-outs that occured on your integration Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"balance/ledger\" ) return await self . _handle_request ( HTTPMethod . GET , url ) async def resend_otp ( self , transfer_code : str , reason : Reason ) -> Response : \"\"\" Generates a new OTP and sends to customer in the event they are having trouble receiving one. Note: Feature Availability This feature is only available to businesses in Nigeria and Ghana. Args: transfer_code: Transfer code reason: Any value from the ``Reason`` enum Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"transfer_code\" : transfer_code , \"reason\" : reason } url = self . _parse_url ( \"/transfer/resend_otp\" ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) async def disable_otp ( self ) -> Response : \"\"\" This is used in the event that you want to be able to complete transfers programmatically without use of OTPs. No arguments required. You will get an OTP to complete the request Note: Feature Availability This feature is only available to businesses in Nigeria and Ghana. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/transfer/disable_otp\" ) return await self . _handle_request ( HTTPMethod . POST , url ) async def finalize_disable_otp ( self , otp : str ) -> Response : \"\"\"Finalize the request to disable OTP on your transfers. Note: Feature Availability This feature is only available to businesses in Nigeria and Ghana. Args: otp: One time password Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"otp\" : otp } url = self . _parse_url ( \"/transfer/disable_otp_finalize\" ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) async def enable_otp ( self ) -> Response : \"\"\" In the event that a customer wants to stop being able to complete transfers programmatically, this endpoint helps turn OTP requirement back on. No arguments required. Note: Feature Availability This feature is only available to businesses in Nigeria and Ghana. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/transfer/enable_otp\" ) return await self . _handle_request ( HTTPMethod . POST , url ) check_balance () async Fetch the available balance on your integration Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transfers_control.py 107 108 109 110 111 112 113 114 async def check_balance ( self ) -> Response : \"\"\"Fetch the available balance on your integration Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/balance\" ) return await self . _handle_request ( HTTPMethod . GET , url ) disable_otp () async This is used in the event that you want to be able to complete transfers programmatically without use of OTPs. No arguments required. You will get an OTP to complete the request Note Feature Availability This feature is only available to businesses in Nigeria and Ghana. Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transfers_control.py 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 async def disable_otp ( self ) -> Response : \"\"\" This is used in the event that you want to be able to complete transfers programmatically without use of OTPs. No arguments required. You will get an OTP to complete the request Note: Feature Availability This feature is only available to businesses in Nigeria and Ghana. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/transfer/disable_otp\" ) return await self . _handle_request ( HTTPMethod . POST , url ) enable_otp () async In the event that a customer wants to stop being able to complete transfers programmatically, this endpoint helps turn OTP requirement back on. No arguments required. Note Feature Availability This feature is only available to businesses in Nigeria and Ghana. Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transfers_control.py 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 async def enable_otp ( self ) -> Response : \"\"\" In the event that a customer wants to stop being able to complete transfers programmatically, this endpoint helps turn OTP requirement back on. No arguments required. Note: Feature Availability This feature is only available to businesses in Nigeria and Ghana. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/transfer/enable_otp\" ) return await self . _handle_request ( HTTPMethod . POST , url ) finalize_disable_otp ( otp ) async Finalize the request to disable OTP on your transfers. Note Feature Availability This feature is only available to businesses in Nigeria and Ghana. Parameters: Name Type Description Default otp str One time password required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transfers_control.py 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 async def finalize_disable_otp ( self , otp : str ) -> Response : \"\"\"Finalize the request to disable OTP on your transfers. Note: Feature Availability This feature is only available to businesses in Nigeria and Ghana. Args: otp: One time password Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"otp\" : otp } url = self . _parse_url ( \"/transfer/disable_otp_finalize\" ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) get_balance_ledger () async Fetch all pay-ins and pay-outs that occured on your integration Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transfers_control.py 116 117 118 119 120 121 122 123 async def get_balance_ledger ( self ) -> Response : \"\"\"Fetch all pay-ins and pay-outs that occured on your integration Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"balance/ledger\" ) return await self . _handle_request ( HTTPMethod . GET , url ) resend_otp ( transfer_code , reason ) async Generates a new OTP and sends to customer in the event they are having trouble receiving one. Note Feature Availability This feature is only available to businesses in Nigeria and Ghana. Parameters: Name Type Description Default transfer_code str Transfer code required reason Reason Any value from the Reason enum required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transfers_control.py 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 async def resend_otp ( self , transfer_code : str , reason : Reason ) -> Response : \"\"\" Generates a new OTP and sends to customer in the event they are having trouble receiving one. Note: Feature Availability This feature is only available to businesses in Nigeria and Ghana. Args: transfer_code: Transfer code reason: Any value from the ``Reason`` enum Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"transfer_code\" : transfer_code , \"reason\" : reason } url = self . _parse_url ( \"/transfer/resend_otp\" ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) TransferControl Bases: BaseAPI Provides a wrapper for paystack Transfers Control API The Transfers Control API allows you to manage settings of your transfers. https://paystack.com/docs/api/#transfer-control Source code in pypaystack2/api/transfers_control.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 class TransferControl ( BaseAPI ): \"\"\"Provides a wrapper for paystack Transfers Control API The Transfers Control API allows you to manage settings of your transfers. https://paystack.com/docs/api/#transfer-control \"\"\" def check_balance ( self ) -> Response : \"\"\"Fetch the available balance on your integration Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/balance\" ) return self . _handle_request ( HTTPMethod . GET , url ) def get_balance_ledger ( self ) -> Response : \"\"\"Fetch all pay-ins and pay-outs that occured on your integration Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/balance/ledger\" ) print ( url ) return self . _handle_request ( HTTPMethod . GET , url ) def resend_otp ( self , transfer_code : str , reason : Reason ) -> Response : \"\"\" Generates a new OTP and sends to customer in the event they are having trouble receiving one. Note: Feature Availability This feature is only available to businesses in Nigeria and Ghana. Args: transfer_code: Transfer code reason: Any value from the ``Reason`` enum Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"transfer_code\" : transfer_code , \"reason\" : reason } url = self . _parse_url ( \"/transfer/resend_otp\" ) return self . _handle_request ( HTTPMethod . POST , url , payload ) def disable_otp ( self ) -> Response : \"\"\" This is used in the event that you want to be able to complete transfers programmatically without use of OTPs. No arguments required. You will get an OTP to complete the request Note: Feature Availability This feature is only available to businesses in Nigeria and Ghana. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/transfer/disable_otp\" ) return self . _handle_request ( HTTPMethod . POST , url ) def finalize_disable_otp ( self , otp : str ) -> Response : \"\"\"Finalize the request to disable OTP on your transfers. Note: Feature Availability This feature is only available to businesses in Nigeria and Ghana. Args: otp: One time password Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"otp\" : otp } url = self . _parse_url ( \"/transfer/disable_otp_finalize\" ) return self . _handle_request ( HTTPMethod . POST , url , payload ) def enable_otp ( self ) -> Response : \"\"\" In the event that a customer wants to stop being able to complete transfers programmatically, this endpoint helps turn OTP requirement back on. No arguments required. Note: Feature Availability This feature is only available to businesses in Nigeria and Ghana. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/transfer/enable_otp\" ) return self . _handle_request ( HTTPMethod . POST , url ) check_balance () Fetch the available balance on your integration Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transfers_control.py 12 13 14 15 16 17 18 19 def check_balance ( self ) -> Response : \"\"\"Fetch the available balance on your integration Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/balance\" ) return self . _handle_request ( HTTPMethod . GET , url ) disable_otp () This is used in the event that you want to be able to complete transfers programmatically without use of OTPs. No arguments required. You will get an OTP to complete the request Note Feature Availability This feature is only available to businesses in Nigeria and Ghana. Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transfers_control.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 def disable_otp ( self ) -> Response : \"\"\" This is used in the event that you want to be able to complete transfers programmatically without use of OTPs. No arguments required. You will get an OTP to complete the request Note: Feature Availability This feature is only available to businesses in Nigeria and Ghana. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/transfer/disable_otp\" ) return self . _handle_request ( HTTPMethod . POST , url ) enable_otp () In the event that a customer wants to stop being able to complete transfers programmatically, this endpoint helps turn OTP requirement back on. No arguments required. Note Feature Availability This feature is only available to businesses in Nigeria and Ghana. Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transfers_control.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 def enable_otp ( self ) -> Response : \"\"\" In the event that a customer wants to stop being able to complete transfers programmatically, this endpoint helps turn OTP requirement back on. No arguments required. Note: Feature Availability This feature is only available to businesses in Nigeria and Ghana. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/transfer/enable_otp\" ) return self . _handle_request ( HTTPMethod . POST , url ) finalize_disable_otp ( otp ) Finalize the request to disable OTP on your transfers. Note Feature Availability This feature is only available to businesses in Nigeria and Ghana. Parameters: Name Type Description Default otp str One time password required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transfers_control.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 def finalize_disable_otp ( self , otp : str ) -> Response : \"\"\"Finalize the request to disable OTP on your transfers. Note: Feature Availability This feature is only available to businesses in Nigeria and Ghana. Args: otp: One time password Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"otp\" : otp } url = self . _parse_url ( \"/transfer/disable_otp_finalize\" ) return self . _handle_request ( HTTPMethod . POST , url , payload ) get_balance_ledger () Fetch all pay-ins and pay-outs that occured on your integration Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transfers_control.py 21 22 23 24 25 26 27 28 29 def get_balance_ledger ( self ) -> Response : \"\"\"Fetch all pay-ins and pay-outs that occured on your integration Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/balance/ledger\" ) print ( url ) return self . _handle_request ( HTTPMethod . GET , url ) resend_otp ( transfer_code , reason ) Generates a new OTP and sends to customer in the event they are having trouble receiving one. Note Feature Availability This feature is only available to businesses in Nigeria and Ghana. Parameters: Name Type Description Default transfer_code str Transfer code required reason Reason Any value from the Reason enum required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transfers_control.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 def resend_otp ( self , transfer_code : str , reason : Reason ) -> Response : \"\"\" Generates a new OTP and sends to customer in the event they are having trouble receiving one. Note: Feature Availability This feature is only available to businesses in Nigeria and Ghana. Args: transfer_code: Transfer code reason: Any value from the ``Reason`` enum Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"transfer_code\" : transfer_code , \"reason\" : reason } url = self . _parse_url ( \"/transfer/resend_otp\" ) return self . _handle_request ( HTTPMethod . POST , url , payload )","title":"Transfers control"},{"location":"reference/transfers_control/#pypaystack2.api.transfers_control.AsyncTransferControl","text":"Bases: BaseAsyncAPI Provides a wrapper for paystack Transfers Control API The Transfer Control API allows you to manage settings of your transfers. https://paystack.com/docs/api/#transfer-control Source code in pypaystack2/api/transfers_control.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 class AsyncTransferControl ( BaseAsyncAPI ): \"\"\"Provides a wrapper for paystack Transfers Control API The Transfer Control API allows you to manage settings of your transfers. https://paystack.com/docs/api/#transfer-control \"\"\" async def check_balance ( self ) -> Response : \"\"\"Fetch the available balance on your integration Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/balance\" ) return await self . _handle_request ( HTTPMethod . GET , url ) async def get_balance_ledger ( self ) -> Response : \"\"\"Fetch all pay-ins and pay-outs that occured on your integration Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"balance/ledger\" ) return await self . _handle_request ( HTTPMethod . GET , url ) async def resend_otp ( self , transfer_code : str , reason : Reason ) -> Response : \"\"\" Generates a new OTP and sends to customer in the event they are having trouble receiving one. Note: Feature Availability This feature is only available to businesses in Nigeria and Ghana. Args: transfer_code: Transfer code reason: Any value from the ``Reason`` enum Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"transfer_code\" : transfer_code , \"reason\" : reason } url = self . _parse_url ( \"/transfer/resend_otp\" ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) async def disable_otp ( self ) -> Response : \"\"\" This is used in the event that you want to be able to complete transfers programmatically without use of OTPs. No arguments required. You will get an OTP to complete the request Note: Feature Availability This feature is only available to businesses in Nigeria and Ghana. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/transfer/disable_otp\" ) return await self . _handle_request ( HTTPMethod . POST , url ) async def finalize_disable_otp ( self , otp : str ) -> Response : \"\"\"Finalize the request to disable OTP on your transfers. Note: Feature Availability This feature is only available to businesses in Nigeria and Ghana. Args: otp: One time password Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"otp\" : otp } url = self . _parse_url ( \"/transfer/disable_otp_finalize\" ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) async def enable_otp ( self ) -> Response : \"\"\" In the event that a customer wants to stop being able to complete transfers programmatically, this endpoint helps turn OTP requirement back on. No arguments required. Note: Feature Availability This feature is only available to businesses in Nigeria and Ghana. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/transfer/enable_otp\" ) return await self . _handle_request ( HTTPMethod . POST , url )","title":"AsyncTransferControl"},{"location":"reference/transfers_control/#pypaystack2.api.transfers_control.AsyncTransferControl.check_balance","text":"Fetch the available balance on your integration Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transfers_control.py 107 108 109 110 111 112 113 114 async def check_balance ( self ) -> Response : \"\"\"Fetch the available balance on your integration Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/balance\" ) return await self . _handle_request ( HTTPMethod . GET , url )","title":"check_balance()"},{"location":"reference/transfers_control/#pypaystack2.api.transfers_control.AsyncTransferControl.disable_otp","text":"This is used in the event that you want to be able to complete transfers programmatically without use of OTPs. No arguments required. You will get an OTP to complete the request Note Feature Availability This feature is only available to businesses in Nigeria and Ghana. Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transfers_control.py 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 async def disable_otp ( self ) -> Response : \"\"\" This is used in the event that you want to be able to complete transfers programmatically without use of OTPs. No arguments required. You will get an OTP to complete the request Note: Feature Availability This feature is only available to businesses in Nigeria and Ghana. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/transfer/disable_otp\" ) return await self . _handle_request ( HTTPMethod . POST , url )","title":"disable_otp()"},{"location":"reference/transfers_control/#pypaystack2.api.transfers_control.AsyncTransferControl.enable_otp","text":"In the event that a customer wants to stop being able to complete transfers programmatically, this endpoint helps turn OTP requirement back on. No arguments required. Note Feature Availability This feature is only available to businesses in Nigeria and Ghana. Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transfers_control.py 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 async def enable_otp ( self ) -> Response : \"\"\" In the event that a customer wants to stop being able to complete transfers programmatically, this endpoint helps turn OTP requirement back on. No arguments required. Note: Feature Availability This feature is only available to businesses in Nigeria and Ghana. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/transfer/enable_otp\" ) return await self . _handle_request ( HTTPMethod . POST , url )","title":"enable_otp()"},{"location":"reference/transfers_control/#pypaystack2.api.transfers_control.AsyncTransferControl.finalize_disable_otp","text":"Finalize the request to disable OTP on your transfers. Note Feature Availability This feature is only available to businesses in Nigeria and Ghana. Parameters: Name Type Description Default otp str One time password required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transfers_control.py 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 async def finalize_disable_otp ( self , otp : str ) -> Response : \"\"\"Finalize the request to disable OTP on your transfers. Note: Feature Availability This feature is only available to businesses in Nigeria and Ghana. Args: otp: One time password Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"otp\" : otp } url = self . _parse_url ( \"/transfer/disable_otp_finalize\" ) return await self . _handle_request ( HTTPMethod . POST , url , payload )","title":"finalize_disable_otp()"},{"location":"reference/transfers_control/#pypaystack2.api.transfers_control.AsyncTransferControl.get_balance_ledger","text":"Fetch all pay-ins and pay-outs that occured on your integration Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transfers_control.py 116 117 118 119 120 121 122 123 async def get_balance_ledger ( self ) -> Response : \"\"\"Fetch all pay-ins and pay-outs that occured on your integration Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"balance/ledger\" ) return await self . _handle_request ( HTTPMethod . GET , url )","title":"get_balance_ledger()"},{"location":"reference/transfers_control/#pypaystack2.api.transfers_control.AsyncTransferControl.resend_otp","text":"Generates a new OTP and sends to customer in the event they are having trouble receiving one. Note Feature Availability This feature is only available to businesses in Nigeria and Ghana. Parameters: Name Type Description Default transfer_code str Transfer code required reason Reason Any value from the Reason enum required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transfers_control.py 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 async def resend_otp ( self , transfer_code : str , reason : Reason ) -> Response : \"\"\" Generates a new OTP and sends to customer in the event they are having trouble receiving one. Note: Feature Availability This feature is only available to businesses in Nigeria and Ghana. Args: transfer_code: Transfer code reason: Any value from the ``Reason`` enum Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"transfer_code\" : transfer_code , \"reason\" : reason } url = self . _parse_url ( \"/transfer/resend_otp\" ) return await self . _handle_request ( HTTPMethod . POST , url , payload )","title":"resend_otp()"},{"location":"reference/transfers_control/#pypaystack2.api.transfers_control.TransferControl","text":"Bases: BaseAPI Provides a wrapper for paystack Transfers Control API The Transfers Control API allows you to manage settings of your transfers. https://paystack.com/docs/api/#transfer-control Source code in pypaystack2/api/transfers_control.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 class TransferControl ( BaseAPI ): \"\"\"Provides a wrapper for paystack Transfers Control API The Transfers Control API allows you to manage settings of your transfers. https://paystack.com/docs/api/#transfer-control \"\"\" def check_balance ( self ) -> Response : \"\"\"Fetch the available balance on your integration Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/balance\" ) return self . _handle_request ( HTTPMethod . GET , url ) def get_balance_ledger ( self ) -> Response : \"\"\"Fetch all pay-ins and pay-outs that occured on your integration Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/balance/ledger\" ) print ( url ) return self . _handle_request ( HTTPMethod . GET , url ) def resend_otp ( self , transfer_code : str , reason : Reason ) -> Response : \"\"\" Generates a new OTP and sends to customer in the event they are having trouble receiving one. Note: Feature Availability This feature is only available to businesses in Nigeria and Ghana. Args: transfer_code: Transfer code reason: Any value from the ``Reason`` enum Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"transfer_code\" : transfer_code , \"reason\" : reason } url = self . _parse_url ( \"/transfer/resend_otp\" ) return self . _handle_request ( HTTPMethod . POST , url , payload ) def disable_otp ( self ) -> Response : \"\"\" This is used in the event that you want to be able to complete transfers programmatically without use of OTPs. No arguments required. You will get an OTP to complete the request Note: Feature Availability This feature is only available to businesses in Nigeria and Ghana. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/transfer/disable_otp\" ) return self . _handle_request ( HTTPMethod . POST , url ) def finalize_disable_otp ( self , otp : str ) -> Response : \"\"\"Finalize the request to disable OTP on your transfers. Note: Feature Availability This feature is only available to businesses in Nigeria and Ghana. Args: otp: One time password Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"otp\" : otp } url = self . _parse_url ( \"/transfer/disable_otp_finalize\" ) return self . _handle_request ( HTTPMethod . POST , url , payload ) def enable_otp ( self ) -> Response : \"\"\" In the event that a customer wants to stop being able to complete transfers programmatically, this endpoint helps turn OTP requirement back on. No arguments required. Note: Feature Availability This feature is only available to businesses in Nigeria and Ghana. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/transfer/enable_otp\" ) return self . _handle_request ( HTTPMethod . POST , url )","title":"TransferControl"},{"location":"reference/transfers_control/#pypaystack2.api.transfers_control.TransferControl.check_balance","text":"Fetch the available balance on your integration Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transfers_control.py 12 13 14 15 16 17 18 19 def check_balance ( self ) -> Response : \"\"\"Fetch the available balance on your integration Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/balance\" ) return self . _handle_request ( HTTPMethod . GET , url )","title":"check_balance()"},{"location":"reference/transfers_control/#pypaystack2.api.transfers_control.TransferControl.disable_otp","text":"This is used in the event that you want to be able to complete transfers programmatically without use of OTPs. No arguments required. You will get an OTP to complete the request Note Feature Availability This feature is only available to businesses in Nigeria and Ghana. Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transfers_control.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 def disable_otp ( self ) -> Response : \"\"\" This is used in the event that you want to be able to complete transfers programmatically without use of OTPs. No arguments required. You will get an OTP to complete the request Note: Feature Availability This feature is only available to businesses in Nigeria and Ghana. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/transfer/disable_otp\" ) return self . _handle_request ( HTTPMethod . POST , url )","title":"disable_otp()"},{"location":"reference/transfers_control/#pypaystack2.api.transfers_control.TransferControl.enable_otp","text":"In the event that a customer wants to stop being able to complete transfers programmatically, this endpoint helps turn OTP requirement back on. No arguments required. Note Feature Availability This feature is only available to businesses in Nigeria and Ghana. Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transfers_control.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 def enable_otp ( self ) -> Response : \"\"\" In the event that a customer wants to stop being able to complete transfers programmatically, this endpoint helps turn OTP requirement back on. No arguments required. Note: Feature Availability This feature is only available to businesses in Nigeria and Ghana. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/transfer/enable_otp\" ) return self . _handle_request ( HTTPMethod . POST , url )","title":"enable_otp()"},{"location":"reference/transfers_control/#pypaystack2.api.transfers_control.TransferControl.finalize_disable_otp","text":"Finalize the request to disable OTP on your transfers. Note Feature Availability This feature is only available to businesses in Nigeria and Ghana. Parameters: Name Type Description Default otp str One time password required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transfers_control.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 def finalize_disable_otp ( self , otp : str ) -> Response : \"\"\"Finalize the request to disable OTP on your transfers. Note: Feature Availability This feature is only available to businesses in Nigeria and Ghana. Args: otp: One time password Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"otp\" : otp } url = self . _parse_url ( \"/transfer/disable_otp_finalize\" ) return self . _handle_request ( HTTPMethod . POST , url , payload )","title":"finalize_disable_otp()"},{"location":"reference/transfers_control/#pypaystack2.api.transfers_control.TransferControl.get_balance_ledger","text":"Fetch all pay-ins and pay-outs that occured on your integration Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transfers_control.py 21 22 23 24 25 26 27 28 29 def get_balance_ledger ( self ) -> Response : \"\"\"Fetch all pay-ins and pay-outs that occured on your integration Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( \"/balance/ledger\" ) print ( url ) return self . _handle_request ( HTTPMethod . GET , url )","title":"get_balance_ledger()"},{"location":"reference/transfers_control/#pypaystack2.api.transfers_control.TransferControl.resend_otp","text":"Generates a new OTP and sends to customer in the event they are having trouble receiving one. Note Feature Availability This feature is only available to businesses in Nigeria and Ghana. Parameters: Name Type Description Default transfer_code str Transfer code required reason Reason Any value from the Reason enum required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/transfers_control.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 def resend_otp ( self , transfer_code : str , reason : Reason ) -> Response : \"\"\" Generates a new OTP and sends to customer in the event they are having trouble receiving one. Note: Feature Availability This feature is only available to businesses in Nigeria and Ghana. Args: transfer_code: Transfer code reason: Any value from the ``Reason`` enum Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"transfer_code\" : transfer_code , \"reason\" : reason } url = self . _parse_url ( \"/transfer/resend_otp\" ) return self . _handle_request ( HTTPMethod . POST , url , payload )","title":"resend_otp()"},{"location":"reference/verification/","text":"AsyncVerification Bases: BaseAsyncAPI Provides a wrapper for paystack Verification API The Verification API allows you to perform KYC processes. https://paystack.com/docs/api/#verification Note This feature is only available to businesses in Nigeria. Source code in pypaystack2/api/verification.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 class AsyncVerification ( BaseAsyncAPI ): \"\"\"Provides a wrapper for paystack Verification API The Verification API allows you to perform KYC processes. https://paystack.com/docs/api/#verification Note: This feature is only available to businesses in Nigeria. \"\"\" async def resolve_account_number ( self , account_number : str , bank_code : str , ) -> Response : \"\"\"Confirm an account belongs to the right customer Note: Feature Availability This feature is only available to businesses in Nigeria. Args: account_number: Account Number bank_code: You can get the list of bank codes by calling the Miscellaneous API wrapper ``.get_banks`` method. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/bank/resolve?account_number= { account_number } &bank_code= { bank_code } \" ) return await self . _handle_request ( HTTPMethod . GET , url ) async def validate_account ( self , account_name : str , account_number : str , account_type : AccountType , bank_code : str , country_code : Country , document_type : Document , document_number : Optional [ str ] = None , ) -> Response : \"\"\"Confirm the authenticity of a customer's account number before sending money Args: account_name: Customer's first and last name registered with their bank account_number: Customer's account number account_type: bank_code: The bank code of the customer\u2019s bank. You can fetch the bank codes by using Miscellaneous API wrapper ``.get_banks`` method. bank_code: The bank code of the customer\u2019s bank country_code: Any value from the ``Country`` enum document_type: Customer\u2019s mode of identity. any value from the ``DocumentType`` enum. document_number: Customer\u2019s mode of identity number Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"account_name\" : account_name , \"account_number\" : account_number , \"account_type\" : account_type , \"bank_code\" : bank_code , \"country_code\" : country_code , \"document_type\" : document_type , } url = self . _parse_url ( \"/bank/validate\" ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) async def resolve_card_bin ( self , bin : str ) -> Response : \"\"\"Get more information about a customer's card Args: bin: First 6 characters of card Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/decision/bin/ { bin } \" ) return await self . _handle_request ( HTTPMethod . GET , url ) resolve_account_number ( account_number , bank_code ) async Confirm an account belongs to the right customer Note Feature Availability This feature is only available to businesses in Nigeria. Parameters: Name Type Description Default account_number str Account Number required bank_code str You can get the list of bank codes by calling the Miscellaneous API wrapper .get_banks method. required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/verification.py 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 async def resolve_account_number ( self , account_number : str , bank_code : str , ) -> Response : \"\"\"Confirm an account belongs to the right customer Note: Feature Availability This feature is only available to businesses in Nigeria. Args: account_number: Account Number bank_code: You can get the list of bank codes by calling the Miscellaneous API wrapper ``.get_banks`` method. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/bank/resolve?account_number= { account_number } &bank_code= { bank_code } \" ) return await self . _handle_request ( HTTPMethod . GET , url ) resolve_card_bin ( bin ) async Get more information about a customer's card Parameters: Name Type Description Default bin str First 6 characters of card required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/verification.py 169 170 171 172 173 174 175 176 177 178 179 180 181 async def resolve_card_bin ( self , bin : str ) -> Response : \"\"\"Get more information about a customer's card Args: bin: First 6 characters of card Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/decision/bin/ { bin } \" ) return await self . _handle_request ( HTTPMethod . GET , url ) validate_account ( account_name , account_number , account_type , bank_code , country_code , document_type , document_number = None ) async Confirm the authenticity of a customer's account number before sending money Parameters: Name Type Description Default account_name str Customer's first and last name registered with their bank required account_number str Customer's account number required account_type AccountType bank_code: The bank code of the customer\u2019s bank. You can fetch the bank codes by using Miscellaneous API wrapper .get_banks method. required bank_code str The bank code of the customer\u2019s bank required country_code Country Any value from the Country enum required document_type Document Customer\u2019s mode of identity. any value from the DocumentType enum. required document_number Optional [ str ] Customer\u2019s mode of identity number None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/verification.py 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 async def validate_account ( self , account_name : str , account_number : str , account_type : AccountType , bank_code : str , country_code : Country , document_type : Document , document_number : Optional [ str ] = None , ) -> Response : \"\"\"Confirm the authenticity of a customer's account number before sending money Args: account_name: Customer's first and last name registered with their bank account_number: Customer's account number account_type: bank_code: The bank code of the customer\u2019s bank. You can fetch the bank codes by using Miscellaneous API wrapper ``.get_banks`` method. bank_code: The bank code of the customer\u2019s bank country_code: Any value from the ``Country`` enum document_type: Customer\u2019s mode of identity. any value from the ``DocumentType`` enum. document_number: Customer\u2019s mode of identity number Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"account_name\" : account_name , \"account_number\" : account_number , \"account_type\" : account_type , \"bank_code\" : bank_code , \"country_code\" : country_code , \"document_type\" : document_type , } url = self . _parse_url ( \"/bank/validate\" ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) Verification Bases: BaseAPI Provides a wrapper for paystack Verification API The Verification API allows you to perform KYC processes. https://paystack.com/docs/api/#verification Note This feature is only available to businesses in Nigeria. Source code in pypaystack2/api/verification.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 class Verification ( BaseAPI ): \"\"\"Provides a wrapper for paystack Verification API The Verification API allows you to perform KYC processes. https://paystack.com/docs/api/#verification Note: This feature is only available to businesses in Nigeria. \"\"\" def resolve_account_number ( self , account_number : str , bank_code : str , ) -> Response : \"\"\"Confirm an account belongs to the right customer Note: Feature Availability This feature is only available to businesses in Nigeria. Args: account_number: Account Number bank_code: You can get the list of bank codes by calling the Miscellaneous API wrapper ``.get_banks`` method. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/bank/resolve?account_number= { account_number } &bank_code= { bank_code } \" ) return self . _handle_request ( HTTPMethod . GET , url ) def validate_account ( self , account_name : str , account_number : str , account_type : AccountType , bank_code : str , country_code : Country , document_type : Document , document_number : Optional [ str ] = None , ) -> Response : \"\"\"Confirm the authenticity of a customer's account number before sending money Args: account_name: Customer's first and last name registered with their bank account_number: Customer's account number account_type: bank_code: The bank code of the customer\u2019s bank. You can fetch the bank codes by using Miscellaneous API wrapper ``.get_banks`` method. bank_code: The bank code of the customer\u2019s bank country_code: Any value from the ``Country`` enum document_type: Customer\u2019s mode of identity. any value from the ``DocumentType`` enum. document_number: Customer\u2019s mode of identity number Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"account_name\" : account_name , \"account_number\" : account_number , \"account_type\" : account_type , \"bank_code\" : bank_code , \"country_code\" : country_code , \"document_type\" : document_type , \"document_number\" : document_number , } url = self . _parse_url ( \"/bank/validate\" ) return self . _handle_request ( HTTPMethod . POST , url , payload ) def resolve_card_bin ( self , bin : str ) -> Response : \"\"\"Get more information about a customer's card Args: bin: First 6 characters of card Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/decision/bin/ { bin } \" ) return self . _handle_request ( HTTPMethod . GET , url ) resolve_account_number ( account_number , bank_code ) Confirm an account belongs to the right customer Note Feature Availability This feature is only available to businesses in Nigeria. Parameters: Name Type Description Default account_number str Account Number required bank_code str You can get the list of bank codes by calling the Miscellaneous API wrapper .get_banks method. required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/verification.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 def resolve_account_number ( self , account_number : str , bank_code : str , ) -> Response : \"\"\"Confirm an account belongs to the right customer Note: Feature Availability This feature is only available to businesses in Nigeria. Args: account_number: Account Number bank_code: You can get the list of bank codes by calling the Miscellaneous API wrapper ``.get_banks`` method. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/bank/resolve?account_number= { account_number } &bank_code= { bank_code } \" ) return self . _handle_request ( HTTPMethod . GET , url ) resolve_card_bin ( bin ) Get more information about a customer's card Parameters: Name Type Description Default bin str First 6 characters of card required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/verification.py 81 82 83 84 85 86 87 88 89 90 91 92 93 def resolve_card_bin ( self , bin : str ) -> Response : \"\"\"Get more information about a customer's card Args: bin: First 6 characters of card Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/decision/bin/ { bin } \" ) return self . _handle_request ( HTTPMethod . GET , url ) validate_account ( account_name , account_number , account_type , bank_code , country_code , document_type , document_number = None ) Confirm the authenticity of a customer's account number before sending money Parameters: Name Type Description Default account_name str Customer's first and last name registered with their bank required account_number str Customer's account number required account_type AccountType bank_code: The bank code of the customer\u2019s bank. You can fetch the bank codes by using Miscellaneous API wrapper .get_banks method. required bank_code str The bank code of the customer\u2019s bank required country_code Country Any value from the Country enum required document_type Document Customer\u2019s mode of identity. any value from the DocumentType enum. required document_number Optional [ str ] Customer\u2019s mode of identity number None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/verification.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 def validate_account ( self , account_name : str , account_number : str , account_type : AccountType , bank_code : str , country_code : Country , document_type : Document , document_number : Optional [ str ] = None , ) -> Response : \"\"\"Confirm the authenticity of a customer's account number before sending money Args: account_name: Customer's first and last name registered with their bank account_number: Customer's account number account_type: bank_code: The bank code of the customer\u2019s bank. You can fetch the bank codes by using Miscellaneous API wrapper ``.get_banks`` method. bank_code: The bank code of the customer\u2019s bank country_code: Any value from the ``Country`` enum document_type: Customer\u2019s mode of identity. any value from the ``DocumentType`` enum. document_number: Customer\u2019s mode of identity number Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"account_name\" : account_name , \"account_number\" : account_number , \"account_type\" : account_type , \"bank_code\" : bank_code , \"country_code\" : country_code , \"document_type\" : document_type , \"document_number\" : document_number , } url = self . _parse_url ( \"/bank/validate\" ) return self . _handle_request ( HTTPMethod . POST , url , payload )","title":"Verification"},{"location":"reference/verification/#pypaystack2.api.verification.AsyncVerification","text":"Bases: BaseAsyncAPI Provides a wrapper for paystack Verification API The Verification API allows you to perform KYC processes. https://paystack.com/docs/api/#verification Note This feature is only available to businesses in Nigeria. Source code in pypaystack2/api/verification.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 class AsyncVerification ( BaseAsyncAPI ): \"\"\"Provides a wrapper for paystack Verification API The Verification API allows you to perform KYC processes. https://paystack.com/docs/api/#verification Note: This feature is only available to businesses in Nigeria. \"\"\" async def resolve_account_number ( self , account_number : str , bank_code : str , ) -> Response : \"\"\"Confirm an account belongs to the right customer Note: Feature Availability This feature is only available to businesses in Nigeria. Args: account_number: Account Number bank_code: You can get the list of bank codes by calling the Miscellaneous API wrapper ``.get_banks`` method. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/bank/resolve?account_number= { account_number } &bank_code= { bank_code } \" ) return await self . _handle_request ( HTTPMethod . GET , url ) async def validate_account ( self , account_name : str , account_number : str , account_type : AccountType , bank_code : str , country_code : Country , document_type : Document , document_number : Optional [ str ] = None , ) -> Response : \"\"\"Confirm the authenticity of a customer's account number before sending money Args: account_name: Customer's first and last name registered with their bank account_number: Customer's account number account_type: bank_code: The bank code of the customer\u2019s bank. You can fetch the bank codes by using Miscellaneous API wrapper ``.get_banks`` method. bank_code: The bank code of the customer\u2019s bank country_code: Any value from the ``Country`` enum document_type: Customer\u2019s mode of identity. any value from the ``DocumentType`` enum. document_number: Customer\u2019s mode of identity number Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"account_name\" : account_name , \"account_number\" : account_number , \"account_type\" : account_type , \"bank_code\" : bank_code , \"country_code\" : country_code , \"document_type\" : document_type , } url = self . _parse_url ( \"/bank/validate\" ) return await self . _handle_request ( HTTPMethod . POST , url , payload ) async def resolve_card_bin ( self , bin : str ) -> Response : \"\"\"Get more information about a customer's card Args: bin: First 6 characters of card Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/decision/bin/ { bin } \" ) return await self . _handle_request ( HTTPMethod . GET , url )","title":"AsyncVerification"},{"location":"reference/verification/#pypaystack2.api.verification.AsyncVerification.resolve_account_number","text":"Confirm an account belongs to the right customer Note Feature Availability This feature is only available to businesses in Nigeria. Parameters: Name Type Description Default account_number str Account Number required bank_code str You can get the list of bank codes by calling the Miscellaneous API wrapper .get_banks method. required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/verification.py 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 async def resolve_account_number ( self , account_number : str , bank_code : str , ) -> Response : \"\"\"Confirm an account belongs to the right customer Note: Feature Availability This feature is only available to businesses in Nigeria. Args: account_number: Account Number bank_code: You can get the list of bank codes by calling the Miscellaneous API wrapper ``.get_banks`` method. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/bank/resolve?account_number= { account_number } &bank_code= { bank_code } \" ) return await self . _handle_request ( HTTPMethod . GET , url )","title":"resolve_account_number()"},{"location":"reference/verification/#pypaystack2.api.verification.AsyncVerification.resolve_card_bin","text":"Get more information about a customer's card Parameters: Name Type Description Default bin str First 6 characters of card required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/verification.py 169 170 171 172 173 174 175 176 177 178 179 180 181 async def resolve_card_bin ( self , bin : str ) -> Response : \"\"\"Get more information about a customer's card Args: bin: First 6 characters of card Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/decision/bin/ { bin } \" ) return await self . _handle_request ( HTTPMethod . GET , url )","title":"resolve_card_bin()"},{"location":"reference/verification/#pypaystack2.api.verification.AsyncVerification.validate_account","text":"Confirm the authenticity of a customer's account number before sending money Parameters: Name Type Description Default account_name str Customer's first and last name registered with their bank required account_number str Customer's account number required account_type AccountType bank_code: The bank code of the customer\u2019s bank. You can fetch the bank codes by using Miscellaneous API wrapper .get_banks method. required bank_code str The bank code of the customer\u2019s bank required country_code Country Any value from the Country enum required document_type Document Customer\u2019s mode of identity. any value from the DocumentType enum. required document_number Optional [ str ] Customer\u2019s mode of identity number None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/verification.py 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 async def validate_account ( self , account_name : str , account_number : str , account_type : AccountType , bank_code : str , country_code : Country , document_type : Document , document_number : Optional [ str ] = None , ) -> Response : \"\"\"Confirm the authenticity of a customer's account number before sending money Args: account_name: Customer's first and last name registered with their bank account_number: Customer's account number account_type: bank_code: The bank code of the customer\u2019s bank. You can fetch the bank codes by using Miscellaneous API wrapper ``.get_banks`` method. bank_code: The bank code of the customer\u2019s bank country_code: Any value from the ``Country`` enum document_type: Customer\u2019s mode of identity. any value from the ``DocumentType`` enum. document_number: Customer\u2019s mode of identity number Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"account_name\" : account_name , \"account_number\" : account_number , \"account_type\" : account_type , \"bank_code\" : bank_code , \"country_code\" : country_code , \"document_type\" : document_type , } url = self . _parse_url ( \"/bank/validate\" ) return await self . _handle_request ( HTTPMethod . POST , url , payload )","title":"validate_account()"},{"location":"reference/verification/#pypaystack2.api.verification.Verification","text":"Bases: BaseAPI Provides a wrapper for paystack Verification API The Verification API allows you to perform KYC processes. https://paystack.com/docs/api/#verification Note This feature is only available to businesses in Nigeria. Source code in pypaystack2/api/verification.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 class Verification ( BaseAPI ): \"\"\"Provides a wrapper for paystack Verification API The Verification API allows you to perform KYC processes. https://paystack.com/docs/api/#verification Note: This feature is only available to businesses in Nigeria. \"\"\" def resolve_account_number ( self , account_number : str , bank_code : str , ) -> Response : \"\"\"Confirm an account belongs to the right customer Note: Feature Availability This feature is only available to businesses in Nigeria. Args: account_number: Account Number bank_code: You can get the list of bank codes by calling the Miscellaneous API wrapper ``.get_banks`` method. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/bank/resolve?account_number= { account_number } &bank_code= { bank_code } \" ) return self . _handle_request ( HTTPMethod . GET , url ) def validate_account ( self , account_name : str , account_number : str , account_type : AccountType , bank_code : str , country_code : Country , document_type : Document , document_number : Optional [ str ] = None , ) -> Response : \"\"\"Confirm the authenticity of a customer's account number before sending money Args: account_name: Customer's first and last name registered with their bank account_number: Customer's account number account_type: bank_code: The bank code of the customer\u2019s bank. You can fetch the bank codes by using Miscellaneous API wrapper ``.get_banks`` method. bank_code: The bank code of the customer\u2019s bank country_code: Any value from the ``Country`` enum document_type: Customer\u2019s mode of identity. any value from the ``DocumentType`` enum. document_number: Customer\u2019s mode of identity number Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"account_name\" : account_name , \"account_number\" : account_number , \"account_type\" : account_type , \"bank_code\" : bank_code , \"country_code\" : country_code , \"document_type\" : document_type , \"document_number\" : document_number , } url = self . _parse_url ( \"/bank/validate\" ) return self . _handle_request ( HTTPMethod . POST , url , payload ) def resolve_card_bin ( self , bin : str ) -> Response : \"\"\"Get more information about a customer's card Args: bin: First 6 characters of card Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/decision/bin/ { bin } \" ) return self . _handle_request ( HTTPMethod . GET , url )","title":"Verification"},{"location":"reference/verification/#pypaystack2.api.verification.Verification.resolve_account_number","text":"Confirm an account belongs to the right customer Note Feature Availability This feature is only available to businesses in Nigeria. Parameters: Name Type Description Default account_number str Account Number required bank_code str You can get the list of bank codes by calling the Miscellaneous API wrapper .get_banks method. required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/verification.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 def resolve_account_number ( self , account_number : str , bank_code : str , ) -> Response : \"\"\"Confirm an account belongs to the right customer Note: Feature Availability This feature is only available to businesses in Nigeria. Args: account_number: Account Number bank_code: You can get the list of bank codes by calling the Miscellaneous API wrapper ``.get_banks`` method. Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/bank/resolve?account_number= { account_number } &bank_code= { bank_code } \" ) return self . _handle_request ( HTTPMethod . GET , url )","title":"resolve_account_number()"},{"location":"reference/verification/#pypaystack2.api.verification.Verification.resolve_card_bin","text":"Get more information about a customer's card Parameters: Name Type Description Default bin str First 6 characters of card required Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/verification.py 81 82 83 84 85 86 87 88 89 90 91 92 93 def resolve_card_bin ( self , bin : str ) -> Response : \"\"\"Get more information about a customer's card Args: bin: First 6 characters of card Returns: A named tuple containing the response gotten from paystack's server. \"\"\" url = self . _parse_url ( f \"/decision/bin/ { bin } \" ) return self . _handle_request ( HTTPMethod . GET , url )","title":"resolve_card_bin()"},{"location":"reference/verification/#pypaystack2.api.verification.Verification.validate_account","text":"Confirm the authenticity of a customer's account number before sending money Parameters: Name Type Description Default account_name str Customer's first and last name registered with their bank required account_number str Customer's account number required account_type AccountType bank_code: The bank code of the customer\u2019s bank. You can fetch the bank codes by using Miscellaneous API wrapper .get_banks method. required bank_code str The bank code of the customer\u2019s bank required country_code Country Any value from the Country enum required document_type Document Customer\u2019s mode of identity. any value from the DocumentType enum. required document_number Optional [ str ] Customer\u2019s mode of identity number None Returns: Type Description Response A named tuple containing the response gotten from paystack's server. Source code in pypaystack2/api/verification.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 def validate_account ( self , account_name : str , account_number : str , account_type : AccountType , bank_code : str , country_code : Country , document_type : Document , document_number : Optional [ str ] = None , ) -> Response : \"\"\"Confirm the authenticity of a customer's account number before sending money Args: account_name: Customer's first and last name registered with their bank account_number: Customer's account number account_type: bank_code: The bank code of the customer\u2019s bank. You can fetch the bank codes by using Miscellaneous API wrapper ``.get_banks`` method. bank_code: The bank code of the customer\u2019s bank country_code: Any value from the ``Country`` enum document_type: Customer\u2019s mode of identity. any value from the ``DocumentType`` enum. document_number: Customer\u2019s mode of identity number Returns: A named tuple containing the response gotten from paystack's server. \"\"\" payload = { \"account_name\" : account_name , \"account_number\" : account_number , \"account_type\" : account_type , \"bank_code\" : bank_code , \"country_code\" : country_code , \"document_type\" : document_type , \"document_number\" : document_number , } url = self . _parse_url ( \"/bank/validate\" ) return self . _handle_request ( HTTPMethod . POST , url , payload )","title":"validate_account()"},{"location":"tutorials/tutorial1/","text":"Paystack Command line Client This tutorial aims to expose you to how to use pypaystack2 in your python projects for paystack integrations. We'll be building a simple command line application that integrates with paystack's services. Project Setup We'll start by setting up our project. We'll be using pipenv for managing this project's dependencies and environment. you're free to use your preferred choice like virtualenv , hatch or poetry . if you don't have pipenv installed yet, you can install it with pip install pipenv . it's important to note that pipenv should be installed globally and not within a virtual environment. You're good to proceed if this prerequisite is met. Create a directory to house our project. mkdir paystack_cli_client && cd paystack_cli_client Initialize a virtual environment for the project. pipenv shell Install the projects dependencies. We'll be needing pypaystack2 , python-dotenv , and typer . pypaystack2 package is an API wrapper for paystack's services. python-dotenv helps us manage our environmental variables and typer makes building command line apps in python super simple. pipenv install pypaystack2 python-dotenv typer If all work's fine, you're good to proceed. Environmental Variables pypaystack2 depends on your paystack authorization key that you get from signing up to paystack. Paystack provides you with two pairs. A pair of public and secret keys for live mode and another set for test mode. You can find them in your account settings. Since this is just a tutorial, we'll be using only the test secret key. create a new file named .env within your project's root directory. Now put in your test secret key in the .env file like so. PAYSTACK_AUTHORIZATION_KEY = \"<your paystack test secret key>\" Warning Because this is just a tutorial, no extra measure is made to protect this environmental. In a more serious project or production code, extra care should be taken to protect it and also avoid pushing it to a remote source control. Let the games begin It's time to start building! create a new file named main.py in your root directory. # root-dir/main.py from dotenv import load_dotenv load_dotenv () What we have just done is loaded our secret test key within the .env file. You may be wondering why do we need that, here's why pypaystack2 needs this key to communicate with paystack's api. alternatively, you can pass your authorization key into any of the api wrappers provided by pypaystack2 via their auth_key parameter. Here's a list of all the API wrappers currently available as at the time of writing of this tutorial. Note As of version 1.1.3 , pypaystack2 provided Paystack class which had all the available api wrappers bounded to it. version 2.0.0 also added AsyncPaystack to provide the asynchronous equivalent. So instead off importing individual wrappers you only have to import the Paystack or AsyncPaystack class. Example: The old way of doing things from pypaystack2.uitls import Country from pypaystack2.api import Miscellaneous miscellaneous_wrapper = Miscellaneous ( auth_key = \"<paystack secret key>\" ) response = miscellaneous_wrapper . get_banks ( country = Country . NIGERIA ) print ( response ) The new way from pypaystack2 import Paystack , Country paystack = Paystack ( auth_key = \"<paystack secret key>\" ) response = paystack . miscellaneous . get_banks ( country = Country . NIGERIA ) print ( response ) So in a situation where you don't have your PAYSTACK_AUTHORIZATION_KEY as an environmental variable, you can pass it into any of the API wrappers. e.g. # When you don't have PAYSTACK_AUTHORIZATION_KEY(paystack secret key) in your environmental variables from pypaystack2 import Paystack paystack = Paystack ( auth_key = \"<your test secret key>\" ) # When you have PAYSTACK_AUTHORIZATION_KEY(paystack secret key) set in your environmental variables paystack = Paystack () Note You don't have to provide your authorization key on the instantiation of any of the API wrappers as long as you have it set in your environmental variables like this tutorial does. On your marks! The first feature we'll be implementing for our Paystack Command line Client is the ability to create new customers on our paystack integration. so now update your main.py file with the code below. # root-dir/main.py from dotenv import load_dotenv from typer import Typer load_dotenv () app = Typer () @app . command () def new_customer (): print ( \"new customer successfully created!\" ) if __name__ == \"__main__\" : app () This is a minimum setup to building cli apps with Typer . Now try this in your project's root directory. python main.py --help You should see. Usage: main.py [ OPTIONS ] Options: --install-completion [ bash | zsh | fish | powershell | pwsh ] Install completion for the specified shell. --show-completion [ bash | zsh | fish | powershell | pwsh ] Show completion for the specified shell, to copy it or customize the installation. --help Show this message and exit. You can see that we now have a command line app that's responding to our command in this case --help . Let's try out the custom command we just added. python main.py You should see new customer successfully created! At the moment, no new customer is actually getting created on your paystack integration. let's bring in pypaystack2 to help us get the job done. For this to work, pypaystack2 provides wrappers for the restful APIs provided by Paystack. These wrappers are named to closely match the API they wrap and methods on these wrappers correspond to endpoints on the Paystack services you're interested in so in this case, for us to create a customer on our integration, we need to use the Customer API wrapper which connects to Paystack's Customer Services API. More info at Paystack's Customer Services API # root-dir/main.py from typing import Optional from dotenv import load_dotenv from pypaystack2 import Paystack from typer import Typer load_dotenv () app = Typer () paystack = Paystack () @app . command () def new_customer ( email : str , first_name : Optional [ str ] = None , last_name : Optional [ str ] = None , phone : Optional [ str ] = None , ): response = paystack . customers . create ( email = email , first_name = first_name , last_name = last_name , phone = phone ) print ( response . status_code ) print ( response . status ) print ( response . message ) print ( response . data ) if __name__ == \"__main__\" : app () Note All API wrappers are available on pypaystack . as attributes e.g. paystack.transactions for the Transactions API Now if you run the script again. python main.py You get error saying you have a missing argument 'EMAIL' Usage: main.py [ OPTIONS ] EMAIL Try 'main.py --help' for help. Error: Missing argument 'EMAIL' . Now let's try out our script with the email of the customer we want to create. python main.py email@example.com Now if all goes fine. \"An Internet connection is required\", you should get something similar to this 200 True Customer created { 'transactions' : [] , 'subscriptions' : [] , 'authorizations' : [] , 'first_name' : '' , 'last_name' : '' , 'email' : 'email@example.com' , 'phone' : '' , 'metadata' : None, 'domain' : 'test' , 'customer_code' : 'CUS_kd197ej30zxr34v' , 'risk_action' : 'default' , 'id' : 47748473 , 'integration' : 630606 , 'createdAt' : '2021-06-20T05:16:20.000Z' , 'updatedAt' : '2021-06-20T05:16:20.000Z' , 'identified' : False, 'identifications' : None } Yay! You've just created a new customer on your integration You can check out the customer's tab in your Paystack account to confirm this. Tip You can also create new customers with a first name and last name like so. python main.py email@example.com --first-name John --last-name Doe What just happened? You have just created a new customer on your integration with the CLI app you just built. But how? If you've followed this tutorial to this point, you already know what wrappers are, or you can quickly skim through the chapters before to get a refresher. The right question should be what is the create method on the Customer wrapper for. You guess right if what's on your mind is that it creates a new customer on your integration. So as it was said earlier, all wrappers have methods on them that correspond to an endpoint on paystack and all of these methods will return a Response object based on the response it gets from Paystack. This Response is just a NamedTuple that holds the status,status_code,message and data . So this call response = paystack . customers . create ( email = email , first_name = first_name , last_name = last_name , phone = phone ) in our script returns the Response object just described, and you can access each of these attributes with response.status , response.status_code , response.message , response.data More Commands! Let's add a few more commands to our Paystack Command line Client # root-dir/main.py from typing import Optional from dotenv import load_dotenv from pypaystack2 import Paystack from typer import Typer load_dotenv () app = Typer () paystack = Paystack () @app . command () def new_customer ( email : str , first_name : Optional [ str ] = None , last_name : Optional [ str ] = None , phone : Optional [ str ] = None , ): response = paystack . customers . create ( email = email , first_name = first_name , last_name = last_name , phone = phone ) print ( response . status_code ) print ( response . status ) print ( response . message ) print ( response . data ) @app . command () def list_customers (): response = paystack . customers . get_customers () print ( response . status_code ) print ( response . status ) print ( response . message ) print ( response . data ) @app . command () def get_customer ( ec : str ): response = paystack . customers . get_customer ( email_or_code = ec ) print ( response . status_code ) print ( response . status ) print ( response . message ) print ( response . data ) @app . command () def update_customer ( code : str , last_name : str , first_name : str ): response = paystack . customers . update ( code = code , last_name = last_name , first_name = first_name ) print ( response . status_code ) print ( response . status ) print ( response . message ) print ( response . data ) if __name__ == \"__main__\" : app () We now have 3 new commands for our cli app. you can check them out with python main.py --help Now under the available command you should see get-customer, list-customers, new-customer, update-customer Usage: main.py [ OPTIONS ] COMMAND [ ARGS ] ... Options: --install-completion [ bash | zsh | fish | powershell | pwsh ] Install completion for the specified shell. --show-completion [ bash | zsh | fish | powershell | pwsh ] Show completion for the specified shell, to copy it or customize the installation. --help Show this message and exit. Commands: get-customer list-customers new-customer update-customer You can try out the new command with the following commands Where to go from here It's all in your hands now . We now have a working cli app, but it does not have all the features to make it a fully fledged Paystack command line client you can implement more commands. It also does not handle all the likely exception that can occur, but then, the purpose of the tutorial is to expose you to pypaystack2 . Not sure how something works, you can always search the documentation. Good luck on your next project!","title":"Paystack Command line Client"},{"location":"tutorials/tutorial1/#paystack-command-line-client","text":"This tutorial aims to expose you to how to use pypaystack2 in your python projects for paystack integrations. We'll be building a simple command line application that integrates with paystack's services.","title":"Paystack Command line Client"},{"location":"tutorials/tutorial1/#project-setup","text":"We'll start by setting up our project. We'll be using pipenv for managing this project's dependencies and environment. you're free to use your preferred choice like virtualenv , hatch or poetry . if you don't have pipenv installed yet, you can install it with pip install pipenv . it's important to note that pipenv should be installed globally and not within a virtual environment. You're good to proceed if this prerequisite is met. Create a directory to house our project. mkdir paystack_cli_client && cd paystack_cli_client Initialize a virtual environment for the project. pipenv shell Install the projects dependencies. We'll be needing pypaystack2 , python-dotenv , and typer . pypaystack2 package is an API wrapper for paystack's services. python-dotenv helps us manage our environmental variables and typer makes building command line apps in python super simple. pipenv install pypaystack2 python-dotenv typer If all work's fine, you're good to proceed.","title":"Project Setup"},{"location":"tutorials/tutorial1/#environmental-variables","text":"pypaystack2 depends on your paystack authorization key that you get from signing up to paystack. Paystack provides you with two pairs. A pair of public and secret keys for live mode and another set for test mode. You can find them in your account settings. Since this is just a tutorial, we'll be using only the test secret key. create a new file named .env within your project's root directory. Now put in your test secret key in the .env file like so. PAYSTACK_AUTHORIZATION_KEY = \"<your paystack test secret key>\" Warning Because this is just a tutorial, no extra measure is made to protect this environmental. In a more serious project or production code, extra care should be taken to protect it and also avoid pushing it to a remote source control.","title":"Environmental Variables"},{"location":"tutorials/tutorial1/#let-the-games-begin","text":"It's time to start building! create a new file named main.py in your root directory. # root-dir/main.py from dotenv import load_dotenv load_dotenv () What we have just done is loaded our secret test key within the .env file. You may be wondering why do we need that, here's why pypaystack2 needs this key to communicate with paystack's api. alternatively, you can pass your authorization key into any of the api wrappers provided by pypaystack2 via their auth_key parameter. Here's a list of all the API wrappers currently available as at the time of writing of this tutorial. Note As of version 1.1.3 , pypaystack2 provided Paystack class which had all the available api wrappers bounded to it. version 2.0.0 also added AsyncPaystack to provide the asynchronous equivalent. So instead off importing individual wrappers you only have to import the Paystack or AsyncPaystack class. Example: The old way of doing things from pypaystack2.uitls import Country from pypaystack2.api import Miscellaneous miscellaneous_wrapper = Miscellaneous ( auth_key = \"<paystack secret key>\" ) response = miscellaneous_wrapper . get_banks ( country = Country . NIGERIA ) print ( response ) The new way from pypaystack2 import Paystack , Country paystack = Paystack ( auth_key = \"<paystack secret key>\" ) response = paystack . miscellaneous . get_banks ( country = Country . NIGERIA ) print ( response ) So in a situation where you don't have your PAYSTACK_AUTHORIZATION_KEY as an environmental variable, you can pass it into any of the API wrappers. e.g. # When you don't have PAYSTACK_AUTHORIZATION_KEY(paystack secret key) in your environmental variables from pypaystack2 import Paystack paystack = Paystack ( auth_key = \"<your test secret key>\" ) # When you have PAYSTACK_AUTHORIZATION_KEY(paystack secret key) set in your environmental variables paystack = Paystack () Note You don't have to provide your authorization key on the instantiation of any of the API wrappers as long as you have it set in your environmental variables like this tutorial does.","title":"Let the games begin"},{"location":"tutorials/tutorial1/#on-your-marks","text":"The first feature we'll be implementing for our Paystack Command line Client is the ability to create new customers on our paystack integration. so now update your main.py file with the code below. # root-dir/main.py from dotenv import load_dotenv from typer import Typer load_dotenv () app = Typer () @app . command () def new_customer (): print ( \"new customer successfully created!\" ) if __name__ == \"__main__\" : app () This is a minimum setup to building cli apps with Typer . Now try this in your project's root directory. python main.py --help You should see. Usage: main.py [ OPTIONS ] Options: --install-completion [ bash | zsh | fish | powershell | pwsh ] Install completion for the specified shell. --show-completion [ bash | zsh | fish | powershell | pwsh ] Show completion for the specified shell, to copy it or customize the installation. --help Show this message and exit. You can see that we now have a command line app that's responding to our command in this case --help . Let's try out the custom command we just added. python main.py You should see new customer successfully created! At the moment, no new customer is actually getting created on your paystack integration. let's bring in pypaystack2 to help us get the job done. For this to work, pypaystack2 provides wrappers for the restful APIs provided by Paystack. These wrappers are named to closely match the API they wrap and methods on these wrappers correspond to endpoints on the Paystack services you're interested in so in this case, for us to create a customer on our integration, we need to use the Customer API wrapper which connects to Paystack's Customer Services API. More info at Paystack's Customer Services API # root-dir/main.py from typing import Optional from dotenv import load_dotenv from pypaystack2 import Paystack from typer import Typer load_dotenv () app = Typer () paystack = Paystack () @app . command () def new_customer ( email : str , first_name : Optional [ str ] = None , last_name : Optional [ str ] = None , phone : Optional [ str ] = None , ): response = paystack . customers . create ( email = email , first_name = first_name , last_name = last_name , phone = phone ) print ( response . status_code ) print ( response . status ) print ( response . message ) print ( response . data ) if __name__ == \"__main__\" : app () Note All API wrappers are available on pypaystack . as attributes e.g. paystack.transactions for the Transactions API Now if you run the script again. python main.py You get error saying you have a missing argument 'EMAIL' Usage: main.py [ OPTIONS ] EMAIL Try 'main.py --help' for help. Error: Missing argument 'EMAIL' . Now let's try out our script with the email of the customer we want to create. python main.py email@example.com Now if all goes fine. \"An Internet connection is required\", you should get something similar to this 200 True Customer created { 'transactions' : [] , 'subscriptions' : [] , 'authorizations' : [] , 'first_name' : '' , 'last_name' : '' , 'email' : 'email@example.com' , 'phone' : '' , 'metadata' : None, 'domain' : 'test' , 'customer_code' : 'CUS_kd197ej30zxr34v' , 'risk_action' : 'default' , 'id' : 47748473 , 'integration' : 630606 , 'createdAt' : '2021-06-20T05:16:20.000Z' , 'updatedAt' : '2021-06-20T05:16:20.000Z' , 'identified' : False, 'identifications' : None } Yay! You've just created a new customer on your integration You can check out the customer's tab in your Paystack account to confirm this. Tip You can also create new customers with a first name and last name like so. python main.py email@example.com --first-name John --last-name Doe","title":"On your marks!"},{"location":"tutorials/tutorial1/#what-just-happened","text":"You have just created a new customer on your integration with the CLI app you just built. But how? If you've followed this tutorial to this point, you already know what wrappers are, or you can quickly skim through the chapters before to get a refresher. The right question should be what is the create method on the Customer wrapper for. You guess right if what's on your mind is that it creates a new customer on your integration. So as it was said earlier, all wrappers have methods on them that correspond to an endpoint on paystack and all of these methods will return a Response object based on the response it gets from Paystack. This Response is just a NamedTuple that holds the status,status_code,message and data . So this call response = paystack . customers . create ( email = email , first_name = first_name , last_name = last_name , phone = phone ) in our script returns the Response object just described, and you can access each of these attributes with response.status , response.status_code , response.message , response.data","title":"What just happened?"},{"location":"tutorials/tutorial1/#more-commands","text":"Let's add a few more commands to our Paystack Command line Client # root-dir/main.py from typing import Optional from dotenv import load_dotenv from pypaystack2 import Paystack from typer import Typer load_dotenv () app = Typer () paystack = Paystack () @app . command () def new_customer ( email : str , first_name : Optional [ str ] = None , last_name : Optional [ str ] = None , phone : Optional [ str ] = None , ): response = paystack . customers . create ( email = email , first_name = first_name , last_name = last_name , phone = phone ) print ( response . status_code ) print ( response . status ) print ( response . message ) print ( response . data ) @app . command () def list_customers (): response = paystack . customers . get_customers () print ( response . status_code ) print ( response . status ) print ( response . message ) print ( response . data ) @app . command () def get_customer ( ec : str ): response = paystack . customers . get_customer ( email_or_code = ec ) print ( response . status_code ) print ( response . status ) print ( response . message ) print ( response . data ) @app . command () def update_customer ( code : str , last_name : str , first_name : str ): response = paystack . customers . update ( code = code , last_name = last_name , first_name = first_name ) print ( response . status_code ) print ( response . status ) print ( response . message ) print ( response . data ) if __name__ == \"__main__\" : app () We now have 3 new commands for our cli app. you can check them out with python main.py --help Now under the available command you should see get-customer, list-customers, new-customer, update-customer Usage: main.py [ OPTIONS ] COMMAND [ ARGS ] ... Options: --install-completion [ bash | zsh | fish | powershell | pwsh ] Install completion for the specified shell. --show-completion [ bash | zsh | fish | powershell | pwsh ] Show completion for the specified shell, to copy it or customize the installation. --help Show this message and exit. Commands: get-customer list-customers new-customer update-customer You can try out the new command with the following commands","title":"More Commands!"},{"location":"tutorials/tutorial1/#where-to-go-from-here","text":"It's all in your hands now . We now have a working cli app, but it does not have all the features to make it a fully fledged Paystack command line client you can implement more commands. It also does not handle all the likely exception that can occur, but then, the purpose of the tutorial is to expose you to pypaystack2 . Not sure how something works, you can always search the documentation. Good luck on your next project!","title":"Where to go from here"}]}