{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What's Pypaystack2 So Paystack provides restful API endpoints for developers from different platforms to integrate their services into their projects. So for python developers, to use these endpoints, you might opt for a package like requests to handle all the API calls which involves a lot of boilerplate. Pypaystack2 abstracts this process by handling all these complexities under the hood and exposing simple APIs for your python project. for example from pypaystack2 import Paystack # assumes you have installed pypaystack2 from pypaystack2.utils import Country paystack = Paystack () # assumes that your paystack auth key is in # your enviromental variables i.e. PAYSTACK_AUTHORIZATION_KEY=<paystack-secret-key> otherwise instatiate # the Miscellaneous API wrapper as it is done below. # paystack = Paystack(auth_key=<paystack-secret-key>) response = paystack . miscellaneous . get_banks ( country = Country . NIGERIA , use_cursor = False ) # Requires internet connection. print ( response ) With the code snippet above, you have successfully queried Paystack's Miscellaneous API to get a list of banks supported by paystack. A requests equivalent of the above will be like import requests # assumes you have requests installed. headers = { \"Content-Type\" : \"application/json\" , \"Authorization\" : \"Bearer <your_auth_key>\" } paystack_url = 'https://api.paystack.co/bank?perPage=50&country=ng&use_cursor=false' response = requests . get ( paystack_url , headers = headers ) # requires internet connection print ( response . json ()) While both approaches achieve the same goal, pypaystack2 uses requests under the hood and manages the headers and URL routes to endpoints, so you can focus more on the actions. with the miscellaneous_wrapper in the example above. you can call all endpoints associated with the Miscellaneous API with methods provided like .get_banks , .get_providers , .get_countries and .get_states . Pypaystack2 provides wrappers to all of Paystack APIs in its pypaystack2.api subpackage. each of the wrapper classes is named to closely match the Paystack API. so say you want to use Paystack's Invoices API, you'd import the wrapper with from pypaystack2.api import Invoice for the Invoices API. All endpoints available on the Invoices API are available as methods in the Invoice wrapper. Say you wanted to create an invoice by sending a POST request to Paystack's Invoice API endpoint /paymentrequest , you'll call Invoice wrapper's .create method. from pypaystack2 import Paystack paystack = Paystack () response = paystack . invoices . create ( customer = \"CUS_xwaj0txjryg393b\" , amount = 1000 ) # Creates an invoice with a charge of \u20a6100 From here you can check out the tutorials section to get more examples and get familiar or surf the documentation for wrappers and methods you'll need for your next project. Hurray!","title":"Introduction"},{"location":"#whats-pypaystack2","text":"So Paystack provides restful API endpoints for developers from different platforms to integrate their services into their projects. So for python developers, to use these endpoints, you might opt for a package like requests to handle all the API calls which involves a lot of boilerplate. Pypaystack2 abstracts this process by handling all these complexities under the hood and exposing simple APIs for your python project. for example from pypaystack2 import Paystack # assumes you have installed pypaystack2 from pypaystack2.utils import Country paystack = Paystack () # assumes that your paystack auth key is in # your enviromental variables i.e. PAYSTACK_AUTHORIZATION_KEY=<paystack-secret-key> otherwise instatiate # the Miscellaneous API wrapper as it is done below. # paystack = Paystack(auth_key=<paystack-secret-key>) response = paystack . miscellaneous . get_banks ( country = Country . NIGERIA , use_cursor = False ) # Requires internet connection. print ( response ) With the code snippet above, you have successfully queried Paystack's Miscellaneous API to get a list of banks supported by paystack. A requests equivalent of the above will be like import requests # assumes you have requests installed. headers = { \"Content-Type\" : \"application/json\" , \"Authorization\" : \"Bearer <your_auth_key>\" } paystack_url = 'https://api.paystack.co/bank?perPage=50&country=ng&use_cursor=false' response = requests . get ( paystack_url , headers = headers ) # requires internet connection print ( response . json ()) While both approaches achieve the same goal, pypaystack2 uses requests under the hood and manages the headers and URL routes to endpoints, so you can focus more on the actions. with the miscellaneous_wrapper in the example above. you can call all endpoints associated with the Miscellaneous API with methods provided like .get_banks , .get_providers , .get_countries and .get_states . Pypaystack2 provides wrappers to all of Paystack APIs in its pypaystack2.api subpackage. each of the wrapper classes is named to closely match the Paystack API. so say you want to use Paystack's Invoices API, you'd import the wrapper with from pypaystack2.api import Invoice for the Invoices API. All endpoints available on the Invoices API are available as methods in the Invoice wrapper. Say you wanted to create an invoice by sending a POST request to Paystack's Invoice API endpoint /paymentrequest , you'll call Invoice wrapper's .create method. from pypaystack2 import Paystack paystack = Paystack () response = paystack . invoices . create ( customer = \"CUS_xwaj0txjryg393b\" , amount = 1000 ) # Creates an invoice with a charge of \u20a6100 From here you can check out the tutorials section to get more examples and get familiar or surf the documentation for wrappers and methods you'll need for your next project. Hurray!","title":"What's Pypaystack2"},{"location":"explanation/","text":"Coming soon!","title":"Explanation"},{"location":"how-to-guides/","text":"How to use the new Paystack class In previous versions of pypaystack2 , it is required to import all the various API wrappers required to achieve a goal. e.g. say you want to work with the transactions API wrapper and the customer API wrapper, the code below demonstrates how it's achieved from pypaystack2.api import Transaction , Customer Besides having to import these different wrappers, you'll also have to instantiate them which is just bad. While this kind of import will continue to be supported, I've added a new Paystack class which has all the wrappers bound to it. So now the preferred way to use pypaystack2 is demonstrated below from pypaystack2 import Paystack # This is all that is required (except cases where enums in the utils are required). Here's a comparison of how a goal is achieved using the old API and the new API Old API from pypaystack2.api import Invoice , Transaction , Customer invoice_api_wrapper = Invoice () # assumes your PAYSTACK_AUTHORIZATION_KEY is set invoice_api_response = invoice_api_wrapper . create ( customer = \"CUS_xwaj0txjryg393b\" , amount = 1000 ) # Creates an invoice with a charge of \u20a6100 transaction_api_wrapper = Transaction () transaction_api_response = transaction_api_wrapper . get_transactions () customer_api_wrapper = Customer () customer_api_response = customer_api_wrapper . get_customers () New API from pypaystack2 import Paystack paystack_api = Paystack () # assumes your PAYSTACK_AUTHORIZATION_KEY is set invoice_api_response = paystack_api . invoices . create ( customer = \"CUS_xwaj0txjryg393b\" , amount = 1000 ) # Creates an invoice with a charge of \u20a6100 transaction_api_response = paystack_api . transactions . get_transactions () customer_api_response = paystack_api . transactions . get_transactions () Bindings on the Paystack object Paystack.apple_pay maps to the ApplePay wrapper in pypaystack2.api.ApplePay Paystack.bulk_charges maps to the BulkCharge wrapper in pypaystack2.api.BulkCharge Paystack.charge maps to the Charge wrapper in pypaystack2.api.Charge Paystack.control_panel maps to the ControlPanel wrapper in pypaystack2.api.ControlPanel Paystack.customers maps to the Customer wrapper in pypaystack2.api.Customer Paystack.dedicated_accounts maps to the DedicatedAccount wrapper in pypaystack2.api.DedicatedAccount Paystack.disputes maps to the Dispute wrapper in pypaystack2.api.Dispute Paystack.invoices maps to the Invoice wrapper in pypaystack2.api.Invoice Paystack.miscellaneous maps to the Miscellaneous wrapper in pypaystack2.api.Miscellaneous Paystack.payment_pages maps to the Page wrapper in pypaystack2.api.Page Paystack.plans maps to the Plan wrapper in pypaystack2.api.Plan Paystack.products maps to the Product wrapper in pypaystack2.api.Product Paystack.refunds maps to the Refund wrapper in pypaystack2.api.Refund Paystack.settlements maps to the Settlement wrapper in pypaystack2.api.Settlement Paystack.splits maps to the Split wrapper in pypaystack2.api.Split Paystack.subaccounts maps to the SubAccount wrapper in pypaystack2.api.SubAccount Paystack.subscriptions maps to the Subscription wrapper in pypaystack2.api.Subscription Paystack.terminals maps to the Terminal wrapper in pypaystack2.api.Terminal Paystack.transactions maps to the Transaction wrapper in pypaystack2.api.Transactions Paystack.transfer_recipients maps to the TransferRecipient wrapper in pypaystack2.api.TransferRecipient Paystack.transfer maps to the Transfer wrapper in pypaystack2.api.Transfer Paystack.tranfer_control maps to the TransferControl wrapper in pypaystack2.api.TransferControl Paystack.verificaton maps to the Verification wrapper in pypaystack2.api.Verification","title":"How-To Guides"},{"location":"how-to-guides/#how-to-use-the-new-paystack-class","text":"In previous versions of pypaystack2 , it is required to import all the various API wrappers required to achieve a goal. e.g. say you want to work with the transactions API wrapper and the customer API wrapper, the code below demonstrates how it's achieved from pypaystack2.api import Transaction , Customer Besides having to import these different wrappers, you'll also have to instantiate them which is just bad. While this kind of import will continue to be supported, I've added a new Paystack class which has all the wrappers bound to it. So now the preferred way to use pypaystack2 is demonstrated below from pypaystack2 import Paystack # This is all that is required (except cases where enums in the utils are required). Here's a comparison of how a goal is achieved using the old API and the new API","title":"How to use the new Paystack class"},{"location":"how-to-guides/#old-api","text":"from pypaystack2.api import Invoice , Transaction , Customer invoice_api_wrapper = Invoice () # assumes your PAYSTACK_AUTHORIZATION_KEY is set invoice_api_response = invoice_api_wrapper . create ( customer = \"CUS_xwaj0txjryg393b\" , amount = 1000 ) # Creates an invoice with a charge of \u20a6100 transaction_api_wrapper = Transaction () transaction_api_response = transaction_api_wrapper . get_transactions () customer_api_wrapper = Customer () customer_api_response = customer_api_wrapper . get_customers ()","title":"Old API"},{"location":"how-to-guides/#new-api","text":"from pypaystack2 import Paystack paystack_api = Paystack () # assumes your PAYSTACK_AUTHORIZATION_KEY is set invoice_api_response = paystack_api . invoices . create ( customer = \"CUS_xwaj0txjryg393b\" , amount = 1000 ) # Creates an invoice with a charge of \u20a6100 transaction_api_response = paystack_api . transactions . get_transactions () customer_api_response = paystack_api . transactions . get_transactions ()","title":"New API"},{"location":"how-to-guides/#bindings-on-the-paystack-object","text":"Paystack.apple_pay maps to the ApplePay wrapper in pypaystack2.api.ApplePay Paystack.bulk_charges maps to the BulkCharge wrapper in pypaystack2.api.BulkCharge Paystack.charge maps to the Charge wrapper in pypaystack2.api.Charge Paystack.control_panel maps to the ControlPanel wrapper in pypaystack2.api.ControlPanel Paystack.customers maps to the Customer wrapper in pypaystack2.api.Customer Paystack.dedicated_accounts maps to the DedicatedAccount wrapper in pypaystack2.api.DedicatedAccount Paystack.disputes maps to the Dispute wrapper in pypaystack2.api.Dispute Paystack.invoices maps to the Invoice wrapper in pypaystack2.api.Invoice Paystack.miscellaneous maps to the Miscellaneous wrapper in pypaystack2.api.Miscellaneous Paystack.payment_pages maps to the Page wrapper in pypaystack2.api.Page Paystack.plans maps to the Plan wrapper in pypaystack2.api.Plan Paystack.products maps to the Product wrapper in pypaystack2.api.Product Paystack.refunds maps to the Refund wrapper in pypaystack2.api.Refund Paystack.settlements maps to the Settlement wrapper in pypaystack2.api.Settlement Paystack.splits maps to the Split wrapper in pypaystack2.api.Split Paystack.subaccounts maps to the SubAccount wrapper in pypaystack2.api.SubAccount Paystack.subscriptions maps to the Subscription wrapper in pypaystack2.api.Subscription Paystack.terminals maps to the Terminal wrapper in pypaystack2.api.Terminal Paystack.transactions maps to the Transaction wrapper in pypaystack2.api.Transactions Paystack.transfer_recipients maps to the TransferRecipient wrapper in pypaystack2.api.TransferRecipient Paystack.transfer maps to the Transfer wrapper in pypaystack2.api.Transfer Paystack.tranfer_control maps to the TransferControl wrapper in pypaystack2.api.TransferControl Paystack.verificaton maps to the Verification wrapper in pypaystack2.api.Verification","title":"Bindings on the Paystack object"},{"location":"tutorials/","text":"Tutorials Paystack Command line Client","title":"Tutorials"},{"location":"tutorials/#tutorials","text":"Paystack Command line Client","title":"Tutorials"},{"location":"tutorials/tutorial1/","text":"Paystack Command line Client This tutorial aims to expose you to how to use pypaystack2 in your python projects for paystack integrations. We'll be building a simple command line application that integrates with paystack's services. Project Setup We'll start by setting up our project. We'll be using pipenv for managing this project's dependencies and environment. you're free to use your preferred choice like virtualenv . if you don't have pipenv installed yet, you can install it with pip install pipenv . it's important to note that pipenv should be installed globally and not within a virtual environment. You're good to proceed if this prerequisite is met. Create a directory to house our project. mkdir paystack_cli_client && cd paystack_cli_client Initialize a virtual environment for the project. pipenv shell Install the projects dependencies. We'll be needing pypaystack2 , python-dotenv , and typer . pypaystack2 package is an API wrapper for paystack's services. python-dotenv helps us manage our environmental variables and typer makes building command line apps in python super simple. pipenv install pypaystack2 python-dotenv typer If all work's fine, you're good to proceed. Environmental Variables pypaystack2 depends on your paystack authorization key that you get from signing up to paystack. Paystack provides you with two pairs. A pair of public and secret key for live mode and another set for test mode. You can find them in your account settings. Since this is just a tutorial we'll be using only the test secret key. create a new file named .env within your project's root directory. Now put in your test secret key in the .env file like so. PAYSTACK_AUTHORIZATION_KEY = \"<your paystack test secret key>\" Warning Because this is just a tutorial, no extra measure is made to protect this environmental. In a more serious project or production code, extra care should be taken to protect it and also avoid pushing it to a remote source control. Let the games begin It's time to start building! create a new file named main.py in your root directory. # root-dir/main.py from dotenv import load_dotenv load_dotenv () What we have just done is loaded our secret test key within the .env file. You may be wondering why do we need that, here's why pypaystack2 needs this key to communicate with paystack's api. alternatively, you can pass your authorization key into any of the api wrappers provided by pypaystack2 via their auth_key parameter. Here's a list of all the API wrappers currently available as at the time of writing of this tutorial. ApplePay BulkCharge Charge ControlPanel Customer DedicatedAccount Dispute Invoice Miscellaneous Page Plan Product Refund Settlement Split SubAccount Subscription Terminal Transaction TransferReceipt TransferControl Transfer Verification So in a situation where you don't have your PAYSTACK_AUTHORIZATION_KEY as an environmental variable, you can pass it into any of the API wrappers. e.g. # When you don't have PAYSTACK_AUTHORIZATION_KEY(paystack secret key) in your environmental variables from pypaystack2 import Paystack paystack = Paystack ( auth_key = \"<your test secret key>\" ) # When you have PAYSTACK_AUTHORIZATION_KEY(paystack secret key) set in your environmental variables paystack = Paystack () Note You don't have to provide your authorization key on the instantiation of any of the API wrappers as long as you have it set in your environmental variables like this tutorial does. On your marks! The first feature we'll be implementing for our Paystack Command line Client is the ability to create new customers on our paystack integration. so now update your main.py file with the code below. # root-dir/main.py from dotenv import load_dotenv from typer import Typer load_dotenv () app = Typer () @app . command () def new_customer (): print ( \"new customer successfully created!\" ) if __name__ == \"__main__\" : app () This is a minimum setup to building cli apps with Typer . Now try this in your project's root directory. python main.py --help You should see. Usage: main.py [ OPTIONS ] Options: --install-completion [ bash | zsh | fish | powershell | pwsh ] Install completion for the specified shell. --show-completion [ bash | zsh | fish | powershell | pwsh ] Show completion for the specified shell, to copy it or customize the installation. --help Show this message and exit. You can see that we now have a command line app that's responding to our command in this case --help . Let's try out the custom command we just added. python main.py You should see new customer successfully created! At the moment, no new customer is actually getting created on your paystack integration. let's bring in pypaystack2 to help us get the job done. For this to work, pypaystack2 provides wrappers for the restful APIs provided by Paystack. These wrappers are named to closely match the API they wrap and methods on these wrappers correspond to endpoints on the Paystack services you're interested in so in this case, for us to create a customer on our integration, we need to use the Customer API wrapper which connects to Paystack's Customer Services API. More info at Paystack's Customer Services API # root-dir/main.py from typing import Optional from dotenv import load_dotenv from pypaystack2 import Paystack from typer import Typer load_dotenv () app = Typer () paystack = Paystack () @app . command () def new_customer ( email : str , first_name : Optional [ str ] = None , last_name : Optional [ str ] = None , phone : Optional [ str ] = None , ): response = paystack . customers . create ( email = email , first_name = first_name , last_name = last_name , phone = phone ) print ( response . status_code ) print ( response . status ) print ( response . message ) print ( response . data ) if __name__ == \"__main__\" : app () Note All API wrappers are available on pypaystack . as attributes e.g. paystack.transactions for the Transactions API Now if you run the script again. python main.py You get error saying you have a missing argument 'EMAIL' Usage: main.py [ OPTIONS ] EMAIL Try 'main.py --help' for help. Error: Missing argument 'EMAIL' . Now let's try out our script with the email of the customer we want to create. python main.py email@example.com Now if all goes fine. \"An Internet connection is required\", you should get something similar to this 200 True Customer created { 'transactions' : [] , 'subscriptions' : [] , 'authorizations' : [] , 'first_name' : '' , 'last_name' : '' , 'email' : 'email@example.com' , 'phone' : '' , 'metadata' : None, 'domain' : 'test' , 'customer_code' : 'CUS_kd197ej30zxr34v' , 'risk_action' : 'default' , 'id' : 47748473 , 'integration' : 630606 , 'createdAt' : '2021-06-20T05:16:20.000Z' , 'updatedAt' : '2021-06-20T05:16:20.000Z' , 'identified' : False, 'identifications' : None } Yay! You've just created a new customer on your integration You can check out the customer's tab in your Paystack account to confirm this. Tip You can also create new customers with a first name and last name like so. python main.py email@example.com --first-name John --last-name Doe What just happened? You have just created a new customer on your integration with the CLI app you just built. But how? If you've followed this tutorial to this point you already know what wrappers are, or you can quickly skim through the chapters before to get a refresher. The right question should be what is the create method on the Customer wrapper for. You guess right if what's on your mind is that it creates the new customer on your integration. So as it was said earlier, all wrappers have methods on them that correspond to an endpoint on paystack and all of this methods will return a Response object based on the response it gets from Paystack. This Response is just a NamedTuple that holds the status,status_code,message and data . So this call response = paystack . customers . create ( email = email , first_name = first_name , last_name = last_name , phone = phone ) in our script returns the Response object just described, and you can access each of these attributes with response.status , response.status_code , response.message , response.data More Commands! Let's add a few more commands to our Paystack Command line Client # root-dir/main.py from typing import Optional from dotenv import load_dotenv from pypaystack2 import Paystack from typer import Typer load_dotenv () app = Typer () paystack = Paystack () @app . command () def new_customer ( email : str , first_name : Optional [ str ] = None , last_name : Optional [ str ] = None , phone : Optional [ str ] = None , ): response = paystack . customers . create ( email = email , first_name = first_name , last_name = last_name , phone = phone ) print ( response . status_code ) print ( response . status ) print ( response . message ) print ( response . data ) @app . command () def list_customers (): response = paystack . customers . get_customers () print ( response . status_code ) print ( response . status ) print ( response . message ) print ( response . data ) @app . command () def get_customer ( ec : str ): response = paystack . customers . get_customer ( email_or_code = ec ) print ( response . status_code ) print ( response . status ) print ( response . message ) print ( response . data ) @app . command () def update_customer ( code : str , last_name : str , first_name : str ): response = paystack . customers . update ( code = code , last_name = last_name , first_name = first_name ) print ( response . status_code ) print ( response . status ) print ( response . message ) print ( response . data ) if __name__ == \"__main__\" : app () We now have 3 new commands for our cli app. you can check them out with python main.py --help Now under the available command you should see get-customer, list-customers, new-customer, update-customer Usage: main.py [ OPTIONS ] COMMAND [ ARGS ] ... Options: --install-completion [ bash | zsh | fish | powershell | pwsh ] Install completion for the specified shell. --show-completion [ bash | zsh | fish | powershell | pwsh ] Show completion for the specified shell, to copy it or customize the installation. --help Show this message and exit. Commands: get-customer list-customers new-customer update-customer You can try out the new command with the following commands Where to go from here It's all in your hands now . We now have a working cli app, but it does not have all the features to make it a fully fledged Paystack command line client you can bring in more wrappers and implement new commands. It also does not handle all the likely exception that can occur, but then, the purpose of the tutorial is to expose you to pypaystack2 . Not sure how something works, you can always search the documentation. Good luck on your next project!","title":"Paystack Command line Client"},{"location":"tutorials/tutorial1/#paystack-command-line-client","text":"This tutorial aims to expose you to how to use pypaystack2 in your python projects for paystack integrations. We'll be building a simple command line application that integrates with paystack's services.","title":"Paystack Command line Client"},{"location":"tutorials/tutorial1/#project-setup","text":"We'll start by setting up our project. We'll be using pipenv for managing this project's dependencies and environment. you're free to use your preferred choice like virtualenv . if you don't have pipenv installed yet, you can install it with pip install pipenv . it's important to note that pipenv should be installed globally and not within a virtual environment. You're good to proceed if this prerequisite is met. Create a directory to house our project. mkdir paystack_cli_client && cd paystack_cli_client Initialize a virtual environment for the project. pipenv shell Install the projects dependencies. We'll be needing pypaystack2 , python-dotenv , and typer . pypaystack2 package is an API wrapper for paystack's services. python-dotenv helps us manage our environmental variables and typer makes building command line apps in python super simple. pipenv install pypaystack2 python-dotenv typer If all work's fine, you're good to proceed.","title":"Project Setup"},{"location":"tutorials/tutorial1/#environmental-variables","text":"pypaystack2 depends on your paystack authorization key that you get from signing up to paystack. Paystack provides you with two pairs. A pair of public and secret key for live mode and another set for test mode. You can find them in your account settings. Since this is just a tutorial we'll be using only the test secret key. create a new file named .env within your project's root directory. Now put in your test secret key in the .env file like so. PAYSTACK_AUTHORIZATION_KEY = \"<your paystack test secret key>\" Warning Because this is just a tutorial, no extra measure is made to protect this environmental. In a more serious project or production code, extra care should be taken to protect it and also avoid pushing it to a remote source control.","title":"Environmental Variables"},{"location":"tutorials/tutorial1/#let-the-games-begin","text":"It's time to start building! create a new file named main.py in your root directory. # root-dir/main.py from dotenv import load_dotenv load_dotenv () What we have just done is loaded our secret test key within the .env file. You may be wondering why do we need that, here's why pypaystack2 needs this key to communicate with paystack's api. alternatively, you can pass your authorization key into any of the api wrappers provided by pypaystack2 via their auth_key parameter. Here's a list of all the API wrappers currently available as at the time of writing of this tutorial. ApplePay BulkCharge Charge ControlPanel Customer DedicatedAccount Dispute Invoice Miscellaneous Page Plan Product Refund Settlement Split SubAccount Subscription Terminal Transaction TransferReceipt TransferControl Transfer Verification So in a situation where you don't have your PAYSTACK_AUTHORIZATION_KEY as an environmental variable, you can pass it into any of the API wrappers. e.g. # When you don't have PAYSTACK_AUTHORIZATION_KEY(paystack secret key) in your environmental variables from pypaystack2 import Paystack paystack = Paystack ( auth_key = \"<your test secret key>\" ) # When you have PAYSTACK_AUTHORIZATION_KEY(paystack secret key) set in your environmental variables paystack = Paystack () Note You don't have to provide your authorization key on the instantiation of any of the API wrappers as long as you have it set in your environmental variables like this tutorial does.","title":"Let the games begin"},{"location":"tutorials/tutorial1/#on-your-marks","text":"The first feature we'll be implementing for our Paystack Command line Client is the ability to create new customers on our paystack integration. so now update your main.py file with the code below. # root-dir/main.py from dotenv import load_dotenv from typer import Typer load_dotenv () app = Typer () @app . command () def new_customer (): print ( \"new customer successfully created!\" ) if __name__ == \"__main__\" : app () This is a minimum setup to building cli apps with Typer . Now try this in your project's root directory. python main.py --help You should see. Usage: main.py [ OPTIONS ] Options: --install-completion [ bash | zsh | fish | powershell | pwsh ] Install completion for the specified shell. --show-completion [ bash | zsh | fish | powershell | pwsh ] Show completion for the specified shell, to copy it or customize the installation. --help Show this message and exit. You can see that we now have a command line app that's responding to our command in this case --help . Let's try out the custom command we just added. python main.py You should see new customer successfully created! At the moment, no new customer is actually getting created on your paystack integration. let's bring in pypaystack2 to help us get the job done. For this to work, pypaystack2 provides wrappers for the restful APIs provided by Paystack. These wrappers are named to closely match the API they wrap and methods on these wrappers correspond to endpoints on the Paystack services you're interested in so in this case, for us to create a customer on our integration, we need to use the Customer API wrapper which connects to Paystack's Customer Services API. More info at Paystack's Customer Services API # root-dir/main.py from typing import Optional from dotenv import load_dotenv from pypaystack2 import Paystack from typer import Typer load_dotenv () app = Typer () paystack = Paystack () @app . command () def new_customer ( email : str , first_name : Optional [ str ] = None , last_name : Optional [ str ] = None , phone : Optional [ str ] = None , ): response = paystack . customers . create ( email = email , first_name = first_name , last_name = last_name , phone = phone ) print ( response . status_code ) print ( response . status ) print ( response . message ) print ( response . data ) if __name__ == \"__main__\" : app () Note All API wrappers are available on pypaystack . as attributes e.g. paystack.transactions for the Transactions API Now if you run the script again. python main.py You get error saying you have a missing argument 'EMAIL' Usage: main.py [ OPTIONS ] EMAIL Try 'main.py --help' for help. Error: Missing argument 'EMAIL' . Now let's try out our script with the email of the customer we want to create. python main.py email@example.com Now if all goes fine. \"An Internet connection is required\", you should get something similar to this 200 True Customer created { 'transactions' : [] , 'subscriptions' : [] , 'authorizations' : [] , 'first_name' : '' , 'last_name' : '' , 'email' : 'email@example.com' , 'phone' : '' , 'metadata' : None, 'domain' : 'test' , 'customer_code' : 'CUS_kd197ej30zxr34v' , 'risk_action' : 'default' , 'id' : 47748473 , 'integration' : 630606 , 'createdAt' : '2021-06-20T05:16:20.000Z' , 'updatedAt' : '2021-06-20T05:16:20.000Z' , 'identified' : False, 'identifications' : None } Yay! You've just created a new customer on your integration You can check out the customer's tab in your Paystack account to confirm this. Tip You can also create new customers with a first name and last name like so. python main.py email@example.com --first-name John --last-name Doe","title":"On your marks!"},{"location":"tutorials/tutorial1/#what-just-happened","text":"You have just created a new customer on your integration with the CLI app you just built. But how? If you've followed this tutorial to this point you already know what wrappers are, or you can quickly skim through the chapters before to get a refresher. The right question should be what is the create method on the Customer wrapper for. You guess right if what's on your mind is that it creates the new customer on your integration. So as it was said earlier, all wrappers have methods on them that correspond to an endpoint on paystack and all of this methods will return a Response object based on the response it gets from Paystack. This Response is just a NamedTuple that holds the status,status_code,message and data . So this call response = paystack . customers . create ( email = email , first_name = first_name , last_name = last_name , phone = phone ) in our script returns the Response object just described, and you can access each of these attributes with response.status , response.status_code , response.message , response.data","title":"What just happened?"},{"location":"tutorials/tutorial1/#more-commands","text":"Let's add a few more commands to our Paystack Command line Client # root-dir/main.py from typing import Optional from dotenv import load_dotenv from pypaystack2 import Paystack from typer import Typer load_dotenv () app = Typer () paystack = Paystack () @app . command () def new_customer ( email : str , first_name : Optional [ str ] = None , last_name : Optional [ str ] = None , phone : Optional [ str ] = None , ): response = paystack . customers . create ( email = email , first_name = first_name , last_name = last_name , phone = phone ) print ( response . status_code ) print ( response . status ) print ( response . message ) print ( response . data ) @app . command () def list_customers (): response = paystack . customers . get_customers () print ( response . status_code ) print ( response . status ) print ( response . message ) print ( response . data ) @app . command () def get_customer ( ec : str ): response = paystack . customers . get_customer ( email_or_code = ec ) print ( response . status_code ) print ( response . status ) print ( response . message ) print ( response . data ) @app . command () def update_customer ( code : str , last_name : str , first_name : str ): response = paystack . customers . update ( code = code , last_name = last_name , first_name = first_name ) print ( response . status_code ) print ( response . status ) print ( response . message ) print ( response . data ) if __name__ == \"__main__\" : app () We now have 3 new commands for our cli app. you can check them out with python main.py --help Now under the available command you should see get-customer, list-customers, new-customer, update-customer Usage: main.py [ OPTIONS ] COMMAND [ ARGS ] ... Options: --install-completion [ bash | zsh | fish | powershell | pwsh ] Install completion for the specified shell. --show-completion [ bash | zsh | fish | powershell | pwsh ] Show completion for the specified shell, to copy it or customize the installation. --help Show this message and exit. Commands: get-customer list-customers new-customer update-customer You can try out the new command with the following commands","title":"More Commands!"},{"location":"tutorials/tutorial1/#where-to-go-from-here","text":"It's all in your hands now . We now have a working cli app, but it does not have all the features to make it a fully fledged Paystack command line client you can bring in more wrappers and implement new commands. It also does not handle all the likely exception that can occur, but then, the purpose of the tutorial is to expose you to pypaystack2 . Not sure how something works, you can always search the documentation. Good luck on your next project!","title":"Where to go from here"}]}