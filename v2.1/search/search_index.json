{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PyPaystack2","text":"<p> A developer friendly wrapper for Paystack API</p> <p>Documentation: https://github.com/gray-adeyi/pypaystack2</p> <p>Source Code: https://gray-adeyi.github.io/pypaystack2/</p> <p>PyPaystack2 is a python wrapper over the Paystack API. It aims at being  developer friendly and easy to use.</p> <p>The key features are:</p> <ul> <li>Type hints: All methods provided by PyPaystack2 are type annotated, so you can infer. This improves the   development experience.</li> <li>Async support: PyPaystack2 allow you to also make calls to Paystack API using <code>async/await</code> which is super great,   for example, if your project is in FastAPI where every chance of a performance   improvement adds up.</li> </ul>"},{"location":"#requirements","title":"Requirements","text":"<p>Python 3.9+</p> <p>PyPaystack2 now uses httpx under the hood to make API calls to Paystack. Compared to previous version <code>1.1.3</code> and down which use <code>requests</code>. This switch has made it possible to support <code>async/await</code> based wrappers.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>$ pip install pypaystack2\n</code></pre>"},{"location":"#example","title":"Example","text":"<pre><code>Python 3.9.15 (main, Dec 12 2022, 21:54:43) \n[GCC 12.2.0] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt; from pypaystack2 import Paystack\n&gt;&gt;&gt; paystack = Paystack() # assumes the environmental variable `PAYSTACK_AUTHORIZATION_KEY=paystack integration secret key` is set. if not, you can alternatively pass it into the `Paystack` instantiation like so Paystack(auth_key='paystack integration secret key')\n&gt;&gt;&gt; response = paystack.customers.get_customer(email_or_code=\"CUS_8x2byd6x3dk5hp0\")\n&gt;&gt;&gt; print(response)\nResponse(status_code=200, status=True, message='Customer retrieved', data={'transactions': [], 'subscriptions': [], 'authorizations': [{'authorization_code': 'AUTH_ohnpjcd7z9', 'bin': '408408', 'last4': '4081', 'exp_month': '12', 'exp_year': '2030', 'channel': 'card', 'card_type': 'visa ', 'bank': 'TEST BANK', 'country_code': 'NG', 'brand': 'visa', 'reusable': True, 'signature': 'SIG_JOdryeujwrsZryg0Lkrg', 'account_name': None}], 'first_name': 'john', 'last_name': 'doe', 'email': 'johndoe@example.com', 'phone': None, 'metadata': None, 'domain': 'test', 'customer_code': 'CUS_8x2byd6x3dk5hp0', 'risk_action': 'default', 'id': 87934333, 'integration': 630606, 'createdAt': '2022-07-25T03:46:01.000Z', 'updatedAt': '2022-07-25T03:46:01.000Z', 'created_at': '2022-07-25T03:46:01.000Z', 'updated_at': '2022-07-25T03:46:01.000Z', 'total_transactions': 0, 'total_transaction_value': [], 'dedicated_account': None, 'identified': False, 'identifications': None})\n&gt;&gt;&gt; print(response.status_code)\n200\n&gt;&gt;&gt; print(response.message)\nCustomer retrieved\n&gt;&gt;&gt; \n</code></pre> <p>All you need to interact with Paystack's API in your python project is the <code>Paystack class</code> it has attributes bounded to it that provides methods you can call in your code to make API calls to Paystack. Every method call on the wrapper has the same return type, which is a Response. A namedtuple containing the data from making the actual call to Paystack servers</p>"},{"location":"#async-now","title":"Async Now!","text":"<p>PyPaystack2 now supports asynchronous wrappers to Paystack's API. <code>AsyncPaystack</code> is an asynchronous mirror equivalent of the <code>Paystack</code> wrapper. i.e. <code>AsyncPaystack</code> provides the same functionality as the <code>Paystack</code> wrapper but is more useful in the context of <code>async\\await</code> code. All the bindings on the <code>AsyncPaystack</code> are the same as on the <code>Paystack</code> wrapper except that the methods on the <code>AsyncPaystack</code> are <code>awaitable</code></p> <pre><code>asyncio REPL 3.9.15 (main, Dec 12 2022, 21:54:43) \n[GCC 12.2.0] on linux\nUse \"await\" directly instead of \"asyncio.run()\".\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt; import asyncio\n&gt;&gt;&gt; from pypaystack2 import AsyncPaystack\n&gt;&gt;&gt; paystack = AsyncPaystack() # assumes the environmental variable `PAYSTACK_AUTHORIZATION_KEY=paystack integration secret key` is set. if not, you can alternatively pass it into the `AsyncPaystack` instantiation like so AsyncPaystack(auth_key='paystack integration secret key')\n&gt;&gt;&gt; response = await paystack.customers.get_customer(email_or_code=\"CUS_8x2byd6x3dk5hp0\")\n&gt;&gt;&gt; print(response)\nResponse(status_code=200, status=True, message='Customer retrieved', data={'transactions': [], 'subscriptions': [], 'authorizations': [{'authorization_code': 'AUTH_ohnpjcd7z9', 'bin': '408408', 'last4': '4081', 'exp_month': '12', 'exp_year': '2030', 'channel': 'card', 'card_type': 'visa ', 'bank': 'TEST BANK', 'country_code': 'NG', 'brand': 'visa', 'reusable': True, 'signature': 'SIG_JOdryeujwrsZryg0Lkrg', 'account_name': None}], 'first_name': 'john', 'last_name': 'doe', 'email': 'johndoe@example.com', 'phone': None, 'metadata': None, 'domain': 'test', 'customer_code': 'CUS_8x2byd6x3dk5hp0', 'risk_action': 'default', 'id': 87934333, 'integration': 630606, 'createdAt': '2022-07-25T03:46:01.000Z', 'updatedAt': '2022-07-25T03:46:01.000Z', 'created_at': '2022-07-25T03:46:01.000Z', 'updated_at': '2022-07-25T03:46:01.000Z', 'total_transactions': 0, 'total_transaction_value': [], 'dedicated_account': None, 'identified': False, 'identifications': None})\n&gt;&gt;&gt; print(response.status_code)\n200\n&gt;&gt;&gt; print(response.message)\nCustomer retrieved\n&gt;&gt;&gt; \n</code></pre>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the terms of the MIT license.</p>"},{"location":"#contributors","title":"Contributors","text":"<ul> <li>gray-adeyi</li> </ul>"},{"location":"#buy-me-a-coffee","title":"Buy me a coffee","text":"<p>https://www.buymeacoffee.com/jigani</p>"},{"location":"explanation/","title":"Explanation","text":"<p>Coming soon!</p>"},{"location":"how-to-guides/","title":"How-To Guides","text":""},{"location":"how-to-guides/#how-to-use-the-new-paystack-class","title":"How to use the new Paystack class","text":"<p>In previous versions of <code>pypaystack2</code>, it is required to import all the various API wrappers required to achieve a goal. E.g. say you want to work with the transactions API wrapper and the customer API wrapper, the code below demonstrates how it's achieved</p> <pre><code>from pypaystack2.api import Transaction, Customer\n</code></pre> <p>Besides having to import these different wrappers, you'll also have to instantiate them, individually. While this kind of import will continue to be supported, I've added a new <code>Paystack</code> class which has all the wrappers bound to it. So now the preferred way to use <code>pypaystack2</code> is demonstrated below</p> <pre><code>from pypaystack2 import Paystack\n</code></pre> <p>Here's a comparison of how a goal is achieved using the old API and the new API</p>"},{"location":"how-to-guides/#old-api","title":"Old API","text":"<pre><code>from pypaystack2.api import PaymentRequest, Transaction, Customer\n\ninvoice_api_wrapper = PaymentRequest()  # assumes your PAYSTACK_AUTHORIZATION_KEY is set\ninvoice_api_response = invoice_api_wrapper.create(customer=\"CUS_xwaj0txjryg393b\",\n                                                  amount=1000)  # Creates an invoice with a charge of \u20a6100\ntransaction_api_wrapper = Transaction()\ntransaction_api_response = transaction_api_wrapper.get_transactions()\ncustomer_api_wrapper = Customer()\ncustomer_api_response = customer_api_wrapper.get_customers()\n</code></pre>"},{"location":"how-to-guides/#new-api","title":"New API","text":"<pre><code>from pypaystack2 import Paystack\n\npaystack_api = Paystack()  # assumes your PAYSTACK_AUTHORIZATION_KEY is set\npayment_requests_api_response = paystack_api.payment_requests.create(customer=\"CUS_xwaj0txjryg393b\",\n                                                                     amount=1000)  # Creates an invoice with a charge of \u20a6100\ntransaction_api_response = paystack_api.transactions.get_transactions()\ncustomer_api_response = paystack_api.transactions.get_transactions()\n</code></pre> <p>For <code>async/await</code></p> <pre><code>from pypaystack2 import AsyncPaystack\n\npaystack_api = AsyncPaystack()  # assumes your PAYSTACK_AUTHORIZATION_KEY is set\npayment_requests_api_response = await paystack_api.payment_requests.create(customer=\"CUS_xwaj0txjryg393b\",\n                                                                           amount=1000)  # Creates an invoice with a charge of \u20a6100\ntransaction_api_response = await paystack_api.transactions.get_transactions()\ncustomer_api_response = await paystack_api.transactions.get_transactions()\n</code></pre> <p>Note</p> <pre><code>For the async equivalent to work start your interpreter in async mode with `python -m asyncio`\nYou should get a prompt similar to this.\n```python\nasyncio REPL 3.9.15 (main, May 14 2023, 15:13:34) \n[GCC 12.2.1 20230201] on linux\nUse \"await\" directly instead of \"asyncio.run()\".\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt; import asyncio\n&gt;&gt;&gt;\n```\n</code></pre>"},{"location":"how-to-guides/#bindings-on-the-paystack-object","title":"Bindings on the Paystack object","text":"API wrapper binding name on <code>Paystack</code> class <code>ApplePay</code> <code>apple_pay</code> <code>BulkCharge</code> <code>bulk_charges</code> <code>Charge</code> <code>charge</code> <code>Integration</code> <code>integration</code> <code>Customer</code> <code>customer</code> <code>DedicatedAccount</code> <code>dedicated_account</code> <code>Dispute</code> <code>disputes</code> <code>PaymentRequest</code> <code>payment_requests</code> <code>Miscellaneous</code> <code>miscellaneous</code> <code>Page</code> <code>payment_pages</code> <code>Product</code> <code>products</code> <code>Refund</code> <code>refunds</code> <code>Settlement</code> <code>settlements</code> <code>Split</code> <code>split</code> <code>SubAccount</code> <code>subaccount</code> <code>Subscription</code> <code>subscriptions</code> <code>Terminal</code> <code>terminals</code> <code>Transaction</code> <code>transactions</code> <code>TransferRecipient</code> <code>transfer_recipients</code> <code>Transfer</code> <code>transfers</code> <code>TransferControl</code> <code>transfer_control</code> <code>Verification</code> <code>verification</code>"},{"location":"how-to-guides/#bindings-on-the-asyncpaystack-object","title":"Bindings on the AsyncPaystack object","text":"API wrapper binding name on <code>Paystack</code> class <code>AsyncApplePay</code> <code>apple_pay</code> <code>AsyncBulkCharge</code> <code>bulk_charges</code> <code>AsyncCharge</code> <code>charge</code> <code>AsyncIntegration</code> <code>integration</code> <code>AsyncCustomer</code> <code>customer</code> <code>AsyncDedicatedAccount</code> <code>dedicated_account</code> <code>AsyncDispute</code> <code>disputes</code> <code>AsyncPaymentRequest</code> <code>payment_requests</code> <code>AsyncMiscellaneous</code> <code>miscellaneous</code> <code>AsyncPage</code> <code>payment_pages</code> <code>AsyncProduct</code> <code>products</code> <code>AsyncRefund</code> <code>refunds</code> <code>AsyncSettlement</code> <code>settlements</code> <code>AsyncSplit</code> <code>split</code> <code>AsyncSubAccount</code> <code>subaccount</code> <code>AsyncSubscription</code> <code>subscriptions</code> <code>AsyncTerminal</code> <code>terminals</code> <code>AsyncTransaction</code> <code>transactions</code> <code>AsyncTransferRecipient</code> <code>transfer_recipients</code> <code>AsyncTransfer</code> <code>transfers</code> <code>AsyncTransferControl</code> <code>transfer_control</code> <code>AsyncVerification</code> <code>verification</code>"},{"location":"reference/","title":"Pypaystack2 Package Reference","text":"<p>Pypaystack2 is a simple python wrapper for Paystack API.</p> <p>it is a fork of the original project Pypaystack Modules and packages exported by this package:    - <code>api</code>: A package containing several wrappers for Paystack API, like apple pay api, bulk charges api e.t.c.    - <code>utils</code>: A module containing useful utilities and enums    - <code>errors</code>: A module containing error types for pypaystack2</p>"},{"location":"reference/#pypaystack2paytack","title":"<code>pypaystack2.paytack</code>","text":""},{"location":"reference/#pypaystack2.paystack.AsyncPaystack","title":"<code>AsyncPaystack</code>","text":"<p>               Bases: <code>BaseAsyncAPI</code></p> <p>An asynchronous Paystack API wrapper class with all the wrappers supported by pypaystack2.</p> <p>This class has all the individual api wrapper classes like <code>ApplePay</code>, <code>BulkCharge</code> bound to it. its intent is to reduce the number of imports by exposing all the api wrappers bound to it via an instance of this class.</p> Source code in <code>src/pypaystack2/paystack.py</code> <pre><code>class AsyncPaystack(BaseAsyncAPI):\n    \"\"\"An asynchronous Paystack API wrapper class with all the wrappers supported by pypaystack2.\n\n    This class has all the individual api wrapper classes like `ApplePay`, `BulkCharge` bound to it.\n    its intent is to reduce the number of imports by exposing all the api wrappers bound to it via an\n    instance of this class.\n    \"\"\"\n\n    def __init__(self, auth_key: str = None):\n        super().__init__(auth_key=auth_key)\n        self.apple_pay = AsyncApplePay(auth_key=self._PAYSTACK_AUTHORIZATION_KEY)\n        self.bulk_charges = AsyncBulkCharge(auth_key=self._PAYSTACK_AUTHORIZATION_KEY)\n        self.charge = AsyncCharge(auth_key=self._PAYSTACK_AUTHORIZATION_KEY)\n        self.integration = AsyncIntegration(auth_key=self._PAYSTACK_AUTHORIZATION_KEY)\n        self.customers = AsyncCustomer(auth_key=self._PAYSTACK_AUTHORIZATION_KEY)\n        self.dedicated_accounts = AsyncDedicatedAccount(\n            auth_key=self._PAYSTACK_AUTHORIZATION_KEY\n        )\n        self.disputes = AsyncDispute(auth_key=self._PAYSTACK_AUTHORIZATION_KEY)\n        self.payment_requests = AsyncPaymentRequest(\n            auth_key=self._PAYSTACK_AUTHORIZATION_KEY\n        )\n        self.miscellaneous = AsyncMiscellaneous(\n            auth_key=self._PAYSTACK_AUTHORIZATION_KEY\n        )\n        self.payment_pages = AsyncPaymentPage(auth_key=self._PAYSTACK_AUTHORIZATION_KEY)\n        self.plans = AsyncPlan(auth_key=self._PAYSTACK_AUTHORIZATION_KEY)\n        self.products = AsyncProduct(auth_key=self._PAYSTACK_AUTHORIZATION_KEY)\n        self.refunds = AsyncRefund(auth_key=self._PAYSTACK_AUTHORIZATION_KEY)\n        self.settlements = AsyncSettlement(auth_key=self._PAYSTACK_AUTHORIZATION_KEY)\n        self.splits = AsyncTransactionSplit(auth_key=self._PAYSTACK_AUTHORIZATION_KEY)\n        self.subaccounts = AsyncSubAccount(auth_key=self._PAYSTACK_AUTHORIZATION_KEY)\n        self.subscriptions = AsyncSubscription(\n            auth_key=self._PAYSTACK_AUTHORIZATION_KEY\n        )\n        self.terminals = AsyncTerminal(auth_key=self._PAYSTACK_AUTHORIZATION_KEY)\n        self.transactions = AsyncTransaction(auth_key=self._PAYSTACK_AUTHORIZATION_KEY)\n        self.transfer_recipients = AsyncTransferRecipient(\n            auth_key=self._PAYSTACK_AUTHORIZATION_KEY\n        )\n        self.transfers = AsyncTransfer(auth_key=self._PAYSTACK_AUTHORIZATION_KEY)\n        self.transfer_control = AsyncTransferControl(\n            auth_key=self._PAYSTACK_AUTHORIZATION_KEY\n        )\n        self.verification = AsyncVerification(auth_key=self._PAYSTACK_AUTHORIZATION_KEY)\n</code></pre>"},{"location":"reference/#pypaystack2.paystack.Paystack","title":"<code>Paystack</code>","text":"<p>               Bases: <code>BaseAPI</code></p> <p>A Paystack API wrapper class with all the wrappers supported by pypaystack2.</p> <p>This class has all the individual api wrapper classes like <code>ApplePay</code>, <code>BulkCharge</code> bound to it. its intent is to reduce the number of imports by exposing all the api wrappers bound to it via an instance of this class.</p> Source code in <code>src/pypaystack2/paystack.py</code> <pre><code>class Paystack(BaseAPI):\n    \"\"\"A Paystack API wrapper class with all the wrappers supported by pypaystack2.\n\n    This class has all the individual api wrapper classes like `ApplePay`, `BulkCharge` bound to it.\n    its intent is to reduce the number of imports by exposing all the api wrappers bound to it via an\n    instance of this class.\n    \"\"\"\n\n    def __init__(self, auth_key: str = None):\n        super().__init__(auth_key=auth_key)\n        self.apple_pay = ApplePay(auth_key=self._PAYSTACK_AUTHORIZATION_KEY)\n        self.bulk_charges = BulkCharge(auth_key=self._PAYSTACK_AUTHORIZATION_KEY)\n        self.charge = Charge(auth_key=self._PAYSTACK_AUTHORIZATION_KEY)\n        self.integration = Integration(auth_key=self._PAYSTACK_AUTHORIZATION_KEY)\n        self.customers = Customer(auth_key=self._PAYSTACK_AUTHORIZATION_KEY)\n        self.dedicated_accounts = DedicatedAccount(\n            auth_key=self._PAYSTACK_AUTHORIZATION_KEY\n        )\n        self.disputes = Dispute(auth_key=self._PAYSTACK_AUTHORIZATION_KEY)\n        self.payment_requests = PaymentRequest(\n            auth_key=self._PAYSTACK_AUTHORIZATION_KEY\n        )\n        self.miscellaneous = Miscellaneous(auth_key=self._PAYSTACK_AUTHORIZATION_KEY)\n        self.payment_pages = PaymentPage(auth_key=self._PAYSTACK_AUTHORIZATION_KEY)\n        self.plans = Plan(auth_key=self._PAYSTACK_AUTHORIZATION_KEY)\n        self.products = Product(auth_key=self._PAYSTACK_AUTHORIZATION_KEY)\n        self.refunds = Refund(auth_key=self._PAYSTACK_AUTHORIZATION_KEY)\n        self.settlements = Settlement(auth_key=self._PAYSTACK_AUTHORIZATION_KEY)\n        self.splits = TransactionSplit(auth_key=self._PAYSTACK_AUTHORIZATION_KEY)\n        self.subaccounts = SubAccount(auth_key=self._PAYSTACK_AUTHORIZATION_KEY)\n        self.subscriptions = Subscription(auth_key=self._PAYSTACK_AUTHORIZATION_KEY)\n        self.terminals = Terminal(auth_key=self._PAYSTACK_AUTHORIZATION_KEY)\n        self.transactions = Transaction(auth_key=self._PAYSTACK_AUTHORIZATION_KEY)\n        self.transfer_recipients = TransferRecipient(\n            auth_key=self._PAYSTACK_AUTHORIZATION_KEY\n        )\n        self.transfers = Transfer(auth_key=self._PAYSTACK_AUTHORIZATION_KEY)\n        self.transfer_control = TransferControl(\n            auth_key=self._PAYSTACK_AUTHORIZATION_KEY\n        )\n        self.verification = Verification(auth_key=self._PAYSTACK_AUTHORIZATION_KEY)\n</code></pre>"},{"location":"reference/#pypaystack2api","title":"<code>pypaystack2.api</code>","text":"<p>A package containing several wrappers for interfacing Paystack API, like apple pay api, bulk charges api e.t.c. Modules exported by this package:     - <code>apple_pay</code>: A module containing implementations for interfacing with Paystack's Apple Pay API     - <code>bulk_charges</code>: A module containing implementations for interfacing with Paystack's Bulk Charges API     - <code>charge</code>: A module containing implementations for interfacing with Paystack's Charge API     - <code>control_panel</code>: A module containing implementations for interfacing with Paystack's Control Panel API     - <code>customer</code>: A module containing implementations for interfacing with Paystack's Customer API     - <code>dedicated_accounts</code>: A module containing implementations for interfacing with Paystack's Dedicated Accounts API     - <code>disputes</code>: A module containing implementations for interfacing with Paystack's Disputes API     - <code>invoices</code>: A module containing implementations for interfacing with Paystack's Invoices API     - <code>miscellaneous</code>: A module containing implementations for interfacing with Paystack's Miscellaneous API     - <code>payment_pages</code>: A module containing implementations for interfacing with Paystack's Payment Page API     - <code>plans</code>: A module containing implementations for interfacing with Paystack's Plans API     - <code>products</code>: A module containing implementations for interfacing with Paystack's Products API     - <code>refunds</code>: A module containing implementations for interfacing with Paystack's Refunds API     - <code>settlements</code>: A module containing implementations for interfacing with Paystack's Settlements API     - <code>splits</code>: A module containing implementations for interfacing with Paystack's Splits API     - <code>subaccounts</code>: A module containing implementations for interfacing with Paystack's Sub Account API     - <code>subscriptions</code>: A module containing implementations for interfacing with Paystack's Subscriptions API     - <code>transactions</code>: A module containing implementations for interfacing with Paystack's Transactions API     - <code>transfer_recipients</code>: A module containing implementations for interfacing with Paystack's Transfer Recipients API     - <code>transfers</code>: A module containing implementations for interfacing with Paystack's Transfers API     - <code>transfers_control</code>: A module containing implementations for interfacing with Paystack's Transfers Control API     - <code>verification</code>: A module containing implementations for interfacing with Paystack's Verification API</p>"},{"location":"reference/#wrappers-within-pypaystack2api","title":"wrappers within <code>pypaystack2.api</code>","text":"<ul> <li>ApplePay &amp; AsyncApplePay</li> <li>BulkCharge &amp; AsyncBulkCharge</li> <li>Charge &amp; AsyncCharge</li> <li>Integration &amp; AsyncIntegration</li> <li>Customer &amp; AsyncCustomer</li> <li>DedicatedAccount &amp; AsyncDedicatedAccount</li> <li>Dispute &amp; AsyncDispute</li> <li>PaymentRequest &amp; AsyncPaymentRequest</li> <li>Miscellaneous &amp; AsyncMiscellaneous</li> <li>PaymentPage &amp; AsyncPaymentPage</li> <li>Plan &amp; AsyncPlan</li> <li>Product &amp; AsyncProduct</li> <li>Refund &amp; AsyncRefund</li> <li>Settlement &amp; AsyncSettlement</li> <li>Split &amp; AsyncSplit</li> <li>SubAccount &amp; AsyncSubAccount</li> <li>Subscription &amp; AsyncSubscription</li> <li>Terminal &amp; AsyncTerminal</li> <li>Transaction &amp; AsyncTransaction</li> <li>TransferRecipient &amp; AsyncTransferRecipient</li> <li>Transfer &amp; AsyncTransfer</li> <li>TransferControl &amp; AsyncTransferControl</li> <li>Verification &amp; AsyncVerification</li> </ul>"},{"location":"reference/#pypaystack2utils","title":"<code>pypaystack2.utils</code>","text":""},{"location":"reference/#pypaystack2exceptions","title":"<code>pypaystack2.exceptions</code>","text":""},{"location":"reference/#pypaystack2.exceptions.InvalidDataException","title":"<code>InvalidDataException</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Invalid input recognized. Saves unnecessary request to the server</p> Source code in <code>src/pypaystack2/exceptions.py</code> <pre><code>class InvalidDataException(Exception):\n    \"\"\"\n    Invalid input recognized. Saves unnecessary request to the server\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/#pypaystack2.exceptions.InvalidMethodException","title":"<code>InvalidMethodException</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Invalid or unrecognized/unimplemented HTTP request method</p> Source code in <code>src/pypaystack2/exceptions.py</code> <pre><code>class InvalidMethodException(Exception):\n    \"\"\"\n    Invalid or unrecognized/unimplemented HTTP request method\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/#pypaystack2.exceptions.MissingAuthKeyException","title":"<code>MissingAuthKeyException</code>","text":"<p>               Bases: <code>Exception</code></p> <p>We can't find the authentication key</p> Source code in <code>src/pypaystack2/exceptions.py</code> <pre><code>class MissingAuthKeyException(Exception):\n    \"\"\"\n    We can't find the authentication key\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/apple_pay/","title":"Apple pay","text":""},{"location":"reference/apple_pay/#pypaystack2.api.apple_pay.ApplePay","title":"<code>ApplePay</code>","text":"<p>               Bases: <code>BaseAPI</code></p> <p>Provides a wrapper for paystack Apple Pay API</p> <p>The Apple Pay API allows you to register your application's top-level domain or subdomain. see https://paystack.com/docs/api/apple-pay/</p> <p>Note   This feature is available to businesses in all markets except South Africa.</p> Source code in <code>src/pypaystack2/api/apple_pay.py</code> <pre><code>class ApplePay(BaseAPI):\n    \"\"\"Provides a wrapper for paystack Apple Pay API\n\n    The Apple Pay API allows you to register your application's top-level domain or subdomain.\n    see https://paystack.com/docs/api/apple-pay/\n\n    Note\n      This feature is available to businesses in all markets except South Africa.\n    \"\"\"\n\n    def register_domain(self, domain_name: str) -&gt; Response:\n        \"\"\"Register a top-level domain or subdomain for your Apple Pay integration.\n\n        Note\n            * This method can only be called with one domain or subdomain at a time.\n            * This feature is available to businesses in all markets except South Africa.\n\n\n        Args:\n            domain_name: Domain name to be registered.\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(\"/apple-pay/domain\")\n        payload = {\n            \"domainName\": domain_name,\n        }\n        return self._handle_request(HTTPMethod.POST, url, payload)\n\n    def get_domains(\n        self,\n        use_cursor: bool = False,\n        next: Optional[str] = None,\n        previous: Optional[str] = None,\n    ) -&gt; Response:\n        \"\"\"Fetches all registered domains on your integration.\n\n        Note\n            * This feature is available to businesses in all markets except South Africa.\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n            An empty list in the data if no domains have been added.\n        \"\"\"\n\n        url = self._parse_url(\"/apple-pay/domain\")\n        query_params = [\n            (\"use_cursor\", use_cursor),\n            (\"next\", next),\n            (\"previous\", previous),\n        ]\n        url = append_query_params(query_params, url)\n        return self._handle_request(HTTPMethod.GET, url)\n\n    def unregister_domain(self, domain_name: str) -&gt; Response:\n        \"\"\"Unregister a top-level domain or subdomain previously used for your Apple Pay integration.\n\n        Args:\n            domain_name: Domain name to be unregistered\n\n        Note\n            * This feature is available to businesses in all markets except South Africa.\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(\"/apple-pay/domain\")\n        payload = {\n            \"domainName\": domain_name,\n        }\n        raw_response = httpx.request(\n            HTTPMethod.DELETE, url, json=payload, headers=self._headers\n        )\n        return (\n            self._parse_response(raw_response)\n            if codes.is_success(raw_response.status_code)\n            else self._parse_response(raw_response, as_error=True)\n        )\n</code></pre>"},{"location":"reference/apple_pay/#pypaystack2.api.apple_pay.ApplePay.get_domains","title":"<code>get_domains(use_cursor=False, next=None, previous=None)</code>","text":"<p>Fetches all registered domains on your integration.</p> <p>Note     * This feature is available to businesses in all markets except South Africa.</p> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> <code>Response</code> <p>An empty list in the data if no domains have been added.</p> Source code in <code>src/pypaystack2/api/apple_pay.py</code> <pre><code>def get_domains(\n    self,\n    use_cursor: bool = False,\n    next: Optional[str] = None,\n    previous: Optional[str] = None,\n) -&gt; Response:\n    \"\"\"Fetches all registered domains on your integration.\n\n    Note\n        * This feature is available to businesses in all markets except South Africa.\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n        An empty list in the data if no domains have been added.\n    \"\"\"\n\n    url = self._parse_url(\"/apple-pay/domain\")\n    query_params = [\n        (\"use_cursor\", use_cursor),\n        (\"next\", next),\n        (\"previous\", previous),\n    ]\n    url = append_query_params(query_params, url)\n    return self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/apple_pay/#pypaystack2.api.apple_pay.ApplePay.register_domain","title":"<code>register_domain(domain_name)</code>","text":"<p>Register a top-level domain or subdomain for your Apple Pay integration.</p> <p>Note     * This method can only be called with one domain or subdomain at a time.     * This feature is available to businesses in all markets except South Africa.</p> <p>Parameters:</p> Name Type Description Default <code>domain_name</code> <code>str</code> <p>Domain name to be registered.</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/apple_pay.py</code> <pre><code>def register_domain(self, domain_name: str) -&gt; Response:\n    \"\"\"Register a top-level domain or subdomain for your Apple Pay integration.\n\n    Note\n        * This method can only be called with one domain or subdomain at a time.\n        * This feature is available to businesses in all markets except South Africa.\n\n\n    Args:\n        domain_name: Domain name to be registered.\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(\"/apple-pay/domain\")\n    payload = {\n        \"domainName\": domain_name,\n    }\n    return self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/apple_pay/#pypaystack2.api.apple_pay.ApplePay.unregister_domain","title":"<code>unregister_domain(domain_name)</code>","text":"<p>Unregister a top-level domain or subdomain previously used for your Apple Pay integration.</p> <p>Parameters:</p> Name Type Description Default <code>domain_name</code> <code>str</code> <p>Domain name to be unregistered</p> required <p>Note     * This feature is available to businesses in all markets except South Africa.</p> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/apple_pay.py</code> <pre><code>def unregister_domain(self, domain_name: str) -&gt; Response:\n    \"\"\"Unregister a top-level domain or subdomain previously used for your Apple Pay integration.\n\n    Args:\n        domain_name: Domain name to be unregistered\n\n    Note\n        * This feature is available to businesses in all markets except South Africa.\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(\"/apple-pay/domain\")\n    payload = {\n        \"domainName\": domain_name,\n    }\n    raw_response = httpx.request(\n        HTTPMethod.DELETE, url, json=payload, headers=self._headers\n    )\n    return (\n        self._parse_response(raw_response)\n        if codes.is_success(raw_response.status_code)\n        else self._parse_response(raw_response, as_error=True)\n    )\n</code></pre>"},{"location":"reference/apple_pay/#pypaystack2.api.apple_pay.AsyncApplePay","title":"<code>AsyncApplePay</code>","text":"<p>               Bases: <code>BaseAsyncAPI</code></p> <p>Provides a wrapper for paystack Apple Pay API</p> <p>The Apple Pay API allows you to register your application's top-level domain or subdomain. Visit paystack api doc</p> Source code in <code>src/pypaystack2/api/apple_pay.py</code> <pre><code>class AsyncApplePay(BaseAsyncAPI):\n    \"\"\"Provides a wrapper for paystack Apple Pay API\n\n    The Apple Pay API allows you to register your application's top-level domain or subdomain.\n    [Visit paystack api doc](https://paystack.com/docs/api/apple-pay/)\n    \"\"\"\n\n    async def register_domain(self, domain_name: str) -&gt; Response:\n        \"\"\"Register a top-level domain or subdomain for your Apple Pay integration.\n\n        This method can only be called with one domain or subdomain at a time.\n\n        Args:\n            domain_name: Domain name to be registered.\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(\"/apple-pay/domain\")\n        payload = {\n            \"domainName\": domain_name,\n        }\n        return await self._handle_request(HTTPMethod.POST, url, payload)\n\n    async def get_domains(\n        self,\n        use_cursor: bool = False,\n        next: Optional[str] = None,\n        previous: Optional[str] = None,\n    ) -&gt; Response:\n        \"\"\"Fetches all registered domains on your integration.\n\n        Note\n            * This feature is available to businesses in all markets except South Africa.\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n            An empty list in the data if no domains have been added.\n        \"\"\"\n\n        url = self._parse_url(\"/apple-pay/domain\")\n        query_params = [\n            (\"use_cursor\", use_cursor),\n            (\"next\", next),\n            (\"previous\", previous),\n        ]\n        url = append_query_params(query_params, url)\n        return await self._handle_request(HTTPMethod.GET, url)\n\n    async def unregister_domain(self, domain_name: str) -&gt; Response:\n        \"\"\"Unregister a top-level domain or subdomain previously used for your Apple Pay integration.\n\n        Args:\n             domain_name: Domain name to be unregistered\n\n         Note\n             * This feature is available to businesses in all markets except South Africa.\n\n         Returns:\n             A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(\"/apple-pay/domain\")\n        payload = {\n            \"domainName\": domain_name,\n        }\n        async with httpx.AsyncClient() as client:\n            raw_response = await client.request(\n                HTTPMethod.DELETE, url, json=payload, headers=self._headers\n            )\n        return (\n            self._parse_response(raw_response)\n            if codes.is_success(raw_response.status_code)\n            else self._parse_response(raw_response, as_error=True)\n        )\n</code></pre>"},{"location":"reference/apple_pay/#pypaystack2.api.apple_pay.AsyncApplePay.get_domains","title":"<code>get_domains(use_cursor=False, next=None, previous=None)</code>  <code>async</code>","text":"<p>Fetches all registered domains on your integration.</p> <p>Note     * This feature is available to businesses in all markets except South Africa.</p> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> <code>Response</code> <p>An empty list in the data if no domains have been added.</p> Source code in <code>src/pypaystack2/api/apple_pay.py</code> <pre><code>async def get_domains(\n    self,\n    use_cursor: bool = False,\n    next: Optional[str] = None,\n    previous: Optional[str] = None,\n) -&gt; Response:\n    \"\"\"Fetches all registered domains on your integration.\n\n    Note\n        * This feature is available to businesses in all markets except South Africa.\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n        An empty list in the data if no domains have been added.\n    \"\"\"\n\n    url = self._parse_url(\"/apple-pay/domain\")\n    query_params = [\n        (\"use_cursor\", use_cursor),\n        (\"next\", next),\n        (\"previous\", previous),\n    ]\n    url = append_query_params(query_params, url)\n    return await self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/apple_pay/#pypaystack2.api.apple_pay.AsyncApplePay.register_domain","title":"<code>register_domain(domain_name)</code>  <code>async</code>","text":"<p>Register a top-level domain or subdomain for your Apple Pay integration.</p> <p>This method can only be called with one domain or subdomain at a time.</p> <p>Parameters:</p> Name Type Description Default <code>domain_name</code> <code>str</code> <p>Domain name to be registered.</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/apple_pay.py</code> <pre><code>async def register_domain(self, domain_name: str) -&gt; Response:\n    \"\"\"Register a top-level domain or subdomain for your Apple Pay integration.\n\n    This method can only be called with one domain or subdomain at a time.\n\n    Args:\n        domain_name: Domain name to be registered.\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(\"/apple-pay/domain\")\n    payload = {\n        \"domainName\": domain_name,\n    }\n    return await self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/apple_pay/#pypaystack2.api.apple_pay.AsyncApplePay.unregister_domain","title":"<code>unregister_domain(domain_name)</code>  <code>async</code>","text":"<p>Unregister a top-level domain or subdomain previously used for your Apple Pay integration.</p> <p>Parameters:</p> Name Type Description Default <code>domain_name</code> <code>str</code> <p>Domain name to be unregistered</p> required <p>Note      * This feature is available to businesses in all markets except South Africa.</p> <p>Returns:      A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/apple_pay.py</code> <pre><code>async def unregister_domain(self, domain_name: str) -&gt; Response:\n    \"\"\"Unregister a top-level domain or subdomain previously used for your Apple Pay integration.\n\n    Args:\n         domain_name: Domain name to be unregistered\n\n     Note\n         * This feature is available to businesses in all markets except South Africa.\n\n     Returns:\n         A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(\"/apple-pay/domain\")\n    payload = {\n        \"domainName\": domain_name,\n    }\n    async with httpx.AsyncClient() as client:\n        raw_response = await client.request(\n            HTTPMethod.DELETE, url, json=payload, headers=self._headers\n        )\n    return (\n        self._parse_response(raw_response)\n        if codes.is_success(raw_response.status_code)\n        else self._parse_response(raw_response, as_error=True)\n    )\n</code></pre>"},{"location":"reference/bulk_charges/","title":"Bulk charges","text":""},{"location":"reference/bulk_charges/#pypaystack2.api.bulk_charges.AsyncBulkCharge","title":"<code>AsyncBulkCharge</code>","text":"<p>               Bases: <code>BaseAsyncAPI</code></p> <p>Provides a wrapper for paystack Bulk Charge API</p> <p>The Bulk Charges API allows you to create and manage multiple recurring payments from your customers. https://paystack.com/docs/api/bulk-charge/</p> Source code in <code>src/pypaystack2/api/bulk_charges.py</code> <pre><code>class AsyncBulkCharge(BaseAsyncAPI):\n    \"\"\"Provides a wrapper for paystack Bulk Charge API\n\n    The Bulk Charges API allows you to create and manage multiple recurring payments from your customers.\n    https://paystack.com/docs/api/bulk-charge/\n    \"\"\"\n\n    async def initiate(self, body: list[BulkChargeInstruction]) -&gt; Response:\n        \"\"\"\n        Send a list of dictionaries with authorization ``codes`` and ``amount``\n        (in kobo if currency is NGN, pesewas, if currency is GHS, and cents,\n        if currency is ZAR ) so paystack can process transactions as a batch.\n\n        Args:\n            body: A list of BulkChargeInstruction.\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(\"/bulkcharge\")\n        payload = [item.dict for item in body]\n        return await self._handle_request(HTTPMethod.POST, url, payload)\n\n    async def get_batches(\n        self,\n        page: int = 1,\n        pagination: int = 50,\n        start_date: Optional[str] = None,\n        end_date: Optional[str] = None,\n    ) -&gt; Response:\n        \"\"\"This gets all bulk charge batches created by the integration.\n\n        Args:\n            page: Specify exactly what transfer you want to page. If not specified, we use a default value of 1.\n            pagination: Specify how many records you want to retrieve per page.\n                If not specified we use a default value of 50.\n            start_date: A timestamp from which to start listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            end_date: A timestamp at which to stop listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/bulkcharge?perPage={pagination}\")\n        query_params = [\n            (\"page\", page),\n            (\"from\", start_date),\n            (\"to\", end_date),\n        ]\n        url = append_query_params(query_params, url)\n        return await self._handle_request(HTTPMethod.GET, url)\n\n    async def get_batch(self, id_or_code: str) -&gt; Response:\n        \"\"\"\n        This method retrieves a specific batch code. It also returns\n        useful information on its progress by way of the total_charges\n        and pending_charges attributes in the Response.\n\n        Args:\n            id_or_code: An ID or code for the charge whose batches you want to retrieve.\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/bulkcharge/{id_or_code}\")\n        return await self._handle_request(HTTPMethod.GET, url)\n\n    async def get_charges_in_batch(\n        self,\n        id_or_code: str,\n        status: Status,\n        pagination: int = 50,\n        page: int = 1,\n        start_date: Optional[str] = None,\n        end_date: Optional[str] = None,\n    ) -&gt; Response:\n        \"\"\"\n        This method retrieves the charges associated with a specified\n        batch code. Pagination parameters are available. You can also\n        filter by status. Charge statuses can be `Status.PENDING`,\n        `Status.SUCCESS` or `Status.FAILED`.\n\n        Args:\n            id_or_code: An ID or code for the batch whose charges you want to retrieve.\n            status: Any of the values from the Status enum.\n            pagination: Specify how many records you want to retrieve per page.\n                If not specified we use a default value of 50.\n            page: Specify exactly what transfer you want to page. If not specified we use a default value of 1.\n            start_date: A timestamp from which to start listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            end_date: A timestamp at which to stop listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/bulkcharge/{id_or_code}/charges?perPage={pagination}\")\n        query_params = [\n            (\"status\", status),\n            (\"page\", page),\n            (\"from\", start_date),\n            (\"to\", end_date),\n        ]\n        url = append_query_params(query_params, url)\n        return await self._handle_request(HTTPMethod.GET, url)\n\n    async def pause_batch(self, batch_code: str) -&gt; Response:\n        \"\"\"Use this method to pause processing a batch.\n\n        Args:\n            batch_code: The batch code for the bulk charge you want to pause.\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/bulkcharge/pause/{batch_code}\")\n        return await self._handle_request(HTTPMethod.GET, url)\n\n    async def resume_batch(self, batch_code: str) -&gt; Response:\n        \"\"\"Use this method to resume processing a batch\n\n        Args:\n            batch_code: The batch code for the bulk charge you want to resume.\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/bulkcharge/resume/{batch_code}\")\n        return await self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/bulk_charges/#pypaystack2.api.bulk_charges.AsyncBulkCharge.get_batch","title":"<code>get_batch(id_or_code)</code>  <code>async</code>","text":"<p>This method retrieves a specific batch code. It also returns useful information on its progress by way of the total_charges and pending_charges attributes in the Response.</p> <p>Parameters:</p> Name Type Description Default <code>id_or_code</code> <code>str</code> <p>An ID or code for the charge whose batches you want to retrieve.</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/bulk_charges.py</code> <pre><code>async def get_batch(self, id_or_code: str) -&gt; Response:\n    \"\"\"\n    This method retrieves a specific batch code. It also returns\n    useful information on its progress by way of the total_charges\n    and pending_charges attributes in the Response.\n\n    Args:\n        id_or_code: An ID or code for the charge whose batches you want to retrieve.\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/bulkcharge/{id_or_code}\")\n    return await self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/bulk_charges/#pypaystack2.api.bulk_charges.AsyncBulkCharge.get_batches","title":"<code>get_batches(page=1, pagination=50, start_date=None, end_date=None)</code>  <code>async</code>","text":"<p>This gets all bulk charge batches created by the integration.</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>int</code> <p>Specify exactly what transfer you want to page. If not specified, we use a default value of 1.</p> <code>1</code> <code>pagination</code> <code>int</code> <p>Specify how many records you want to retrieve per page. If not specified we use a default value of 50.</p> <code>50</code> <code>start_date</code> <code>Optional[str]</code> <p>A timestamp from which to start listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>end_date</code> <code>Optional[str]</code> <p>A timestamp at which to stop listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/bulk_charges.py</code> <pre><code>async def get_batches(\n    self,\n    page: int = 1,\n    pagination: int = 50,\n    start_date: Optional[str] = None,\n    end_date: Optional[str] = None,\n) -&gt; Response:\n    \"\"\"This gets all bulk charge batches created by the integration.\n\n    Args:\n        page: Specify exactly what transfer you want to page. If not specified, we use a default value of 1.\n        pagination: Specify how many records you want to retrieve per page.\n            If not specified we use a default value of 50.\n        start_date: A timestamp from which to start listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        end_date: A timestamp at which to stop listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/bulkcharge?perPage={pagination}\")\n    query_params = [\n        (\"page\", page),\n        (\"from\", start_date),\n        (\"to\", end_date),\n    ]\n    url = append_query_params(query_params, url)\n    return await self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/bulk_charges/#pypaystack2.api.bulk_charges.AsyncBulkCharge.get_charges_in_batch","title":"<code>get_charges_in_batch(id_or_code, status, pagination=50, page=1, start_date=None, end_date=None)</code>  <code>async</code>","text":"<p>This method retrieves the charges associated with a specified batch code. Pagination parameters are available. You can also filter by status. Charge statuses can be <code>Status.PENDING</code>, <code>Status.SUCCESS</code> or <code>Status.FAILED</code>.</p> <p>Parameters:</p> Name Type Description Default <code>id_or_code</code> <code>str</code> <p>An ID or code for the batch whose charges you want to retrieve.</p> required <code>status</code> <code>Status</code> <p>Any of the values from the Status enum.</p> required <code>pagination</code> <code>int</code> <p>Specify how many records you want to retrieve per page. If not specified we use a default value of 50.</p> <code>50</code> <code>page</code> <code>int</code> <p>Specify exactly what transfer you want to page. If not specified we use a default value of 1.</p> <code>1</code> <code>start_date</code> <code>Optional[str]</code> <p>A timestamp from which to start listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>end_date</code> <code>Optional[str]</code> <p>A timestamp at which to stop listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/bulk_charges.py</code> <pre><code>async def get_charges_in_batch(\n    self,\n    id_or_code: str,\n    status: Status,\n    pagination: int = 50,\n    page: int = 1,\n    start_date: Optional[str] = None,\n    end_date: Optional[str] = None,\n) -&gt; Response:\n    \"\"\"\n    This method retrieves the charges associated with a specified\n    batch code. Pagination parameters are available. You can also\n    filter by status. Charge statuses can be `Status.PENDING`,\n    `Status.SUCCESS` or `Status.FAILED`.\n\n    Args:\n        id_or_code: An ID or code for the batch whose charges you want to retrieve.\n        status: Any of the values from the Status enum.\n        pagination: Specify how many records you want to retrieve per page.\n            If not specified we use a default value of 50.\n        page: Specify exactly what transfer you want to page. If not specified we use a default value of 1.\n        start_date: A timestamp from which to start listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        end_date: A timestamp at which to stop listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/bulkcharge/{id_or_code}/charges?perPage={pagination}\")\n    query_params = [\n        (\"status\", status),\n        (\"page\", page),\n        (\"from\", start_date),\n        (\"to\", end_date),\n    ]\n    url = append_query_params(query_params, url)\n    return await self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/bulk_charges/#pypaystack2.api.bulk_charges.AsyncBulkCharge.initiate","title":"<code>initiate(body)</code>  <code>async</code>","text":"<p>Send a list of dictionaries with authorization <code>codes</code> and <code>amount</code> (in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR ) so paystack can process transactions as a batch.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>list[BulkChargeInstruction]</code> <p>A list of BulkChargeInstruction.</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/bulk_charges.py</code> <pre><code>async def initiate(self, body: list[BulkChargeInstruction]) -&gt; Response:\n    \"\"\"\n    Send a list of dictionaries with authorization ``codes`` and ``amount``\n    (in kobo if currency is NGN, pesewas, if currency is GHS, and cents,\n    if currency is ZAR ) so paystack can process transactions as a batch.\n\n    Args:\n        body: A list of BulkChargeInstruction.\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(\"/bulkcharge\")\n    payload = [item.dict for item in body]\n    return await self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/bulk_charges/#pypaystack2.api.bulk_charges.AsyncBulkCharge.pause_batch","title":"<code>pause_batch(batch_code)</code>  <code>async</code>","text":"<p>Use this method to pause processing a batch.</p> <p>Parameters:</p> Name Type Description Default <code>batch_code</code> <code>str</code> <p>The batch code for the bulk charge you want to pause.</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/bulk_charges.py</code> <pre><code>async def pause_batch(self, batch_code: str) -&gt; Response:\n    \"\"\"Use this method to pause processing a batch.\n\n    Args:\n        batch_code: The batch code for the bulk charge you want to pause.\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/bulkcharge/pause/{batch_code}\")\n    return await self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/bulk_charges/#pypaystack2.api.bulk_charges.AsyncBulkCharge.resume_batch","title":"<code>resume_batch(batch_code)</code>  <code>async</code>","text":"<p>Use this method to resume processing a batch</p> <p>Parameters:</p> Name Type Description Default <code>batch_code</code> <code>str</code> <p>The batch code for the bulk charge you want to resume.</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/bulk_charges.py</code> <pre><code>async def resume_batch(self, batch_code: str) -&gt; Response:\n    \"\"\"Use this method to resume processing a batch\n\n    Args:\n        batch_code: The batch code for the bulk charge you want to resume.\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/bulkcharge/resume/{batch_code}\")\n    return await self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/bulk_charges/#pypaystack2.api.bulk_charges.BulkCharge","title":"<code>BulkCharge</code>","text":"<p>               Bases: <code>BaseAPI</code></p> <p>Provides a wrapper for paystack Bulk Charge API</p> <p>The Bulk Charges API allows you to create and manage multiple recurring payments from your customers. https://paystack.com/docs/api/bulk-charge/</p> Source code in <code>src/pypaystack2/api/bulk_charges.py</code> <pre><code>class BulkCharge(BaseAPI):\n    \"\"\"Provides a wrapper for paystack Bulk Charge API\n\n    The Bulk Charges API allows you to create and manage multiple recurring payments from your customers.\n    https://paystack.com/docs/api/bulk-charge/\n    \"\"\"\n\n    def initiate(self, body: list[BulkChargeInstruction]) -&gt; Response:\n        \"\"\"\n        Send a list of dictionaries with authorization ``codes`` and ``amount``\n        (in kobo if currency is NGN, pesewas, if currency is GHS, and cents,\n        if currency is ZAR ) so paystack can process transactions as a batch.\n\n        Args:\n            body: A list of BulkChargeInstruction.\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(\"/bulkcharge\")\n        payload = [item.dict for item in body]\n        return self._handle_request(HTTPMethod.POST, url, payload)\n\n    def get_batches(\n        self,\n        page: int = 1,\n        pagination: int = 50,\n        start_date: Optional[str] = None,\n        end_date: Optional[str] = None,\n    ) -&gt; Response:\n        \"\"\"This gets all bulk charge batches created by the integration.\n\n        Args:\n            page: Specify exactly what transfer you want to page. If not specified, we use a default value of 1.\n            pagination: Specify how many records you want to retrieve per page.\n                If not specified we use a default value of 50.\n            start_date: A timestamp from which to start listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            end_date: A timestamp at which to stop listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/bulkcharge?perPage={pagination}\")\n        query_params = [\n            (\"page\", page),\n            (\"from\", start_date),\n            (\"to\", end_date),\n        ]\n        url = append_query_params(query_params, url)\n        return self._handle_request(HTTPMethod.GET, url)\n\n    def get_batch(self, id_or_code: str) -&gt; Response:\n        \"\"\"\n        This method retrieves a specific batch code. It also returns\n        useful information on its progress by way of the total_charges\n        and pending_charges attributes in the Response.\n\n        Args:\n            id_or_code: An ID or code for the charge whose batches you want to retrieve.\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/bulkcharge/{id_or_code}\")\n        return self._handle_request(HTTPMethod.GET, url)\n\n    def get_charges_in_batch(\n        self,\n        id_or_code: str,\n        status: Status,\n        pagination: int = 50,\n        page: int = 1,\n        start_date: Optional[str] = None,\n        end_date: Optional[str] = None,\n    ) -&gt; Response:\n        \"\"\"\n        This method retrieves the charges associated with a specified\n        batch code. Pagination parameters are available. You can also\n        filter by status. Charge statuses can be `Status.PENDING`,\n        `Status.SUCCESS` or `Status.FAILED`.\n\n        Args:\n            id_or_code: An ID or code for the batch whose charges you want to retrieve.\n            status: Any of the values from the Status enum.\n            pagination: Specify how many records you want to retrieve per page.\n                If not specified we use a default value of 50.\n            page: Specify exactly what transfer you want to page. If not specified we use a default value of 1.\n            start_date: A timestamp from which to start listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            end_date: A timestamp at which to stop listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/bulkcharge/{id_or_code}/charges?perPage={pagination}\")\n        query_params = [\n            (\"status\", status),\n            (\"page\", page),\n            (\"from\", start_date),\n            (\"to\", end_date),\n        ]\n        url = append_query_params(query_params, url)\n        return self._handle_request(HTTPMethod.GET, url)\n\n    def pause_batch(self, batch_code: str) -&gt; Response:\n        \"\"\"Use this method to pause processing a batch.\n\n        Args:\n            batch_code: The batch code for the bulk charge you want to pause.\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/bulkcharge/pause/{batch_code}\")\n        return self._handle_request(HTTPMethod.GET, url)\n\n    def resume_batch(self, batch_code: str) -&gt; Response:\n        \"\"\"Use this method to resume processing a batch\n\n        Args:\n            batch_code: The batch code for the bulk charge you want to resume.\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/bulkcharge/resume/{batch_code}\")\n        return self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/bulk_charges/#pypaystack2.api.bulk_charges.BulkCharge.get_batch","title":"<code>get_batch(id_or_code)</code>","text":"<p>This method retrieves a specific batch code. It also returns useful information on its progress by way of the total_charges and pending_charges attributes in the Response.</p> <p>Parameters:</p> Name Type Description Default <code>id_or_code</code> <code>str</code> <p>An ID or code for the charge whose batches you want to retrieve.</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/bulk_charges.py</code> <pre><code>def get_batch(self, id_or_code: str) -&gt; Response:\n    \"\"\"\n    This method retrieves a specific batch code. It also returns\n    useful information on its progress by way of the total_charges\n    and pending_charges attributes in the Response.\n\n    Args:\n        id_or_code: An ID or code for the charge whose batches you want to retrieve.\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/bulkcharge/{id_or_code}\")\n    return self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/bulk_charges/#pypaystack2.api.bulk_charges.BulkCharge.get_batches","title":"<code>get_batches(page=1, pagination=50, start_date=None, end_date=None)</code>","text":"<p>This gets all bulk charge batches created by the integration.</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>int</code> <p>Specify exactly what transfer you want to page. If not specified, we use a default value of 1.</p> <code>1</code> <code>pagination</code> <code>int</code> <p>Specify how many records you want to retrieve per page. If not specified we use a default value of 50.</p> <code>50</code> <code>start_date</code> <code>Optional[str]</code> <p>A timestamp from which to start listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>end_date</code> <code>Optional[str]</code> <p>A timestamp at which to stop listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/bulk_charges.py</code> <pre><code>def get_batches(\n    self,\n    page: int = 1,\n    pagination: int = 50,\n    start_date: Optional[str] = None,\n    end_date: Optional[str] = None,\n) -&gt; Response:\n    \"\"\"This gets all bulk charge batches created by the integration.\n\n    Args:\n        page: Specify exactly what transfer you want to page. If not specified, we use a default value of 1.\n        pagination: Specify how many records you want to retrieve per page.\n            If not specified we use a default value of 50.\n        start_date: A timestamp from which to start listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        end_date: A timestamp at which to stop listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/bulkcharge?perPage={pagination}\")\n    query_params = [\n        (\"page\", page),\n        (\"from\", start_date),\n        (\"to\", end_date),\n    ]\n    url = append_query_params(query_params, url)\n    return self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/bulk_charges/#pypaystack2.api.bulk_charges.BulkCharge.get_charges_in_batch","title":"<code>get_charges_in_batch(id_or_code, status, pagination=50, page=1, start_date=None, end_date=None)</code>","text":"<p>This method retrieves the charges associated with a specified batch code. Pagination parameters are available. You can also filter by status. Charge statuses can be <code>Status.PENDING</code>, <code>Status.SUCCESS</code> or <code>Status.FAILED</code>.</p> <p>Parameters:</p> Name Type Description Default <code>id_or_code</code> <code>str</code> <p>An ID or code for the batch whose charges you want to retrieve.</p> required <code>status</code> <code>Status</code> <p>Any of the values from the Status enum.</p> required <code>pagination</code> <code>int</code> <p>Specify how many records you want to retrieve per page. If not specified we use a default value of 50.</p> <code>50</code> <code>page</code> <code>int</code> <p>Specify exactly what transfer you want to page. If not specified we use a default value of 1.</p> <code>1</code> <code>start_date</code> <code>Optional[str]</code> <p>A timestamp from which to start listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>end_date</code> <code>Optional[str]</code> <p>A timestamp at which to stop listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/bulk_charges.py</code> <pre><code>def get_charges_in_batch(\n    self,\n    id_or_code: str,\n    status: Status,\n    pagination: int = 50,\n    page: int = 1,\n    start_date: Optional[str] = None,\n    end_date: Optional[str] = None,\n) -&gt; Response:\n    \"\"\"\n    This method retrieves the charges associated with a specified\n    batch code. Pagination parameters are available. You can also\n    filter by status. Charge statuses can be `Status.PENDING`,\n    `Status.SUCCESS` or `Status.FAILED`.\n\n    Args:\n        id_or_code: An ID or code for the batch whose charges you want to retrieve.\n        status: Any of the values from the Status enum.\n        pagination: Specify how many records you want to retrieve per page.\n            If not specified we use a default value of 50.\n        page: Specify exactly what transfer you want to page. If not specified we use a default value of 1.\n        start_date: A timestamp from which to start listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        end_date: A timestamp at which to stop listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/bulkcharge/{id_or_code}/charges?perPage={pagination}\")\n    query_params = [\n        (\"status\", status),\n        (\"page\", page),\n        (\"from\", start_date),\n        (\"to\", end_date),\n    ]\n    url = append_query_params(query_params, url)\n    return self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/bulk_charges/#pypaystack2.api.bulk_charges.BulkCharge.initiate","title":"<code>initiate(body)</code>","text":"<p>Send a list of dictionaries with authorization <code>codes</code> and <code>amount</code> (in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR ) so paystack can process transactions as a batch.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>list[BulkChargeInstruction]</code> <p>A list of BulkChargeInstruction.</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/bulk_charges.py</code> <pre><code>def initiate(self, body: list[BulkChargeInstruction]) -&gt; Response:\n    \"\"\"\n    Send a list of dictionaries with authorization ``codes`` and ``amount``\n    (in kobo if currency is NGN, pesewas, if currency is GHS, and cents,\n    if currency is ZAR ) so paystack can process transactions as a batch.\n\n    Args:\n        body: A list of BulkChargeInstruction.\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(\"/bulkcharge\")\n    payload = [item.dict for item in body]\n    return self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/bulk_charges/#pypaystack2.api.bulk_charges.BulkCharge.pause_batch","title":"<code>pause_batch(batch_code)</code>","text":"<p>Use this method to pause processing a batch.</p> <p>Parameters:</p> Name Type Description Default <code>batch_code</code> <code>str</code> <p>The batch code for the bulk charge you want to pause.</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/bulk_charges.py</code> <pre><code>def pause_batch(self, batch_code: str) -&gt; Response:\n    \"\"\"Use this method to pause processing a batch.\n\n    Args:\n        batch_code: The batch code for the bulk charge you want to pause.\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/bulkcharge/pause/{batch_code}\")\n    return self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/bulk_charges/#pypaystack2.api.bulk_charges.BulkCharge.resume_batch","title":"<code>resume_batch(batch_code)</code>","text":"<p>Use this method to resume processing a batch</p> <p>Parameters:</p> Name Type Description Default <code>batch_code</code> <code>str</code> <p>The batch code for the bulk charge you want to resume.</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/bulk_charges.py</code> <pre><code>def resume_batch(self, batch_code: str) -&gt; Response:\n    \"\"\"Use this method to resume processing a batch\n\n    Args:\n        batch_code: The batch code for the bulk charge you want to resume.\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/bulkcharge/resume/{batch_code}\")\n    return self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/charge/","title":"Charge","text":""},{"location":"reference/charge/#pypaystack2.api.charge.AsyncCharge","title":"<code>AsyncCharge</code>","text":"<p>               Bases: <code>BaseAsyncAPI</code></p> <p>Provides a wrapper for paystack Charge API</p> <p>The Charge API allows you to configure a payment channel of your choice when initiating a payment. https://paystack.com/docs/api/charge/</p> Source code in <code>src/pypaystack2/api/charge.py</code> <pre><code>class AsyncCharge(BaseAsyncAPI):\n    \"\"\"Provides a wrapper for paystack Charge API\n\n    The Charge API allows you to configure a payment channel of your choice when initiating a payment.\n    https://paystack.com/docs/api/charge/\n\n    \"\"\"\n\n    async def charge(\n        self,\n        email: str,\n        amount: int,\n        bank: Optional[dict] = None,\n        bank_transfer: Optional[dict] = None,\n        auth_code: Optional[str] = None,\n        pin: Optional[str] = None,\n        metadata: Optional[dict] = None,\n        reference: Optional[str] = None,\n        ussd: Optional[dict] = None,\n        mobile_money: Optional[dict] = None,\n        device_id: Optional[str] = None,\n    ) -&gt; Response:\n        \"\"\"Initiate a payment by integrating the payment channel of your choice.\n\n        Args:\n            email: Customer's email address\n            amount: Amount should be in kobo if currency is NGN, pesewas, if currency is GHS,\n                and cents, if currency is ZAR\n            bank: Bank account to charge (don't send if charging an authorization code)\n            bank_transfer: Takes the settings for the Pay with Transfer (PwT) channel. Pass in the\n                account_expires_at param to set the expiry time.\n            auth_code: An authorization code to charge (don't send if charging a bank account)\n            pin: 4-digit PIN (send with a non-reusable authorization code)\n            metadata: A dictionary of data.\n            reference: Unique transaction reference. Only -, .\\\\`, = and alphanumeric characters allowed.\n            ussd: USSD type to charge (don't send if charging an authorization code, bank or card)\n            mobile_money: Mobile details (don't send if charging an authorization code, bank or card)\n            device_id: This is the unique identifier of the device a user uses in making payment. Only -, .\\\\`,\n                = and alphanumeric characters allowed.\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        amount = validate_amount(amount)\n        payload = {\"email\": email, \"amount\": amount}\n        optional_params = [\n            (\"bank\", bank),\n            (\"bank_transfer\", bank_transfer),\n            (\"authorization_code\", auth_code),\n            (\"pin\", pin),\n            (\"metadata\", metadata),\n            (\"reference\", reference),\n            (\"ussd\", ussd),\n            (\"mobile_money\", mobile_money),\n            (\"device_id\", device_id),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        url = self._parse_url(\"/charge\")\n        return await self._handle_request(HTTPMethod.POST, url, payload)\n\n    async def submit_pin(self, pin: str, reference: str) -&gt; Response:\n        \"\"\"Submit PIN to continue a charge\n\n        Args:\n            pin: PIN submitted by user\n            reference: Reference for transaction that requested pin\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        payload = {\"pin\": pin, \"reference\": reference}\n        url = self._parse_url(\"/charge/submit_pin\")\n        return await self._handle_request(HTTPMethod.POST, url, payload)\n\n    async def submit_otp(self, otp: str, reference: str) -&gt; Response:\n        \"\"\"Submit OTP to complete a charge\n\n        Args:\n            otp: OTP submitted by user\n            reference: Reference for ongoing transaction\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        payload = {\"otp\": otp, \"reference\": reference}\n        url = self._parse_url(\"/charge/submit_otp\")\n        return await self._handle_request(HTTPMethod.POST, url, payload)\n\n    async def submit_phone(self, phone: str, reference: str) -&gt; Response:\n        \"\"\"Submit Phone when requested\n\n        Args:\n            phone: Phone submitted by user\n            reference: Reference for ongoing transaction\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        payload = {\"phone\": phone, \"reference\": reference}\n        url = self._parse_url(\"/charge/submit_phone\")\n        return await self._handle_request(HTTPMethod.POST, url, payload)\n\n    async def submit_birthday(self, birthday: str, reference: str) -&gt; Response:\n        \"\"\"Submit Birthday when requested\n\n        Args:\n            birthday: Birthday submitted by user. ISO Format e.g. 2016-09-21\n            reference: Reference for ongoing transaction\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        payload = {\"birthday\": birthday, \"reference\": reference}\n        url = self._parse_url(\"/charge/submit_birthday\")\n        return await self._handle_request(HTTPMethod.POST, url, payload)\n\n    async def set_address(\n        self,\n        address: str,\n        reference: str,\n        city: str,\n        state: str,\n        zipcode: str,\n    ) -&gt; Response:\n        \"\"\"Submit address to continue a charge\n\n        Args:\n            address: Address submitted by user\n            reference: Reference for ongoing transaction\n            city: City submitted by user\n            state: State submitted by user\n            zipcode: sZipcode submitted by user\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        payload = {\n            \"address\": address,\n            \"reference\": reference,\n            \"city\": city,\n            \"state\": state,\n            \"zip_code\": zipcode,\n        }\n        url = self._parse_url(\"/charge/submit_address\")\n        return await self._handle_request(HTTPMethod.POST, url, payload)\n\n    async def check_pending_charge(self, reference: str) -&gt; Response:\n        \"\"\"\n        When you get \"pending\" as a charge status or if there was an\n        exception when calling any of the /charge endpoints, wait 10\n        seconds or more, then make a check to see if its status has changed.\n        Don't call too early as you may get a lot more pending than you should.\n\n        Args:\n            reference: The reference to check\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/charge/{reference}\")\n        return await self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/charge/#pypaystack2.api.charge.AsyncCharge.charge","title":"<code>charge(email, amount, bank=None, bank_transfer=None, auth_code=None, pin=None, metadata=None, reference=None, ussd=None, mobile_money=None, device_id=None)</code>  <code>async</code>","text":"<p>Initiate a payment by integrating the payment channel of your choice.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Customer's email address</p> required <code>amount</code> <code>int</code> <p>Amount should be in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR</p> required <code>bank</code> <code>Optional[dict]</code> <p>Bank account to charge (don't send if charging an authorization code)</p> <code>None</code> <code>bank_transfer</code> <code>Optional[dict]</code> <p>Takes the settings for the Pay with Transfer (PwT) channel. Pass in the account_expires_at param to set the expiry time.</p> <code>None</code> <code>auth_code</code> <code>Optional[str]</code> <p>An authorization code to charge (don't send if charging a bank account)</p> <code>None</code> <code>pin</code> <code>Optional[str]</code> <p>4-digit PIN (send with a non-reusable authorization code)</p> <code>None</code> <code>metadata</code> <code>Optional[dict]</code> <p>A dictionary of data.</p> <code>None</code> <code>reference</code> <code>Optional[str]</code> <p>Unique transaction reference. Only -, .`, = and alphanumeric characters allowed.</p> <code>None</code> <code>ussd</code> <code>Optional[dict]</code> <p>USSD type to charge (don't send if charging an authorization code, bank or card)</p> <code>None</code> <code>mobile_money</code> <code>Optional[dict]</code> <p>Mobile details (don't send if charging an authorization code, bank or card)</p> <code>None</code> <code>device_id</code> <code>Optional[str]</code> <p>This is the unique identifier of the device a user uses in making payment. Only -, .`, = and alphanumeric characters allowed.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/charge.py</code> <pre><code>async def charge(\n    self,\n    email: str,\n    amount: int,\n    bank: Optional[dict] = None,\n    bank_transfer: Optional[dict] = None,\n    auth_code: Optional[str] = None,\n    pin: Optional[str] = None,\n    metadata: Optional[dict] = None,\n    reference: Optional[str] = None,\n    ussd: Optional[dict] = None,\n    mobile_money: Optional[dict] = None,\n    device_id: Optional[str] = None,\n) -&gt; Response:\n    \"\"\"Initiate a payment by integrating the payment channel of your choice.\n\n    Args:\n        email: Customer's email address\n        amount: Amount should be in kobo if currency is NGN, pesewas, if currency is GHS,\n            and cents, if currency is ZAR\n        bank: Bank account to charge (don't send if charging an authorization code)\n        bank_transfer: Takes the settings for the Pay with Transfer (PwT) channel. Pass in the\n            account_expires_at param to set the expiry time.\n        auth_code: An authorization code to charge (don't send if charging a bank account)\n        pin: 4-digit PIN (send with a non-reusable authorization code)\n        metadata: A dictionary of data.\n        reference: Unique transaction reference. Only -, .\\\\`, = and alphanumeric characters allowed.\n        ussd: USSD type to charge (don't send if charging an authorization code, bank or card)\n        mobile_money: Mobile details (don't send if charging an authorization code, bank or card)\n        device_id: This is the unique identifier of the device a user uses in making payment. Only -, .\\\\`,\n            = and alphanumeric characters allowed.\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    amount = validate_amount(amount)\n    payload = {\"email\": email, \"amount\": amount}\n    optional_params = [\n        (\"bank\", bank),\n        (\"bank_transfer\", bank_transfer),\n        (\"authorization_code\", auth_code),\n        (\"pin\", pin),\n        (\"metadata\", metadata),\n        (\"reference\", reference),\n        (\"ussd\", ussd),\n        (\"mobile_money\", mobile_money),\n        (\"device_id\", device_id),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    url = self._parse_url(\"/charge\")\n    return await self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/charge/#pypaystack2.api.charge.AsyncCharge.check_pending_charge","title":"<code>check_pending_charge(reference)</code>  <code>async</code>","text":"<p>When you get \"pending\" as a charge status or if there was an exception when calling any of the /charge endpoints, wait 10 seconds or more, then make a check to see if its status has changed. Don't call too early as you may get a lot more pending than you should.</p> <p>Parameters:</p> Name Type Description Default <code>reference</code> <code>str</code> <p>The reference to check</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/charge.py</code> <pre><code>async def check_pending_charge(self, reference: str) -&gt; Response:\n    \"\"\"\n    When you get \"pending\" as a charge status or if there was an\n    exception when calling any of the /charge endpoints, wait 10\n    seconds or more, then make a check to see if its status has changed.\n    Don't call too early as you may get a lot more pending than you should.\n\n    Args:\n        reference: The reference to check\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/charge/{reference}\")\n    return await self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/charge/#pypaystack2.api.charge.AsyncCharge.set_address","title":"<code>set_address(address, reference, city, state, zipcode)</code>  <code>async</code>","text":"<p>Submit address to continue a charge</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>str</code> <p>Address submitted by user</p> required <code>reference</code> <code>str</code> <p>Reference for ongoing transaction</p> required <code>city</code> <code>str</code> <p>City submitted by user</p> required <code>state</code> <code>str</code> <p>State submitted by user</p> required <code>zipcode</code> <code>str</code> <p>sZipcode submitted by user</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/charge.py</code> <pre><code>async def set_address(\n    self,\n    address: str,\n    reference: str,\n    city: str,\n    state: str,\n    zipcode: str,\n) -&gt; Response:\n    \"\"\"Submit address to continue a charge\n\n    Args:\n        address: Address submitted by user\n        reference: Reference for ongoing transaction\n        city: City submitted by user\n        state: State submitted by user\n        zipcode: sZipcode submitted by user\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    payload = {\n        \"address\": address,\n        \"reference\": reference,\n        \"city\": city,\n        \"state\": state,\n        \"zip_code\": zipcode,\n    }\n    url = self._parse_url(\"/charge/submit_address\")\n    return await self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/charge/#pypaystack2.api.charge.AsyncCharge.submit_birthday","title":"<code>submit_birthday(birthday, reference)</code>  <code>async</code>","text":"<p>Submit Birthday when requested</p> <p>Parameters:</p> Name Type Description Default <code>birthday</code> <code>str</code> <p>Birthday submitted by user. ISO Format e.g. 2016-09-21</p> required <code>reference</code> <code>str</code> <p>Reference for ongoing transaction</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/charge.py</code> <pre><code>async def submit_birthday(self, birthday: str, reference: str) -&gt; Response:\n    \"\"\"Submit Birthday when requested\n\n    Args:\n        birthday: Birthday submitted by user. ISO Format e.g. 2016-09-21\n        reference: Reference for ongoing transaction\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    payload = {\"birthday\": birthday, \"reference\": reference}\n    url = self._parse_url(\"/charge/submit_birthday\")\n    return await self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/charge/#pypaystack2.api.charge.AsyncCharge.submit_otp","title":"<code>submit_otp(otp, reference)</code>  <code>async</code>","text":"<p>Submit OTP to complete a charge</p> <p>Parameters:</p> Name Type Description Default <code>otp</code> <code>str</code> <p>OTP submitted by user</p> required <code>reference</code> <code>str</code> <p>Reference for ongoing transaction</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/charge.py</code> <pre><code>async def submit_otp(self, otp: str, reference: str) -&gt; Response:\n    \"\"\"Submit OTP to complete a charge\n\n    Args:\n        otp: OTP submitted by user\n        reference: Reference for ongoing transaction\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    payload = {\"otp\": otp, \"reference\": reference}\n    url = self._parse_url(\"/charge/submit_otp\")\n    return await self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/charge/#pypaystack2.api.charge.AsyncCharge.submit_phone","title":"<code>submit_phone(phone, reference)</code>  <code>async</code>","text":"<p>Submit Phone when requested</p> <p>Parameters:</p> Name Type Description Default <code>phone</code> <code>str</code> <p>Phone submitted by user</p> required <code>reference</code> <code>str</code> <p>Reference for ongoing transaction</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/charge.py</code> <pre><code>async def submit_phone(self, phone: str, reference: str) -&gt; Response:\n    \"\"\"Submit Phone when requested\n\n    Args:\n        phone: Phone submitted by user\n        reference: Reference for ongoing transaction\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    payload = {\"phone\": phone, \"reference\": reference}\n    url = self._parse_url(\"/charge/submit_phone\")\n    return await self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/charge/#pypaystack2.api.charge.AsyncCharge.submit_pin","title":"<code>submit_pin(pin, reference)</code>  <code>async</code>","text":"<p>Submit PIN to continue a charge</p> <p>Parameters:</p> Name Type Description Default <code>pin</code> <code>str</code> <p>PIN submitted by user</p> required <code>reference</code> <code>str</code> <p>Reference for transaction that requested pin</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/charge.py</code> <pre><code>async def submit_pin(self, pin: str, reference: str) -&gt; Response:\n    \"\"\"Submit PIN to continue a charge\n\n    Args:\n        pin: PIN submitted by user\n        reference: Reference for transaction that requested pin\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    payload = {\"pin\": pin, \"reference\": reference}\n    url = self._parse_url(\"/charge/submit_pin\")\n    return await self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/charge/#pypaystack2.api.charge.Charge","title":"<code>Charge</code>","text":"<p>               Bases: <code>BaseAPI</code></p> <p>Provides a wrapper for paystack Charge API</p> <p>The Charge API allows you to configure a payment channel of your choice when initiating a payment. https://paystack.com/docs/api/charge/</p> Source code in <code>src/pypaystack2/api/charge.py</code> <pre><code>class Charge(BaseAPI):\n    \"\"\"Provides a wrapper for paystack Charge API\n\n    The Charge API allows you to configure a payment channel of your choice when initiating a payment.\n    https://paystack.com/docs/api/charge/\n\n    \"\"\"\n\n    def charge(\n        self,\n        email: str,\n        amount: int,\n        bank: Optional[dict] = None,\n        bank_transfer: Optional[dict] = None,\n        auth_code: Optional[str] = None,\n        pin: Optional[str] = None,\n        metadata: Optional[dict] = None,\n        reference: Optional[str] = None,\n        ussd: Optional[dict] = None,\n        mobile_money: Optional[dict] = None,\n        device_id: Optional[str] = None,\n    ) -&gt; Response:\n        \"\"\"Initiate a payment by integrating the payment channel of your choice.\n\n        Args:\n            email: Customer's email address\n            amount: Amount should be in kobo if currency is NGN, pesewas, if currency is GHS,\n                and cents, if currency is ZAR\n            bank: Bank account to charge (don't send if charging an authorization code)\n            bank_transfer: Takes the settings for the Pay with Transfer (PwT) channel. Pass in the\n                account_expires_at param to set the expiry time.\n            auth_code: An authorization code to charge (don't send if charging a bank account)\n            pin: 4-digit PIN (send with a non-reusable authorization code)\n            metadata: A dictionary of data.\n            reference: Unique transaction reference. Only -, .\\\\`, = and alphanumeric characters allowed.\n            ussd: USSD type to charge (don't send if charging an authorization code, bank or card)\n            mobile_money: Mobile details (don't send if charging an authorization code, bank or card)\n            device_id: This is the unique identifier of the device a user uses in making payment. Only -, .\\\\`,\n                = and alphanumeric characters allowed.\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        amount = validate_amount(amount)\n        payload = {\"email\": email, \"amount\": amount}\n        optional_params = [\n            (\"bank\", bank),\n            (\"bank_transfer\", bank_transfer),\n            (\"authorization_code\", auth_code),\n            (\"pin\", pin),\n            (\"metadata\", metadata),\n            (\"reference\", reference),\n            (\"ussd\", ussd),\n            (\"mobile_money\", mobile_money),\n            (\"device_id\", device_id),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        url = self._parse_url(\"/charge\")\n        return self._handle_request(HTTPMethod.POST, url, payload)\n\n    def submit_pin(self, pin: str, reference: str) -&gt; Response:\n        \"\"\"Submit PIN to continue a charge\n\n        Args:\n            pin: PIN submitted by user\n            reference: Reference for transaction that requested pin\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        payload = {\"pin\": pin, \"reference\": reference}\n        url = self._parse_url(\"/charge/submit_pin\")\n        return self._handle_request(HTTPMethod.POST, url, payload)\n\n    def submit_otp(self, otp: str, reference: str) -&gt; Response:\n        \"\"\"Submit OTP to complete a charge\n\n        Args:\n            otp: OTP submitted by user\n            reference: Reference for ongoing transaction\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        payload = {\"otp\": otp, \"reference\": reference}\n        url = self._parse_url(\"/charge/submit_otp\")\n        return self._handle_request(HTTPMethod.POST, url, payload)\n\n    def submit_phone(self, phone: str, reference: str) -&gt; Response:\n        \"\"\"Submit Phone when requested\n\n        Args:\n            phone: Phone submitted by user\n            reference: Reference for ongoing transaction\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        payload = {\"phone\": phone, \"reference\": reference}\n        url = self._parse_url(\"/charge/submit_phone\")\n        return self._handle_request(HTTPMethod.POST, url, payload)\n\n    def submit_birthday(self, birthday: str, reference: str) -&gt; Response:\n        \"\"\"Submit Birthday when requested\n\n        Args:\n            birthday: Birthday submitted by user. ISO Format e.g. 2016-09-21\n            reference: Reference for ongoing transaction\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        payload = {\"birthday\": birthday, \"reference\": reference}\n        url = self._parse_url(\"/charge/submit_birthday\")\n        return self._handle_request(HTTPMethod.POST, url, payload)\n\n    def set_address(\n        self,\n        address: str,\n        reference: str,\n        city: str,\n        state: str,\n        zipcode: str,\n    ) -&gt; Response:\n        \"\"\"Submit address to continue a charge\n\n        Args:\n            address: Address submitted by user\n            reference: Reference for ongoing transaction\n            city: City submitted by user\n            state: State submitted by user\n            zipcode: sZipcode submitted by user\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        payload = {\n            \"address\": address,\n            \"reference\": reference,\n            \"city\": city,\n            \"state\": state,\n            \"zip_code\": zipcode,\n        }\n        url = self._parse_url(\"/charge/submit_address\")\n        return self._handle_request(HTTPMethod.POST, url, payload)\n\n    def check_pending_charge(self, reference: str) -&gt; Response:\n        \"\"\"\n        When you get \"pending\" as a charge status or if there was an\n        exception when calling any of the /charge endpoints, wait 10\n        seconds or more, then make a check to see if its status has changed.\n        Don't call too early as you may get a lot more pending than you should.\n\n        Args:\n            reference: The reference to check\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/charge/{reference}\")\n        return self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/charge/#pypaystack2.api.charge.Charge.charge","title":"<code>charge(email, amount, bank=None, bank_transfer=None, auth_code=None, pin=None, metadata=None, reference=None, ussd=None, mobile_money=None, device_id=None)</code>","text":"<p>Initiate a payment by integrating the payment channel of your choice.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Customer's email address</p> required <code>amount</code> <code>int</code> <p>Amount should be in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR</p> required <code>bank</code> <code>Optional[dict]</code> <p>Bank account to charge (don't send if charging an authorization code)</p> <code>None</code> <code>bank_transfer</code> <code>Optional[dict]</code> <p>Takes the settings for the Pay with Transfer (PwT) channel. Pass in the account_expires_at param to set the expiry time.</p> <code>None</code> <code>auth_code</code> <code>Optional[str]</code> <p>An authorization code to charge (don't send if charging a bank account)</p> <code>None</code> <code>pin</code> <code>Optional[str]</code> <p>4-digit PIN (send with a non-reusable authorization code)</p> <code>None</code> <code>metadata</code> <code>Optional[dict]</code> <p>A dictionary of data.</p> <code>None</code> <code>reference</code> <code>Optional[str]</code> <p>Unique transaction reference. Only -, .`, = and alphanumeric characters allowed.</p> <code>None</code> <code>ussd</code> <code>Optional[dict]</code> <p>USSD type to charge (don't send if charging an authorization code, bank or card)</p> <code>None</code> <code>mobile_money</code> <code>Optional[dict]</code> <p>Mobile details (don't send if charging an authorization code, bank or card)</p> <code>None</code> <code>device_id</code> <code>Optional[str]</code> <p>This is the unique identifier of the device a user uses in making payment. Only -, .`, = and alphanumeric characters allowed.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/charge.py</code> <pre><code>def charge(\n    self,\n    email: str,\n    amount: int,\n    bank: Optional[dict] = None,\n    bank_transfer: Optional[dict] = None,\n    auth_code: Optional[str] = None,\n    pin: Optional[str] = None,\n    metadata: Optional[dict] = None,\n    reference: Optional[str] = None,\n    ussd: Optional[dict] = None,\n    mobile_money: Optional[dict] = None,\n    device_id: Optional[str] = None,\n) -&gt; Response:\n    \"\"\"Initiate a payment by integrating the payment channel of your choice.\n\n    Args:\n        email: Customer's email address\n        amount: Amount should be in kobo if currency is NGN, pesewas, if currency is GHS,\n            and cents, if currency is ZAR\n        bank: Bank account to charge (don't send if charging an authorization code)\n        bank_transfer: Takes the settings for the Pay with Transfer (PwT) channel. Pass in the\n            account_expires_at param to set the expiry time.\n        auth_code: An authorization code to charge (don't send if charging a bank account)\n        pin: 4-digit PIN (send with a non-reusable authorization code)\n        metadata: A dictionary of data.\n        reference: Unique transaction reference. Only -, .\\\\`, = and alphanumeric characters allowed.\n        ussd: USSD type to charge (don't send if charging an authorization code, bank or card)\n        mobile_money: Mobile details (don't send if charging an authorization code, bank or card)\n        device_id: This is the unique identifier of the device a user uses in making payment. Only -, .\\\\`,\n            = and alphanumeric characters allowed.\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    amount = validate_amount(amount)\n    payload = {\"email\": email, \"amount\": amount}\n    optional_params = [\n        (\"bank\", bank),\n        (\"bank_transfer\", bank_transfer),\n        (\"authorization_code\", auth_code),\n        (\"pin\", pin),\n        (\"metadata\", metadata),\n        (\"reference\", reference),\n        (\"ussd\", ussd),\n        (\"mobile_money\", mobile_money),\n        (\"device_id\", device_id),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    url = self._parse_url(\"/charge\")\n    return self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/charge/#pypaystack2.api.charge.Charge.check_pending_charge","title":"<code>check_pending_charge(reference)</code>","text":"<p>When you get \"pending\" as a charge status or if there was an exception when calling any of the /charge endpoints, wait 10 seconds or more, then make a check to see if its status has changed. Don't call too early as you may get a lot more pending than you should.</p> <p>Parameters:</p> Name Type Description Default <code>reference</code> <code>str</code> <p>The reference to check</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/charge.py</code> <pre><code>def check_pending_charge(self, reference: str) -&gt; Response:\n    \"\"\"\n    When you get \"pending\" as a charge status or if there was an\n    exception when calling any of the /charge endpoints, wait 10\n    seconds or more, then make a check to see if its status has changed.\n    Don't call too early as you may get a lot more pending than you should.\n\n    Args:\n        reference: The reference to check\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/charge/{reference}\")\n    return self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/charge/#pypaystack2.api.charge.Charge.set_address","title":"<code>set_address(address, reference, city, state, zipcode)</code>","text":"<p>Submit address to continue a charge</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>str</code> <p>Address submitted by user</p> required <code>reference</code> <code>str</code> <p>Reference for ongoing transaction</p> required <code>city</code> <code>str</code> <p>City submitted by user</p> required <code>state</code> <code>str</code> <p>State submitted by user</p> required <code>zipcode</code> <code>str</code> <p>sZipcode submitted by user</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/charge.py</code> <pre><code>def set_address(\n    self,\n    address: str,\n    reference: str,\n    city: str,\n    state: str,\n    zipcode: str,\n) -&gt; Response:\n    \"\"\"Submit address to continue a charge\n\n    Args:\n        address: Address submitted by user\n        reference: Reference for ongoing transaction\n        city: City submitted by user\n        state: State submitted by user\n        zipcode: sZipcode submitted by user\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    payload = {\n        \"address\": address,\n        \"reference\": reference,\n        \"city\": city,\n        \"state\": state,\n        \"zip_code\": zipcode,\n    }\n    url = self._parse_url(\"/charge/submit_address\")\n    return self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/charge/#pypaystack2.api.charge.Charge.submit_birthday","title":"<code>submit_birthday(birthday, reference)</code>","text":"<p>Submit Birthday when requested</p> <p>Parameters:</p> Name Type Description Default <code>birthday</code> <code>str</code> <p>Birthday submitted by user. ISO Format e.g. 2016-09-21</p> required <code>reference</code> <code>str</code> <p>Reference for ongoing transaction</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/charge.py</code> <pre><code>def submit_birthday(self, birthday: str, reference: str) -&gt; Response:\n    \"\"\"Submit Birthday when requested\n\n    Args:\n        birthday: Birthday submitted by user. ISO Format e.g. 2016-09-21\n        reference: Reference for ongoing transaction\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    payload = {\"birthday\": birthday, \"reference\": reference}\n    url = self._parse_url(\"/charge/submit_birthday\")\n    return self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/charge/#pypaystack2.api.charge.Charge.submit_otp","title":"<code>submit_otp(otp, reference)</code>","text":"<p>Submit OTP to complete a charge</p> <p>Parameters:</p> Name Type Description Default <code>otp</code> <code>str</code> <p>OTP submitted by user</p> required <code>reference</code> <code>str</code> <p>Reference for ongoing transaction</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/charge.py</code> <pre><code>def submit_otp(self, otp: str, reference: str) -&gt; Response:\n    \"\"\"Submit OTP to complete a charge\n\n    Args:\n        otp: OTP submitted by user\n        reference: Reference for ongoing transaction\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    payload = {\"otp\": otp, \"reference\": reference}\n    url = self._parse_url(\"/charge/submit_otp\")\n    return self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/charge/#pypaystack2.api.charge.Charge.submit_phone","title":"<code>submit_phone(phone, reference)</code>","text":"<p>Submit Phone when requested</p> <p>Parameters:</p> Name Type Description Default <code>phone</code> <code>str</code> <p>Phone submitted by user</p> required <code>reference</code> <code>str</code> <p>Reference for ongoing transaction</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/charge.py</code> <pre><code>def submit_phone(self, phone: str, reference: str) -&gt; Response:\n    \"\"\"Submit Phone when requested\n\n    Args:\n        phone: Phone submitted by user\n        reference: Reference for ongoing transaction\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    payload = {\"phone\": phone, \"reference\": reference}\n    url = self._parse_url(\"/charge/submit_phone\")\n    return self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/charge/#pypaystack2.api.charge.Charge.submit_pin","title":"<code>submit_pin(pin, reference)</code>","text":"<p>Submit PIN to continue a charge</p> <p>Parameters:</p> Name Type Description Default <code>pin</code> <code>str</code> <p>PIN submitted by user</p> required <code>reference</code> <code>str</code> <p>Reference for transaction that requested pin</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/charge.py</code> <pre><code>def submit_pin(self, pin: str, reference: str) -&gt; Response:\n    \"\"\"Submit PIN to continue a charge\n\n    Args:\n        pin: PIN submitted by user\n        reference: Reference for transaction that requested pin\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    payload = {\"pin\": pin, \"reference\": reference}\n    url = self._parse_url(\"/charge/submit_pin\")\n    return self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/customer/","title":"Customer","text":""},{"location":"reference/customer/#pypaystack2.api.customers.AsyncCustomer","title":"<code>AsyncCustomer</code>","text":"<p>               Bases: <code>BaseAsyncAPI</code></p> <p>Provides a wrapper for paystack Customer API</p> <p>The Customers API allows you to create and manage customers in your integration. https://paystack.com/docs/api/customer/</p> Source code in <code>src/pypaystack2/api/customers.py</code> <pre><code>class AsyncCustomer(BaseAsyncAPI):\n    \"\"\"Provides a wrapper for paystack Customer API\n\n    The Customers API allows you to create and manage customers in your integration.\n    https://paystack.com/docs/api/customer/\n    \"\"\"\n\n    async def create(\n        self,\n        email: str,\n        first_name: Optional[str] = None,\n        last_name: Optional[str] = None,\n        phone: Optional[str] = None,\n        metadata: Optional[dict] = None,\n    ) -&gt; Response:\n        \"\"\"Create a customer on your integration.\n\n        Note:\n            The `first_name`, `last_name` and `phone` are optional parameters. However,\n            when creating a customer that would be assigned a Dedicated Virtual\n            Account and your business category falls under Betting, Financial\n            services, and General Service, then these parameters become compulsory.\n\n        Args:\n            email: Customer's email address\n            first_name: Customer's first name\n            last_name: Customer's last name\n            phone: Customer's phone number\n            metadata: A dictionary that you can attach to the customer. It can be used\n                to store additional information in a structured format.\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(\"/customer/\")\n        payload = {\n            \"email\": email,\n        }\n        optional_params = [\n            (\"first_name\", first_name),\n            (\"last_name\", last_name),\n            (\"phone\", phone),\n            (\"metadata\", metadata),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return await self._handle_request(HTTPMethod.POST, url, payload)\n\n    async def get_customers(\n        self,\n        start_date: Optional[str] = None,\n        end_date: Optional[str] = None,\n        page: int = 1,\n        pagination: int = 50,\n    ) -&gt; Response:\n        \"\"\"Fetches customers available on your integration.\n\n        Args:\n            start_date: A timestamp from which to start listing customers e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            end_date: A timestamp at which to stop listing customers e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            page: Specify exactly what page you want to retrieve. If not specified, we use a default value of 1.\n            pagination: Specifies how many records you want to retrieve per page.\n                If not specified we use a default value of 50.\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        query_params = [\n            (\"page\", page),\n            (\"from\", start_date),\n            (\"to\", end_date),\n        ]\n        url = self._parse_url(f\"/customer/?perPage={pagination}\")\n        url = append_query_params(query_params, url)\n        return await self._handle_request(HTTPMethod.GET, url)\n\n    async def get_customer(self, email_or_code: str) -&gt; Response:\n        \"\"\"Get details of a customer on your integration.\n\n        Args:\n            email_or_code: An email or customer code for the customer you want to fetch\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/customer/{email_or_code}/\")\n        return await self._handle_request(HTTPMethod.GET, url)\n\n    async def update(\n        self,\n        code: str,\n        first_name: Optional[str] = None,\n        last_name: Optional[str] = None,\n        phone: Optional[str] = None,\n        metadata: Optional[dict] = None,\n    ) -&gt; Response:\n        \"\"\"Update a customer's details on your integration\n\n        Args:\n            code: Customer's code\n            first_name: Customer's first name\n            last_name: Customer's last name\n            phone: Customer's phone number\n            metadata: A dictionary that you can attach to the customer. It can be used to store additional\n                information in a structured format.\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/customer/{code}/\")\n        payload = {}\n\n        optional_params = [\n            (\"first_name\", first_name),\n            (\"last_name\", last_name),\n            (\"phone\", phone),\n            (\"metadata\", metadata),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return await self._handle_request(HTTPMethod.PUT, url, payload)\n\n    async def validate(\n        self,\n        email_or_code: str,\n        first_name: str,\n        last_name: str,\n        identification_type: Identification,\n        country: Country,\n        bvn: str,\n        identification_number: Optional[str] = None,\n        bank_code: Optional[str] = None,\n        account_number: Optional[str] = None,\n        middle_name: Optional[str] = None,\n    ) -&gt; Response:\n        \"\"\"Validate a customer's identity\n\n        Args:\n            email_or_code: Customer's email or code\n            first_name: Customer's first name\n            last_name: Customer's last name\n            identification_type: Enum of Identification e.g `Identification.BVN`\n            identification_number: An identification number based on the `identification_type`\n            country: Customer's Country e.g `Country.NIGERIA`\n            bvn: Customer's Bank Verification Number\n            bank_code: You can get the list of Bank Codes by calling the\n                Miscellaneous API `get_banks` method. (required if type is bank_account)\n            account_number: Customer's bank account number. (required if type is bank_account)\n            middle_name: Customer's middle name\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        if identification_type == Identification.BANK_ACCOUNT:\n            if bank_code is None:\n                raise InvalidDataException(\n                    \"`bank_code` is required if identification type is `Identification.BANK_ACCOUNT`\"\n                )\n            if account_number is None:\n                raise InvalidDataException(\n                    \"`account_number` is required if identification type is `Identification.BANK_ACCOUNT`\"\n                )\n\n        url = self._parse_url(f\"/customer/{email_or_code}/identification\")\n        payload = {\n            \"first_name\": first_name,\n            \"last_name\": last_name,\n            \"type\": identification_type,\n            \"country\": country,\n            \"bvn\": bvn,\n        }\n        optional_params = [\n            (\"bank_code\", bank_code),\n            (\"account_number\", account_number),\n            (\"middle_name\", middle_name),\n            (\"value\", identification_number),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return await self._handle_request(HTTPMethod.POST, url, payload)\n\n    async def flag(\n        self,\n        customer: str,\n        risk_action: Optional[RiskAction] = None,\n    ) -&gt; Response:\n        \"\"\"Whitelist or blacklist a customer on your integration\n\n        Args:\n            customer: Customer's code, or email address\n            risk_action: One of the possible risk actions from the RiskAction enum e.g `RiskAction.DEFAULT`\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(\"/customer/set_risk_action\")\n        payload = {\n            \"customer\": customer,\n        }\n        optional_params = [\n            (\"risk_action\", risk_action),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return await self._handle_request(HTTPMethod.POST, url, payload)\n\n    async def deactivate(\n        self,\n        auth_code: str,\n    ) -&gt; Response:\n        \"\"\"Deactivate an authorization when the card needs to be forgotten\n\n        Args:\n            auth_code: Authorization code to be deactivated\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(\"/customer/deactivate_authorization\")\n        payload = {\n            \"authorization_code\": auth_code,\n        }\n        return await self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/customer/#pypaystack2.api.customers.AsyncCustomer.create","title":"<code>create(email, first_name=None, last_name=None, phone=None, metadata=None)</code>  <code>async</code>","text":"<p>Create a customer on your integration.</p> Note <p>The <code>first_name</code>, <code>last_name</code> and <code>phone</code> are optional parameters. However, when creating a customer that would be assigned a Dedicated Virtual Account and your business category falls under Betting, Financial services, and General Service, then these parameters become compulsory.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Customer's email address</p> required <code>first_name</code> <code>Optional[str]</code> <p>Customer's first name</p> <code>None</code> <code>last_name</code> <code>Optional[str]</code> <p>Customer's last name</p> <code>None</code> <code>phone</code> <code>Optional[str]</code> <p>Customer's phone number</p> <code>None</code> <code>metadata</code> <code>Optional[dict]</code> <p>A dictionary that you can attach to the customer. It can be used to store additional information in a structured format.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/customers.py</code> <pre><code>async def create(\n    self,\n    email: str,\n    first_name: Optional[str] = None,\n    last_name: Optional[str] = None,\n    phone: Optional[str] = None,\n    metadata: Optional[dict] = None,\n) -&gt; Response:\n    \"\"\"Create a customer on your integration.\n\n    Note:\n        The `first_name`, `last_name` and `phone` are optional parameters. However,\n        when creating a customer that would be assigned a Dedicated Virtual\n        Account and your business category falls under Betting, Financial\n        services, and General Service, then these parameters become compulsory.\n\n    Args:\n        email: Customer's email address\n        first_name: Customer's first name\n        last_name: Customer's last name\n        phone: Customer's phone number\n        metadata: A dictionary that you can attach to the customer. It can be used\n            to store additional information in a structured format.\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(\"/customer/\")\n    payload = {\n        \"email\": email,\n    }\n    optional_params = [\n        (\"first_name\", first_name),\n        (\"last_name\", last_name),\n        (\"phone\", phone),\n        (\"metadata\", metadata),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return await self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/customer/#pypaystack2.api.customers.AsyncCustomer.deactivate","title":"<code>deactivate(auth_code)</code>  <code>async</code>","text":"<p>Deactivate an authorization when the card needs to be forgotten</p> <p>Parameters:</p> Name Type Description Default <code>auth_code</code> <code>str</code> <p>Authorization code to be deactivated</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/customers.py</code> <pre><code>async def deactivate(\n    self,\n    auth_code: str,\n) -&gt; Response:\n    \"\"\"Deactivate an authorization when the card needs to be forgotten\n\n    Args:\n        auth_code: Authorization code to be deactivated\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(\"/customer/deactivate_authorization\")\n    payload = {\n        \"authorization_code\": auth_code,\n    }\n    return await self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/customer/#pypaystack2.api.customers.AsyncCustomer.flag","title":"<code>flag(customer, risk_action=None)</code>  <code>async</code>","text":"<p>Whitelist or blacklist a customer on your integration</p> <p>Parameters:</p> Name Type Description Default <code>customer</code> <code>str</code> <p>Customer's code, or email address</p> required <code>risk_action</code> <code>Optional[RiskAction]</code> <p>One of the possible risk actions from the RiskAction enum e.g <code>RiskAction.DEFAULT</code></p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/customers.py</code> <pre><code>async def flag(\n    self,\n    customer: str,\n    risk_action: Optional[RiskAction] = None,\n) -&gt; Response:\n    \"\"\"Whitelist or blacklist a customer on your integration\n\n    Args:\n        customer: Customer's code, or email address\n        risk_action: One of the possible risk actions from the RiskAction enum e.g `RiskAction.DEFAULT`\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(\"/customer/set_risk_action\")\n    payload = {\n        \"customer\": customer,\n    }\n    optional_params = [\n        (\"risk_action\", risk_action),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return await self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/customer/#pypaystack2.api.customers.AsyncCustomer.get_customer","title":"<code>get_customer(email_or_code)</code>  <code>async</code>","text":"<p>Get details of a customer on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>email_or_code</code> <code>str</code> <p>An email or customer code for the customer you want to fetch</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/customers.py</code> <pre><code>async def get_customer(self, email_or_code: str) -&gt; Response:\n    \"\"\"Get details of a customer on your integration.\n\n    Args:\n        email_or_code: An email or customer code for the customer you want to fetch\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/customer/{email_or_code}/\")\n    return await self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/customer/#pypaystack2.api.customers.AsyncCustomer.get_customers","title":"<code>get_customers(start_date=None, end_date=None, page=1, pagination=50)</code>  <code>async</code>","text":"<p>Fetches customers available on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>start_date</code> <code>Optional[str]</code> <p>A timestamp from which to start listing customers e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>end_date</code> <code>Optional[str]</code> <p>A timestamp at which to stop listing customers e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>page</code> <code>int</code> <p>Specify exactly what page you want to retrieve. If not specified, we use a default value of 1.</p> <code>1</code> <code>pagination</code> <code>int</code> <p>Specifies how many records you want to retrieve per page. If not specified we use a default value of 50.</p> <code>50</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/customers.py</code> <pre><code>async def get_customers(\n    self,\n    start_date: Optional[str] = None,\n    end_date: Optional[str] = None,\n    page: int = 1,\n    pagination: int = 50,\n) -&gt; Response:\n    \"\"\"Fetches customers available on your integration.\n\n    Args:\n        start_date: A timestamp from which to start listing customers e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        end_date: A timestamp at which to stop listing customers e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        page: Specify exactly what page you want to retrieve. If not specified, we use a default value of 1.\n        pagination: Specifies how many records you want to retrieve per page.\n            If not specified we use a default value of 50.\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    query_params = [\n        (\"page\", page),\n        (\"from\", start_date),\n        (\"to\", end_date),\n    ]\n    url = self._parse_url(f\"/customer/?perPage={pagination}\")\n    url = append_query_params(query_params, url)\n    return await self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/customer/#pypaystack2.api.customers.AsyncCustomer.update","title":"<code>update(code, first_name=None, last_name=None, phone=None, metadata=None)</code>  <code>async</code>","text":"<p>Update a customer's details on your integration</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>Customer's code</p> required <code>first_name</code> <code>Optional[str]</code> <p>Customer's first name</p> <code>None</code> <code>last_name</code> <code>Optional[str]</code> <p>Customer's last name</p> <code>None</code> <code>phone</code> <code>Optional[str]</code> <p>Customer's phone number</p> <code>None</code> <code>metadata</code> <code>Optional[dict]</code> <p>A dictionary that you can attach to the customer. It can be used to store additional information in a structured format.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/customers.py</code> <pre><code>async def update(\n    self,\n    code: str,\n    first_name: Optional[str] = None,\n    last_name: Optional[str] = None,\n    phone: Optional[str] = None,\n    metadata: Optional[dict] = None,\n) -&gt; Response:\n    \"\"\"Update a customer's details on your integration\n\n    Args:\n        code: Customer's code\n        first_name: Customer's first name\n        last_name: Customer's last name\n        phone: Customer's phone number\n        metadata: A dictionary that you can attach to the customer. It can be used to store additional\n            information in a structured format.\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/customer/{code}/\")\n    payload = {}\n\n    optional_params = [\n        (\"first_name\", first_name),\n        (\"last_name\", last_name),\n        (\"phone\", phone),\n        (\"metadata\", metadata),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return await self._handle_request(HTTPMethod.PUT, url, payload)\n</code></pre>"},{"location":"reference/customer/#pypaystack2.api.customers.AsyncCustomer.validate","title":"<code>validate(email_or_code, first_name, last_name, identification_type, country, bvn, identification_number=None, bank_code=None, account_number=None, middle_name=None)</code>  <code>async</code>","text":"<p>Validate a customer's identity</p> <p>Parameters:</p> Name Type Description Default <code>email_or_code</code> <code>str</code> <p>Customer's email or code</p> required <code>first_name</code> <code>str</code> <p>Customer's first name</p> required <code>last_name</code> <code>str</code> <p>Customer's last name</p> required <code>identification_type</code> <code>Identification</code> <p>Enum of Identification e.g <code>Identification.BVN</code></p> required <code>identification_number</code> <code>Optional[str]</code> <p>An identification number based on the <code>identification_type</code></p> <code>None</code> <code>country</code> <code>Country</code> <p>Customer's Country e.g <code>Country.NIGERIA</code></p> required <code>bvn</code> <code>str</code> <p>Customer's Bank Verification Number</p> required <code>bank_code</code> <code>Optional[str]</code> <p>You can get the list of Bank Codes by calling the Miscellaneous API <code>get_banks</code> method. (required if type is bank_account)</p> <code>None</code> <code>account_number</code> <code>Optional[str]</code> <p>Customer's bank account number. (required if type is bank_account)</p> <code>None</code> <code>middle_name</code> <code>Optional[str]</code> <p>Customer's middle name</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/customers.py</code> <pre><code>async def validate(\n    self,\n    email_or_code: str,\n    first_name: str,\n    last_name: str,\n    identification_type: Identification,\n    country: Country,\n    bvn: str,\n    identification_number: Optional[str] = None,\n    bank_code: Optional[str] = None,\n    account_number: Optional[str] = None,\n    middle_name: Optional[str] = None,\n) -&gt; Response:\n    \"\"\"Validate a customer's identity\n\n    Args:\n        email_or_code: Customer's email or code\n        first_name: Customer's first name\n        last_name: Customer's last name\n        identification_type: Enum of Identification e.g `Identification.BVN`\n        identification_number: An identification number based on the `identification_type`\n        country: Customer's Country e.g `Country.NIGERIA`\n        bvn: Customer's Bank Verification Number\n        bank_code: You can get the list of Bank Codes by calling the\n            Miscellaneous API `get_banks` method. (required if type is bank_account)\n        account_number: Customer's bank account number. (required if type is bank_account)\n        middle_name: Customer's middle name\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    if identification_type == Identification.BANK_ACCOUNT:\n        if bank_code is None:\n            raise InvalidDataException(\n                \"`bank_code` is required if identification type is `Identification.BANK_ACCOUNT`\"\n            )\n        if account_number is None:\n            raise InvalidDataException(\n                \"`account_number` is required if identification type is `Identification.BANK_ACCOUNT`\"\n            )\n\n    url = self._parse_url(f\"/customer/{email_or_code}/identification\")\n    payload = {\n        \"first_name\": first_name,\n        \"last_name\": last_name,\n        \"type\": identification_type,\n        \"country\": country,\n        \"bvn\": bvn,\n    }\n    optional_params = [\n        (\"bank_code\", bank_code),\n        (\"account_number\", account_number),\n        (\"middle_name\", middle_name),\n        (\"value\", identification_number),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return await self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/customer/#pypaystack2.api.customers.Customer","title":"<code>Customer</code>","text":"<p>               Bases: <code>BaseAPI</code></p> <p>Provides a wrapper for paystack Customer API</p> <p>The Customers API allows you to create and manage customers in your integration. https://paystack.com/docs/api/customer/</p> Source code in <code>src/pypaystack2/api/customers.py</code> <pre><code>class Customer(BaseAPI):\n    \"\"\"Provides a wrapper for paystack Customer API\n\n    The Customers API allows you to create and manage customers in your integration.\n    https://paystack.com/docs/api/customer/\n    \"\"\"\n\n    def create(\n        self,\n        email: str,\n        first_name: Optional[str] = None,\n        last_name: Optional[str] = None,\n        phone: Optional[str] = None,\n        metadata: Optional[dict] = None,\n    ) -&gt; Response:\n        \"\"\"Create a customer on your integration.\n\n        Note:\n            The `first_name`, `last_name` and `phone` are optional parameters. However,\n            when creating a customer that would be assigned a Dedicated Virtual\n            Account and your business category falls under Betting, Financial\n            services, and General Service, then these parameters become compulsory.\n\n        Args:\n            email: Customer's email address\n            first_name: Customer's first name\n            last_name: Customer's last name\n            phone: Customer's phone number\n            metadata: A dictionary that you can attach to the customer. It can be used\n                to store additional information in a structured format.\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(\"/customer/\")\n        payload = {\n            \"email\": email,\n        }\n        optional_params = [\n            (\"first_name\", first_name),\n            (\"last_name\", last_name),\n            (\"phone\", phone),\n            (\"metadata\", metadata),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return self._handle_request(HTTPMethod.POST, url, payload)\n\n    def get_customers(\n        self,\n        start_date: Optional[str] = None,\n        end_date: Optional[str] = None,\n        page: int = 1,\n        pagination: int = 50,\n    ) -&gt; Response:\n        \"\"\"Fetches customers available on your integration.\n\n        Args:\n            start_date: A timestamp from which to start listing customers e.g., 2016-09-24T00:00:05.000Z, 2016-09-21\n            end_date: A timestamp at which to stop listing customers e.g., 2016-09-24T00:00:05.000Z, 2016-09-21\n            page: Specify exactly what page you want to retrieve. If not specified, we use a default value of 1.\n            pagination: Specifies how many records you want to retrieve per page.\n                If not specified, we use a default value of 50.\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        query_params = [\n            (\"page\", page),\n            (\"from\", start_date),\n            (\"to\", end_date),\n        ]\n        url = self._parse_url(f\"/customer/?perPage={pagination}\")\n        url = append_query_params(query_params, url)\n        return self._handle_request(HTTPMethod.GET, url)\n\n    def get_customer(self, email_or_code: str) -&gt; Response:\n        \"\"\"Get details of a customer on your integration.\n\n        Args:\n            email_or_code: An email or customer code for the customer you want to fetch\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/customer/{email_or_code}/\")\n        return self._handle_request(HTTPMethod.GET, url)\n\n    def update(\n        self,\n        code: str,\n        first_name: Optional[str] = None,\n        last_name: Optional[str] = None,\n        phone: Optional[str] = None,\n        metadata: Optional[dict] = None,\n    ) -&gt; Response:\n        \"\"\"Update a customer's details on your integration\n\n        Args:\n            code: Customer's code\n            first_name: Customer's first name\n            last_name: Customer's last name\n            phone: Customer's phone number\n            metadata: A dictionary that you can attach to the customer. It can be used to store additional\n                information in a structured format.\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/customer/{code}/\")\n        payload = {}\n\n        optional_params = [\n            (\"first_name\", first_name),\n            (\"last_name\", last_name),\n            (\"phone\", phone),\n            (\"metadata\", metadata),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return self._handle_request(HTTPMethod.PUT, url, payload)\n\n    def validate(\n        self,\n        email_or_code: str,\n        first_name: str,\n        last_name: str,\n        identification_type: Identification,\n        country: Country,\n        bvn: str,\n        identification_number: Optional[str] = None,\n        bank_code: Optional[str] = None,\n        account_number: Optional[str] = None,\n        middle_name: Optional[str] = None,\n    ) -&gt; Response:\n        \"\"\"Validate a customer's identity\n\n        Args:\n            email_or_code: Customer's email or code\n            first_name: Customer's first name\n            last_name: Customer's last name\n            identification_type: Enum of Identification e.g `Identification.BVN`\n            identification_number: An identification number based on the `identification_type`\n            country: Customer's Country e.g `Country.NIGERIA`\n            bvn: Customer's Bank Verification Number\n            bank_code: You can get the list of Bank Codes by calling the\n                Miscellaneous API `get_banks` method. (required if type is bank_account)\n            account_number: Customer's bank account number. (required if type is bank_account)\n            middle_name: Customer's middle name\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        if identification_type == Identification.BANK_ACCOUNT:\n            if bank_code is None:\n                raise InvalidDataException(\n                    \"`bank_code` is required if identification type is `Identification.BANK_ACCOUNT`\"\n                )\n            if account_number is None:\n                raise InvalidDataException(\n                    \"`account_number` is required if identification type is `Identification.BANK_ACCOUNT`\"\n                )\n\n        url = self._parse_url(f\"/customer/{email_or_code}/identification\")\n        payload = {\n            \"first_name\": first_name,\n            \"last_name\": last_name,\n            \"type\": identification_type,\n            \"country\": country,\n            \"bvn\": bvn,\n        }\n        optional_params = [\n            (\"bank_code\", bank_code),\n            (\"account_number\", account_number),\n            (\"middle_name\", middle_name),\n            (\"value\", identification_number),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return self._handle_request(HTTPMethod.POST, url, payload)\n\n    def flag(\n        self,\n        customer: str,\n        risk_action: Optional[RiskAction] = None,\n    ) -&gt; Response:\n        \"\"\"Whitelist or blacklist a customer on your integration\n\n        Args:\n            customer: Customer's code, or email address\n            risk_action: One of the possible risk actions from the RiskAction enum e.g `RiskAction.DEFAULT`\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(\"/customer/set_risk_action\")\n        payload = {\n            \"customer\": customer,\n        }\n        optional_params = [\n            (\"risk_action\", risk_action),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return self._handle_request(HTTPMethod.POST, url, payload)\n\n    def deactivate(\n        self,\n        auth_code: str,\n    ) -&gt; Response:\n        \"\"\"Deactivate an authorization when the card needs to be forgotten\n\n        Args:\n            auth_code: Authorization code to be deactivated\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(\"/customer/deactivate_authorization\")\n        payload = {\n            \"authorization_code\": auth_code,\n        }\n        return self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/customer/#pypaystack2.api.customers.Customer.create","title":"<code>create(email, first_name=None, last_name=None, phone=None, metadata=None)</code>","text":"<p>Create a customer on your integration.</p> Note <p>The <code>first_name</code>, <code>last_name</code> and <code>phone</code> are optional parameters. However, when creating a customer that would be assigned a Dedicated Virtual Account and your business category falls under Betting, Financial services, and General Service, then these parameters become compulsory.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Customer's email address</p> required <code>first_name</code> <code>Optional[str]</code> <p>Customer's first name</p> <code>None</code> <code>last_name</code> <code>Optional[str]</code> <p>Customer's last name</p> <code>None</code> <code>phone</code> <code>Optional[str]</code> <p>Customer's phone number</p> <code>None</code> <code>metadata</code> <code>Optional[dict]</code> <p>A dictionary that you can attach to the customer. It can be used to store additional information in a structured format.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/customers.py</code> <pre><code>def create(\n    self,\n    email: str,\n    first_name: Optional[str] = None,\n    last_name: Optional[str] = None,\n    phone: Optional[str] = None,\n    metadata: Optional[dict] = None,\n) -&gt; Response:\n    \"\"\"Create a customer on your integration.\n\n    Note:\n        The `first_name`, `last_name` and `phone` are optional parameters. However,\n        when creating a customer that would be assigned a Dedicated Virtual\n        Account and your business category falls under Betting, Financial\n        services, and General Service, then these parameters become compulsory.\n\n    Args:\n        email: Customer's email address\n        first_name: Customer's first name\n        last_name: Customer's last name\n        phone: Customer's phone number\n        metadata: A dictionary that you can attach to the customer. It can be used\n            to store additional information in a structured format.\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(\"/customer/\")\n    payload = {\n        \"email\": email,\n    }\n    optional_params = [\n        (\"first_name\", first_name),\n        (\"last_name\", last_name),\n        (\"phone\", phone),\n        (\"metadata\", metadata),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/customer/#pypaystack2.api.customers.Customer.deactivate","title":"<code>deactivate(auth_code)</code>","text":"<p>Deactivate an authorization when the card needs to be forgotten</p> <p>Parameters:</p> Name Type Description Default <code>auth_code</code> <code>str</code> <p>Authorization code to be deactivated</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/customers.py</code> <pre><code>def deactivate(\n    self,\n    auth_code: str,\n) -&gt; Response:\n    \"\"\"Deactivate an authorization when the card needs to be forgotten\n\n    Args:\n        auth_code: Authorization code to be deactivated\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(\"/customer/deactivate_authorization\")\n    payload = {\n        \"authorization_code\": auth_code,\n    }\n    return self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/customer/#pypaystack2.api.customers.Customer.flag","title":"<code>flag(customer, risk_action=None)</code>","text":"<p>Whitelist or blacklist a customer on your integration</p> <p>Parameters:</p> Name Type Description Default <code>customer</code> <code>str</code> <p>Customer's code, or email address</p> required <code>risk_action</code> <code>Optional[RiskAction]</code> <p>One of the possible risk actions from the RiskAction enum e.g <code>RiskAction.DEFAULT</code></p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/customers.py</code> <pre><code>def flag(\n    self,\n    customer: str,\n    risk_action: Optional[RiskAction] = None,\n) -&gt; Response:\n    \"\"\"Whitelist or blacklist a customer on your integration\n\n    Args:\n        customer: Customer's code, or email address\n        risk_action: One of the possible risk actions from the RiskAction enum e.g `RiskAction.DEFAULT`\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(\"/customer/set_risk_action\")\n    payload = {\n        \"customer\": customer,\n    }\n    optional_params = [\n        (\"risk_action\", risk_action),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/customer/#pypaystack2.api.customers.Customer.get_customer","title":"<code>get_customer(email_or_code)</code>","text":"<p>Get details of a customer on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>email_or_code</code> <code>str</code> <p>An email or customer code for the customer you want to fetch</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/customers.py</code> <pre><code>def get_customer(self, email_or_code: str) -&gt; Response:\n    \"\"\"Get details of a customer on your integration.\n\n    Args:\n        email_or_code: An email or customer code for the customer you want to fetch\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/customer/{email_or_code}/\")\n    return self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/customer/#pypaystack2.api.customers.Customer.get_customers","title":"<code>get_customers(start_date=None, end_date=None, page=1, pagination=50)</code>","text":"<p>Fetches customers available on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>start_date</code> <code>Optional[str]</code> <p>A timestamp from which to start listing customers e.g., 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>end_date</code> <code>Optional[str]</code> <p>A timestamp at which to stop listing customers e.g., 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>page</code> <code>int</code> <p>Specify exactly what page you want to retrieve. If not specified, we use a default value of 1.</p> <code>1</code> <code>pagination</code> <code>int</code> <p>Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50.</p> <code>50</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/customers.py</code> <pre><code>def get_customers(\n    self,\n    start_date: Optional[str] = None,\n    end_date: Optional[str] = None,\n    page: int = 1,\n    pagination: int = 50,\n) -&gt; Response:\n    \"\"\"Fetches customers available on your integration.\n\n    Args:\n        start_date: A timestamp from which to start listing customers e.g., 2016-09-24T00:00:05.000Z, 2016-09-21\n        end_date: A timestamp at which to stop listing customers e.g., 2016-09-24T00:00:05.000Z, 2016-09-21\n        page: Specify exactly what page you want to retrieve. If not specified, we use a default value of 1.\n        pagination: Specifies how many records you want to retrieve per page.\n            If not specified, we use a default value of 50.\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    query_params = [\n        (\"page\", page),\n        (\"from\", start_date),\n        (\"to\", end_date),\n    ]\n    url = self._parse_url(f\"/customer/?perPage={pagination}\")\n    url = append_query_params(query_params, url)\n    return self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/customer/#pypaystack2.api.customers.Customer.update","title":"<code>update(code, first_name=None, last_name=None, phone=None, metadata=None)</code>","text":"<p>Update a customer's details on your integration</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>Customer's code</p> required <code>first_name</code> <code>Optional[str]</code> <p>Customer's first name</p> <code>None</code> <code>last_name</code> <code>Optional[str]</code> <p>Customer's last name</p> <code>None</code> <code>phone</code> <code>Optional[str]</code> <p>Customer's phone number</p> <code>None</code> <code>metadata</code> <code>Optional[dict]</code> <p>A dictionary that you can attach to the customer. It can be used to store additional information in a structured format.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/customers.py</code> <pre><code>def update(\n    self,\n    code: str,\n    first_name: Optional[str] = None,\n    last_name: Optional[str] = None,\n    phone: Optional[str] = None,\n    metadata: Optional[dict] = None,\n) -&gt; Response:\n    \"\"\"Update a customer's details on your integration\n\n    Args:\n        code: Customer's code\n        first_name: Customer's first name\n        last_name: Customer's last name\n        phone: Customer's phone number\n        metadata: A dictionary that you can attach to the customer. It can be used to store additional\n            information in a structured format.\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/customer/{code}/\")\n    payload = {}\n\n    optional_params = [\n        (\"first_name\", first_name),\n        (\"last_name\", last_name),\n        (\"phone\", phone),\n        (\"metadata\", metadata),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return self._handle_request(HTTPMethod.PUT, url, payload)\n</code></pre>"},{"location":"reference/customer/#pypaystack2.api.customers.Customer.validate","title":"<code>validate(email_or_code, first_name, last_name, identification_type, country, bvn, identification_number=None, bank_code=None, account_number=None, middle_name=None)</code>","text":"<p>Validate a customer's identity</p> <p>Parameters:</p> Name Type Description Default <code>email_or_code</code> <code>str</code> <p>Customer's email or code</p> required <code>first_name</code> <code>str</code> <p>Customer's first name</p> required <code>last_name</code> <code>str</code> <p>Customer's last name</p> required <code>identification_type</code> <code>Identification</code> <p>Enum of Identification e.g <code>Identification.BVN</code></p> required <code>identification_number</code> <code>Optional[str]</code> <p>An identification number based on the <code>identification_type</code></p> <code>None</code> <code>country</code> <code>Country</code> <p>Customer's Country e.g <code>Country.NIGERIA</code></p> required <code>bvn</code> <code>str</code> <p>Customer's Bank Verification Number</p> required <code>bank_code</code> <code>Optional[str]</code> <p>You can get the list of Bank Codes by calling the Miscellaneous API <code>get_banks</code> method. (required if type is bank_account)</p> <code>None</code> <code>account_number</code> <code>Optional[str]</code> <p>Customer's bank account number. (required if type is bank_account)</p> <code>None</code> <code>middle_name</code> <code>Optional[str]</code> <p>Customer's middle name</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/customers.py</code> <pre><code>def validate(\n    self,\n    email_or_code: str,\n    first_name: str,\n    last_name: str,\n    identification_type: Identification,\n    country: Country,\n    bvn: str,\n    identification_number: Optional[str] = None,\n    bank_code: Optional[str] = None,\n    account_number: Optional[str] = None,\n    middle_name: Optional[str] = None,\n) -&gt; Response:\n    \"\"\"Validate a customer's identity\n\n    Args:\n        email_or_code: Customer's email or code\n        first_name: Customer's first name\n        last_name: Customer's last name\n        identification_type: Enum of Identification e.g `Identification.BVN`\n        identification_number: An identification number based on the `identification_type`\n        country: Customer's Country e.g `Country.NIGERIA`\n        bvn: Customer's Bank Verification Number\n        bank_code: You can get the list of Bank Codes by calling the\n            Miscellaneous API `get_banks` method. (required if type is bank_account)\n        account_number: Customer's bank account number. (required if type is bank_account)\n        middle_name: Customer's middle name\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    if identification_type == Identification.BANK_ACCOUNT:\n        if bank_code is None:\n            raise InvalidDataException(\n                \"`bank_code` is required if identification type is `Identification.BANK_ACCOUNT`\"\n            )\n        if account_number is None:\n            raise InvalidDataException(\n                \"`account_number` is required if identification type is `Identification.BANK_ACCOUNT`\"\n            )\n\n    url = self._parse_url(f\"/customer/{email_or_code}/identification\")\n    payload = {\n        \"first_name\": first_name,\n        \"last_name\": last_name,\n        \"type\": identification_type,\n        \"country\": country,\n        \"bvn\": bvn,\n    }\n    optional_params = [\n        (\"bank_code\", bank_code),\n        (\"account_number\", account_number),\n        (\"middle_name\", middle_name),\n        (\"value\", identification_number),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/dedicated_accounts/","title":"Dedicated accounts","text":""},{"location":"reference/dedicated_accounts/#pypaystack2.api.dedicated_accounts.AsyncDedicatedAccount","title":"<code>AsyncDedicatedAccount</code>","text":"<p>               Bases: <code>BaseAsyncAPI</code></p> <p>Provides a wrapper for paystack Dedicated Virtual Account API</p> <p>The Dedicated Virtual Account API enables Nigerian merchants to manage unique payment accounts of their customers. https://paystack.com/docs/api/dedicated-virtual-account/</p> Note <p>This feature is only available to businesses in Nigeria.</p> Source code in <code>src/pypaystack2/api/dedicated_accounts.py</code> <pre><code>class AsyncDedicatedAccount(BaseAsyncAPI):\n    \"\"\"Provides a wrapper for paystack Dedicated Virtual Account API\n\n    The Dedicated Virtual Account API enables Nigerian merchants to manage\n    unique payment accounts of their customers.\n    https://paystack.com/docs/api/dedicated-virtual-account/\n\n\n    Note:\n        This feature is only available to businesses in Nigeria.\n    \"\"\"\n\n    async def create(\n        self,\n        customer: str,\n        preferred_bank: Optional[str] = None,\n        subaccount: Optional[str] = None,\n        split_code: Optional[str] = None,\n        first_name: Optional[str] = None,\n        last_name: Optional[str] = None,\n        phone: Optional[str] = None,\n    ) -&gt; Response:\n        \"\"\"Create a dedicated virtual account for an existing customer\n\n        Note:\n            * This feature is only available to businesses in Nigeria.\n            * Paystack currently supports Wema Bank and Titan Paystack.\n\n        Args:\n            customer: Customer ID or code\n            preferred_bank: The bank slug for a preferred bank. To get a list of available banks, use the\n                Miscellaneous API ``.get_providers`` method.\n            subaccount: Subaccount code of the account you want to split the transaction with\n            split_code: Split code consisting of the lists of accounts you want to split the transaction with\n            first_name: Customer's first name\n            last_name: Customer's last name\n            phone: Customer's phone number\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(\"/dedicated_account\")\n        payload = {\n            \"customer\": customer,\n        }\n        optional_params = [\n            (\"preferred_bank\", preferred_bank),\n            (\"subaccount\", subaccount),\n            (\"split_code\", split_code),\n            (\"first_name\", first_name),\n            (\"last_name\", last_name),\n            (\"phone\", phone),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return await self._handle_request(HTTPMethod.POST, url, payload)\n\n    async def assign(\n        self,\n        email: str,\n        first_name: str,\n        last_name: str,\n        phone: str,\n        preferred_bank: str,\n        country: Country = Country.NIGERIA,\n        account_number: Optional[str] = None,\n        bvn: Optional[str] = None,\n        bank_code: Optional[str] = None,\n        subaccount: Optional[str] = None,\n        split_code: Optional[str] = None,\n    ) -&gt; Response:\n        \"\"\"Create a customer, validate the customer, and assign a DVA to the customer.\n\n        Note:\n            * This feature is only available to businesses in Nigeria.\n            * Paystack currently supports Wema Bank and Titan Paystack.\n\n        Args:\n            email: Customer email address\n            first_name: Customer's first name\n            last_name: Customer's last name\n            phone: Customer's phone number\n            preferred_bank: The bank slug for preferred bank. To get a list of available banks, use the\n                Paystack.miscellaneous.get_banks, AsyncPaystack.miscellaneous.get_banks, Miscellaneous.get_banks\n                or AsyncMiscellaneous.get_banks, with `pay_with_bank_transfer=true`\n            country: Currently accepts `Country.NIGERIA` only\n            account_number: Customer's account number\n            bvn: Customer's Bank Verification Number\n            bank_code: Customer's bank code\n            subaccount: Subaccount code of the account you want to split the transaction with\n            split_code: Split code consisting of the lists of accounts you want to split the transaction with\n        \"\"\"\n\n        url = self._parse_url(\"/dedicated_account/assign\")\n        payload = {\n            \"email\": email,\n            \"first_name\": first_name,\n            \"last_name\": last_name,\n            \"phone\": phone,\n            \"preferred_bank\": preferred_bank,\n            \"country\": country,\n        }\n        optional_params = [\n            (\"account_number\", account_number),\n            (\"bvn\", bvn),\n            (\"bank_code\", bank_code),\n            (\"subaccount\", subaccount),\n            (\"split_code\", split_code),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return await self._handle_request(HTTPMethod.POST, url, payload)\n\n    async def get_dedicated_accounts(\n        self,\n        active: bool = True,\n        currency: Currency = Currency.NGN,\n        provider_slug: Optional[str] = None,\n        bank_id: Optional[str] = None,\n        customer: Optional[str] = None,\n    ) -&gt; Response:\n        \"\"\"Fetches dedicated virtual accounts available on your integration.\n\n        Note:\n            * This feature is only available to businesses in Nigeria.\n            * Paystack currently supports Wema Bank and Titan Paystack.\n\n        Args:\n            active: Status of the dedicated virtual account\n            currency: The currency of the dedicated virtual account. Only ``Currency.NGN`` is currently allowed\n            provider_slug: The bank's slug in lowercase, without spaces e.g. wema-bank. call the `.get_providers`\n                method of this class to see available providers.\n            bank_id: The bank's ID e.g., 035\n            customer: The customer's ID\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        query_params = [\n            (\"currency\", currency),\n            (\"provider_slug\", provider_slug),\n            (\"bank_id\", bank_id),\n            (\"customer\", customer),\n        ]\n        url = self._parse_url(f\"/dedicated_account?active={active}\")\n        url = append_query_params(query_params, url)\n        return await self._handle_request(HTTPMethod.GET, url)\n\n    async def get_dedicated_account(self, dedicated_account_id: int) -&gt; Response:\n        \"\"\"Get details of a dedicated virtual account on your integration.\n\n        Note:\n            * This feature is only available to businesses in Nigeria.\n            * Paystack currently supports Wema Bank and Titan Paystack.\n\n        Args:\n            dedicated_account_id: ID of dedicated virtual account\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/dedicated_account/{dedicated_account_id}\")\n        return await self._handle_request(HTTPMethod.GET, url)\n\n    async def requery(\n        self, account_number: str, provider_slug: str, date: Optional[str]\n    ) -&gt; Response:\n        \"\"\"Get details of a dedicated virtual account on your integration.\n\n        Note:\n            * This feature is only available to businesses in Nigeria.\n            * Paystack currently supports Wema Bank and Titan Paystack.\n\n        Args:\n            account_number: Virtual account number to requery\n            provider_slug: The bank's slug in lowercase, without spaces e.g. wema-bank\n            date: The day the transfer was made in YYYY-MM-DD ISO format\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/dedicated_account?account_number={account_number}\")\n        query_params = [\n            (\"provider_slug\", provider_slug),\n            (\"date\", date),\n        ]\n        url = append_query_params(query_params, url)\n        return await self._handle_request(HTTPMethod.GET, url)\n\n    async def deactivate(self, dedicated_account_id: int) -&gt; Response:\n        \"\"\"Deactivate a dedicated virtual account on your integration.\n\n        Note:\n            * This feature is only available to businesses in Nigeria.\n            * Paystack currently supports Access Bank and Wema Bank.\n\n        Args:\n            dedicated_account_id: ID of dedicated virtual account\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/dedicated_account/{dedicated_account_id}\")\n        return await self._handle_request(HTTPMethod.DELETE, url)\n\n    async def split(\n        self,\n        customer: str,\n        subaccount: Optional[str] = None,\n        split_code: Optional[str] = None,\n        preferred_bank: Optional[str] = None,\n    ) -&gt; Response:\n        \"\"\"Split a dedicated virtual account transaction with one or more accounts\n\n        Note:\n            * This feature is only available to businesses in Nigeria.\n            * Paystack currently supports Access Bank and Wema Bank.\n\n        Args:\n            customer: Customer ID or code\n            subaccount: Subaccount code of the account you want to split the transaction with\n            split_code: Split code consisting of the lists of accounts you want to split the transaction with\n            preferred_bank: The bank slug for a preferred bank. To get a list of available banks,\n                use the Miscellaneous API ``.get_providers`` method\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(\"/dedicated_account/split\")\n        payload = {\"customer\": customer}\n\n        optional_params = [\n            (\"subaccount\", subaccount),\n            (\"split_code\", split_code),\n            (\"preferred_bank\", preferred_bank),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return await self._handle_request(HTTPMethod.POST, url, payload)\n\n    async def remove_split(self, account_number: str) -&gt; Response:\n        \"\"\"Removes a split.\n\n        If you've previously set up split payment for transactions on a dedicated virtual\n        account, you can remove it with this method.\n\n        Note:\n            * This feature is only available to businesses in Nigeria.\n            * Paystack currently supports Access Bank and Wema Bank.\n\n        Args:\n            account_number: Dedicated virtual account number\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(\"/dedicated_account/split\")\n        payload = {\n            \"account_number\": account_number,\n        }\n        return await self._handle_request(HTTPMethod.DELETE, url, payload)\n\n    async def get_providers(self) -&gt; Response:\n        \"\"\"Get available bank providers for a dedicated virtual account\n\n        Note:\n            * This feature is only available to businesses in Nigeria.\n            * Paystack currently supports Access Bank and Wema Bank.\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(\"/dedicated_account/available_providers\")\n        return await self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/dedicated_accounts/#pypaystack2.api.dedicated_accounts.AsyncDedicatedAccount.assign","title":"<code>assign(email, first_name, last_name, phone, preferred_bank, country=Country.NIGERIA, account_number=None, bvn=None, bank_code=None, subaccount=None, split_code=None)</code>  <code>async</code>","text":"<p>Create a customer, validate the customer, and assign a DVA to the customer.</p> Note <ul> <li>This feature is only available to businesses in Nigeria.</li> <li>Paystack currently supports Wema Bank and Titan Paystack.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Customer email address</p> required <code>first_name</code> <code>str</code> <p>Customer's first name</p> required <code>last_name</code> <code>str</code> <p>Customer's last name</p> required <code>phone</code> <code>str</code> <p>Customer's phone number</p> required <code>preferred_bank</code> <code>str</code> <p>The bank slug for preferred bank. To get a list of available banks, use the Paystack.miscellaneous.get_banks, AsyncPaystack.miscellaneous.get_banks, Miscellaneous.get_banks or AsyncMiscellaneous.get_banks, with <code>pay_with_bank_transfer=true</code></p> required <code>country</code> <code>Country</code> <p>Currently accepts <code>Country.NIGERIA</code> only</p> <code>NIGERIA</code> <code>account_number</code> <code>Optional[str]</code> <p>Customer's account number</p> <code>None</code> <code>bvn</code> <code>Optional[str]</code> <p>Customer's Bank Verification Number</p> <code>None</code> <code>bank_code</code> <code>Optional[str]</code> <p>Customer's bank code</p> <code>None</code> <code>subaccount</code> <code>Optional[str]</code> <p>Subaccount code of the account you want to split the transaction with</p> <code>None</code> <code>split_code</code> <code>Optional[str]</code> <p>Split code consisting of the lists of accounts you want to split the transaction with</p> <code>None</code> Source code in <code>src/pypaystack2/api/dedicated_accounts.py</code> <pre><code>async def assign(\n    self,\n    email: str,\n    first_name: str,\n    last_name: str,\n    phone: str,\n    preferred_bank: str,\n    country: Country = Country.NIGERIA,\n    account_number: Optional[str] = None,\n    bvn: Optional[str] = None,\n    bank_code: Optional[str] = None,\n    subaccount: Optional[str] = None,\n    split_code: Optional[str] = None,\n) -&gt; Response:\n    \"\"\"Create a customer, validate the customer, and assign a DVA to the customer.\n\n    Note:\n        * This feature is only available to businesses in Nigeria.\n        * Paystack currently supports Wema Bank and Titan Paystack.\n\n    Args:\n        email: Customer email address\n        first_name: Customer's first name\n        last_name: Customer's last name\n        phone: Customer's phone number\n        preferred_bank: The bank slug for preferred bank. To get a list of available banks, use the\n            Paystack.miscellaneous.get_banks, AsyncPaystack.miscellaneous.get_banks, Miscellaneous.get_banks\n            or AsyncMiscellaneous.get_banks, with `pay_with_bank_transfer=true`\n        country: Currently accepts `Country.NIGERIA` only\n        account_number: Customer's account number\n        bvn: Customer's Bank Verification Number\n        bank_code: Customer's bank code\n        subaccount: Subaccount code of the account you want to split the transaction with\n        split_code: Split code consisting of the lists of accounts you want to split the transaction with\n    \"\"\"\n\n    url = self._parse_url(\"/dedicated_account/assign\")\n    payload = {\n        \"email\": email,\n        \"first_name\": first_name,\n        \"last_name\": last_name,\n        \"phone\": phone,\n        \"preferred_bank\": preferred_bank,\n        \"country\": country,\n    }\n    optional_params = [\n        (\"account_number\", account_number),\n        (\"bvn\", bvn),\n        (\"bank_code\", bank_code),\n        (\"subaccount\", subaccount),\n        (\"split_code\", split_code),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return await self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/dedicated_accounts/#pypaystack2.api.dedicated_accounts.AsyncDedicatedAccount.create","title":"<code>create(customer, preferred_bank=None, subaccount=None, split_code=None, first_name=None, last_name=None, phone=None)</code>  <code>async</code>","text":"<p>Create a dedicated virtual account for an existing customer</p> Note <ul> <li>This feature is only available to businesses in Nigeria.</li> <li>Paystack currently supports Wema Bank and Titan Paystack.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>customer</code> <code>str</code> <p>Customer ID or code</p> required <code>preferred_bank</code> <code>Optional[str]</code> <p>The bank slug for a preferred bank. To get a list of available banks, use the Miscellaneous API <code>.get_providers</code> method.</p> <code>None</code> <code>subaccount</code> <code>Optional[str]</code> <p>Subaccount code of the account you want to split the transaction with</p> <code>None</code> <code>split_code</code> <code>Optional[str]</code> <p>Split code consisting of the lists of accounts you want to split the transaction with</p> <code>None</code> <code>first_name</code> <code>Optional[str]</code> <p>Customer's first name</p> <code>None</code> <code>last_name</code> <code>Optional[str]</code> <p>Customer's last name</p> <code>None</code> <code>phone</code> <code>Optional[str]</code> <p>Customer's phone number</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/dedicated_accounts.py</code> <pre><code>async def create(\n    self,\n    customer: str,\n    preferred_bank: Optional[str] = None,\n    subaccount: Optional[str] = None,\n    split_code: Optional[str] = None,\n    first_name: Optional[str] = None,\n    last_name: Optional[str] = None,\n    phone: Optional[str] = None,\n) -&gt; Response:\n    \"\"\"Create a dedicated virtual account for an existing customer\n\n    Note:\n        * This feature is only available to businesses in Nigeria.\n        * Paystack currently supports Wema Bank and Titan Paystack.\n\n    Args:\n        customer: Customer ID or code\n        preferred_bank: The bank slug for a preferred bank. To get a list of available banks, use the\n            Miscellaneous API ``.get_providers`` method.\n        subaccount: Subaccount code of the account you want to split the transaction with\n        split_code: Split code consisting of the lists of accounts you want to split the transaction with\n        first_name: Customer's first name\n        last_name: Customer's last name\n        phone: Customer's phone number\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(\"/dedicated_account\")\n    payload = {\n        \"customer\": customer,\n    }\n    optional_params = [\n        (\"preferred_bank\", preferred_bank),\n        (\"subaccount\", subaccount),\n        (\"split_code\", split_code),\n        (\"first_name\", first_name),\n        (\"last_name\", last_name),\n        (\"phone\", phone),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return await self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/dedicated_accounts/#pypaystack2.api.dedicated_accounts.AsyncDedicatedAccount.deactivate","title":"<code>deactivate(dedicated_account_id)</code>  <code>async</code>","text":"<p>Deactivate a dedicated virtual account on your integration.</p> Note <ul> <li>This feature is only available to businesses in Nigeria.</li> <li>Paystack currently supports Access Bank and Wema Bank.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>dedicated_account_id</code> <code>int</code> <p>ID of dedicated virtual account</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/dedicated_accounts.py</code> <pre><code>async def deactivate(self, dedicated_account_id: int) -&gt; Response:\n    \"\"\"Deactivate a dedicated virtual account on your integration.\n\n    Note:\n        * This feature is only available to businesses in Nigeria.\n        * Paystack currently supports Access Bank and Wema Bank.\n\n    Args:\n        dedicated_account_id: ID of dedicated virtual account\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/dedicated_account/{dedicated_account_id}\")\n    return await self._handle_request(HTTPMethod.DELETE, url)\n</code></pre>"},{"location":"reference/dedicated_accounts/#pypaystack2.api.dedicated_accounts.AsyncDedicatedAccount.get_dedicated_account","title":"<code>get_dedicated_account(dedicated_account_id)</code>  <code>async</code>","text":"<p>Get details of a dedicated virtual account on your integration.</p> Note <ul> <li>This feature is only available to businesses in Nigeria.</li> <li>Paystack currently supports Wema Bank and Titan Paystack.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>dedicated_account_id</code> <code>int</code> <p>ID of dedicated virtual account</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/dedicated_accounts.py</code> <pre><code>async def get_dedicated_account(self, dedicated_account_id: int) -&gt; Response:\n    \"\"\"Get details of a dedicated virtual account on your integration.\n\n    Note:\n        * This feature is only available to businesses in Nigeria.\n        * Paystack currently supports Wema Bank and Titan Paystack.\n\n    Args:\n        dedicated_account_id: ID of dedicated virtual account\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/dedicated_account/{dedicated_account_id}\")\n    return await self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/dedicated_accounts/#pypaystack2.api.dedicated_accounts.AsyncDedicatedAccount.get_dedicated_accounts","title":"<code>get_dedicated_accounts(active=True, currency=Currency.NGN, provider_slug=None, bank_id=None, customer=None)</code>  <code>async</code>","text":"<p>Fetches dedicated virtual accounts available on your integration.</p> Note <ul> <li>This feature is only available to businesses in Nigeria.</li> <li>Paystack currently supports Wema Bank and Titan Paystack.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>active</code> <code>bool</code> <p>Status of the dedicated virtual account</p> <code>True</code> <code>currency</code> <code>Currency</code> <p>The currency of the dedicated virtual account. Only <code>Currency.NGN</code> is currently allowed</p> <code>NGN</code> <code>provider_slug</code> <code>Optional[str]</code> <p>The bank's slug in lowercase, without spaces e.g. wema-bank. call the <code>.get_providers</code> method of this class to see available providers.</p> <code>None</code> <code>bank_id</code> <code>Optional[str]</code> <p>The bank's ID e.g., 035</p> <code>None</code> <code>customer</code> <code>Optional[str]</code> <p>The customer's ID</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/dedicated_accounts.py</code> <pre><code>async def get_dedicated_accounts(\n    self,\n    active: bool = True,\n    currency: Currency = Currency.NGN,\n    provider_slug: Optional[str] = None,\n    bank_id: Optional[str] = None,\n    customer: Optional[str] = None,\n) -&gt; Response:\n    \"\"\"Fetches dedicated virtual accounts available on your integration.\n\n    Note:\n        * This feature is only available to businesses in Nigeria.\n        * Paystack currently supports Wema Bank and Titan Paystack.\n\n    Args:\n        active: Status of the dedicated virtual account\n        currency: The currency of the dedicated virtual account. Only ``Currency.NGN`` is currently allowed\n        provider_slug: The bank's slug in lowercase, without spaces e.g. wema-bank. call the `.get_providers`\n            method of this class to see available providers.\n        bank_id: The bank's ID e.g., 035\n        customer: The customer's ID\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    query_params = [\n        (\"currency\", currency),\n        (\"provider_slug\", provider_slug),\n        (\"bank_id\", bank_id),\n        (\"customer\", customer),\n    ]\n    url = self._parse_url(f\"/dedicated_account?active={active}\")\n    url = append_query_params(query_params, url)\n    return await self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/dedicated_accounts/#pypaystack2.api.dedicated_accounts.AsyncDedicatedAccount.get_providers","title":"<code>get_providers()</code>  <code>async</code>","text":"<p>Get available bank providers for a dedicated virtual account</p> Note <ul> <li>This feature is only available to businesses in Nigeria.</li> <li>Paystack currently supports Access Bank and Wema Bank.</li> </ul> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/dedicated_accounts.py</code> <pre><code>async def get_providers(self) -&gt; Response:\n    \"\"\"Get available bank providers for a dedicated virtual account\n\n    Note:\n        * This feature is only available to businesses in Nigeria.\n        * Paystack currently supports Access Bank and Wema Bank.\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(\"/dedicated_account/available_providers\")\n    return await self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/dedicated_accounts/#pypaystack2.api.dedicated_accounts.AsyncDedicatedAccount.remove_split","title":"<code>remove_split(account_number)</code>  <code>async</code>","text":"<p>Removes a split.</p> <p>If you've previously set up split payment for transactions on a dedicated virtual account, you can remove it with this method.</p> Note <ul> <li>This feature is only available to businesses in Nigeria.</li> <li>Paystack currently supports Access Bank and Wema Bank.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>account_number</code> <code>str</code> <p>Dedicated virtual account number</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/dedicated_accounts.py</code> <pre><code>async def remove_split(self, account_number: str) -&gt; Response:\n    \"\"\"Removes a split.\n\n    If you've previously set up split payment for transactions on a dedicated virtual\n    account, you can remove it with this method.\n\n    Note:\n        * This feature is only available to businesses in Nigeria.\n        * Paystack currently supports Access Bank and Wema Bank.\n\n    Args:\n        account_number: Dedicated virtual account number\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(\"/dedicated_account/split\")\n    payload = {\n        \"account_number\": account_number,\n    }\n    return await self._handle_request(HTTPMethod.DELETE, url, payload)\n</code></pre>"},{"location":"reference/dedicated_accounts/#pypaystack2.api.dedicated_accounts.AsyncDedicatedAccount.requery","title":"<code>requery(account_number, provider_slug, date)</code>  <code>async</code>","text":"<p>Get details of a dedicated virtual account on your integration.</p> Note <ul> <li>This feature is only available to businesses in Nigeria.</li> <li>Paystack currently supports Wema Bank and Titan Paystack.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>account_number</code> <code>str</code> <p>Virtual account number to requery</p> required <code>provider_slug</code> <code>str</code> <p>The bank's slug in lowercase, without spaces e.g. wema-bank</p> required <code>date</code> <code>Optional[str]</code> <p>The day the transfer was made in YYYY-MM-DD ISO format</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/dedicated_accounts.py</code> <pre><code>async def requery(\n    self, account_number: str, provider_slug: str, date: Optional[str]\n) -&gt; Response:\n    \"\"\"Get details of a dedicated virtual account on your integration.\n\n    Note:\n        * This feature is only available to businesses in Nigeria.\n        * Paystack currently supports Wema Bank and Titan Paystack.\n\n    Args:\n        account_number: Virtual account number to requery\n        provider_slug: The bank's slug in lowercase, without spaces e.g. wema-bank\n        date: The day the transfer was made in YYYY-MM-DD ISO format\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/dedicated_account?account_number={account_number}\")\n    query_params = [\n        (\"provider_slug\", provider_slug),\n        (\"date\", date),\n    ]\n    url = append_query_params(query_params, url)\n    return await self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/dedicated_accounts/#pypaystack2.api.dedicated_accounts.AsyncDedicatedAccount.split","title":"<code>split(customer, subaccount=None, split_code=None, preferred_bank=None)</code>  <code>async</code>","text":"<p>Split a dedicated virtual account transaction with one or more accounts</p> Note <ul> <li>This feature is only available to businesses in Nigeria.</li> <li>Paystack currently supports Access Bank and Wema Bank.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>customer</code> <code>str</code> <p>Customer ID or code</p> required <code>subaccount</code> <code>Optional[str]</code> <p>Subaccount code of the account you want to split the transaction with</p> <code>None</code> <code>split_code</code> <code>Optional[str]</code> <p>Split code consisting of the lists of accounts you want to split the transaction with</p> <code>None</code> <code>preferred_bank</code> <code>Optional[str]</code> <p>The bank slug for a preferred bank. To get a list of available banks, use the Miscellaneous API <code>.get_providers</code> method</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/dedicated_accounts.py</code> <pre><code>async def split(\n    self,\n    customer: str,\n    subaccount: Optional[str] = None,\n    split_code: Optional[str] = None,\n    preferred_bank: Optional[str] = None,\n) -&gt; Response:\n    \"\"\"Split a dedicated virtual account transaction with one or more accounts\n\n    Note:\n        * This feature is only available to businesses in Nigeria.\n        * Paystack currently supports Access Bank and Wema Bank.\n\n    Args:\n        customer: Customer ID or code\n        subaccount: Subaccount code of the account you want to split the transaction with\n        split_code: Split code consisting of the lists of accounts you want to split the transaction with\n        preferred_bank: The bank slug for a preferred bank. To get a list of available banks,\n            use the Miscellaneous API ``.get_providers`` method\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(\"/dedicated_account/split\")\n    payload = {\"customer\": customer}\n\n    optional_params = [\n        (\"subaccount\", subaccount),\n        (\"split_code\", split_code),\n        (\"preferred_bank\", preferred_bank),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return await self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/dedicated_accounts/#pypaystack2.api.dedicated_accounts.DedicatedAccount","title":"<code>DedicatedAccount</code>","text":"<p>               Bases: <code>BaseAPI</code></p> <p>Provides a wrapper for paystack Dedicated Virtual Account API</p> <p>The Dedicated Virtual Account API enables Nigerian merchants to manage unique payment accounts of their customers. https://paystack.com/docs/api/dedicated-virtual-account/</p> Note <p>This feature is only available to businesses in Nigeria.</p> Source code in <code>src/pypaystack2/api/dedicated_accounts.py</code> <pre><code>class DedicatedAccount(BaseAPI):\n    \"\"\"Provides a wrapper for paystack Dedicated Virtual Account API\n\n    The Dedicated Virtual Account API enables Nigerian merchants to manage\n    unique payment accounts of their customers.\n    https://paystack.com/docs/api/dedicated-virtual-account/\n\n\n    Note:\n        This feature is only available to businesses in Nigeria.\n    \"\"\"\n\n    def create(\n        self,\n        customer: str,\n        preferred_bank: Optional[str] = None,\n        subaccount: Optional[str] = None,\n        split_code: Optional[str] = None,\n        first_name: Optional[str] = None,\n        last_name: Optional[str] = None,\n        phone: Optional[str] = None,\n    ) -&gt; Response:\n        \"\"\"Create a dedicated virtual account for an existing customer\n\n        Note:\n            * This feature is only available to businesses in Nigeria.\n            * Paystack currently supports Wema Bank and Titan Paystack.\n\n        Args:\n            customer: Customer ID or code\n            preferred_bank: The bank slug for a preferred bank. To get a list of available banks, use the\n                Miscellaneous API ``.get_providers`` method.\n            subaccount: Subaccount code of the account you want to split the transaction with\n            split_code: Split code consisting of the lists of accounts you want to split the transaction with\n            first_name: Customer's first name\n            last_name: Customer's last name\n            phone: Customer's phone number\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(\"/dedicated_account\")\n        payload = {\n            \"customer\": customer,\n        }\n        optional_params = [\n            (\"preferred_bank\", preferred_bank),\n            (\"subaccount\", subaccount),\n            (\"split_code\", split_code),\n            (\"first_name\", first_name),\n            (\"last_name\", last_name),\n            (\"phone\", phone),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return self._handle_request(HTTPMethod.POST, url, payload)\n\n    def assign(\n        self,\n        email: str,\n        first_name: str,\n        last_name: str,\n        phone: str,\n        preferred_bank: str,\n        country: Country = Country.NIGERIA,\n        account_number: Optional[str] = None,\n        bvn: Optional[str] = None,\n        bank_code: Optional[str] = None,\n        subaccount: Optional[str] = None,\n        split_code: Optional[str] = None,\n    ) -&gt; Response:\n        \"\"\"Create a customer, validate the customer, and assign a DVA to the customer.\n\n        Note:\n            * This feature is only available to businesses in Nigeria.\n            * Paystack currently supports Wema Bank and Titan Paystack.\n\n        Args:\n            email: Customer email address\n            first_name: Customer's first name\n            last_name: Customer's last name\n            phone: Customer's phone number\n            preferred_bank: The bank slug for preferred bank. To get a list of available banks, use the\n                Paystack.miscellaneous.get_banks, AsyncPaystack.miscellaneous.get_banks, Miscellaneous.get_banks\n                or AsyncMiscellaneous.get_banks, with `pay_with_bank_transfer=true`\n            country: Currently accepts `Country.NIGERIA` only\n            account_number: Customer's account number\n            bvn: Customer's Bank Verification Number\n            bank_code: Customer's bank code\n            subaccount: Subaccount code of the account you want to split the transaction with\n            split_code: Split code consisting of the lists of accounts you want to split the transaction with\n        \"\"\"\n\n        url = self._parse_url(\"/dedicated_account/assign\")\n        payload = {\n            \"email\": email,\n            \"first_name\": first_name,\n            \"last_name\": last_name,\n            \"phone\": phone,\n            \"preferred_bank\": preferred_bank,\n            \"country\": country,\n        }\n        optional_params = [\n            (\"account_number\", account_number),\n            (\"bvn\", bvn),\n            (\"bank_code\", bank_code),\n            (\"subaccount\", subaccount),\n            (\"split_code\", split_code),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return self._handle_request(HTTPMethod.POST, url, payload)\n\n    def get_dedicated_accounts(\n        self,\n        active: bool = True,\n        currency: Currency = Currency.NGN,\n        provider_slug: Optional[str] = None,\n        bank_id: Optional[str] = None,\n        customer: Optional[str] = None,\n    ) -&gt; Response:\n        \"\"\"Fetches dedicated virtual accounts available on your integration.\n\n        Note:\n            * This feature is only available to businesses in Nigeria.\n            * Paystack currently supports Wema Bank and Titan Paystack.\n\n        Args:\n            active: Status of the dedicated virtual account\n            currency: The currency of the dedicated virtual account. Only ``Currency.NGN`` is currently allowed\n            provider_slug: The bank's slug in lowercase, without spaces e.g. wema-bank. call the `.get_providers`\n                method of this class to see available providers.\n            bank_id: The bank's ID e.g., 035\n            customer: The customer's ID\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        query_params = [\n            (\"currency\", currency),\n            (\"provider_slug\", provider_slug),\n            (\"bank_id\", bank_id),\n            (\"customer\", customer),\n        ]\n        url = self._parse_url(f\"/dedicated_account?active={active}\")\n        url = append_query_params(query_params, url)\n        return self._handle_request(HTTPMethod.GET, url)\n\n    def get_dedicated_account(self, dedicated_account_id: int) -&gt; Response:\n        \"\"\"Get details of a dedicated virtual account on your integration.\n\n        Note:\n            * This feature is only available to businesses in Nigeria.\n            * Paystack currently supports Wema Bank and Titan Paystack.\n\n        Args:\n            dedicated_account_id: ID of dedicated virtual account\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/dedicated_account/{dedicated_account_id}\")\n        return self._handle_request(HTTPMethod.GET, url)\n\n    def requery(\n        self, account_number: str, provider_slug: str, date: Optional[str]\n    ) -&gt; Response:\n        \"\"\"Get details of a dedicated virtual account on your integration.\n\n        Note:\n            * This feature is only available to businesses in Nigeria.\n            * Paystack currently supports Wema Bank and Titan Paystack.\n\n        Args:\n            account_number: Virtual account number to requery\n            provider_slug: The bank's slug in lowercase, without spaces e.g. wema-bank\n            date: The day the transfer was made in YYYY-MM-DD ISO format\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/dedicated_account?account_number={account_number}\")\n        query_params = [\n            (\"provider_slug\", provider_slug),\n            (\"date\", date),\n        ]\n        url = append_query_params(query_params, url)\n        return self._handle_request(HTTPMethod.GET, url)\n\n    def deactivate(self, dedicated_account_id: int) -&gt; Response:\n        \"\"\"Deactivate a dedicated virtual account on your integration.\n\n        Note:\n            * This feature is only available to businesses in Nigeria.\n            * Paystack currently supports Access Bank and Wema Bank.\n\n        Args:\n            dedicated_account_id: ID of dedicated virtual account\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/dedicated_account/{dedicated_account_id}\")\n        return self._handle_request(HTTPMethod.DELETE, url)\n\n    def split(\n        self,\n        customer: str,\n        subaccount: Optional[str] = None,\n        split_code: Optional[str] = None,\n        preferred_bank: Optional[str] = None,\n    ) -&gt; Response:\n        \"\"\"Split a dedicated virtual account transaction with one or more accounts\n\n        Note:\n            * This feature is only available to businesses in Nigeria.\n            * Paystack currently supports Access Bank and Wema Bank.\n\n        Args:\n            customer: Customer ID or code\n            subaccount: Subaccount code of the account you want to split the transaction with\n            split_code: Split code consisting of the lists of accounts you want to split the transaction with\n            preferred_bank: The bank slug for a preferred bank. To get a list of available banks,\n                use the Miscellaneous API ``.get_providers`` method\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(\"/dedicated_account/split\")\n        payload = {\"customer\": customer}\n\n        optional_params = [\n            (\"subaccount\", subaccount),\n            (\"split_code\", split_code),\n            (\"preferred_bank\", preferred_bank),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return self._handle_request(HTTPMethod.POST, url, payload)\n\n    def remove_split(self, account_number: str) -&gt; Response:\n        \"\"\"Removes a split.\n\n        If you've previously set up split payment for transactions on a dedicated virtual\n        account, you can remove it with this method.\n\n        Note:\n            * This feature is only available to businesses in Nigeria.\n            * Paystack currently supports Access Bank and Wema Bank.\n\n        Args:\n            account_number: Dedicated virtual account number\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(\"/dedicated_account/split\")\n        payload = {\n            \"account_number\": account_number,\n        }\n        return self._handle_request(HTTPMethod.DELETE, url, payload)\n\n    def get_providers(self) -&gt; Response:\n        \"\"\"Get available bank providers for a dedicated virtual account\n\n        Note:\n            * This feature is only available to businesses in Nigeria.\n            * Paystack currently supports Access Bank and Wema Bank.\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(\"/dedicated_account/available_providers\")\n        return self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/dedicated_accounts/#pypaystack2.api.dedicated_accounts.DedicatedAccount.assign","title":"<code>assign(email, first_name, last_name, phone, preferred_bank, country=Country.NIGERIA, account_number=None, bvn=None, bank_code=None, subaccount=None, split_code=None)</code>","text":"<p>Create a customer, validate the customer, and assign a DVA to the customer.</p> Note <ul> <li>This feature is only available to businesses in Nigeria.</li> <li>Paystack currently supports Wema Bank and Titan Paystack.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Customer email address</p> required <code>first_name</code> <code>str</code> <p>Customer's first name</p> required <code>last_name</code> <code>str</code> <p>Customer's last name</p> required <code>phone</code> <code>str</code> <p>Customer's phone number</p> required <code>preferred_bank</code> <code>str</code> <p>The bank slug for preferred bank. To get a list of available banks, use the Paystack.miscellaneous.get_banks, AsyncPaystack.miscellaneous.get_banks, Miscellaneous.get_banks or AsyncMiscellaneous.get_banks, with <code>pay_with_bank_transfer=true</code></p> required <code>country</code> <code>Country</code> <p>Currently accepts <code>Country.NIGERIA</code> only</p> <code>NIGERIA</code> <code>account_number</code> <code>Optional[str]</code> <p>Customer's account number</p> <code>None</code> <code>bvn</code> <code>Optional[str]</code> <p>Customer's Bank Verification Number</p> <code>None</code> <code>bank_code</code> <code>Optional[str]</code> <p>Customer's bank code</p> <code>None</code> <code>subaccount</code> <code>Optional[str]</code> <p>Subaccount code of the account you want to split the transaction with</p> <code>None</code> <code>split_code</code> <code>Optional[str]</code> <p>Split code consisting of the lists of accounts you want to split the transaction with</p> <code>None</code> Source code in <code>src/pypaystack2/api/dedicated_accounts.py</code> <pre><code>def assign(\n    self,\n    email: str,\n    first_name: str,\n    last_name: str,\n    phone: str,\n    preferred_bank: str,\n    country: Country = Country.NIGERIA,\n    account_number: Optional[str] = None,\n    bvn: Optional[str] = None,\n    bank_code: Optional[str] = None,\n    subaccount: Optional[str] = None,\n    split_code: Optional[str] = None,\n) -&gt; Response:\n    \"\"\"Create a customer, validate the customer, and assign a DVA to the customer.\n\n    Note:\n        * This feature is only available to businesses in Nigeria.\n        * Paystack currently supports Wema Bank and Titan Paystack.\n\n    Args:\n        email: Customer email address\n        first_name: Customer's first name\n        last_name: Customer's last name\n        phone: Customer's phone number\n        preferred_bank: The bank slug for preferred bank. To get a list of available banks, use the\n            Paystack.miscellaneous.get_banks, AsyncPaystack.miscellaneous.get_banks, Miscellaneous.get_banks\n            or AsyncMiscellaneous.get_banks, with `pay_with_bank_transfer=true`\n        country: Currently accepts `Country.NIGERIA` only\n        account_number: Customer's account number\n        bvn: Customer's Bank Verification Number\n        bank_code: Customer's bank code\n        subaccount: Subaccount code of the account you want to split the transaction with\n        split_code: Split code consisting of the lists of accounts you want to split the transaction with\n    \"\"\"\n\n    url = self._parse_url(\"/dedicated_account/assign\")\n    payload = {\n        \"email\": email,\n        \"first_name\": first_name,\n        \"last_name\": last_name,\n        \"phone\": phone,\n        \"preferred_bank\": preferred_bank,\n        \"country\": country,\n    }\n    optional_params = [\n        (\"account_number\", account_number),\n        (\"bvn\", bvn),\n        (\"bank_code\", bank_code),\n        (\"subaccount\", subaccount),\n        (\"split_code\", split_code),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/dedicated_accounts/#pypaystack2.api.dedicated_accounts.DedicatedAccount.create","title":"<code>create(customer, preferred_bank=None, subaccount=None, split_code=None, first_name=None, last_name=None, phone=None)</code>","text":"<p>Create a dedicated virtual account for an existing customer</p> Note <ul> <li>This feature is only available to businesses in Nigeria.</li> <li>Paystack currently supports Wema Bank and Titan Paystack.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>customer</code> <code>str</code> <p>Customer ID or code</p> required <code>preferred_bank</code> <code>Optional[str]</code> <p>The bank slug for a preferred bank. To get a list of available banks, use the Miscellaneous API <code>.get_providers</code> method.</p> <code>None</code> <code>subaccount</code> <code>Optional[str]</code> <p>Subaccount code of the account you want to split the transaction with</p> <code>None</code> <code>split_code</code> <code>Optional[str]</code> <p>Split code consisting of the lists of accounts you want to split the transaction with</p> <code>None</code> <code>first_name</code> <code>Optional[str]</code> <p>Customer's first name</p> <code>None</code> <code>last_name</code> <code>Optional[str]</code> <p>Customer's last name</p> <code>None</code> <code>phone</code> <code>Optional[str]</code> <p>Customer's phone number</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/dedicated_accounts.py</code> <pre><code>def create(\n    self,\n    customer: str,\n    preferred_bank: Optional[str] = None,\n    subaccount: Optional[str] = None,\n    split_code: Optional[str] = None,\n    first_name: Optional[str] = None,\n    last_name: Optional[str] = None,\n    phone: Optional[str] = None,\n) -&gt; Response:\n    \"\"\"Create a dedicated virtual account for an existing customer\n\n    Note:\n        * This feature is only available to businesses in Nigeria.\n        * Paystack currently supports Wema Bank and Titan Paystack.\n\n    Args:\n        customer: Customer ID or code\n        preferred_bank: The bank slug for a preferred bank. To get a list of available banks, use the\n            Miscellaneous API ``.get_providers`` method.\n        subaccount: Subaccount code of the account you want to split the transaction with\n        split_code: Split code consisting of the lists of accounts you want to split the transaction with\n        first_name: Customer's first name\n        last_name: Customer's last name\n        phone: Customer's phone number\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(\"/dedicated_account\")\n    payload = {\n        \"customer\": customer,\n    }\n    optional_params = [\n        (\"preferred_bank\", preferred_bank),\n        (\"subaccount\", subaccount),\n        (\"split_code\", split_code),\n        (\"first_name\", first_name),\n        (\"last_name\", last_name),\n        (\"phone\", phone),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/dedicated_accounts/#pypaystack2.api.dedicated_accounts.DedicatedAccount.deactivate","title":"<code>deactivate(dedicated_account_id)</code>","text":"<p>Deactivate a dedicated virtual account on your integration.</p> Note <ul> <li>This feature is only available to businesses in Nigeria.</li> <li>Paystack currently supports Access Bank and Wema Bank.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>dedicated_account_id</code> <code>int</code> <p>ID of dedicated virtual account</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/dedicated_accounts.py</code> <pre><code>def deactivate(self, dedicated_account_id: int) -&gt; Response:\n    \"\"\"Deactivate a dedicated virtual account on your integration.\n\n    Note:\n        * This feature is only available to businesses in Nigeria.\n        * Paystack currently supports Access Bank and Wema Bank.\n\n    Args:\n        dedicated_account_id: ID of dedicated virtual account\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/dedicated_account/{dedicated_account_id}\")\n    return self._handle_request(HTTPMethod.DELETE, url)\n</code></pre>"},{"location":"reference/dedicated_accounts/#pypaystack2.api.dedicated_accounts.DedicatedAccount.get_dedicated_account","title":"<code>get_dedicated_account(dedicated_account_id)</code>","text":"<p>Get details of a dedicated virtual account on your integration.</p> Note <ul> <li>This feature is only available to businesses in Nigeria.</li> <li>Paystack currently supports Wema Bank and Titan Paystack.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>dedicated_account_id</code> <code>int</code> <p>ID of dedicated virtual account</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/dedicated_accounts.py</code> <pre><code>def get_dedicated_account(self, dedicated_account_id: int) -&gt; Response:\n    \"\"\"Get details of a dedicated virtual account on your integration.\n\n    Note:\n        * This feature is only available to businesses in Nigeria.\n        * Paystack currently supports Wema Bank and Titan Paystack.\n\n    Args:\n        dedicated_account_id: ID of dedicated virtual account\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/dedicated_account/{dedicated_account_id}\")\n    return self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/dedicated_accounts/#pypaystack2.api.dedicated_accounts.DedicatedAccount.get_dedicated_accounts","title":"<code>get_dedicated_accounts(active=True, currency=Currency.NGN, provider_slug=None, bank_id=None, customer=None)</code>","text":"<p>Fetches dedicated virtual accounts available on your integration.</p> Note <ul> <li>This feature is only available to businesses in Nigeria.</li> <li>Paystack currently supports Wema Bank and Titan Paystack.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>active</code> <code>bool</code> <p>Status of the dedicated virtual account</p> <code>True</code> <code>currency</code> <code>Currency</code> <p>The currency of the dedicated virtual account. Only <code>Currency.NGN</code> is currently allowed</p> <code>NGN</code> <code>provider_slug</code> <code>Optional[str]</code> <p>The bank's slug in lowercase, without spaces e.g. wema-bank. call the <code>.get_providers</code> method of this class to see available providers.</p> <code>None</code> <code>bank_id</code> <code>Optional[str]</code> <p>The bank's ID e.g., 035</p> <code>None</code> <code>customer</code> <code>Optional[str]</code> <p>The customer's ID</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/dedicated_accounts.py</code> <pre><code>def get_dedicated_accounts(\n    self,\n    active: bool = True,\n    currency: Currency = Currency.NGN,\n    provider_slug: Optional[str] = None,\n    bank_id: Optional[str] = None,\n    customer: Optional[str] = None,\n) -&gt; Response:\n    \"\"\"Fetches dedicated virtual accounts available on your integration.\n\n    Note:\n        * This feature is only available to businesses in Nigeria.\n        * Paystack currently supports Wema Bank and Titan Paystack.\n\n    Args:\n        active: Status of the dedicated virtual account\n        currency: The currency of the dedicated virtual account. Only ``Currency.NGN`` is currently allowed\n        provider_slug: The bank's slug in lowercase, without spaces e.g. wema-bank. call the `.get_providers`\n            method of this class to see available providers.\n        bank_id: The bank's ID e.g., 035\n        customer: The customer's ID\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    query_params = [\n        (\"currency\", currency),\n        (\"provider_slug\", provider_slug),\n        (\"bank_id\", bank_id),\n        (\"customer\", customer),\n    ]\n    url = self._parse_url(f\"/dedicated_account?active={active}\")\n    url = append_query_params(query_params, url)\n    return self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/dedicated_accounts/#pypaystack2.api.dedicated_accounts.DedicatedAccount.get_providers","title":"<code>get_providers()</code>","text":"<p>Get available bank providers for a dedicated virtual account</p> Note <ul> <li>This feature is only available to businesses in Nigeria.</li> <li>Paystack currently supports Access Bank and Wema Bank.</li> </ul> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/dedicated_accounts.py</code> <pre><code>def get_providers(self) -&gt; Response:\n    \"\"\"Get available bank providers for a dedicated virtual account\n\n    Note:\n        * This feature is only available to businesses in Nigeria.\n        * Paystack currently supports Access Bank and Wema Bank.\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(\"/dedicated_account/available_providers\")\n    return self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/dedicated_accounts/#pypaystack2.api.dedicated_accounts.DedicatedAccount.remove_split","title":"<code>remove_split(account_number)</code>","text":"<p>Removes a split.</p> <p>If you've previously set up split payment for transactions on a dedicated virtual account, you can remove it with this method.</p> Note <ul> <li>This feature is only available to businesses in Nigeria.</li> <li>Paystack currently supports Access Bank and Wema Bank.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>account_number</code> <code>str</code> <p>Dedicated virtual account number</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/dedicated_accounts.py</code> <pre><code>def remove_split(self, account_number: str) -&gt; Response:\n    \"\"\"Removes a split.\n\n    If you've previously set up split payment for transactions on a dedicated virtual\n    account, you can remove it with this method.\n\n    Note:\n        * This feature is only available to businesses in Nigeria.\n        * Paystack currently supports Access Bank and Wema Bank.\n\n    Args:\n        account_number: Dedicated virtual account number\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(\"/dedicated_account/split\")\n    payload = {\n        \"account_number\": account_number,\n    }\n    return self._handle_request(HTTPMethod.DELETE, url, payload)\n</code></pre>"},{"location":"reference/dedicated_accounts/#pypaystack2.api.dedicated_accounts.DedicatedAccount.requery","title":"<code>requery(account_number, provider_slug, date)</code>","text":"<p>Get details of a dedicated virtual account on your integration.</p> Note <ul> <li>This feature is only available to businesses in Nigeria.</li> <li>Paystack currently supports Wema Bank and Titan Paystack.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>account_number</code> <code>str</code> <p>Virtual account number to requery</p> required <code>provider_slug</code> <code>str</code> <p>The bank's slug in lowercase, without spaces e.g. wema-bank</p> required <code>date</code> <code>Optional[str]</code> <p>The day the transfer was made in YYYY-MM-DD ISO format</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/dedicated_accounts.py</code> <pre><code>def requery(\n    self, account_number: str, provider_slug: str, date: Optional[str]\n) -&gt; Response:\n    \"\"\"Get details of a dedicated virtual account on your integration.\n\n    Note:\n        * This feature is only available to businesses in Nigeria.\n        * Paystack currently supports Wema Bank and Titan Paystack.\n\n    Args:\n        account_number: Virtual account number to requery\n        provider_slug: The bank's slug in lowercase, without spaces e.g. wema-bank\n        date: The day the transfer was made in YYYY-MM-DD ISO format\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/dedicated_account?account_number={account_number}\")\n    query_params = [\n        (\"provider_slug\", provider_slug),\n        (\"date\", date),\n    ]\n    url = append_query_params(query_params, url)\n    return self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/dedicated_accounts/#pypaystack2.api.dedicated_accounts.DedicatedAccount.split","title":"<code>split(customer, subaccount=None, split_code=None, preferred_bank=None)</code>","text":"<p>Split a dedicated virtual account transaction with one or more accounts</p> Note <ul> <li>This feature is only available to businesses in Nigeria.</li> <li>Paystack currently supports Access Bank and Wema Bank.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>customer</code> <code>str</code> <p>Customer ID or code</p> required <code>subaccount</code> <code>Optional[str]</code> <p>Subaccount code of the account you want to split the transaction with</p> <code>None</code> <code>split_code</code> <code>Optional[str]</code> <p>Split code consisting of the lists of accounts you want to split the transaction with</p> <code>None</code> <code>preferred_bank</code> <code>Optional[str]</code> <p>The bank slug for a preferred bank. To get a list of available banks, use the Miscellaneous API <code>.get_providers</code> method</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/dedicated_accounts.py</code> <pre><code>def split(\n    self,\n    customer: str,\n    subaccount: Optional[str] = None,\n    split_code: Optional[str] = None,\n    preferred_bank: Optional[str] = None,\n) -&gt; Response:\n    \"\"\"Split a dedicated virtual account transaction with one or more accounts\n\n    Note:\n        * This feature is only available to businesses in Nigeria.\n        * Paystack currently supports Access Bank and Wema Bank.\n\n    Args:\n        customer: Customer ID or code\n        subaccount: Subaccount code of the account you want to split the transaction with\n        split_code: Split code consisting of the lists of accounts you want to split the transaction with\n        preferred_bank: The bank slug for a preferred bank. To get a list of available banks,\n            use the Miscellaneous API ``.get_providers`` method\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(\"/dedicated_account/split\")\n    payload = {\"customer\": customer}\n\n    optional_params = [\n        (\"subaccount\", subaccount),\n        (\"split_code\", split_code),\n        (\"preferred_bank\", preferred_bank),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/disputes/","title":"Disputes","text":""},{"location":"reference/disputes/#pypaystack2.api.disputes.AsyncDispute","title":"<code>AsyncDispute</code>","text":"<p>               Bases: <code>BaseAsyncAPI</code></p> <p>Provides a wrapper for paystack Disputes API</p> <p>The Disputes API allows you manage transaction disputes on your integration. https://paystack.com/docs/api/dispute/</p> Source code in <code>src/pypaystack2/api/disputes.py</code> <pre><code>class AsyncDispute(BaseAsyncAPI):\n    \"\"\"Provides a wrapper for paystack Disputes API\n\n    The Disputes API allows you manage transaction disputes on your integration.\n    https://paystack.com/docs/api/dispute/\n    \"\"\"\n\n    async def get_disputes(\n        self,\n        start_date: str,\n        end_date: str,\n        pagination: int = 50,\n        page: int = 1,\n        transaction: Optional[str] = None,\n        status: Optional[DisputeStatus] = None,\n    ) -&gt; Response:\n        \"\"\"Fetches disputes filed against you\n\n        Args:\n            start_date: A timestamp from which to start listing dispute e.g. 2016-09-21\n            end_date: A timestamp at which to stop listing dispute e.g. 2016-09-21\n            pagination : Specifies how many records you want to retrieve per page.\n                If not specified we use a default value of 50.\n            page: Specifies exactly what dispute you want to page.\n                If not specified we use a default value of 1.\n            transaction: Transaction ID\n            status: Any of DisputeStatus enum values.\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/dispute?perPage={pagination}\")\n        query_params = [\n            (\"page\", page),\n            (\"from\", start_date),\n            (\"to\", end_date),\n            (\"transaction\", transaction),\n            (\"status\", status),\n        ]\n        url = append_query_params(query_params, url)\n        return await self._handle_request(HTTPMethod.GET, url)\n\n    async def get_dispute(self, id: str) -&gt; Response:\n        \"\"\"Get more details about a dispute.\n\n        Args:\n            id: The dispute ID you want to fetch\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/dispute/{id}\")\n        return await self._handle_request(HTTPMethod.GET, url)\n\n    async def get_transaction_disputes(self, id: str) -&gt; Response:\n        \"\"\"This method retrieves disputes for a particular transaction\n\n        Args:\n            id: The transaction ID you want to fetch\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/dispute/transaction/{id}\")\n        return await self._handle_request(HTTPMethod.GET, url)\n\n    async def update_dispute(\n        self, id: str, refund_amount: int, uploaded_filename: Optional[str]\n    ) -&gt; Response:\n        \"\"\"Update details of a dispute on your integration\n\n        Args:\n            id: Dispute ID\n            refund_amount: the amount to refund, in kobo if currency is NGN, pesewas,\n                if currency is GHS, and cents, if currency is ZAR\n            uploaded_filename: filename of attachment returned via response from upload url(GET /dispute/:id/upload_url)\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        refund_amount = validate_amount(refund_amount)\n        payload = {\"refund_amount\": refund_amount}\n        payload = add_to_payload([(\"uploaded_filename\", uploaded_filename)], payload)\n        url = self._parse_url(f\"/dispute/{id}\")\n        return await self._handle_request(HTTPMethod.PUT, url, payload)\n\n    async def add_evidence(\n        self,\n        id: str,\n        customer_email: str,\n        customer_name: str,\n        customer_phone: str,\n        service_details: str,\n        delivery_address: Optional[str] = None,\n        delivery_date: Optional[str] = None,\n    ) -&gt; Response:\n        \"\"\"Provide evidence for a dispute\n\n        Args:\n            id: Dispute ID\n            customer_email: Customer email\n            customer_name: Customer name\n            customer_phone: Customer phone\n            service_details: Details of service involved\n            delivery_address: Delivery Address\n            delivery_date: ISO 8601 representation of delivery date (YYYY-MM-DD)\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        payload = {\n            \"customer_email\": customer_email,\n            \"customer_name\": customer_name,\n            \"customer_phone\": customer_phone,\n            \"service_details\": service_details,\n        }\n        optional_params = [\n            (\"delivery_address\", delivery_address),\n            (\"delivery_date\", delivery_date),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        url = self._parse_url(f\"dispute/{id}/evidence\")\n        return await self._handle_request(HTTPMethod.POST, url, payload)\n\n    async def get_upload_url(self, id: str, upload_filename: str) -&gt; Response:\n        \"\"\"Get URL to upload a dispute evidence.\n\n        Args:\n            id: Dispute ID\n            upload_filename: The file name, with its extension, that you want to upload. e.g. filename.pdf\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._parse_url(\n            f\"/dispute/{id}/upload_url?upload_filename={upload_filename}\"\n        )\n        return await self._handle_request(HTTPMethod.GET, url)\n\n    async def resolve_dispute(\n        self,\n        id: str,\n        resolution: Resolution,\n        message: str,\n        refund_amount: int,\n        uploaded_filename: str,\n        evidence: Optional[int] = None,\n    ) -&gt; Response:\n        \"\"\"Resolve a dispute on your integration\n\n        Args:\n            id: Dispute ID\n            resolution: Any of the Resolution enum value.\n            message: Reason for resolving\n            refund_amount: the amount to refund, in kobo if currency is NGN,\n                pesewas, if currency is GHS, and cents, if currency is ZAR\n            uploaded_filename: filename of attachment returned via response from\n                upload url(GET /dispute/:id/upload_url)\n            evidence: Evidence ID for fraud claims\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        refund_amount = validate_amount(refund_amount)\n        payload = {\n            \"resolution\": resolution,\n            \"message\": message,\n            \"refund_amount\": refund_amount,\n            \"uploaded_filename\": uploaded_filename,\n        }\n        payload = add_to_payload([(\"evidence\", evidence)], payload)\n        url = self._parse_url(f\"/dispute/{id}/resolve\")\n        return await self._handle_request(HTTPMethod.PUT, url, payload)\n\n    async def export_disputes(\n        self,\n        start_date: str,\n        end_date: str,\n        pagination: int = 50,\n        page: int = 1,\n        transaction: Optional[str] = None,\n        status: Optional[DisputeStatus] = None,\n    ) -&gt; Response:\n        \"\"\"Export disputes available on your integration.\n\n        Args:\n            start_date: A timestamp from which to start listing dispute e.g. 2016-09-21\n            end_date: A timestamp at which to stop listing dispute e.g. 2016-09-21\n            pagination: Specifies how many records you want to retrieve per page.\n                If not specified we use a default value of 50.\n            page: Specifies exactly what dispute you want to page. If not specified we use a default value of 1.\n            transaction: Transaction ID\n            status: Any value from the DisputeStatus enum\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/dispute/export?perPage={pagination}\")\n        query_params = [\n            (\"page\", page),\n            (\"from\", start_date),\n            (\"to\", end_date),\n            (\"transaction\", transaction),\n            (\"status\", status),\n        ]\n        url = append_query_params(query_params, url)\n        return await self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/disputes/#pypaystack2.api.disputes.AsyncDispute.add_evidence","title":"<code>add_evidence(id, customer_email, customer_name, customer_phone, service_details, delivery_address=None, delivery_date=None)</code>  <code>async</code>","text":"<p>Provide evidence for a dispute</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>Dispute ID</p> required <code>customer_email</code> <code>str</code> <p>Customer email</p> required <code>customer_name</code> <code>str</code> <p>Customer name</p> required <code>customer_phone</code> <code>str</code> <p>Customer phone</p> required <code>service_details</code> <code>str</code> <p>Details of service involved</p> required <code>delivery_address</code> <code>Optional[str]</code> <p>Delivery Address</p> <code>None</code> <code>delivery_date</code> <code>Optional[str]</code> <p>ISO 8601 representation of delivery date (YYYY-MM-DD)</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/disputes.py</code> <pre><code>async def add_evidence(\n    self,\n    id: str,\n    customer_email: str,\n    customer_name: str,\n    customer_phone: str,\n    service_details: str,\n    delivery_address: Optional[str] = None,\n    delivery_date: Optional[str] = None,\n) -&gt; Response:\n    \"\"\"Provide evidence for a dispute\n\n    Args:\n        id: Dispute ID\n        customer_email: Customer email\n        customer_name: Customer name\n        customer_phone: Customer phone\n        service_details: Details of service involved\n        delivery_address: Delivery Address\n        delivery_date: ISO 8601 representation of delivery date (YYYY-MM-DD)\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    payload = {\n        \"customer_email\": customer_email,\n        \"customer_name\": customer_name,\n        \"customer_phone\": customer_phone,\n        \"service_details\": service_details,\n    }\n    optional_params = [\n        (\"delivery_address\", delivery_address),\n        (\"delivery_date\", delivery_date),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    url = self._parse_url(f\"dispute/{id}/evidence\")\n    return await self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/disputes/#pypaystack2.api.disputes.AsyncDispute.export_disputes","title":"<code>export_disputes(start_date, end_date, pagination=50, page=1, transaction=None, status=None)</code>  <code>async</code>","text":"<p>Export disputes available on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>start_date</code> <code>str</code> <p>A timestamp from which to start listing dispute e.g. 2016-09-21</p> required <code>end_date</code> <code>str</code> <p>A timestamp at which to stop listing dispute e.g. 2016-09-21</p> required <code>pagination</code> <code>int</code> <p>Specifies how many records you want to retrieve per page. If not specified we use a default value of 50.</p> <code>50</code> <code>page</code> <code>int</code> <p>Specifies exactly what dispute you want to page. If not specified we use a default value of 1.</p> <code>1</code> <code>transaction</code> <code>Optional[str]</code> <p>Transaction ID</p> <code>None</code> <code>status</code> <code>Optional[DisputeStatus]</code> <p>Any value from the DisputeStatus enum</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/disputes.py</code> <pre><code>async def export_disputes(\n    self,\n    start_date: str,\n    end_date: str,\n    pagination: int = 50,\n    page: int = 1,\n    transaction: Optional[str] = None,\n    status: Optional[DisputeStatus] = None,\n) -&gt; Response:\n    \"\"\"Export disputes available on your integration.\n\n    Args:\n        start_date: A timestamp from which to start listing dispute e.g. 2016-09-21\n        end_date: A timestamp at which to stop listing dispute e.g. 2016-09-21\n        pagination: Specifies how many records you want to retrieve per page.\n            If not specified we use a default value of 50.\n        page: Specifies exactly what dispute you want to page. If not specified we use a default value of 1.\n        transaction: Transaction ID\n        status: Any value from the DisputeStatus enum\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/dispute/export?perPage={pagination}\")\n    query_params = [\n        (\"page\", page),\n        (\"from\", start_date),\n        (\"to\", end_date),\n        (\"transaction\", transaction),\n        (\"status\", status),\n    ]\n    url = append_query_params(query_params, url)\n    return await self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/disputes/#pypaystack2.api.disputes.AsyncDispute.get_dispute","title":"<code>get_dispute(id)</code>  <code>async</code>","text":"<p>Get more details about a dispute.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The dispute ID you want to fetch</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/disputes.py</code> <pre><code>async def get_dispute(self, id: str) -&gt; Response:\n    \"\"\"Get more details about a dispute.\n\n    Args:\n        id: The dispute ID you want to fetch\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/dispute/{id}\")\n    return await self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/disputes/#pypaystack2.api.disputes.AsyncDispute.get_disputes","title":"<code>get_disputes(start_date, end_date, pagination=50, page=1, transaction=None, status=None)</code>  <code>async</code>","text":"<p>Fetches disputes filed against you</p> <p>Parameters:</p> Name Type Description Default <code>start_date</code> <code>str</code> <p>A timestamp from which to start listing dispute e.g. 2016-09-21</p> required <code>end_date</code> <code>str</code> <p>A timestamp at which to stop listing dispute e.g. 2016-09-21</p> required <code>pagination</code> <p>Specifies how many records you want to retrieve per page. If not specified we use a default value of 50.</p> <code>50</code> <code>page</code> <code>int</code> <p>Specifies exactly what dispute you want to page. If not specified we use a default value of 1.</p> <code>1</code> <code>transaction</code> <code>Optional[str]</code> <p>Transaction ID</p> <code>None</code> <code>status</code> <code>Optional[DisputeStatus]</code> <p>Any of DisputeStatus enum values.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/disputes.py</code> <pre><code>async def get_disputes(\n    self,\n    start_date: str,\n    end_date: str,\n    pagination: int = 50,\n    page: int = 1,\n    transaction: Optional[str] = None,\n    status: Optional[DisputeStatus] = None,\n) -&gt; Response:\n    \"\"\"Fetches disputes filed against you\n\n    Args:\n        start_date: A timestamp from which to start listing dispute e.g. 2016-09-21\n        end_date: A timestamp at which to stop listing dispute e.g. 2016-09-21\n        pagination : Specifies how many records you want to retrieve per page.\n            If not specified we use a default value of 50.\n        page: Specifies exactly what dispute you want to page.\n            If not specified we use a default value of 1.\n        transaction: Transaction ID\n        status: Any of DisputeStatus enum values.\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/dispute?perPage={pagination}\")\n    query_params = [\n        (\"page\", page),\n        (\"from\", start_date),\n        (\"to\", end_date),\n        (\"transaction\", transaction),\n        (\"status\", status),\n    ]\n    url = append_query_params(query_params, url)\n    return await self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/disputes/#pypaystack2.api.disputes.AsyncDispute.get_transaction_disputes","title":"<code>get_transaction_disputes(id)</code>  <code>async</code>","text":"<p>This method retrieves disputes for a particular transaction</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The transaction ID you want to fetch</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/disputes.py</code> <pre><code>async def get_transaction_disputes(self, id: str) -&gt; Response:\n    \"\"\"This method retrieves disputes for a particular transaction\n\n    Args:\n        id: The transaction ID you want to fetch\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/dispute/transaction/{id}\")\n    return await self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/disputes/#pypaystack2.api.disputes.AsyncDispute.get_upload_url","title":"<code>get_upload_url(id, upload_filename)</code>  <code>async</code>","text":"<p>Get URL to upload a dispute evidence.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>Dispute ID</p> required <code>upload_filename</code> <code>str</code> <p>The file name, with its extension, that you want to upload. e.g. filename.pdf</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/disputes.py</code> <pre><code>async def get_upload_url(self, id: str, upload_filename: str) -&gt; Response:\n    \"\"\"Get URL to upload a dispute evidence.\n\n    Args:\n        id: Dispute ID\n        upload_filename: The file name, with its extension, that you want to upload. e.g. filename.pdf\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._parse_url(\n        f\"/dispute/{id}/upload_url?upload_filename={upload_filename}\"\n    )\n    return await self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/disputes/#pypaystack2.api.disputes.AsyncDispute.resolve_dispute","title":"<code>resolve_dispute(id, resolution, message, refund_amount, uploaded_filename, evidence=None)</code>  <code>async</code>","text":"<p>Resolve a dispute on your integration</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>Dispute ID</p> required <code>resolution</code> <code>Resolution</code> <p>Any of the Resolution enum value.</p> required <code>message</code> <code>str</code> <p>Reason for resolving</p> required <code>refund_amount</code> <code>int</code> <p>the amount to refund, in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR</p> required <code>uploaded_filename</code> <code>str</code> <p>filename of attachment returned via response from upload url(GET /dispute/:id/upload_url)</p> required <code>evidence</code> <code>Optional[int]</code> <p>Evidence ID for fraud claims</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/disputes.py</code> <pre><code>async def resolve_dispute(\n    self,\n    id: str,\n    resolution: Resolution,\n    message: str,\n    refund_amount: int,\n    uploaded_filename: str,\n    evidence: Optional[int] = None,\n) -&gt; Response:\n    \"\"\"Resolve a dispute on your integration\n\n    Args:\n        id: Dispute ID\n        resolution: Any of the Resolution enum value.\n        message: Reason for resolving\n        refund_amount: the amount to refund, in kobo if currency is NGN,\n            pesewas, if currency is GHS, and cents, if currency is ZAR\n        uploaded_filename: filename of attachment returned via response from\n            upload url(GET /dispute/:id/upload_url)\n        evidence: Evidence ID for fraud claims\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    refund_amount = validate_amount(refund_amount)\n    payload = {\n        \"resolution\": resolution,\n        \"message\": message,\n        \"refund_amount\": refund_amount,\n        \"uploaded_filename\": uploaded_filename,\n    }\n    payload = add_to_payload([(\"evidence\", evidence)], payload)\n    url = self._parse_url(f\"/dispute/{id}/resolve\")\n    return await self._handle_request(HTTPMethod.PUT, url, payload)\n</code></pre>"},{"location":"reference/disputes/#pypaystack2.api.disputes.AsyncDispute.update_dispute","title":"<code>update_dispute(id, refund_amount, uploaded_filename)</code>  <code>async</code>","text":"<p>Update details of a dispute on your integration</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>Dispute ID</p> required <code>refund_amount</code> <code>int</code> <p>the amount to refund, in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR</p> required <code>uploaded_filename</code> <code>Optional[str]</code> <p>filename of attachment returned via response from upload url(GET /dispute/:id/upload_url)</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/disputes.py</code> <pre><code>async def update_dispute(\n    self, id: str, refund_amount: int, uploaded_filename: Optional[str]\n) -&gt; Response:\n    \"\"\"Update details of a dispute on your integration\n\n    Args:\n        id: Dispute ID\n        refund_amount: the amount to refund, in kobo if currency is NGN, pesewas,\n            if currency is GHS, and cents, if currency is ZAR\n        uploaded_filename: filename of attachment returned via response from upload url(GET /dispute/:id/upload_url)\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    refund_amount = validate_amount(refund_amount)\n    payload = {\"refund_amount\": refund_amount}\n    payload = add_to_payload([(\"uploaded_filename\", uploaded_filename)], payload)\n    url = self._parse_url(f\"/dispute/{id}\")\n    return await self._handle_request(HTTPMethod.PUT, url, payload)\n</code></pre>"},{"location":"reference/disputes/#pypaystack2.api.disputes.Dispute","title":"<code>Dispute</code>","text":"<p>               Bases: <code>BaseAPI</code></p> <p>Provides a wrapper for paystack Disputes API</p> <p>The Disputes API allows you to manage transaction disputes on your integration. https://paystack.com/docs/api/dispute/</p> Source code in <code>src/pypaystack2/api/disputes.py</code> <pre><code>class Dispute(BaseAPI):\n    \"\"\"Provides a wrapper for paystack Disputes API\n\n    The Disputes API allows you to manage transaction disputes on your integration.\n    https://paystack.com/docs/api/dispute/\n    \"\"\"\n\n    def get_disputes(\n        self,\n        start_date: str,\n        end_date: str,\n        pagination: int = 50,\n        page: int = 1,\n        transaction: Optional[str] = None,\n        status: Optional[DisputeStatus] = None,\n    ) -&gt; Response:\n        \"\"\"Fetches disputes filed against you\n\n        Args:\n            start_date: A timestamp from which to start listing dispute e.g. 2016-09-21\n            end_date: A timestamp at which to stop listing dispute e.g. 2016-09-21\n            pagination : Specifies how many records you want to retrieve per page.\n                If not specified we use a default value of 50.\n            page: Specifies exactly what dispute you want to page.\n                If not specified we use a default value of 1.\n            transaction: Transaction ID\n            status: Any of DisputeStatus enum values.\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/dispute?perPage={pagination}\")\n        query_params = [\n            (\"page\", page),\n            (\"from\", start_date),\n            (\"to\", end_date),\n            (\"transaction\", transaction),\n            (\"status\", status),\n        ]\n        url = append_query_params(query_params, url)\n        return self._handle_request(HTTPMethod.GET, url)\n\n    def get_dispute(self, id: str) -&gt; Response:\n        \"\"\"Get more details about a dispute.\n\n        Args:\n            id: The dispute ID you want to fetch\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/dispute/{id}\")\n        return self._handle_request(HTTPMethod.GET, url)\n\n    def get_transaction_disputes(self, id: str) -&gt; Response:\n        \"\"\"This method retrieves disputes for a particular transaction\n\n        Args:\n            id: The transaction ID you want to fetch\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/dispute/transaction/{id}\")\n        return self._handle_request(HTTPMethod.GET, url)\n\n    def update_dispute(\n        self, id: str, refund_amount: int, uploaded_filename: Optional[str]\n    ) -&gt; Response:\n        \"\"\"Update details of a dispute on your integration\n\n        Args:\n            id: Dispute ID\n            refund_amount: the amount to refund, in kobo if currency is NGN, pesewas,\n                if currency is GHS, and cents, if currency is ZAR\n            uploaded_filename: filename of attachment returned via response from upload url(GET /dispute/:id/upload_url)\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        refund_amount = validate_amount(refund_amount)\n        payload = {\"refund_amount\": refund_amount}\n        payload = add_to_payload([(\"uploaded_filename\", uploaded_filename)], payload)\n        url = self._parse_url(f\"/dispute/{id}\")\n        return self._handle_request(HTTPMethod.PUT, url, payload)\n\n    def add_evidence(\n        self,\n        id: str,\n        customer_email: str,\n        customer_name: str,\n        customer_phone: str,\n        service_details: str,\n        delivery_address: Optional[str] = None,\n        delivery_date: Optional[str] = None,\n    ) -&gt; Response:\n        \"\"\"Provide evidence for a dispute\n\n        Args:\n            id: Dispute ID\n            customer_email: Customer email\n            customer_name: Customer name\n            customer_phone: Customer phone\n            service_details: Details of service involved\n            delivery_address: Delivery Address\n            delivery_date: ISO 8601 representation of delivery date (YYYY-MM-DD)\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        payload = {\n            \"customer_email\": customer_email,\n            \"customer_name\": customer_name,\n            \"customer_phone\": customer_phone,\n            \"service_details\": service_details,\n        }\n        optional_params = [\n            (\"delivery_address\", delivery_address),\n            (\"delivery_date\", delivery_date),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        url = self._parse_url(f\"dispute/{id}/evidence\")\n        return self._handle_request(HTTPMethod.POST, url, payload)\n\n    def get_upload_url(self, id: str, upload_filename: str) -&gt; Response:\n        \"\"\"Get URL to upload a dispute evidence.\n\n        Args:\n            id: Dispute ID\n            upload_filename: The file name, with its extension, that you want to upload. e.g. filename.pdf\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._parse_url(\n            f\"/dispute/{id}/upload_url?upload_filename={upload_filename}\"\n        )\n        return self._handle_request(HTTPMethod.GET, url)\n\n    def resolve_dispute(\n        self,\n        id: str,\n        resolution: Resolution,\n        message: str,\n        refund_amount: int,\n        uploaded_filename: str,\n        evidence: Optional[int] = None,\n    ) -&gt; Response:\n        \"\"\"Resolve a dispute on your integration\n\n        Args:\n            id: Dispute ID\n            resolution: Any of the Resolution enum value.\n            message: Reason for resolving\n            refund_amount: the amount to refund, in kobo if currency is NGN,\n                pesewas, if currency is GHS, and cents, if currency is ZAR\n            uploaded_filename: filename of attachment returned via response from\n                upload url(GET /dispute/:id/upload_url)\n            evidence: Evidence ID for fraud claims\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        refund_amount = validate_amount(refund_amount)\n        payload = {\n            \"resolution\": resolution,\n            \"message\": message,\n            \"refund_amount\": refund_amount,\n            \"uploaded_filename\": uploaded_filename,\n        }\n        payload = add_to_payload([(\"evidence\", evidence)], payload)\n        url = self._parse_url(f\"/dispute/{id}/resolve\")\n        return self._handle_request(HTTPMethod.PUT, url, payload)\n\n    def export_disputes(\n        self,\n        start_date: str,\n        end_date: str,\n        pagination: int = 50,\n        page: int = 1,\n        transaction: Optional[str] = None,\n        status: Optional[DisputeStatus] = None,\n    ) -&gt; Response:\n        \"\"\"Export disputes available on your integration.\n\n        Args:\n            start_date: A timestamp from which to start listing dispute e.g. 2016-09-21\n            end_date: A timestamp at which to stop listing dispute e.g. 2016-09-21\n            pagination: Specifies how many records you want to retrieve per page.\n                If not specified we use a default value of 50.\n            page: Specifies exactly what dispute you want to page. If not specified we use a default value of 1.\n            transaction: Transaction ID\n            status: Any value from the DisputeStatus enum\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/dispute/export?perPage={pagination}\")\n        query_params = [\n            (\"page\", page),\n            (\"from\", start_date),\n            (\"to\", end_date),\n            (\"transaction\", transaction),\n            (\"status\", status),\n        ]\n        url = append_query_params(query_params, url)\n        return self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/disputes/#pypaystack2.api.disputes.Dispute.add_evidence","title":"<code>add_evidence(id, customer_email, customer_name, customer_phone, service_details, delivery_address=None, delivery_date=None)</code>","text":"<p>Provide evidence for a dispute</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>Dispute ID</p> required <code>customer_email</code> <code>str</code> <p>Customer email</p> required <code>customer_name</code> <code>str</code> <p>Customer name</p> required <code>customer_phone</code> <code>str</code> <p>Customer phone</p> required <code>service_details</code> <code>str</code> <p>Details of service involved</p> required <code>delivery_address</code> <code>Optional[str]</code> <p>Delivery Address</p> <code>None</code> <code>delivery_date</code> <code>Optional[str]</code> <p>ISO 8601 representation of delivery date (YYYY-MM-DD)</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/disputes.py</code> <pre><code>def add_evidence(\n    self,\n    id: str,\n    customer_email: str,\n    customer_name: str,\n    customer_phone: str,\n    service_details: str,\n    delivery_address: Optional[str] = None,\n    delivery_date: Optional[str] = None,\n) -&gt; Response:\n    \"\"\"Provide evidence for a dispute\n\n    Args:\n        id: Dispute ID\n        customer_email: Customer email\n        customer_name: Customer name\n        customer_phone: Customer phone\n        service_details: Details of service involved\n        delivery_address: Delivery Address\n        delivery_date: ISO 8601 representation of delivery date (YYYY-MM-DD)\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    payload = {\n        \"customer_email\": customer_email,\n        \"customer_name\": customer_name,\n        \"customer_phone\": customer_phone,\n        \"service_details\": service_details,\n    }\n    optional_params = [\n        (\"delivery_address\", delivery_address),\n        (\"delivery_date\", delivery_date),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    url = self._parse_url(f\"dispute/{id}/evidence\")\n    return self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/disputes/#pypaystack2.api.disputes.Dispute.export_disputes","title":"<code>export_disputes(start_date, end_date, pagination=50, page=1, transaction=None, status=None)</code>","text":"<p>Export disputes available on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>start_date</code> <code>str</code> <p>A timestamp from which to start listing dispute e.g. 2016-09-21</p> required <code>end_date</code> <code>str</code> <p>A timestamp at which to stop listing dispute e.g. 2016-09-21</p> required <code>pagination</code> <code>int</code> <p>Specifies how many records you want to retrieve per page. If not specified we use a default value of 50.</p> <code>50</code> <code>page</code> <code>int</code> <p>Specifies exactly what dispute you want to page. If not specified we use a default value of 1.</p> <code>1</code> <code>transaction</code> <code>Optional[str]</code> <p>Transaction ID</p> <code>None</code> <code>status</code> <code>Optional[DisputeStatus]</code> <p>Any value from the DisputeStatus enum</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/disputes.py</code> <pre><code>def export_disputes(\n    self,\n    start_date: str,\n    end_date: str,\n    pagination: int = 50,\n    page: int = 1,\n    transaction: Optional[str] = None,\n    status: Optional[DisputeStatus] = None,\n) -&gt; Response:\n    \"\"\"Export disputes available on your integration.\n\n    Args:\n        start_date: A timestamp from which to start listing dispute e.g. 2016-09-21\n        end_date: A timestamp at which to stop listing dispute e.g. 2016-09-21\n        pagination: Specifies how many records you want to retrieve per page.\n            If not specified we use a default value of 50.\n        page: Specifies exactly what dispute you want to page. If not specified we use a default value of 1.\n        transaction: Transaction ID\n        status: Any value from the DisputeStatus enum\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/dispute/export?perPage={pagination}\")\n    query_params = [\n        (\"page\", page),\n        (\"from\", start_date),\n        (\"to\", end_date),\n        (\"transaction\", transaction),\n        (\"status\", status),\n    ]\n    url = append_query_params(query_params, url)\n    return self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/disputes/#pypaystack2.api.disputes.Dispute.get_dispute","title":"<code>get_dispute(id)</code>","text":"<p>Get more details about a dispute.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The dispute ID you want to fetch</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/disputes.py</code> <pre><code>def get_dispute(self, id: str) -&gt; Response:\n    \"\"\"Get more details about a dispute.\n\n    Args:\n        id: The dispute ID you want to fetch\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/dispute/{id}\")\n    return self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/disputes/#pypaystack2.api.disputes.Dispute.get_disputes","title":"<code>get_disputes(start_date, end_date, pagination=50, page=1, transaction=None, status=None)</code>","text":"<p>Fetches disputes filed against you</p> <p>Parameters:</p> Name Type Description Default <code>start_date</code> <code>str</code> <p>A timestamp from which to start listing dispute e.g. 2016-09-21</p> required <code>end_date</code> <code>str</code> <p>A timestamp at which to stop listing dispute e.g. 2016-09-21</p> required <code>pagination</code> <p>Specifies how many records you want to retrieve per page. If not specified we use a default value of 50.</p> <code>50</code> <code>page</code> <code>int</code> <p>Specifies exactly what dispute you want to page. If not specified we use a default value of 1.</p> <code>1</code> <code>transaction</code> <code>Optional[str]</code> <p>Transaction ID</p> <code>None</code> <code>status</code> <code>Optional[DisputeStatus]</code> <p>Any of DisputeStatus enum values.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/disputes.py</code> <pre><code>def get_disputes(\n    self,\n    start_date: str,\n    end_date: str,\n    pagination: int = 50,\n    page: int = 1,\n    transaction: Optional[str] = None,\n    status: Optional[DisputeStatus] = None,\n) -&gt; Response:\n    \"\"\"Fetches disputes filed against you\n\n    Args:\n        start_date: A timestamp from which to start listing dispute e.g. 2016-09-21\n        end_date: A timestamp at which to stop listing dispute e.g. 2016-09-21\n        pagination : Specifies how many records you want to retrieve per page.\n            If not specified we use a default value of 50.\n        page: Specifies exactly what dispute you want to page.\n            If not specified we use a default value of 1.\n        transaction: Transaction ID\n        status: Any of DisputeStatus enum values.\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/dispute?perPage={pagination}\")\n    query_params = [\n        (\"page\", page),\n        (\"from\", start_date),\n        (\"to\", end_date),\n        (\"transaction\", transaction),\n        (\"status\", status),\n    ]\n    url = append_query_params(query_params, url)\n    return self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/disputes/#pypaystack2.api.disputes.Dispute.get_transaction_disputes","title":"<code>get_transaction_disputes(id)</code>","text":"<p>This method retrieves disputes for a particular transaction</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The transaction ID you want to fetch</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/disputes.py</code> <pre><code>def get_transaction_disputes(self, id: str) -&gt; Response:\n    \"\"\"This method retrieves disputes for a particular transaction\n\n    Args:\n        id: The transaction ID you want to fetch\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/dispute/transaction/{id}\")\n    return self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/disputes/#pypaystack2.api.disputes.Dispute.get_upload_url","title":"<code>get_upload_url(id, upload_filename)</code>","text":"<p>Get URL to upload a dispute evidence.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>Dispute ID</p> required <code>upload_filename</code> <code>str</code> <p>The file name, with its extension, that you want to upload. e.g. filename.pdf</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/disputes.py</code> <pre><code>def get_upload_url(self, id: str, upload_filename: str) -&gt; Response:\n    \"\"\"Get URL to upload a dispute evidence.\n\n    Args:\n        id: Dispute ID\n        upload_filename: The file name, with its extension, that you want to upload. e.g. filename.pdf\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._parse_url(\n        f\"/dispute/{id}/upload_url?upload_filename={upload_filename}\"\n    )\n    return self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/disputes/#pypaystack2.api.disputes.Dispute.resolve_dispute","title":"<code>resolve_dispute(id, resolution, message, refund_amount, uploaded_filename, evidence=None)</code>","text":"<p>Resolve a dispute on your integration</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>Dispute ID</p> required <code>resolution</code> <code>Resolution</code> <p>Any of the Resolution enum value.</p> required <code>message</code> <code>str</code> <p>Reason for resolving</p> required <code>refund_amount</code> <code>int</code> <p>the amount to refund, in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR</p> required <code>uploaded_filename</code> <code>str</code> <p>filename of attachment returned via response from upload url(GET /dispute/:id/upload_url)</p> required <code>evidence</code> <code>Optional[int]</code> <p>Evidence ID for fraud claims</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/disputes.py</code> <pre><code>def resolve_dispute(\n    self,\n    id: str,\n    resolution: Resolution,\n    message: str,\n    refund_amount: int,\n    uploaded_filename: str,\n    evidence: Optional[int] = None,\n) -&gt; Response:\n    \"\"\"Resolve a dispute on your integration\n\n    Args:\n        id: Dispute ID\n        resolution: Any of the Resolution enum value.\n        message: Reason for resolving\n        refund_amount: the amount to refund, in kobo if currency is NGN,\n            pesewas, if currency is GHS, and cents, if currency is ZAR\n        uploaded_filename: filename of attachment returned via response from\n            upload url(GET /dispute/:id/upload_url)\n        evidence: Evidence ID for fraud claims\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    refund_amount = validate_amount(refund_amount)\n    payload = {\n        \"resolution\": resolution,\n        \"message\": message,\n        \"refund_amount\": refund_amount,\n        \"uploaded_filename\": uploaded_filename,\n    }\n    payload = add_to_payload([(\"evidence\", evidence)], payload)\n    url = self._parse_url(f\"/dispute/{id}/resolve\")\n    return self._handle_request(HTTPMethod.PUT, url, payload)\n</code></pre>"},{"location":"reference/disputes/#pypaystack2.api.disputes.Dispute.update_dispute","title":"<code>update_dispute(id, refund_amount, uploaded_filename)</code>","text":"<p>Update details of a dispute on your integration</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>Dispute ID</p> required <code>refund_amount</code> <code>int</code> <p>the amount to refund, in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR</p> required <code>uploaded_filename</code> <code>Optional[str]</code> <p>filename of attachment returned via response from upload url(GET /dispute/:id/upload_url)</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/disputes.py</code> <pre><code>def update_dispute(\n    self, id: str, refund_amount: int, uploaded_filename: Optional[str]\n) -&gt; Response:\n    \"\"\"Update details of a dispute on your integration\n\n    Args:\n        id: Dispute ID\n        refund_amount: the amount to refund, in kobo if currency is NGN, pesewas,\n            if currency is GHS, and cents, if currency is ZAR\n        uploaded_filename: filename of attachment returned via response from upload url(GET /dispute/:id/upload_url)\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    refund_amount = validate_amount(refund_amount)\n    payload = {\"refund_amount\": refund_amount}\n    payload = add_to_payload([(\"uploaded_filename\", uploaded_filename)], payload)\n    url = self._parse_url(f\"/dispute/{id}\")\n    return self._handle_request(HTTPMethod.PUT, url, payload)\n</code></pre>"},{"location":"reference/integration/","title":"Integration","text":""},{"location":"reference/integration/#pypaystack2.api.integration.AsyncIntegration","title":"<code>AsyncIntegration</code>","text":"<p>               Bases: <code>BaseAsyncAPI</code></p> <p>Provides a wrapper for paystack Integration API</p> <p>The Integration API allows you to manage some settings on your integration. https://paystack.com/docs/api/integration/</p> Source code in <code>src/pypaystack2/api/integration.py</code> <pre><code>class AsyncIntegration(BaseAsyncAPI):\n    \"\"\"Provides a wrapper for paystack Integration API\n\n    The Integration API allows you to manage some settings on your integration.\n    https://paystack.com/docs/api/integration/\n    \"\"\"\n\n    async def get_payment_session_timeout(self) -&gt; Response:\n        \"\"\"Fetch the payment session timeout on your integration\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(\"/integration/payment_session_timeout\")\n        return await self._handle_request(HTTPMethod.GET, url)\n\n    async def update_payment_session_timeout(self, timeout: int) -&gt; Response:\n        \"\"\"Update the payment session timeout on your integration\n\n        Args:\n            timeout: Time before stopping session (in seconds). Set to 0 to cancel session timeouts\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        payload = {\"timeout\": timeout}\n        url = self._parse_url(\"/integration/payment_session_timeout\")\n        return await self._handle_request(HTTPMethod.PUT, url, payload)\n</code></pre>"},{"location":"reference/integration/#pypaystack2.api.integration.AsyncIntegration.get_payment_session_timeout","title":"<code>get_payment_session_timeout()</code>  <code>async</code>","text":"<p>Fetch the payment session timeout on your integration</p> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/integration.py</code> <pre><code>async def get_payment_session_timeout(self) -&gt; Response:\n    \"\"\"Fetch the payment session timeout on your integration\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(\"/integration/payment_session_timeout\")\n    return await self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/integration/#pypaystack2.api.integration.AsyncIntegration.update_payment_session_timeout","title":"<code>update_payment_session_timeout(timeout)</code>  <code>async</code>","text":"<p>Update the payment session timeout on your integration</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>int</code> <p>Time before stopping session (in seconds). Set to 0 to cancel session timeouts</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/integration.py</code> <pre><code>async def update_payment_session_timeout(self, timeout: int) -&gt; Response:\n    \"\"\"Update the payment session timeout on your integration\n\n    Args:\n        timeout: Time before stopping session (in seconds). Set to 0 to cancel session timeouts\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    payload = {\"timeout\": timeout}\n    url = self._parse_url(\"/integration/payment_session_timeout\")\n    return await self._handle_request(HTTPMethod.PUT, url, payload)\n</code></pre>"},{"location":"reference/integration/#pypaystack2.api.integration.Integration","title":"<code>Integration</code>","text":"<p>               Bases: <code>BaseAPI</code></p> <p>Provides a wrapper for paystack Integration API</p> <p>The Integration API allows you to manage some settings on your integration. https://paystack.com/docs/api/integration/</p> Source code in <code>src/pypaystack2/api/integration.py</code> <pre><code>class Integration(BaseAPI):\n    \"\"\"Provides a wrapper for paystack Integration API\n\n    The Integration API allows you to manage some settings on your integration.\n    https://paystack.com/docs/api/integration/\n    \"\"\"\n\n    def get_payment_session_timeout(self) -&gt; Response:\n        \"\"\"Fetch the payment session timeout on your integration\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(\"/integration/payment_session_timeout\")\n        return self._handle_request(HTTPMethod.GET, url)\n\n    def update_payment_session_timeout(self, timeout: int) -&gt; Response:\n        \"\"\"Update the payment session timeout on your integration\n\n        Args:\n            timeout: Time before stopping session (in seconds). Set to 0 to cancel session timeouts\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        payload = {\"timeout\": timeout}\n        url = self._parse_url(\"/integration/payment_session_timeout\")\n        return self._handle_request(HTTPMethod.PUT, url, payload)\n</code></pre>"},{"location":"reference/integration/#pypaystack2.api.integration.Integration.get_payment_session_timeout","title":"<code>get_payment_session_timeout()</code>","text":"<p>Fetch the payment session timeout on your integration</p> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/integration.py</code> <pre><code>def get_payment_session_timeout(self) -&gt; Response:\n    \"\"\"Fetch the payment session timeout on your integration\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(\"/integration/payment_session_timeout\")\n    return self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/integration/#pypaystack2.api.integration.Integration.update_payment_session_timeout","title":"<code>update_payment_session_timeout(timeout)</code>","text":"<p>Update the payment session timeout on your integration</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>int</code> <p>Time before stopping session (in seconds). Set to 0 to cancel session timeouts</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/integration.py</code> <pre><code>def update_payment_session_timeout(self, timeout: int) -&gt; Response:\n    \"\"\"Update the payment session timeout on your integration\n\n    Args:\n        timeout: Time before stopping session (in seconds). Set to 0 to cancel session timeouts\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    payload = {\"timeout\": timeout}\n    url = self._parse_url(\"/integration/payment_session_timeout\")\n    return self._handle_request(HTTPMethod.PUT, url, payload)\n</code></pre>"},{"location":"reference/miscellaneous/","title":"Miscellaneous","text":""},{"location":"reference/miscellaneous/#pypaystack2.api.miscellaneous.AsyncMiscellaneous","title":"<code>AsyncMiscellaneous</code>","text":"<p>               Bases: <code>BaseAsyncAPI</code></p> <p>Provides a wrapper for paystack Miscellaneous API</p> <p>The Miscellaneous API are supporting APIs that can be used to provide more details to other APIs. https://paystack.com/docs/api/miscellaneous/</p> Source code in <code>src/pypaystack2/api/miscellaneous.py</code> <pre><code>class AsyncMiscellaneous(BaseAsyncAPI):\n    \"\"\"Provides a wrapper for paystack Miscellaneous API\n\n    The Miscellaneous API are supporting APIs that can be used to provide more details to other APIs.\n    https://paystack.com/docs/api/miscellaneous/\n    \"\"\"\n\n    async def get_banks(\n        self,\n        country: Country,\n        use_cursor: bool = False,\n        next: Optional[str] = None,\n        previous: Optional[str] = None,\n        gateway: Optional[Gateway] = None,\n        type: Optional[BankType] = None,\n        currency: Optional[Currency] = None,\n        pay_with_bank_transfer: Optional[bool] = None,\n        pay_with_bank: Optional[bool] = None,\n        pagination: int = 50,\n    ) -&gt; Response:\n        \"\"\"Get a list of all supported banks and their properties\n\n        Args:\n            country: The country from which to obtain the list of supported banks. any value from the ``Country`` enum.\n            use_cursor: Flag to enable cursor pagination.\n            next: A cursor that indicates your place in the list. It can be used to fetch the next page of the list\n            previous: A cursor that indicates your place in the list. It should be used\n                to fetch the previous page of the list after an intial next request\n            gateway: The gateway type of the bank. Any value from the ``Gateway`` enum.\n            type: Type of financial channel. For Ghanaian channels, please use either\n                mobile_money for mobile money channels OR ghipps for bank channels\n            currency: Any value from the Currency enum.\n            pay_with_bank_transfer: A flag to filter for available banks a customer can make a transfer to\n                complete a payment\n            pay_with_bank: A flag to filter for banks a customer can pay directly from\n            pagination: The number of objects to return per page. Defaults to 50, and limited to 100 records per page.\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        country = Country.get_full(country)\n        url = self._parse_url(f\"/bank?perPage={pagination}\")\n        query_params = [\n            (\"country\", country),\n            (\"use_cursor\", use_cursor),\n            (\"next\", next),\n            (\"previous\", previous),\n            (\"gateway\", gateway),\n            (\"type\", type),\n            (\"currency\", currency),\n            (\"pay_with_bank_transfer\", pay_with_bank_transfer),\n            (\"pay_with_bank\", pay_with_bank),\n        ]\n        url = append_query_params(query_params, url)\n        return await self._handle_request(HTTPMethod.GET, url)\n\n    async def get_countries(self) -&gt; Response:\n        \"\"\"Gets a list of Countries that Paystack currently supports\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(\"/country\")\n        return await self._handle_request(HTTPMethod.GET, url)\n\n    async def get_states(self, country: Country) -&gt; Response:\n        \"\"\"Get a list of states for a country for address verification.\n\n        Args:\n            country: Any value from the country enum.\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/address_verification/states?country={country}\")\n        return await self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/miscellaneous/#pypaystack2.api.miscellaneous.AsyncMiscellaneous.get_banks","title":"<code>get_banks(country, use_cursor=False, next=None, previous=None, gateway=None, type=None, currency=None, pay_with_bank_transfer=None, pay_with_bank=None, pagination=50)</code>  <code>async</code>","text":"<p>Get a list of all supported banks and their properties</p> <p>Parameters:</p> Name Type Description Default <code>country</code> <code>Country</code> <p>The country from which to obtain the list of supported banks. any value from the <code>Country</code> enum.</p> required <code>use_cursor</code> <code>bool</code> <p>Flag to enable cursor pagination.</p> <code>False</code> <code>next</code> <code>Optional[str]</code> <p>A cursor that indicates your place in the list. It can be used to fetch the next page of the list</p> <code>None</code> <code>previous</code> <code>Optional[str]</code> <p>A cursor that indicates your place in the list. It should be used to fetch the previous page of the list after an intial next request</p> <code>None</code> <code>gateway</code> <code>Optional[Gateway]</code> <p>The gateway type of the bank. Any value from the <code>Gateway</code> enum.</p> <code>None</code> <code>type</code> <code>Optional[BankType]</code> <p>Type of financial channel. For Ghanaian channels, please use either mobile_money for mobile money channels OR ghipps for bank channels</p> <code>None</code> <code>currency</code> <code>Optional[Currency]</code> <p>Any value from the Currency enum.</p> <code>None</code> <code>pay_with_bank_transfer</code> <code>Optional[bool]</code> <p>A flag to filter for available banks a customer can make a transfer to complete a payment</p> <code>None</code> <code>pay_with_bank</code> <code>Optional[bool]</code> <p>A flag to filter for banks a customer can pay directly from</p> <code>None</code> <code>pagination</code> <code>int</code> <p>The number of objects to return per page. Defaults to 50, and limited to 100 records per page.</p> <code>50</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/miscellaneous.py</code> <pre><code>async def get_banks(\n    self,\n    country: Country,\n    use_cursor: bool = False,\n    next: Optional[str] = None,\n    previous: Optional[str] = None,\n    gateway: Optional[Gateway] = None,\n    type: Optional[BankType] = None,\n    currency: Optional[Currency] = None,\n    pay_with_bank_transfer: Optional[bool] = None,\n    pay_with_bank: Optional[bool] = None,\n    pagination: int = 50,\n) -&gt; Response:\n    \"\"\"Get a list of all supported banks and their properties\n\n    Args:\n        country: The country from which to obtain the list of supported banks. any value from the ``Country`` enum.\n        use_cursor: Flag to enable cursor pagination.\n        next: A cursor that indicates your place in the list. It can be used to fetch the next page of the list\n        previous: A cursor that indicates your place in the list. It should be used\n            to fetch the previous page of the list after an intial next request\n        gateway: The gateway type of the bank. Any value from the ``Gateway`` enum.\n        type: Type of financial channel. For Ghanaian channels, please use either\n            mobile_money for mobile money channels OR ghipps for bank channels\n        currency: Any value from the Currency enum.\n        pay_with_bank_transfer: A flag to filter for available banks a customer can make a transfer to\n            complete a payment\n        pay_with_bank: A flag to filter for banks a customer can pay directly from\n        pagination: The number of objects to return per page. Defaults to 50, and limited to 100 records per page.\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    country = Country.get_full(country)\n    url = self._parse_url(f\"/bank?perPage={pagination}\")\n    query_params = [\n        (\"country\", country),\n        (\"use_cursor\", use_cursor),\n        (\"next\", next),\n        (\"previous\", previous),\n        (\"gateway\", gateway),\n        (\"type\", type),\n        (\"currency\", currency),\n        (\"pay_with_bank_transfer\", pay_with_bank_transfer),\n        (\"pay_with_bank\", pay_with_bank),\n    ]\n    url = append_query_params(query_params, url)\n    return await self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/miscellaneous/#pypaystack2.api.miscellaneous.AsyncMiscellaneous.get_countries","title":"<code>get_countries()</code>  <code>async</code>","text":"<p>Gets a list of Countries that Paystack currently supports</p> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/miscellaneous.py</code> <pre><code>async def get_countries(self) -&gt; Response:\n    \"\"\"Gets a list of Countries that Paystack currently supports\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(\"/country\")\n    return await self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/miscellaneous/#pypaystack2.api.miscellaneous.AsyncMiscellaneous.get_states","title":"<code>get_states(country)</code>  <code>async</code>","text":"<p>Get a list of states for a country for address verification.</p> <p>Parameters:</p> Name Type Description Default <code>country</code> <code>Country</code> <p>Any value from the country enum.</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/miscellaneous.py</code> <pre><code>async def get_states(self, country: Country) -&gt; Response:\n    \"\"\"Get a list of states for a country for address verification.\n\n    Args:\n        country: Any value from the country enum.\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/address_verification/states?country={country}\")\n    return await self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/miscellaneous/#pypaystack2.api.miscellaneous.Miscellaneous","title":"<code>Miscellaneous</code>","text":"<p>               Bases: <code>BaseAPI</code></p> <p>Provides a wrapper for paystack Miscellaneous API</p> <p>The Miscellaneous API are supporting APIs that can be used to provide more details to other APIs. https://paystack.com/docs/api/miscellaneous/</p> Source code in <code>src/pypaystack2/api/miscellaneous.py</code> <pre><code>class Miscellaneous(BaseAPI):\n    \"\"\"Provides a wrapper for paystack Miscellaneous API\n\n    The Miscellaneous API are supporting APIs that can be used to provide more details to other APIs.\n    https://paystack.com/docs/api/miscellaneous/\n    \"\"\"\n\n    def get_banks(\n        self,\n        country: Country,\n        use_cursor: bool = False,\n        next: Optional[str] = None,\n        previous: Optional[str] = None,\n        gateway: Optional[Gateway] = None,\n        type: Optional[BankType] = None,\n        currency: Optional[Currency] = None,\n        pay_with_bank_transfer: Optional[bool] = None,\n        pay_with_bank: Optional[bool] = None,\n        pagination: int = 50,\n    ) -&gt; Response:\n        \"\"\"Get a list of all supported banks and their properties\n\n        Args:\n            country: The country from which to obtain the list of supported banks. any value from the ``Country`` enum.\n            use_cursor: Flag to enable cursor pagination.\n            next: A cursor that indicates your place in the list. It can be used to fetch the next page of the list\n            previous: A cursor that indicates your place in the list. It should be used\n                to fetch the previous page of the list after an intial next request\n            gateway: The gateway type of the bank. Any value from the ``Gateway`` enum.\n            type: Type of financial channel. For Ghanaian channels, please use either\n                mobile_money for mobile money channels OR ghipps for bank channels\n            currency: Any value from the Currency enum.\n            pay_with_bank_transfer: A flag to filter for available banks a customer can make a transfer to\n                complete a payment\n            pay_with_bank: A flag to filter for banks a customer can pay directly from\n            pagination: The number of objects to return per page. Defaults to 50, and limited to 100 records per page.\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        country = Country.get_full(country)\n        url = self._parse_url(f\"/bank?perPage={pagination}\")\n        query_params = [\n            (\"country\", country),\n            (\"use_cursor\", use_cursor),\n            (\"next\", next),\n            (\"previous\", previous),\n            (\"gateway\", gateway),\n            (\"type\", type),\n            (\"currency\", currency),\n            (\"pay_with_bank_transfer\", pay_with_bank_transfer),\n            (\"pay_with_bank\", pay_with_bank),\n        ]\n        url = append_query_params(query_params, url)\n        return self._handle_request(HTTPMethod.GET, url)\n\n    def get_countries(self) -&gt; Response:\n        \"\"\"Gets a list of Countries that Paystack currently supports\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(\"/country\")\n        return self._handle_request(HTTPMethod.GET, url)\n\n    def get_states(self, country: Country) -&gt; Response:\n        \"\"\"Get a list of states for a country for address verification.\n\n        Args:\n            country: Any value from the country enum.\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/address_verification/states?country={country}\")\n        return self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/miscellaneous/#pypaystack2.api.miscellaneous.Miscellaneous.get_banks","title":"<code>get_banks(country, use_cursor=False, next=None, previous=None, gateway=None, type=None, currency=None, pay_with_bank_transfer=None, pay_with_bank=None, pagination=50)</code>","text":"<p>Get a list of all supported banks and their properties</p> <p>Parameters:</p> Name Type Description Default <code>country</code> <code>Country</code> <p>The country from which to obtain the list of supported banks. any value from the <code>Country</code> enum.</p> required <code>use_cursor</code> <code>bool</code> <p>Flag to enable cursor pagination.</p> <code>False</code> <code>next</code> <code>Optional[str]</code> <p>A cursor that indicates your place in the list. It can be used to fetch the next page of the list</p> <code>None</code> <code>previous</code> <code>Optional[str]</code> <p>A cursor that indicates your place in the list. It should be used to fetch the previous page of the list after an intial next request</p> <code>None</code> <code>gateway</code> <code>Optional[Gateway]</code> <p>The gateway type of the bank. Any value from the <code>Gateway</code> enum.</p> <code>None</code> <code>type</code> <code>Optional[BankType]</code> <p>Type of financial channel. For Ghanaian channels, please use either mobile_money for mobile money channels OR ghipps for bank channels</p> <code>None</code> <code>currency</code> <code>Optional[Currency]</code> <p>Any value from the Currency enum.</p> <code>None</code> <code>pay_with_bank_transfer</code> <code>Optional[bool]</code> <p>A flag to filter for available banks a customer can make a transfer to complete a payment</p> <code>None</code> <code>pay_with_bank</code> <code>Optional[bool]</code> <p>A flag to filter for banks a customer can pay directly from</p> <code>None</code> <code>pagination</code> <code>int</code> <p>The number of objects to return per page. Defaults to 50, and limited to 100 records per page.</p> <code>50</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/miscellaneous.py</code> <pre><code>def get_banks(\n    self,\n    country: Country,\n    use_cursor: bool = False,\n    next: Optional[str] = None,\n    previous: Optional[str] = None,\n    gateway: Optional[Gateway] = None,\n    type: Optional[BankType] = None,\n    currency: Optional[Currency] = None,\n    pay_with_bank_transfer: Optional[bool] = None,\n    pay_with_bank: Optional[bool] = None,\n    pagination: int = 50,\n) -&gt; Response:\n    \"\"\"Get a list of all supported banks and their properties\n\n    Args:\n        country: The country from which to obtain the list of supported banks. any value from the ``Country`` enum.\n        use_cursor: Flag to enable cursor pagination.\n        next: A cursor that indicates your place in the list. It can be used to fetch the next page of the list\n        previous: A cursor that indicates your place in the list. It should be used\n            to fetch the previous page of the list after an intial next request\n        gateway: The gateway type of the bank. Any value from the ``Gateway`` enum.\n        type: Type of financial channel. For Ghanaian channels, please use either\n            mobile_money for mobile money channels OR ghipps for bank channels\n        currency: Any value from the Currency enum.\n        pay_with_bank_transfer: A flag to filter for available banks a customer can make a transfer to\n            complete a payment\n        pay_with_bank: A flag to filter for banks a customer can pay directly from\n        pagination: The number of objects to return per page. Defaults to 50, and limited to 100 records per page.\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    country = Country.get_full(country)\n    url = self._parse_url(f\"/bank?perPage={pagination}\")\n    query_params = [\n        (\"country\", country),\n        (\"use_cursor\", use_cursor),\n        (\"next\", next),\n        (\"previous\", previous),\n        (\"gateway\", gateway),\n        (\"type\", type),\n        (\"currency\", currency),\n        (\"pay_with_bank_transfer\", pay_with_bank_transfer),\n        (\"pay_with_bank\", pay_with_bank),\n    ]\n    url = append_query_params(query_params, url)\n    return self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/miscellaneous/#pypaystack2.api.miscellaneous.Miscellaneous.get_countries","title":"<code>get_countries()</code>","text":"<p>Gets a list of Countries that Paystack currently supports</p> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/miscellaneous.py</code> <pre><code>def get_countries(self) -&gt; Response:\n    \"\"\"Gets a list of Countries that Paystack currently supports\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(\"/country\")\n    return self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/miscellaneous/#pypaystack2.api.miscellaneous.Miscellaneous.get_states","title":"<code>get_states(country)</code>","text":"<p>Get a list of states for a country for address verification.</p> <p>Parameters:</p> Name Type Description Default <code>country</code> <code>Country</code> <p>Any value from the country enum.</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/miscellaneous.py</code> <pre><code>def get_states(self, country: Country) -&gt; Response:\n    \"\"\"Get a list of states for a country for address verification.\n\n    Args:\n        country: Any value from the country enum.\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/address_verification/states?country={country}\")\n    return self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/payment_pages/","title":"Payment pages","text":""},{"location":"reference/payment_pages/#pypaystack2.api.payment_pages.AsyncPaymentPage","title":"<code>AsyncPaymentPage</code>","text":"<p>               Bases: <code>BaseAsyncAPI</code></p> <p>Provides a wrapper for paystack Payment Pages API</p> <p>The Payment Pages API provides a quick and secure way to collect payment for products. https://paystack.com/docs/api/page/</p> Source code in <code>src/pypaystack2/api/payment_pages.py</code> <pre><code>class AsyncPaymentPage(BaseAsyncAPI):\n    \"\"\"Provides a wrapper for paystack Payment Pages API\n\n    The Payment Pages API provides a quick and secure way to collect payment for products.\n    https://paystack.com/docs/api/page/\n    \"\"\"\n\n    async def create(\n        self,\n        name: str,\n        description: Optional[str] = None,\n        amount: Optional[int] = None,\n        split_code: Optional[str] = None,\n        slug: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n        redirect_url: Optional[str] = None,\n        custom_fields: Optional[list] = None,\n    ) -&gt; Response:\n        \"\"\"Create a payment page on your integration\n\n        Args:\n            name: Name of page\n            description: A description for this page\n            amount: Amount should be in kobo if currency is ``Currency.NGN``, pesewas, if\n                currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR``\n            split_code: The split code of the transaction split. e.g. SPL_98WF13Eb3w\n            slug: URL slug you would like to be associated with this page.\n                Page will be accessible at ``https://paystack.com/pay/[slug]``\n            metadata: Extra data to configure the payment page including subaccount,\n                logo image, transaction charge\n            redirect_url: If you would like Paystack to redirect someplace upon\n                successful payment, specify the URL here.\n            custom_fields: If you would like to accept custom fields,\n                specify them here.\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(\"/page\")\n\n        payload = {\"name\": name}\n        optional_params = [\n            (\"description\", description),\n            (\"amount\", amount),\n            (\"split_code\", split_code),\n            (\"slug\", slug),\n            (\"metadata\", metadata),\n            (\"redirect_url\", redirect_url),\n            (\"custom_fields\", custom_fields),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return await self._handle_request(HTTPMethod.POST, url, payload)\n\n    async def get_pages(\n        self,\n        page: int = 1,\n        pagination: int = 50,\n        start_date: Optional[str] = None,\n        end_date: Optional[str] = None,\n    ) -&gt; Response:\n        \"\"\"Fetch payment pages available on your integration.\n\n        Args:\n            page: Specifies exactly what page you want to retrieve.\n                If not specified we use a default value of 1.\n            pagination: Specifies how many records you want to retrieve per page.\n                If not specified we use a default value of 50.\n            start_date: A timestamp from which to start listing page e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            end_date: A timestamp at which to stop listing page e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(\"/page?perPage=\" + str(pagination))\n        query_params = [\n            (\"page\", page),\n            (\"start_date\", start_date),\n            (\"end_date\", end_date),\n        ]\n        url = append_query_params(query_params, url)\n        return await self._handle_request(HTTPMethod.GET, url)\n\n    async def get_page(self, id_or_slug: str) -&gt; Response:\n        \"\"\"Get details of a payment page on your integration.\n\n        Args:\n            id_or_slug: The page ``ID`` or ``slug`` you want to fetch\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/page/{id_or_slug}\")\n        return await self._handle_request(HTTPMethod.GET, url)\n\n    async def update(\n        self,\n        id_or_slug: str,\n        name: str,\n        description: str,\n        amount: Optional[int] = None,\n        active: Optional[bool] = None,\n    ) -&gt; Response:\n        \"\"\"Get details of a payment page on your integration.\n\n        Args:\n            id_or_slug: The page ``ID`` or ``slug`` you want to fetch\n            name: Name of page\n            description: A description for the page\n            amount: Default amount you want to accept using this page.\n                If none is set, customer is free to provide any amount\n                of their choice. The latter scenario is useful for\n                accepting donations\n            active: Set to ``False`` to deactivate page url\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/page/{id_or_slug}\")\n        payload = {\n            \"name\": name,\n            \"description\": description,\n        }\n        optional_params = [\n            (\"amount\", amount),\n            (\"active\", active),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return await self._handle_request(HTTPMethod.PUT, url, payload)\n\n    async def check_slug_available(self, slug: str) -&gt; Response:\n        \"\"\"Check the availability of a slug for a payment page.\n\n        Args:\n            slug: URL slug to be confirmed\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/page/check_slug_availability/{slug}\")\n        return await self._handle_request(HTTPMethod.GET, url)\n\n    async def add_products(self, id: str, products: list[int]) -&gt; Response:\n        \"\"\"Add products to a payment page\n\n        Args:\n            id: ID of the payment page\n            products: Ids of all the products\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/page/{id}/product\")\n        payload = {\"product\": products}\n        return await self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/payment_pages/#pypaystack2.api.payment_pages.AsyncPaymentPage.add_products","title":"<code>add_products(id, products)</code>  <code>async</code>","text":"<p>Add products to a payment page</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>ID of the payment page</p> required <code>products</code> <code>list[int]</code> <p>Ids of all the products</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/payment_pages.py</code> <pre><code>async def add_products(self, id: str, products: list[int]) -&gt; Response:\n    \"\"\"Add products to a payment page\n\n    Args:\n        id: ID of the payment page\n        products: Ids of all the products\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/page/{id}/product\")\n    payload = {\"product\": products}\n    return await self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/payment_pages/#pypaystack2.api.payment_pages.AsyncPaymentPage.check_slug_available","title":"<code>check_slug_available(slug)</code>  <code>async</code>","text":"<p>Check the availability of a slug for a payment page.</p> <p>Parameters:</p> Name Type Description Default <code>slug</code> <code>str</code> <p>URL slug to be confirmed</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/payment_pages.py</code> <pre><code>async def check_slug_available(self, slug: str) -&gt; Response:\n    \"\"\"Check the availability of a slug for a payment page.\n\n    Args:\n        slug: URL slug to be confirmed\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/page/check_slug_availability/{slug}\")\n    return await self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/payment_pages/#pypaystack2.api.payment_pages.AsyncPaymentPage.create","title":"<code>create(name, description=None, amount=None, split_code=None, slug=None, metadata=None, redirect_url=None, custom_fields=None)</code>  <code>async</code>","text":"<p>Create a payment page on your integration</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of page</p> required <code>description</code> <code>Optional[str]</code> <p>A description for this page</p> <code>None</code> <code>amount</code> <code>Optional[int]</code> <p>Amount should be in kobo if currency is <code>Currency.NGN</code>, pesewas, if currency is <code>Currency.GHS</code>, and cents, if currency is <code>Currency.ZAR</code></p> <code>None</code> <code>split_code</code> <code>Optional[str]</code> <p>The split code of the transaction split. e.g. SPL_98WF13Eb3w</p> <code>None</code> <code>slug</code> <code>Optional[str]</code> <p>URL slug you would like to be associated with this page. Page will be accessible at <code>https://paystack.com/pay/[slug]</code></p> <code>None</code> <code>metadata</code> <code>Optional[dict[str, Any]]</code> <p>Extra data to configure the payment page including subaccount, logo image, transaction charge</p> <code>None</code> <code>redirect_url</code> <code>Optional[str]</code> <p>If you would like Paystack to redirect someplace upon successful payment, specify the URL here.</p> <code>None</code> <code>custom_fields</code> <code>Optional[list]</code> <p>If you would like to accept custom fields, specify them here.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/payment_pages.py</code> <pre><code>async def create(\n    self,\n    name: str,\n    description: Optional[str] = None,\n    amount: Optional[int] = None,\n    split_code: Optional[str] = None,\n    slug: Optional[str] = None,\n    metadata: Optional[dict[str, Any]] = None,\n    redirect_url: Optional[str] = None,\n    custom_fields: Optional[list] = None,\n) -&gt; Response:\n    \"\"\"Create a payment page on your integration\n\n    Args:\n        name: Name of page\n        description: A description for this page\n        amount: Amount should be in kobo if currency is ``Currency.NGN``, pesewas, if\n            currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR``\n        split_code: The split code of the transaction split. e.g. SPL_98WF13Eb3w\n        slug: URL slug you would like to be associated with this page.\n            Page will be accessible at ``https://paystack.com/pay/[slug]``\n        metadata: Extra data to configure the payment page including subaccount,\n            logo image, transaction charge\n        redirect_url: If you would like Paystack to redirect someplace upon\n            successful payment, specify the URL here.\n        custom_fields: If you would like to accept custom fields,\n            specify them here.\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(\"/page\")\n\n    payload = {\"name\": name}\n    optional_params = [\n        (\"description\", description),\n        (\"amount\", amount),\n        (\"split_code\", split_code),\n        (\"slug\", slug),\n        (\"metadata\", metadata),\n        (\"redirect_url\", redirect_url),\n        (\"custom_fields\", custom_fields),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return await self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/payment_pages/#pypaystack2.api.payment_pages.AsyncPaymentPage.get_page","title":"<code>get_page(id_or_slug)</code>  <code>async</code>","text":"<p>Get details of a payment page on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>id_or_slug</code> <code>str</code> <p>The page <code>ID</code> or <code>slug</code> you want to fetch</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/payment_pages.py</code> <pre><code>async def get_page(self, id_or_slug: str) -&gt; Response:\n    \"\"\"Get details of a payment page on your integration.\n\n    Args:\n        id_or_slug: The page ``ID`` or ``slug`` you want to fetch\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/page/{id_or_slug}\")\n    return await self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/payment_pages/#pypaystack2.api.payment_pages.AsyncPaymentPage.get_pages","title":"<code>get_pages(page=1, pagination=50, start_date=None, end_date=None)</code>  <code>async</code>","text":"<p>Fetch payment pages available on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>int</code> <p>Specifies exactly what page you want to retrieve. If not specified we use a default value of 1.</p> <code>1</code> <code>pagination</code> <code>int</code> <p>Specifies how many records you want to retrieve per page. If not specified we use a default value of 50.</p> <code>50</code> <code>start_date</code> <code>Optional[str]</code> <p>A timestamp from which to start listing page e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>end_date</code> <code>Optional[str]</code> <p>A timestamp at which to stop listing page e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/payment_pages.py</code> <pre><code>async def get_pages(\n    self,\n    page: int = 1,\n    pagination: int = 50,\n    start_date: Optional[str] = None,\n    end_date: Optional[str] = None,\n) -&gt; Response:\n    \"\"\"Fetch payment pages available on your integration.\n\n    Args:\n        page: Specifies exactly what page you want to retrieve.\n            If not specified we use a default value of 1.\n        pagination: Specifies how many records you want to retrieve per page.\n            If not specified we use a default value of 50.\n        start_date: A timestamp from which to start listing page e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        end_date: A timestamp at which to stop listing page e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(\"/page?perPage=\" + str(pagination))\n    query_params = [\n        (\"page\", page),\n        (\"start_date\", start_date),\n        (\"end_date\", end_date),\n    ]\n    url = append_query_params(query_params, url)\n    return await self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/payment_pages/#pypaystack2.api.payment_pages.AsyncPaymentPage.update","title":"<code>update(id_or_slug, name, description, amount=None, active=None)</code>  <code>async</code>","text":"<p>Get details of a payment page on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>id_or_slug</code> <code>str</code> <p>The page <code>ID</code> or <code>slug</code> you want to fetch</p> required <code>name</code> <code>str</code> <p>Name of page</p> required <code>description</code> <code>str</code> <p>A description for the page</p> required <code>amount</code> <code>Optional[int]</code> <p>Default amount you want to accept using this page. If none is set, customer is free to provide any amount of their choice. The latter scenario is useful for accepting donations</p> <code>None</code> <code>active</code> <code>Optional[bool]</code> <p>Set to <code>False</code> to deactivate page url</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/payment_pages.py</code> <pre><code>async def update(\n    self,\n    id_or_slug: str,\n    name: str,\n    description: str,\n    amount: Optional[int] = None,\n    active: Optional[bool] = None,\n) -&gt; Response:\n    \"\"\"Get details of a payment page on your integration.\n\n    Args:\n        id_or_slug: The page ``ID`` or ``slug`` you want to fetch\n        name: Name of page\n        description: A description for the page\n        amount: Default amount you want to accept using this page.\n            If none is set, customer is free to provide any amount\n            of their choice. The latter scenario is useful for\n            accepting donations\n        active: Set to ``False`` to deactivate page url\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/page/{id_or_slug}\")\n    payload = {\n        \"name\": name,\n        \"description\": description,\n    }\n    optional_params = [\n        (\"amount\", amount),\n        (\"active\", active),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return await self._handle_request(HTTPMethod.PUT, url, payload)\n</code></pre>"},{"location":"reference/payment_pages/#pypaystack2.api.payment_pages.PaymentPage","title":"<code>PaymentPage</code>","text":"<p>               Bases: <code>BaseAPI</code></p> <p>Provides a wrapper for paystack Payment Pages API</p> <p>The Payment Pages API provides a quick and secure way to collect payment for products. https://paystack.com/docs/api/page/</p> Source code in <code>src/pypaystack2/api/payment_pages.py</code> <pre><code>class PaymentPage(BaseAPI):\n    \"\"\"Provides a wrapper for paystack Payment Pages API\n\n    The Payment Pages API provides a quick and secure way to collect payment for products.\n    https://paystack.com/docs/api/page/\n    \"\"\"\n\n    def create(\n        self,\n        name: str,\n        description: Optional[str] = None,\n        amount: Optional[int] = None,\n        split_code: Optional[str] = None,\n        slug: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n        redirect_url: Optional[str] = None,\n        custom_fields: Optional[list] = None,\n    ) -&gt; Response:\n        \"\"\"Create a payment page on your integration\n\n        Args:\n            name: Name of page\n            description: A description for this page\n            amount: Amount should be in kobo if currency is ``Currency.NGN``, pesewas, if\n                currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR``\n            split_code: The split code of the transaction split. e.g. SPL_98WF13Eb3w\n            slug: URL slug you would like to be associated with this page.\n                Page will be accessible at ``https://paystack.com/pay/[slug]``\n            metadata: Extra data to configure the payment page including subaccount,\n                logo image, transaction charge\n            redirect_url: If you would like Paystack to redirect someplace upon\n                successful payment, specify the URL here.\n            custom_fields: If you would like to accept custom fields,\n                specify them here.\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(\"/page\")\n\n        payload = {\"name\": name}\n        optional_params = [\n            (\"description\", description),\n            (\"amount\", amount),\n            (\"split_code\", split_code),\n            (\"slug\", slug),\n            (\"metadata\", metadata),\n            (\"redirect_url\", redirect_url),\n            (\"custom_fields\", custom_fields),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return self._handle_request(HTTPMethod.POST, url, payload)\n\n    def get_pages(\n        self,\n        page: int = 1,\n        pagination: int = 50,\n        start_date: Optional[str] = None,\n        end_date: Optional[str] = None,\n    ) -&gt; Response:\n        \"\"\"Fetch payment pages available on your integration.\n\n        Args:\n            page: Specifies exactly what page you want to retrieve.\n                If not specified, we use a default value of 1.\n            pagination: Specifies how many records you want to retrieve per page.\n                If not specified, we use a default value of 50.\n            start_date: A timestamp from which to start listing page e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            end_date: A timestamp at which to stop listing page e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(\"/page?perPage=\" + str(pagination))\n        query_params = [\n            (\"page\", page),\n            (\"start_date\", start_date),\n            (\"end_date\", end_date),\n        ]\n        url = append_query_params(query_params, url)\n        return self._handle_request(HTTPMethod.GET, url)\n\n    def get_page(self, id_or_slug: str) -&gt; Response:\n        \"\"\"Get details of a payment page on your integration.\n\n        Args:\n            id_or_slug: The page ``ID`` or ``slug`` you want to fetch\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/page/{id_or_slug}\")\n        return self._handle_request(HTTPMethod.GET, url)\n\n    def update(\n        self,\n        id_or_slug: str,\n        name: str,\n        description: str,\n        amount: Optional[int] = None,\n        active: Optional[bool] = None,\n    ) -&gt; Response:\n        \"\"\"Get details of a payment page on your integration.\n\n        Args:\n            id_or_slug: The page ``ID`` or ``slug`` you want to fetch\n            name: Name of page\n            description: A description for the page\n            amount: Default amount you want to accept using this page.\n                If none is set, customer is free to provide any amount\n                of their choice. The latter scenario is useful for\n                accepting donations\n            active: Set to ``False`` to deactivate page url\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/page/{id_or_slug}\")\n        payload = {\n            \"name\": name,\n            \"description\": description,\n        }\n        optional_params = [\n            (\"amount\", amount),\n            (\"active\", active),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return self._handle_request(HTTPMethod.PUT, url, payload)\n\n    def check_slug_available(self, slug: str) -&gt; Response:\n        \"\"\"Check the availability of a slug for a payment page.\n\n        Args:\n            slug: URL slug to be confirmed\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/page/check_slug_availability/{slug}\")\n        return self._handle_request(HTTPMethod.GET, url)\n\n    def add_products(self, id: str, products: list[int]) -&gt; Response:\n        \"\"\"Add products to a payment page\n\n        Args:\n            id: ID of the payment page\n            products: Ids of all the products\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/page/{id}/product\")\n        payload = {\"product\": products}\n        return self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/payment_pages/#pypaystack2.api.payment_pages.PaymentPage.add_products","title":"<code>add_products(id, products)</code>","text":"<p>Add products to a payment page</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>ID of the payment page</p> required <code>products</code> <code>list[int]</code> <p>Ids of all the products</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/payment_pages.py</code> <pre><code>def add_products(self, id: str, products: list[int]) -&gt; Response:\n    \"\"\"Add products to a payment page\n\n    Args:\n        id: ID of the payment page\n        products: Ids of all the products\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/page/{id}/product\")\n    payload = {\"product\": products}\n    return self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/payment_pages/#pypaystack2.api.payment_pages.PaymentPage.check_slug_available","title":"<code>check_slug_available(slug)</code>","text":"<p>Check the availability of a slug for a payment page.</p> <p>Parameters:</p> Name Type Description Default <code>slug</code> <code>str</code> <p>URL slug to be confirmed</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/payment_pages.py</code> <pre><code>def check_slug_available(self, slug: str) -&gt; Response:\n    \"\"\"Check the availability of a slug for a payment page.\n\n    Args:\n        slug: URL slug to be confirmed\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/page/check_slug_availability/{slug}\")\n    return self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/payment_pages/#pypaystack2.api.payment_pages.PaymentPage.create","title":"<code>create(name, description=None, amount=None, split_code=None, slug=None, metadata=None, redirect_url=None, custom_fields=None)</code>","text":"<p>Create a payment page on your integration</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of page</p> required <code>description</code> <code>Optional[str]</code> <p>A description for this page</p> <code>None</code> <code>amount</code> <code>Optional[int]</code> <p>Amount should be in kobo if currency is <code>Currency.NGN</code>, pesewas, if currency is <code>Currency.GHS</code>, and cents, if currency is <code>Currency.ZAR</code></p> <code>None</code> <code>split_code</code> <code>Optional[str]</code> <p>The split code of the transaction split. e.g. SPL_98WF13Eb3w</p> <code>None</code> <code>slug</code> <code>Optional[str]</code> <p>URL slug you would like to be associated with this page. Page will be accessible at <code>https://paystack.com/pay/[slug]</code></p> <code>None</code> <code>metadata</code> <code>Optional[dict[str, Any]]</code> <p>Extra data to configure the payment page including subaccount, logo image, transaction charge</p> <code>None</code> <code>redirect_url</code> <code>Optional[str]</code> <p>If you would like Paystack to redirect someplace upon successful payment, specify the URL here.</p> <code>None</code> <code>custom_fields</code> <code>Optional[list]</code> <p>If you would like to accept custom fields, specify them here.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/payment_pages.py</code> <pre><code>def create(\n    self,\n    name: str,\n    description: Optional[str] = None,\n    amount: Optional[int] = None,\n    split_code: Optional[str] = None,\n    slug: Optional[str] = None,\n    metadata: Optional[dict[str, Any]] = None,\n    redirect_url: Optional[str] = None,\n    custom_fields: Optional[list] = None,\n) -&gt; Response:\n    \"\"\"Create a payment page on your integration\n\n    Args:\n        name: Name of page\n        description: A description for this page\n        amount: Amount should be in kobo if currency is ``Currency.NGN``, pesewas, if\n            currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR``\n        split_code: The split code of the transaction split. e.g. SPL_98WF13Eb3w\n        slug: URL slug you would like to be associated with this page.\n            Page will be accessible at ``https://paystack.com/pay/[slug]``\n        metadata: Extra data to configure the payment page including subaccount,\n            logo image, transaction charge\n        redirect_url: If you would like Paystack to redirect someplace upon\n            successful payment, specify the URL here.\n        custom_fields: If you would like to accept custom fields,\n            specify them here.\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(\"/page\")\n\n    payload = {\"name\": name}\n    optional_params = [\n        (\"description\", description),\n        (\"amount\", amount),\n        (\"split_code\", split_code),\n        (\"slug\", slug),\n        (\"metadata\", metadata),\n        (\"redirect_url\", redirect_url),\n        (\"custom_fields\", custom_fields),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/payment_pages/#pypaystack2.api.payment_pages.PaymentPage.get_page","title":"<code>get_page(id_or_slug)</code>","text":"<p>Get details of a payment page on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>id_or_slug</code> <code>str</code> <p>The page <code>ID</code> or <code>slug</code> you want to fetch</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/payment_pages.py</code> <pre><code>def get_page(self, id_or_slug: str) -&gt; Response:\n    \"\"\"Get details of a payment page on your integration.\n\n    Args:\n        id_or_slug: The page ``ID`` or ``slug`` you want to fetch\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/page/{id_or_slug}\")\n    return self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/payment_pages/#pypaystack2.api.payment_pages.PaymentPage.get_pages","title":"<code>get_pages(page=1, pagination=50, start_date=None, end_date=None)</code>","text":"<p>Fetch payment pages available on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>int</code> <p>Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1.</p> <code>1</code> <code>pagination</code> <code>int</code> <p>Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50.</p> <code>50</code> <code>start_date</code> <code>Optional[str]</code> <p>A timestamp from which to start listing page e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>end_date</code> <code>Optional[str]</code> <p>A timestamp at which to stop listing page e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/payment_pages.py</code> <pre><code>def get_pages(\n    self,\n    page: int = 1,\n    pagination: int = 50,\n    start_date: Optional[str] = None,\n    end_date: Optional[str] = None,\n) -&gt; Response:\n    \"\"\"Fetch payment pages available on your integration.\n\n    Args:\n        page: Specifies exactly what page you want to retrieve.\n            If not specified, we use a default value of 1.\n        pagination: Specifies how many records you want to retrieve per page.\n            If not specified, we use a default value of 50.\n        start_date: A timestamp from which to start listing page e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        end_date: A timestamp at which to stop listing page e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(\"/page?perPage=\" + str(pagination))\n    query_params = [\n        (\"page\", page),\n        (\"start_date\", start_date),\n        (\"end_date\", end_date),\n    ]\n    url = append_query_params(query_params, url)\n    return self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/payment_pages/#pypaystack2.api.payment_pages.PaymentPage.update","title":"<code>update(id_or_slug, name, description, amount=None, active=None)</code>","text":"<p>Get details of a payment page on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>id_or_slug</code> <code>str</code> <p>The page <code>ID</code> or <code>slug</code> you want to fetch</p> required <code>name</code> <code>str</code> <p>Name of page</p> required <code>description</code> <code>str</code> <p>A description for the page</p> required <code>amount</code> <code>Optional[int]</code> <p>Default amount you want to accept using this page. If none is set, customer is free to provide any amount of their choice. The latter scenario is useful for accepting donations</p> <code>None</code> <code>active</code> <code>Optional[bool]</code> <p>Set to <code>False</code> to deactivate page url</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/payment_pages.py</code> <pre><code>def update(\n    self,\n    id_or_slug: str,\n    name: str,\n    description: str,\n    amount: Optional[int] = None,\n    active: Optional[bool] = None,\n) -&gt; Response:\n    \"\"\"Get details of a payment page on your integration.\n\n    Args:\n        id_or_slug: The page ``ID`` or ``slug`` you want to fetch\n        name: Name of page\n        description: A description for the page\n        amount: Default amount you want to accept using this page.\n            If none is set, customer is free to provide any amount\n            of their choice. The latter scenario is useful for\n            accepting donations\n        active: Set to ``False`` to deactivate page url\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/page/{id_or_slug}\")\n    payload = {\n        \"name\": name,\n        \"description\": description,\n    }\n    optional_params = [\n        (\"amount\", amount),\n        (\"active\", active),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return self._handle_request(HTTPMethod.PUT, url, payload)\n</code></pre>"},{"location":"reference/payment_requests/","title":"Payment requests","text":""},{"location":"reference/payment_requests/#pypaystack2.api.payment_requests.AsyncPaymentRequest","title":"<code>AsyncPaymentRequest</code>","text":"<p>               Bases: <code>BaseAsyncAPI</code></p> <p>Provides a wrapper for paystack Payment Requests API</p> <p>The Payment Requests API allows you to manage requests for payment of goods and services. https://paystack.com/docs/api/payment-request/</p> Source code in <code>src/pypaystack2/api/payment_requests.py</code> <pre><code>class AsyncPaymentRequest(BaseAsyncAPI):\n    \"\"\"Provides a wrapper for paystack Payment Requests API\n\n    The Payment Requests API allows you to manage requests for payment of goods and services.\n    https://paystack.com/docs/api/payment-request/\n    \"\"\"\n\n    async def create(\n        self,\n        customer: str,\n        amount: int,\n        due_date: Optional[str] = None,\n        description: Optional[str] = None,\n        line_items: Optional[list[LineItem]] = None,\n        tax: Optional[list[Tax]] = None,\n        currency: Optional[Currency] = None,\n        send_notification: Optional[bool] = None,\n        draft: Optional[bool] = None,\n        has_invoice: Optional[bool] = None,\n        invoice_number: Optional[int] = None,\n        split_code: Optional[str] = None,\n    ) -&gt; Response:\n        \"\"\"Create a payment request for a transaction on your integration\n\n        Args:\n            customer: Customer id or code\n            amount: Payment request amount. It should be used when line items and tax values aren't specified.\n            due_date: ISO 8601 representation of request due date\n            description: A short description of the payment request\n            line_items: List of line items int the format [{\"name\":\"item 1\", \"amount\":2000, \"quantity\": 1}]\n            tax: List of taxes to be charged in the format [{\"name\":\"VAT\", \"amount\":2000}]\n            currency: Any value from Currency enum. default ``Currency.NGN``\n            send_notification: Indicates whether Paystack sends an email notification to customer. Defaults to ``True``\n            draft: Indicate if request should be saved as draft. Defaults to ``False`` and overrides send_notification\n            has_invoice: Set to ``True`` to create a draft invoice (adds an auto incrementing invoice number\n                if none is provided) even if there are no line_items or tax passed\n            invoice_number: Numeric value of invoice. Invoice will start from 1 and auto increment from there.\n                This field is to help override whatever value Paystack decides. Auto increment for\n                subsequent invoices continue from this point.\n            split_code: The split code of the transaction split. e.g. SPL_98WF13Eb3w\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n        if line_items:\n            line_items = [item.dict for item in line_items]\n        if tax:\n            tax = [unit_tax.dict for unit_tax in tax]\n\n        url = self._parse_url(\"/paymentrequest\")\n\n        payload = {\"customer\": customer, \"amount\": amount}\n        optional_params = [\n            (\"due_date\", due_date),\n            (\"description\", description),\n            (\"line_items\", line_items),\n            (\"tax\", tax),\n            (\"currency\", currency),\n            (\"send_notification\", send_notification),\n            (\"draft\", draft),\n            (\"has_invoice\", has_invoice),\n            (\"invoice_number\", invoice_number),\n            (\"split_code\", split_code),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return await self._handle_request(HTTPMethod.POST, url, payload)\n\n    async def get_payment_requests(\n        self,\n        customer: Optional[str] = None,\n        status: Optional[Status] = None,\n        currency: Optional[Currency] = None,\n        include_archive: bool = False,\n        page: int = 1,\n        pagination: int = 50,\n        start_date: Optional[str] = None,\n        end_date: Optional[str] = None,\n    ) -&gt; Response:\n        \"\"\"Fetches the payment requests available on your integration.\n\n        Args:\n            customer: Filter by customer ID\n            status: Filter by payment request status. Any value from enum of ``Status``\n            currency: Filter by currency. Any value from enum of ``Currency``\n            include_archive: Show archived payment requests.\n            page: Specify exactly what payment request you want to page. If not specify we use a default value of 1.\n            pagination: Specifies how many records you want to retrieve per page. If not specified\n                we use a default value of 50.\n            start_date: A timestamp from which to start listing payment request\n                e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            end_date: A timestamp at which to stop listing payment request e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/paymentrequest?perPage={pagination}\")\n        query_params = [\n            (\"customer\", customer),\n            (\"status\", status),\n            (\"currency\", currency),\n            (\"include_archive\", include_archive),\n            (\"page\", page),\n            (\"start_date\", start_date),\n            (\"end_date\", end_date),\n        ]\n        url = append_query_params(query_params, url)\n        return await self._handle_request(HTTPMethod.GET, url)\n\n    async def get_payment_request(self, id_or_code: str) -&gt; Response:\n        \"\"\"Get details of a payment request on your integration.\n\n        Args:\n            id_or_code: Payment Request id or code\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/paymentrequest/{id_or_code}\")\n        return await self._handle_request(HTTPMethod.GET, url)\n\n    async def verify(self, code: str) -&gt; Response:\n        \"\"\"Verify details of a payment request on your integration.\n\n        Args:\n            code: Payment Request id or code\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/paymentrequest/verify/{code}\")\n        return await self._handle_request(HTTPMethod.GET, url)\n\n    async def send_notification(self, id_or_code: str) -&gt; Response:\n        \"\"\"Send notification of a payment request to your customers\n\n        Args:\n            id_or_code: Payment Request id or code\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/paymentrequest/notify/{id_or_code}\")\n        return await self._handle_request(HTTPMethod.POST, url)\n\n    async def get_total(self) -&gt; Response:\n        \"\"\"Get payment requests metric\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(\"/paymentrequest/totals\")\n        return await self._handle_request(HTTPMethod.GET, url)\n\n    async def finalize(self, id_or_code: str) -&gt; Response:\n        \"\"\"Finalize a draft payment request\n\n        Args:\n            id_or_code: Payment Request id or code\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/paymentrequest/finalize/{id_or_code}\")\n        return await self._handle_request(HTTPMethod.POST, url)\n\n    async def update(\n        self,\n        id_or_code: str,\n        customer: str,\n        amount: int,\n        due_date: Optional[str] = None,\n        description: Optional[str] = None,\n        line_items: Optional[list[LineItem]] = None,\n        tax: Optional[list[Tax]] = None,\n        currency: Optional[Currency] = None,\n        send_notification: Optional[bool] = None,\n        draft: Optional[bool] = None,\n        invoice_number: Optional[int] = None,\n        split_code: Optional[str] = None,\n    ) -&gt; Response:\n        \"\"\"Update a payment request details on your integration\n\n        Args:\n            id_or_code: Payment Request id or code\n            customer: Customer id or code\n            amount: Payment request amount. Only useful if line items and tax values are ignored.\n                method will throw a friendly warning in the response if neither is available.\n            due_date: ISO 8601 representation of request due date\n            description: A short description of the payment request\n            line_items: List of line items in the format [{\"name\":\"item 1\", \"amount\":2000}]\n            tax: List of taxes to be charged in the format [{\"name\":\"VAT\", \"amount\":2000}]\n            currency: Specify the currency of the payment request. Any value from the ``Currency`` enum\n            send_notification: Indicates whether Paystack sends an email notification to customer. Defaults to ``True``\n            draft: Indicate if request should be saved as draft. Defaults to false and overrides send_notification\n            invoice_number: Numeric value of invoice. Invoice will start from 1 and auto increment from there.\n                This field is to help override whatever value Paystack decides. Auto increment for\n                subsequent invoices continue from this point.\n            split_code: The split code of the transaction split. e.g. SPL_98WF13Eb3w\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        amount = validate_amount(amount)\n\n        if line_items:\n            line_items = [item.dict for item in line_items]\n        if tax:\n            tax = [unit_tax.dict for unit_tax in tax]\n\n        url = self._parse_url(f\"/paymentrequest/{id_or_code}\")\n        payload = {\n            \"customer\": customer,\n            \"amount\": amount,\n        }\n        optional_params = [\n            (\"due_date\", due_date),\n            (\"description\", description),\n            (\"line_items\", line_items),\n            (\"tax\", tax),\n            (\"currency\", currency),\n            (\"send_notification\", send_notification),\n            (\"draft\", draft),\n            (\"invoice_number\", invoice_number),\n            (\"split_code\", split_code),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return await self._handle_request(HTTPMethod.PUT, url, payload)\n\n    async def archive(self, id_or_code: str) -&gt; Response:\n        \"\"\"Used to archive a payment request. A payment request will no longer be fetched on list or returned on verify.\n\n        Args:\n            id_or_code: Payment Request id or code\n\n         Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/paymentrequest/archive/{id_or_code}\")\n        return await self._handle_request(HTTPMethod.POST, url)\n</code></pre>"},{"location":"reference/payment_requests/#pypaystack2.api.payment_requests.AsyncPaymentRequest.archive","title":"<code>archive(id_or_code)</code>  <code>async</code>","text":"<p>Used to archive a payment request. A payment request will no longer be fetched on list or returned on verify.</p> <p>Parameters:</p> Name Type Description Default <code>id_or_code</code> <code>str</code> <p>Payment Request id or code</p> required <p>Returns:     A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/payment_requests.py</code> <pre><code>async def archive(self, id_or_code: str) -&gt; Response:\n    \"\"\"Used to archive a payment request. A payment request will no longer be fetched on list or returned on verify.\n\n    Args:\n        id_or_code: Payment Request id or code\n\n     Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/paymentrequest/archive/{id_or_code}\")\n    return await self._handle_request(HTTPMethod.POST, url)\n</code></pre>"},{"location":"reference/payment_requests/#pypaystack2.api.payment_requests.AsyncPaymentRequest.create","title":"<code>create(customer, amount, due_date=None, description=None, line_items=None, tax=None, currency=None, send_notification=None, draft=None, has_invoice=None, invoice_number=None, split_code=None)</code>  <code>async</code>","text":"<p>Create a payment request for a transaction on your integration</p> <p>Parameters:</p> Name Type Description Default <code>customer</code> <code>str</code> <p>Customer id or code</p> required <code>amount</code> <code>int</code> <p>Payment request amount. It should be used when line items and tax values aren't specified.</p> required <code>due_date</code> <code>Optional[str]</code> <p>ISO 8601 representation of request due date</p> <code>None</code> <code>description</code> <code>Optional[str]</code> <p>A short description of the payment request</p> <code>None</code> <code>line_items</code> <code>Optional[list[LineItem]]</code> <p>List of line items int the format [{\"name\":\"item 1\", \"amount\":2000, \"quantity\": 1}]</p> <code>None</code> <code>tax</code> <code>Optional[list[Tax]]</code> <p>List of taxes to be charged in the format [{\"name\":\"VAT\", \"amount\":2000}]</p> <code>None</code> <code>currency</code> <code>Optional[Currency]</code> <p>Any value from Currency enum. default <code>Currency.NGN</code></p> <code>None</code> <code>send_notification</code> <code>Optional[bool]</code> <p>Indicates whether Paystack sends an email notification to customer. Defaults to <code>True</code></p> <code>None</code> <code>draft</code> <code>Optional[bool]</code> <p>Indicate if request should be saved as draft. Defaults to <code>False</code> and overrides send_notification</p> <code>None</code> <code>has_invoice</code> <code>Optional[bool]</code> <p>Set to <code>True</code> to create a draft invoice (adds an auto incrementing invoice number if none is provided) even if there are no line_items or tax passed</p> <code>None</code> <code>invoice_number</code> <code>Optional[int]</code> <p>Numeric value of invoice. Invoice will start from 1 and auto increment from there. This field is to help override whatever value Paystack decides. Auto increment for subsequent invoices continue from this point.</p> <code>None</code> <code>split_code</code> <code>Optional[str]</code> <p>The split code of the transaction split. e.g. SPL_98WF13Eb3w</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/payment_requests.py</code> <pre><code>async def create(\n    self,\n    customer: str,\n    amount: int,\n    due_date: Optional[str] = None,\n    description: Optional[str] = None,\n    line_items: Optional[list[LineItem]] = None,\n    tax: Optional[list[Tax]] = None,\n    currency: Optional[Currency] = None,\n    send_notification: Optional[bool] = None,\n    draft: Optional[bool] = None,\n    has_invoice: Optional[bool] = None,\n    invoice_number: Optional[int] = None,\n    split_code: Optional[str] = None,\n) -&gt; Response:\n    \"\"\"Create a payment request for a transaction on your integration\n\n    Args:\n        customer: Customer id or code\n        amount: Payment request amount. It should be used when line items and tax values aren't specified.\n        due_date: ISO 8601 representation of request due date\n        description: A short description of the payment request\n        line_items: List of line items int the format [{\"name\":\"item 1\", \"amount\":2000, \"quantity\": 1}]\n        tax: List of taxes to be charged in the format [{\"name\":\"VAT\", \"amount\":2000}]\n        currency: Any value from Currency enum. default ``Currency.NGN``\n        send_notification: Indicates whether Paystack sends an email notification to customer. Defaults to ``True``\n        draft: Indicate if request should be saved as draft. Defaults to ``False`` and overrides send_notification\n        has_invoice: Set to ``True`` to create a draft invoice (adds an auto incrementing invoice number\n            if none is provided) even if there are no line_items or tax passed\n        invoice_number: Numeric value of invoice. Invoice will start from 1 and auto increment from there.\n            This field is to help override whatever value Paystack decides. Auto increment for\n            subsequent invoices continue from this point.\n        split_code: The split code of the transaction split. e.g. SPL_98WF13Eb3w\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n    if line_items:\n        line_items = [item.dict for item in line_items]\n    if tax:\n        tax = [unit_tax.dict for unit_tax in tax]\n\n    url = self._parse_url(\"/paymentrequest\")\n\n    payload = {\"customer\": customer, \"amount\": amount}\n    optional_params = [\n        (\"due_date\", due_date),\n        (\"description\", description),\n        (\"line_items\", line_items),\n        (\"tax\", tax),\n        (\"currency\", currency),\n        (\"send_notification\", send_notification),\n        (\"draft\", draft),\n        (\"has_invoice\", has_invoice),\n        (\"invoice_number\", invoice_number),\n        (\"split_code\", split_code),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return await self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/payment_requests/#pypaystack2.api.payment_requests.AsyncPaymentRequest.finalize","title":"<code>finalize(id_or_code)</code>  <code>async</code>","text":"<p>Finalize a draft payment request</p> <p>Parameters:</p> Name Type Description Default <code>id_or_code</code> <code>str</code> <p>Payment Request id or code</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/payment_requests.py</code> <pre><code>async def finalize(self, id_or_code: str) -&gt; Response:\n    \"\"\"Finalize a draft payment request\n\n    Args:\n        id_or_code: Payment Request id or code\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/paymentrequest/finalize/{id_or_code}\")\n    return await self._handle_request(HTTPMethod.POST, url)\n</code></pre>"},{"location":"reference/payment_requests/#pypaystack2.api.payment_requests.AsyncPaymentRequest.get_payment_request","title":"<code>get_payment_request(id_or_code)</code>  <code>async</code>","text":"<p>Get details of a payment request on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>id_or_code</code> <code>str</code> <p>Payment Request id or code</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/payment_requests.py</code> <pre><code>async def get_payment_request(self, id_or_code: str) -&gt; Response:\n    \"\"\"Get details of a payment request on your integration.\n\n    Args:\n        id_or_code: Payment Request id or code\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/paymentrequest/{id_or_code}\")\n    return await self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/payment_requests/#pypaystack2.api.payment_requests.AsyncPaymentRequest.get_payment_requests","title":"<code>get_payment_requests(customer=None, status=None, currency=None, include_archive=False, page=1, pagination=50, start_date=None, end_date=None)</code>  <code>async</code>","text":"<p>Fetches the payment requests available on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>customer</code> <code>Optional[str]</code> <p>Filter by customer ID</p> <code>None</code> <code>status</code> <code>Optional[Status]</code> <p>Filter by payment request status. Any value from enum of <code>Status</code></p> <code>None</code> <code>currency</code> <code>Optional[Currency]</code> <p>Filter by currency. Any value from enum of <code>Currency</code></p> <code>None</code> <code>include_archive</code> <code>bool</code> <p>Show archived payment requests.</p> <code>False</code> <code>page</code> <code>int</code> <p>Specify exactly what payment request you want to page. If not specify we use a default value of 1.</p> <code>1</code> <code>pagination</code> <code>int</code> <p>Specifies how many records you want to retrieve per page. If not specified we use a default value of 50.</p> <code>50</code> <code>start_date</code> <code>Optional[str]</code> <p>A timestamp from which to start listing payment request e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>end_date</code> <code>Optional[str]</code> <p>A timestamp at which to stop listing payment request e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/payment_requests.py</code> <pre><code>async def get_payment_requests(\n    self,\n    customer: Optional[str] = None,\n    status: Optional[Status] = None,\n    currency: Optional[Currency] = None,\n    include_archive: bool = False,\n    page: int = 1,\n    pagination: int = 50,\n    start_date: Optional[str] = None,\n    end_date: Optional[str] = None,\n) -&gt; Response:\n    \"\"\"Fetches the payment requests available on your integration.\n\n    Args:\n        customer: Filter by customer ID\n        status: Filter by payment request status. Any value from enum of ``Status``\n        currency: Filter by currency. Any value from enum of ``Currency``\n        include_archive: Show archived payment requests.\n        page: Specify exactly what payment request you want to page. If not specify we use a default value of 1.\n        pagination: Specifies how many records you want to retrieve per page. If not specified\n            we use a default value of 50.\n        start_date: A timestamp from which to start listing payment request\n            e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        end_date: A timestamp at which to stop listing payment request e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/paymentrequest?perPage={pagination}\")\n    query_params = [\n        (\"customer\", customer),\n        (\"status\", status),\n        (\"currency\", currency),\n        (\"include_archive\", include_archive),\n        (\"page\", page),\n        (\"start_date\", start_date),\n        (\"end_date\", end_date),\n    ]\n    url = append_query_params(query_params, url)\n    return await self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/payment_requests/#pypaystack2.api.payment_requests.AsyncPaymentRequest.get_total","title":"<code>get_total()</code>  <code>async</code>","text":"<p>Get payment requests metric</p> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/payment_requests.py</code> <pre><code>async def get_total(self) -&gt; Response:\n    \"\"\"Get payment requests metric\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(\"/paymentrequest/totals\")\n    return await self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/payment_requests/#pypaystack2.api.payment_requests.AsyncPaymentRequest.send_notification","title":"<code>send_notification(id_or_code)</code>  <code>async</code>","text":"<p>Send notification of a payment request to your customers</p> <p>Parameters:</p> Name Type Description Default <code>id_or_code</code> <code>str</code> <p>Payment Request id or code</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/payment_requests.py</code> <pre><code>async def send_notification(self, id_or_code: str) -&gt; Response:\n    \"\"\"Send notification of a payment request to your customers\n\n    Args:\n        id_or_code: Payment Request id or code\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/paymentrequest/notify/{id_or_code}\")\n    return await self._handle_request(HTTPMethod.POST, url)\n</code></pre>"},{"location":"reference/payment_requests/#pypaystack2.api.payment_requests.AsyncPaymentRequest.update","title":"<code>update(id_or_code, customer, amount, due_date=None, description=None, line_items=None, tax=None, currency=None, send_notification=None, draft=None, invoice_number=None, split_code=None)</code>  <code>async</code>","text":"<p>Update a payment request details on your integration</p> <p>Parameters:</p> Name Type Description Default <code>id_or_code</code> <code>str</code> <p>Payment Request id or code</p> required <code>customer</code> <code>str</code> <p>Customer id or code</p> required <code>amount</code> <code>int</code> <p>Payment request amount. Only useful if line items and tax values are ignored. method will throw a friendly warning in the response if neither is available.</p> required <code>due_date</code> <code>Optional[str]</code> <p>ISO 8601 representation of request due date</p> <code>None</code> <code>description</code> <code>Optional[str]</code> <p>A short description of the payment request</p> <code>None</code> <code>line_items</code> <code>Optional[list[LineItem]]</code> <p>List of line items in the format [{\"name\":\"item 1\", \"amount\":2000}]</p> <code>None</code> <code>tax</code> <code>Optional[list[Tax]]</code> <p>List of taxes to be charged in the format [{\"name\":\"VAT\", \"amount\":2000}]</p> <code>None</code> <code>currency</code> <code>Optional[Currency]</code> <p>Specify the currency of the payment request. Any value from the <code>Currency</code> enum</p> <code>None</code> <code>send_notification</code> <code>Optional[bool]</code> <p>Indicates whether Paystack sends an email notification to customer. Defaults to <code>True</code></p> <code>None</code> <code>draft</code> <code>Optional[bool]</code> <p>Indicate if request should be saved as draft. Defaults to false and overrides send_notification</p> <code>None</code> <code>invoice_number</code> <code>Optional[int]</code> <p>Numeric value of invoice. Invoice will start from 1 and auto increment from there. This field is to help override whatever value Paystack decides. Auto increment for subsequent invoices continue from this point.</p> <code>None</code> <code>split_code</code> <code>Optional[str]</code> <p>The split code of the transaction split. e.g. SPL_98WF13Eb3w</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/payment_requests.py</code> <pre><code>async def update(\n    self,\n    id_or_code: str,\n    customer: str,\n    amount: int,\n    due_date: Optional[str] = None,\n    description: Optional[str] = None,\n    line_items: Optional[list[LineItem]] = None,\n    tax: Optional[list[Tax]] = None,\n    currency: Optional[Currency] = None,\n    send_notification: Optional[bool] = None,\n    draft: Optional[bool] = None,\n    invoice_number: Optional[int] = None,\n    split_code: Optional[str] = None,\n) -&gt; Response:\n    \"\"\"Update a payment request details on your integration\n\n    Args:\n        id_or_code: Payment Request id or code\n        customer: Customer id or code\n        amount: Payment request amount. Only useful if line items and tax values are ignored.\n            method will throw a friendly warning in the response if neither is available.\n        due_date: ISO 8601 representation of request due date\n        description: A short description of the payment request\n        line_items: List of line items in the format [{\"name\":\"item 1\", \"amount\":2000}]\n        tax: List of taxes to be charged in the format [{\"name\":\"VAT\", \"amount\":2000}]\n        currency: Specify the currency of the payment request. Any value from the ``Currency`` enum\n        send_notification: Indicates whether Paystack sends an email notification to customer. Defaults to ``True``\n        draft: Indicate if request should be saved as draft. Defaults to false and overrides send_notification\n        invoice_number: Numeric value of invoice. Invoice will start from 1 and auto increment from there.\n            This field is to help override whatever value Paystack decides. Auto increment for\n            subsequent invoices continue from this point.\n        split_code: The split code of the transaction split. e.g. SPL_98WF13Eb3w\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    amount = validate_amount(amount)\n\n    if line_items:\n        line_items = [item.dict for item in line_items]\n    if tax:\n        tax = [unit_tax.dict for unit_tax in tax]\n\n    url = self._parse_url(f\"/paymentrequest/{id_or_code}\")\n    payload = {\n        \"customer\": customer,\n        \"amount\": amount,\n    }\n    optional_params = [\n        (\"due_date\", due_date),\n        (\"description\", description),\n        (\"line_items\", line_items),\n        (\"tax\", tax),\n        (\"currency\", currency),\n        (\"send_notification\", send_notification),\n        (\"draft\", draft),\n        (\"invoice_number\", invoice_number),\n        (\"split_code\", split_code),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return await self._handle_request(HTTPMethod.PUT, url, payload)\n</code></pre>"},{"location":"reference/payment_requests/#pypaystack2.api.payment_requests.AsyncPaymentRequest.verify","title":"<code>verify(code)</code>  <code>async</code>","text":"<p>Verify details of a payment request on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>Payment Request id or code</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/payment_requests.py</code> <pre><code>async def verify(self, code: str) -&gt; Response:\n    \"\"\"Verify details of a payment request on your integration.\n\n    Args:\n        code: Payment Request id or code\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/paymentrequest/verify/{code}\")\n    return await self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/payment_requests/#pypaystack2.api.payment_requests.PaymentRequest","title":"<code>PaymentRequest</code>","text":"<p>               Bases: <code>BaseAPI</code></p> <p>Provides a wrapper for paystack Payment Requests API</p> <p>The Payment Requests API allows you to manage requests for payment of goods and services. https://paystack.com/docs/api/payment-request/</p> Source code in <code>src/pypaystack2/api/payment_requests.py</code> <pre><code>class PaymentRequest(BaseAPI):\n    \"\"\"Provides a wrapper for paystack Payment Requests API\n\n    The Payment Requests API allows you to manage requests for payment of goods and services.\n    https://paystack.com/docs/api/payment-request/\n    \"\"\"\n\n    def create(\n        self,\n        customer: str,\n        amount: int,\n        due_date: Optional[str] = None,\n        description: Optional[str] = None,\n        line_items: Optional[list[LineItem]] = None,\n        tax: Optional[list[Tax]] = None,\n        currency: Optional[Currency] = None,\n        send_notification: Optional[bool] = None,\n        draft: Optional[bool] = None,\n        has_invoice: Optional[bool] = None,\n        invoice_number: Optional[int] = None,\n        split_code: Optional[str] = None,\n    ) -&gt; Response:\n        \"\"\"Create a payment request for a transaction on your integration\n\n        Args:\n            customer: Customer id or code\n            amount: Payment request amount. It should be used when line items and tax values aren't specified.\n            due_date: ISO 8601 representation of request due date\n            description: A short description of the payment request\n            line_items: List of line items int the format [{\"name\":\"item 1\", \"amount\":2000, \"quantity\": 1}]\n            tax: List of taxes to be charged in the format [{\"name\":\"VAT\", \"amount\":2000}]\n            currency: Any value from Currency enum. default ``Currency.NGN``\n            send_notification: Indicates whether Paystack sends an email notification to customer. Defaults to ``True``\n            draft: Indicate if request should be saved as draft. Defaults to ``False`` and overrides send_notification\n            has_invoice: Set to ``True`` to create a draft invoice (adds an auto-incrementing invoice number\n                if none is provided) even if there are no line_items or tax passed\n            invoice_number: Numeric value of invoice. Invoice will start from 1 and auto increment from there.\n                This field is to help override whatever value Paystack decides. Auto increment for\n                subsequent invoices continue from this point.\n            split_code: The split code of the transaction split. e.g. SPL_98WF13Eb3w\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        if line_items:\n            line_items = [item.dict for item in line_items]\n        if tax:\n            tax = [unit_tax.dict for unit_tax in tax]\n\n        url = self._parse_url(\"/paymentrequest\")\n\n        payload = {\"customer\": customer, \"amount\": amount}\n        optional_params = [\n            (\"due_date\", due_date),\n            (\"description\", description),\n            (\"line_items\", line_items),\n            (\"tax\", tax),\n            (\"currency\", currency),\n            (\"send_notification\", send_notification),\n            (\"draft\", draft),\n            (\"has_invoice\", has_invoice),\n            (\"invoice_number\", invoice_number),\n            (\"split_code\", split_code),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return self._handle_request(HTTPMethod.POST, url, payload)\n\n    def get_payment_requests(\n        self,\n        customer: Optional[str] = None,\n        status: Optional[Status] = None,\n        currency: Optional[Currency] = None,\n        include_archive: bool = False,\n        page: int = 1,\n        pagination: int = 50,\n        start_date: Optional[str] = None,\n        end_date: Optional[str] = None,\n    ) -&gt; Response:\n        \"\"\"Fetches the payment requests available on your integration.\n\n        Args:\n            customer: Filter by customer ID\n            status: Filter by payment request status. Any value from enum of ``Status``\n            currency: Filter by currency. Any value from enum of ``Currency``\n            include_archive: Show archived payment requests.\n            page: Specify exactly what payment request you want to page. If not specified, we use a default value of 1.\n            pagination: Specifies how many records you want to retrieve per page. If not specified,\n                we use a default value of 50.\n            start_date: A timestamp from which to start listing payment requests\n                e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            end_date: A timestamp at which to stop listing payment requests e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/paymentrequest?perPage={pagination}\")\n        query_params = [\n            (\"customer\", customer),\n            (\"status\", status),\n            (\"currency\", currency),\n            (\"include_archive\", include_archive),\n            (\"page\", page),\n            (\"start_date\", start_date),\n            (\"end_date\", end_date),\n        ]\n        url = append_query_params(query_params, url)\n        return self._handle_request(HTTPMethod.GET, url)\n\n    def get_payment_request(self, id_or_code: str) -&gt; Response:\n        \"\"\"Get details of a payment request on your integration\n\n        Args:\n            id_or_code: The payment request ID or code you want to fetch\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/paymentrequest/{id_or_code}\")\n        return self._handle_request(HTTPMethod.GET, url)\n\n    def verify(self, code: str) -&gt; Response:\n        \"\"\"Verify details of a payment request on your integration.\n\n        Args:\n            code: Payment Request id or code\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/paymentrequest/verify/{code}\")\n        return self._handle_request(HTTPMethod.GET, url)\n\n    def send_notification(self, id_or_code: str) -&gt; Response:\n        \"\"\"Send notification of a payment request to your customers\n\n        Args:\n            id_or_code: Payment Request id or code\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/paymentrequest/notify/{id_or_code}\")\n        return self._handle_request(HTTPMethod.POST, url)\n\n    def get_total(self) -&gt; Response:\n        \"\"\"Get payment requests metric\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(\"/paymentrequest/totals\")\n        return self._handle_request(HTTPMethod.GET, url)\n\n    def finalize(self, id_or_code: str) -&gt; Response:\n        \"\"\"Finalize a draft payment request\n\n        Args:\n            id_or_code: Payment Request id or code\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/paymentrequest/finalize/{id_or_code}\")\n        return self._handle_request(HTTPMethod.POST, url)\n\n    def update(\n        self,\n        id_or_code: str,\n        customer: str,\n        amount: int,\n        due_date: Optional[str] = None,\n        description: Optional[str] = None,\n        line_items: Optional[list[LineItem]] = None,\n        tax: Optional[list[Tax]] = None,\n        currency: Optional[Currency] = None,\n        send_notification: Optional[bool] = None,\n        draft: Optional[bool] = None,\n        invoice_number: Optional[int] = None,\n        split_code: Optional[str] = None,\n    ) -&gt; Response:\n        \"\"\"Update the payment request details on your integration\n\n        Args:\n            id_or_code: Payment Request id or code\n            customer: Customer id or code\n            amount: Payment request amount. Only useful if line items and tax values are ignored.\n                method will throw a friendly warning in the response if neither is available.\n            due_date: ISO 8601 representation of request due date\n            description: A short description of the payment request\n            line_items: List of line items in the format [{\"name\":\"item 1\", \"amount\":2000}]\n            tax: List of taxes to be charged in the format [{\"name\":\"VAT\", \"amount\":2000}]\n            currency: Specify the currency of the Payment Request id or code. Any value from the ``Currency`` enum\n            send_notification: Indicates whether Paystack sends an email notification to customer. Defaults to ``True``\n            draft: Indicate if request should be saved as draft. Defaults to false and overrides send_notification\n            invoice_number: Numeric value of invoice. Invoice will start from 1 and auto increment from there.\n                This field is to help override whatever value Paystack decides. Auto increment for\n                subsequent invoices continue from this point.\n            split_code: The split code of the transaction split. e.g. SPL_98WF13Eb3w\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        amount = validate_amount(amount)\n\n        if line_items:\n            line_items = [item.dict for item in line_items]\n        if tax:\n            tax = [unit_tax.dict for unit_tax in tax]\n\n        url = self._parse_url(f\"/paymentrequest/{id_or_code}\")\n        payload = {\n            \"customer\": customer,\n            \"amount\": amount,\n        }\n        optional_params = [\n            (\"due_date\", due_date),\n            (\"description\", description),\n            (\"line_items\", line_items),\n            (\"tax\", tax),\n            (\"currency\", currency),\n            (\"send_notification\", send_notification),\n            (\"draft\", draft),\n            (\"invoice_number\", invoice_number),\n            (\"split_code\", split_code),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return self._handle_request(HTTPMethod.PUT, url, payload)\n\n    def archive(self, id_or_code: str) -&gt; Response:\n        \"\"\"Used to archive a payment request. A payment request will no longer be fetched on list or returned on verify.\n\n        Args:\n            id_or_code: Payment Request id or code\n\n         Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/paymentrequest/archive/{id_or_code}\")\n        return self._handle_request(HTTPMethod.POST, url)\n</code></pre>"},{"location":"reference/payment_requests/#pypaystack2.api.payment_requests.PaymentRequest.archive","title":"<code>archive(id_or_code)</code>","text":"<p>Used to archive a payment request. A payment request will no longer be fetched on list or returned on verify.</p> <p>Parameters:</p> Name Type Description Default <code>id_or_code</code> <code>str</code> <p>Payment Request id or code</p> required <p>Returns:     A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/payment_requests.py</code> <pre><code>def archive(self, id_or_code: str) -&gt; Response:\n    \"\"\"Used to archive a payment request. A payment request will no longer be fetched on list or returned on verify.\n\n    Args:\n        id_or_code: Payment Request id or code\n\n     Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/paymentrequest/archive/{id_or_code}\")\n    return self._handle_request(HTTPMethod.POST, url)\n</code></pre>"},{"location":"reference/payment_requests/#pypaystack2.api.payment_requests.PaymentRequest.create","title":"<code>create(customer, amount, due_date=None, description=None, line_items=None, tax=None, currency=None, send_notification=None, draft=None, has_invoice=None, invoice_number=None, split_code=None)</code>","text":"<p>Create a payment request for a transaction on your integration</p> <p>Parameters:</p> Name Type Description Default <code>customer</code> <code>str</code> <p>Customer id or code</p> required <code>amount</code> <code>int</code> <p>Payment request amount. It should be used when line items and tax values aren't specified.</p> required <code>due_date</code> <code>Optional[str]</code> <p>ISO 8601 representation of request due date</p> <code>None</code> <code>description</code> <code>Optional[str]</code> <p>A short description of the payment request</p> <code>None</code> <code>line_items</code> <code>Optional[list[LineItem]]</code> <p>List of line items int the format [{\"name\":\"item 1\", \"amount\":2000, \"quantity\": 1}]</p> <code>None</code> <code>tax</code> <code>Optional[list[Tax]]</code> <p>List of taxes to be charged in the format [{\"name\":\"VAT\", \"amount\":2000}]</p> <code>None</code> <code>currency</code> <code>Optional[Currency]</code> <p>Any value from Currency enum. default <code>Currency.NGN</code></p> <code>None</code> <code>send_notification</code> <code>Optional[bool]</code> <p>Indicates whether Paystack sends an email notification to customer. Defaults to <code>True</code></p> <code>None</code> <code>draft</code> <code>Optional[bool]</code> <p>Indicate if request should be saved as draft. Defaults to <code>False</code> and overrides send_notification</p> <code>None</code> <code>has_invoice</code> <code>Optional[bool]</code> <p>Set to <code>True</code> to create a draft invoice (adds an auto-incrementing invoice number if none is provided) even if there are no line_items or tax passed</p> <code>None</code> <code>invoice_number</code> <code>Optional[int]</code> <p>Numeric value of invoice. Invoice will start from 1 and auto increment from there. This field is to help override whatever value Paystack decides. Auto increment for subsequent invoices continue from this point.</p> <code>None</code> <code>split_code</code> <code>Optional[str]</code> <p>The split code of the transaction split. e.g. SPL_98WF13Eb3w</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/payment_requests.py</code> <pre><code>def create(\n    self,\n    customer: str,\n    amount: int,\n    due_date: Optional[str] = None,\n    description: Optional[str] = None,\n    line_items: Optional[list[LineItem]] = None,\n    tax: Optional[list[Tax]] = None,\n    currency: Optional[Currency] = None,\n    send_notification: Optional[bool] = None,\n    draft: Optional[bool] = None,\n    has_invoice: Optional[bool] = None,\n    invoice_number: Optional[int] = None,\n    split_code: Optional[str] = None,\n) -&gt; Response:\n    \"\"\"Create a payment request for a transaction on your integration\n\n    Args:\n        customer: Customer id or code\n        amount: Payment request amount. It should be used when line items and tax values aren't specified.\n        due_date: ISO 8601 representation of request due date\n        description: A short description of the payment request\n        line_items: List of line items int the format [{\"name\":\"item 1\", \"amount\":2000, \"quantity\": 1}]\n        tax: List of taxes to be charged in the format [{\"name\":\"VAT\", \"amount\":2000}]\n        currency: Any value from Currency enum. default ``Currency.NGN``\n        send_notification: Indicates whether Paystack sends an email notification to customer. Defaults to ``True``\n        draft: Indicate if request should be saved as draft. Defaults to ``False`` and overrides send_notification\n        has_invoice: Set to ``True`` to create a draft invoice (adds an auto-incrementing invoice number\n            if none is provided) even if there are no line_items or tax passed\n        invoice_number: Numeric value of invoice. Invoice will start from 1 and auto increment from there.\n            This field is to help override whatever value Paystack decides. Auto increment for\n            subsequent invoices continue from this point.\n        split_code: The split code of the transaction split. e.g. SPL_98WF13Eb3w\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    if line_items:\n        line_items = [item.dict for item in line_items]\n    if tax:\n        tax = [unit_tax.dict for unit_tax in tax]\n\n    url = self._parse_url(\"/paymentrequest\")\n\n    payload = {\"customer\": customer, \"amount\": amount}\n    optional_params = [\n        (\"due_date\", due_date),\n        (\"description\", description),\n        (\"line_items\", line_items),\n        (\"tax\", tax),\n        (\"currency\", currency),\n        (\"send_notification\", send_notification),\n        (\"draft\", draft),\n        (\"has_invoice\", has_invoice),\n        (\"invoice_number\", invoice_number),\n        (\"split_code\", split_code),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/payment_requests/#pypaystack2.api.payment_requests.PaymentRequest.finalize","title":"<code>finalize(id_or_code)</code>","text":"<p>Finalize a draft payment request</p> <p>Parameters:</p> Name Type Description Default <code>id_or_code</code> <code>str</code> <p>Payment Request id or code</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/payment_requests.py</code> <pre><code>def finalize(self, id_or_code: str) -&gt; Response:\n    \"\"\"Finalize a draft payment request\n\n    Args:\n        id_or_code: Payment Request id or code\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/paymentrequest/finalize/{id_or_code}\")\n    return self._handle_request(HTTPMethod.POST, url)\n</code></pre>"},{"location":"reference/payment_requests/#pypaystack2.api.payment_requests.PaymentRequest.get_payment_request","title":"<code>get_payment_request(id_or_code)</code>","text":"<p>Get details of a payment request on your integration</p> <p>Parameters:</p> Name Type Description Default <code>id_or_code</code> <code>str</code> <p>The payment request ID or code you want to fetch</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/payment_requests.py</code> <pre><code>def get_payment_request(self, id_or_code: str) -&gt; Response:\n    \"\"\"Get details of a payment request on your integration\n\n    Args:\n        id_or_code: The payment request ID or code you want to fetch\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/paymentrequest/{id_or_code}\")\n    return self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/payment_requests/#pypaystack2.api.payment_requests.PaymentRequest.get_payment_requests","title":"<code>get_payment_requests(customer=None, status=None, currency=None, include_archive=False, page=1, pagination=50, start_date=None, end_date=None)</code>","text":"<p>Fetches the payment requests available on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>customer</code> <code>Optional[str]</code> <p>Filter by customer ID</p> <code>None</code> <code>status</code> <code>Optional[Status]</code> <p>Filter by payment request status. Any value from enum of <code>Status</code></p> <code>None</code> <code>currency</code> <code>Optional[Currency]</code> <p>Filter by currency. Any value from enum of <code>Currency</code></p> <code>None</code> <code>include_archive</code> <code>bool</code> <p>Show archived payment requests.</p> <code>False</code> <code>page</code> <code>int</code> <p>Specify exactly what payment request you want to page. If not specified, we use a default value of 1.</p> <code>1</code> <code>pagination</code> <code>int</code> <p>Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50.</p> <code>50</code> <code>start_date</code> <code>Optional[str]</code> <p>A timestamp from which to start listing payment requests e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>end_date</code> <code>Optional[str]</code> <p>A timestamp at which to stop listing payment requests e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/payment_requests.py</code> <pre><code>def get_payment_requests(\n    self,\n    customer: Optional[str] = None,\n    status: Optional[Status] = None,\n    currency: Optional[Currency] = None,\n    include_archive: bool = False,\n    page: int = 1,\n    pagination: int = 50,\n    start_date: Optional[str] = None,\n    end_date: Optional[str] = None,\n) -&gt; Response:\n    \"\"\"Fetches the payment requests available on your integration.\n\n    Args:\n        customer: Filter by customer ID\n        status: Filter by payment request status. Any value from enum of ``Status``\n        currency: Filter by currency. Any value from enum of ``Currency``\n        include_archive: Show archived payment requests.\n        page: Specify exactly what payment request you want to page. If not specified, we use a default value of 1.\n        pagination: Specifies how many records you want to retrieve per page. If not specified,\n            we use a default value of 50.\n        start_date: A timestamp from which to start listing payment requests\n            e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        end_date: A timestamp at which to stop listing payment requests e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/paymentrequest?perPage={pagination}\")\n    query_params = [\n        (\"customer\", customer),\n        (\"status\", status),\n        (\"currency\", currency),\n        (\"include_archive\", include_archive),\n        (\"page\", page),\n        (\"start_date\", start_date),\n        (\"end_date\", end_date),\n    ]\n    url = append_query_params(query_params, url)\n    return self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/payment_requests/#pypaystack2.api.payment_requests.PaymentRequest.get_total","title":"<code>get_total()</code>","text":"<p>Get payment requests metric</p> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/payment_requests.py</code> <pre><code>def get_total(self) -&gt; Response:\n    \"\"\"Get payment requests metric\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(\"/paymentrequest/totals\")\n    return self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/payment_requests/#pypaystack2.api.payment_requests.PaymentRequest.send_notification","title":"<code>send_notification(id_or_code)</code>","text":"<p>Send notification of a payment request to your customers</p> <p>Parameters:</p> Name Type Description Default <code>id_or_code</code> <code>str</code> <p>Payment Request id or code</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/payment_requests.py</code> <pre><code>def send_notification(self, id_or_code: str) -&gt; Response:\n    \"\"\"Send notification of a payment request to your customers\n\n    Args:\n        id_or_code: Payment Request id or code\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/paymentrequest/notify/{id_or_code}\")\n    return self._handle_request(HTTPMethod.POST, url)\n</code></pre>"},{"location":"reference/payment_requests/#pypaystack2.api.payment_requests.PaymentRequest.update","title":"<code>update(id_or_code, customer, amount, due_date=None, description=None, line_items=None, tax=None, currency=None, send_notification=None, draft=None, invoice_number=None, split_code=None)</code>","text":"<p>Update the payment request details on your integration</p> <p>Parameters:</p> Name Type Description Default <code>id_or_code</code> <code>str</code> <p>Payment Request id or code</p> required <code>customer</code> <code>str</code> <p>Customer id or code</p> required <code>amount</code> <code>int</code> <p>Payment request amount. Only useful if line items and tax values are ignored. method will throw a friendly warning in the response if neither is available.</p> required <code>due_date</code> <code>Optional[str]</code> <p>ISO 8601 representation of request due date</p> <code>None</code> <code>description</code> <code>Optional[str]</code> <p>A short description of the payment request</p> <code>None</code> <code>line_items</code> <code>Optional[list[LineItem]]</code> <p>List of line items in the format [{\"name\":\"item 1\", \"amount\":2000}]</p> <code>None</code> <code>tax</code> <code>Optional[list[Tax]]</code> <p>List of taxes to be charged in the format [{\"name\":\"VAT\", \"amount\":2000}]</p> <code>None</code> <code>currency</code> <code>Optional[Currency]</code> <p>Specify the currency of the Payment Request id or code. Any value from the <code>Currency</code> enum</p> <code>None</code> <code>send_notification</code> <code>Optional[bool]</code> <p>Indicates whether Paystack sends an email notification to customer. Defaults to <code>True</code></p> <code>None</code> <code>draft</code> <code>Optional[bool]</code> <p>Indicate if request should be saved as draft. Defaults to false and overrides send_notification</p> <code>None</code> <code>invoice_number</code> <code>Optional[int]</code> <p>Numeric value of invoice. Invoice will start from 1 and auto increment from there. This field is to help override whatever value Paystack decides. Auto increment for subsequent invoices continue from this point.</p> <code>None</code> <code>split_code</code> <code>Optional[str]</code> <p>The split code of the transaction split. e.g. SPL_98WF13Eb3w</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/payment_requests.py</code> <pre><code>def update(\n    self,\n    id_or_code: str,\n    customer: str,\n    amount: int,\n    due_date: Optional[str] = None,\n    description: Optional[str] = None,\n    line_items: Optional[list[LineItem]] = None,\n    tax: Optional[list[Tax]] = None,\n    currency: Optional[Currency] = None,\n    send_notification: Optional[bool] = None,\n    draft: Optional[bool] = None,\n    invoice_number: Optional[int] = None,\n    split_code: Optional[str] = None,\n) -&gt; Response:\n    \"\"\"Update the payment request details on your integration\n\n    Args:\n        id_or_code: Payment Request id or code\n        customer: Customer id or code\n        amount: Payment request amount. Only useful if line items and tax values are ignored.\n            method will throw a friendly warning in the response if neither is available.\n        due_date: ISO 8601 representation of request due date\n        description: A short description of the payment request\n        line_items: List of line items in the format [{\"name\":\"item 1\", \"amount\":2000}]\n        tax: List of taxes to be charged in the format [{\"name\":\"VAT\", \"amount\":2000}]\n        currency: Specify the currency of the Payment Request id or code. Any value from the ``Currency`` enum\n        send_notification: Indicates whether Paystack sends an email notification to customer. Defaults to ``True``\n        draft: Indicate if request should be saved as draft. Defaults to false and overrides send_notification\n        invoice_number: Numeric value of invoice. Invoice will start from 1 and auto increment from there.\n            This field is to help override whatever value Paystack decides. Auto increment for\n            subsequent invoices continue from this point.\n        split_code: The split code of the transaction split. e.g. SPL_98WF13Eb3w\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    amount = validate_amount(amount)\n\n    if line_items:\n        line_items = [item.dict for item in line_items]\n    if tax:\n        tax = [unit_tax.dict for unit_tax in tax]\n\n    url = self._parse_url(f\"/paymentrequest/{id_or_code}\")\n    payload = {\n        \"customer\": customer,\n        \"amount\": amount,\n    }\n    optional_params = [\n        (\"due_date\", due_date),\n        (\"description\", description),\n        (\"line_items\", line_items),\n        (\"tax\", tax),\n        (\"currency\", currency),\n        (\"send_notification\", send_notification),\n        (\"draft\", draft),\n        (\"invoice_number\", invoice_number),\n        (\"split_code\", split_code),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return self._handle_request(HTTPMethod.PUT, url, payload)\n</code></pre>"},{"location":"reference/payment_requests/#pypaystack2.api.payment_requests.PaymentRequest.verify","title":"<code>verify(code)</code>","text":"<p>Verify details of a payment request on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>Payment Request id or code</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/payment_requests.py</code> <pre><code>def verify(self, code: str) -&gt; Response:\n    \"\"\"Verify details of a payment request on your integration.\n\n    Args:\n        code: Payment Request id or code\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/paymentrequest/verify/{code}\")\n    return self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/plans/","title":"Plans","text":""},{"location":"reference/plans/#pypaystack2.api.plans.AsyncPlan","title":"<code>AsyncPlan</code>","text":"<p>               Bases: <code>BaseAsyncAPI</code></p> <p>Provides a wrapper for paystack Plans API</p> <p>The Plans API allows you to create and manage installment payment options on your integration. https://paystack.com/docs/api/plan/</p> Source code in <code>src/pypaystack2/api/plans.py</code> <pre><code>class AsyncPlan(BaseAsyncAPI):\n    \"\"\"Provides a wrapper for paystack Plans API\n\n    The Plans API allows you to create and manage installment payment options on your integration.\n    https://paystack.com/docs/api/plan/\n    \"\"\"\n\n    async def create(\n        self,\n        name: str,\n        amount: int,\n        interval: Interval,\n        description: Optional[str] = None,\n        currency: Optional[Currency] = None,\n        invoice_limit: Optional[int] = None,\n        send_invoices: bool = False,\n        send_sms: bool = False,\n    ) -&gt; Response:\n        \"\"\"Create a plan on your integration\n\n        Args:\n            name: Name of plan\n            amount: Amount should be in kobo if currency is ``Currency.NGN``, pesewas,\n                if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR``\n            interval: Any value from the ``Interval`` enum.\n            description: A description for this plan\n            currency: Currency in which amount is set. Any of the value from\n                the ``Currency`` enum\n            invoice_limit: Number of invoices to raise during subscription to this plan.\n                Can be overridden by specifying an ``invoice_limit`` while subscribing\n            send_invoices: Set to ``False`` if you don't want invoices to be sent to your customers\n            send_sms: Set to ``False`` if you don't want text messages to be sent to your customers\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        interval = validate_interval(interval)\n        amount = validate_amount(amount)\n\n        url = self._parse_url(\"/plan/\")\n\n        payload = {\n            \"name\": name,\n            \"amount\": amount,\n            \"interval\": interval,\n        }\n        optional_params = [\n            (\"send_invoices\", send_invoices),\n            (\"send_sms\", send_sms),\n            (\"description\", description),\n            (\"currency\", currency),\n            (\"invoice_limit\", invoice_limit),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return await self._handle_request(HTTPMethod.POST, url, payload)\n\n    async def get_plans(\n        self,\n        page: int = 1,\n        pagination: int = 50,\n        status: Optional[Status] = None,\n        interval: Optional[Interval] = None,\n        amount: Optional[int] = None,\n    ) -&gt; Response:\n        \"\"\"Fetch plans available on your integration.\n\n        Args:\n            page: Specifies exactly what page you want to retrieve.\n                If not specified we use a default value of 1.\n            pagination: Specifies how many records you want to retrieve per page.\n                If not specified we use a default value of 50.\n            status: Filter list by plans with specified status\n            interval: Filter list by plans with specified interval\n            amount: Filter list by plans with specified amount ( kobo if currency\n                is ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``,\n                and cents, if currency is ``Currency.ZAR``)\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        if amount:\n            amount = validate_amount(amount)\n\n        url = self._parse_url(f\"/plan/?perPage={pagination}\")\n        query_params = [\n            (\"page\", page),\n            (\"status\", status),\n            (\"interval\", interval),\n            (\"amount\", amount),\n        ]\n        url = append_query_params(query_params, url)\n        return await self._handle_request(HTTPMethod.GET, url)\n\n    async def get_plan(self, id_or_code: str) -&gt; Response:\n        \"\"\"Get details of a plan on your integration.\n\n        Args:\n            id_or_code: The plan ``ID`` or ``code`` you want to fetch\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._parse_url(\"/plan/{}/\".format(id_or_code))\n        return await self._handle_request(HTTPMethod.GET, url)\n\n    async def update(\n        self,\n        id_or_code: str,\n        name: Optional[str] = None,\n        amount: Optional[int] = None,\n        interval: Optional[Interval] = None,\n        description: Optional[str] = None,\n        currency: Optional[Currency] = None,\n        invoice_limit: Optional[int] = None,\n        send_invoices: bool = False,\n        send_sms: bool = False,\n    ) -&gt; Response:\n        \"\"\"\n\n        Args:\n            id_or_code: Plan's ID or code\n            name: Name of plan\n            amount: Amount should be in kobo if currency is\n                ``Currency.NGN`` and pesewas for ``Currency.GHS``\n            interval: Any value from the ``Interval`` enum.\n            description: A description for this plan.\n            currency: Any value from the ``Currency`` enum.\n            invoice_limit: Number of invoices to raise during subscription to this plan.\n                Can be overridden by specifying an ``invoice_limit`` while subscribing.\n            send_invoices: Set to ``False`` if you don't want invoices\n                to be sent to your customers\n            send_sms: Set to ``False`` if you don't want text messages to\n                be sent to your customers\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        interval = validate_interval(interval)\n        amount = validate_amount(amount)\n\n        url = self._parse_url(\"/plan/{}/\".format(id_or_code))\n        payload = {\n            \"name\": name,\n            \"amount\": amount,\n            \"interval\": interval,\n        }\n\n        optional_params = [\n            (\"send_invoices\", send_invoices),\n            (\"send_sms\", send_sms),\n            (\"description\", description),\n            (\"currency\", currency),\n            (\"invoice_limit\", invoice_limit),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return await self._handle_request(HTTPMethod.PUT, url, payload)\n</code></pre>"},{"location":"reference/plans/#pypaystack2.api.plans.AsyncPlan.create","title":"<code>create(name, amount, interval, description=None, currency=None, invoice_limit=None, send_invoices=False, send_sms=False)</code>  <code>async</code>","text":"<p>Create a plan on your integration</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of plan</p> required <code>amount</code> <code>int</code> <p>Amount should be in kobo if currency is <code>Currency.NGN</code>, pesewas, if currency is <code>Currency.GHS</code>, and cents, if currency is <code>Currency.ZAR</code></p> required <code>interval</code> <code>Interval</code> <p>Any value from the <code>Interval</code> enum.</p> required <code>description</code> <code>Optional[str]</code> <p>A description for this plan</p> <code>None</code> <code>currency</code> <code>Optional[Currency]</code> <p>Currency in which amount is set. Any of the value from the <code>Currency</code> enum</p> <code>None</code> <code>invoice_limit</code> <code>Optional[int]</code> <p>Number of invoices to raise during subscription to this plan. Can be overridden by specifying an <code>invoice_limit</code> while subscribing</p> <code>None</code> <code>send_invoices</code> <code>bool</code> <p>Set to <code>False</code> if you don't want invoices to be sent to your customers</p> <code>False</code> <code>send_sms</code> <code>bool</code> <p>Set to <code>False</code> if you don't want text messages to be sent to your customers</p> <code>False</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/plans.py</code> <pre><code>async def create(\n    self,\n    name: str,\n    amount: int,\n    interval: Interval,\n    description: Optional[str] = None,\n    currency: Optional[Currency] = None,\n    invoice_limit: Optional[int] = None,\n    send_invoices: bool = False,\n    send_sms: bool = False,\n) -&gt; Response:\n    \"\"\"Create a plan on your integration\n\n    Args:\n        name: Name of plan\n        amount: Amount should be in kobo if currency is ``Currency.NGN``, pesewas,\n            if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR``\n        interval: Any value from the ``Interval`` enum.\n        description: A description for this plan\n        currency: Currency in which amount is set. Any of the value from\n            the ``Currency`` enum\n        invoice_limit: Number of invoices to raise during subscription to this plan.\n            Can be overridden by specifying an ``invoice_limit`` while subscribing\n        send_invoices: Set to ``False`` if you don't want invoices to be sent to your customers\n        send_sms: Set to ``False`` if you don't want text messages to be sent to your customers\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    interval = validate_interval(interval)\n    amount = validate_amount(amount)\n\n    url = self._parse_url(\"/plan/\")\n\n    payload = {\n        \"name\": name,\n        \"amount\": amount,\n        \"interval\": interval,\n    }\n    optional_params = [\n        (\"send_invoices\", send_invoices),\n        (\"send_sms\", send_sms),\n        (\"description\", description),\n        (\"currency\", currency),\n        (\"invoice_limit\", invoice_limit),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return await self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/plans/#pypaystack2.api.plans.AsyncPlan.get_plan","title":"<code>get_plan(id_or_code)</code>  <code>async</code>","text":"<p>Get details of a plan on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>id_or_code</code> <code>str</code> <p>The plan <code>ID</code> or <code>code</code> you want to fetch</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/plans.py</code> <pre><code>async def get_plan(self, id_or_code: str) -&gt; Response:\n    \"\"\"Get details of a plan on your integration.\n\n    Args:\n        id_or_code: The plan ``ID`` or ``code`` you want to fetch\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._parse_url(\"/plan/{}/\".format(id_or_code))\n    return await self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/plans/#pypaystack2.api.plans.AsyncPlan.get_plans","title":"<code>get_plans(page=1, pagination=50, status=None, interval=None, amount=None)</code>  <code>async</code>","text":"<p>Fetch plans available on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>int</code> <p>Specifies exactly what page you want to retrieve. If not specified we use a default value of 1.</p> <code>1</code> <code>pagination</code> <code>int</code> <p>Specifies how many records you want to retrieve per page. If not specified we use a default value of 50.</p> <code>50</code> <code>status</code> <code>Optional[Status]</code> <p>Filter list by plans with specified status</p> <code>None</code> <code>interval</code> <code>Optional[Interval]</code> <p>Filter list by plans with specified interval</p> <code>None</code> <code>amount</code> <code>Optional[int]</code> <p>Filter list by plans with specified amount ( kobo if currency is <code>Currency.NGN</code>, pesewas, if currency is <code>Currency.GHS</code>, and cents, if currency is <code>Currency.ZAR</code>)</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/plans.py</code> <pre><code>async def get_plans(\n    self,\n    page: int = 1,\n    pagination: int = 50,\n    status: Optional[Status] = None,\n    interval: Optional[Interval] = None,\n    amount: Optional[int] = None,\n) -&gt; Response:\n    \"\"\"Fetch plans available on your integration.\n\n    Args:\n        page: Specifies exactly what page you want to retrieve.\n            If not specified we use a default value of 1.\n        pagination: Specifies how many records you want to retrieve per page.\n            If not specified we use a default value of 50.\n        status: Filter list by plans with specified status\n        interval: Filter list by plans with specified interval\n        amount: Filter list by plans with specified amount ( kobo if currency\n            is ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``,\n            and cents, if currency is ``Currency.ZAR``)\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    if amount:\n        amount = validate_amount(amount)\n\n    url = self._parse_url(f\"/plan/?perPage={pagination}\")\n    query_params = [\n        (\"page\", page),\n        (\"status\", status),\n        (\"interval\", interval),\n        (\"amount\", amount),\n    ]\n    url = append_query_params(query_params, url)\n    return await self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/plans/#pypaystack2.api.plans.AsyncPlan.update","title":"<code>update(id_or_code, name=None, amount=None, interval=None, description=None, currency=None, invoice_limit=None, send_invoices=False, send_sms=False)</code>  <code>async</code>","text":"<p>Parameters:</p> Name Type Description Default <code>id_or_code</code> <code>str</code> <p>Plan's ID or code</p> required <code>name</code> <code>Optional[str]</code> <p>Name of plan</p> <code>None</code> <code>amount</code> <code>Optional[int]</code> <p>Amount should be in kobo if currency is <code>Currency.NGN</code> and pesewas for <code>Currency.GHS</code></p> <code>None</code> <code>interval</code> <code>Optional[Interval]</code> <p>Any value from the <code>Interval</code> enum.</p> <code>None</code> <code>description</code> <code>Optional[str]</code> <p>A description for this plan.</p> <code>None</code> <code>currency</code> <code>Optional[Currency]</code> <p>Any value from the <code>Currency</code> enum.</p> <code>None</code> <code>invoice_limit</code> <code>Optional[int]</code> <p>Number of invoices to raise during subscription to this plan. Can be overridden by specifying an <code>invoice_limit</code> while subscribing.</p> <code>None</code> <code>send_invoices</code> <code>bool</code> <p>Set to <code>False</code> if you don't want invoices to be sent to your customers</p> <code>False</code> <code>send_sms</code> <code>bool</code> <p>Set to <code>False</code> if you don't want text messages to be sent to your customers</p> <code>False</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/plans.py</code> <pre><code>async def update(\n    self,\n    id_or_code: str,\n    name: Optional[str] = None,\n    amount: Optional[int] = None,\n    interval: Optional[Interval] = None,\n    description: Optional[str] = None,\n    currency: Optional[Currency] = None,\n    invoice_limit: Optional[int] = None,\n    send_invoices: bool = False,\n    send_sms: bool = False,\n) -&gt; Response:\n    \"\"\"\n\n    Args:\n        id_or_code: Plan's ID or code\n        name: Name of plan\n        amount: Amount should be in kobo if currency is\n            ``Currency.NGN`` and pesewas for ``Currency.GHS``\n        interval: Any value from the ``Interval`` enum.\n        description: A description for this plan.\n        currency: Any value from the ``Currency`` enum.\n        invoice_limit: Number of invoices to raise during subscription to this plan.\n            Can be overridden by specifying an ``invoice_limit`` while subscribing.\n        send_invoices: Set to ``False`` if you don't want invoices\n            to be sent to your customers\n        send_sms: Set to ``False`` if you don't want text messages to\n            be sent to your customers\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    interval = validate_interval(interval)\n    amount = validate_amount(amount)\n\n    url = self._parse_url(\"/plan/{}/\".format(id_or_code))\n    payload = {\n        \"name\": name,\n        \"amount\": amount,\n        \"interval\": interval,\n    }\n\n    optional_params = [\n        (\"send_invoices\", send_invoices),\n        (\"send_sms\", send_sms),\n        (\"description\", description),\n        (\"currency\", currency),\n        (\"invoice_limit\", invoice_limit),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return await self._handle_request(HTTPMethod.PUT, url, payload)\n</code></pre>"},{"location":"reference/plans/#pypaystack2.api.plans.Plan","title":"<code>Plan</code>","text":"<p>               Bases: <code>BaseAPI</code></p> <p>Provides a wrapper for paystack Plans API</p> <p>The Plans API allows you to create and manage installment payment options on your integration. https://paystack.com/docs/api/plan/</p> Source code in <code>src/pypaystack2/api/plans.py</code> <pre><code>class Plan(BaseAPI):\n    \"\"\"Provides a wrapper for paystack Plans API\n\n    The Plans API allows you to create and manage installment payment options on your integration.\n    https://paystack.com/docs/api/plan/\n    \"\"\"\n\n    def create(\n        self,\n        name: str,\n        amount: int,\n        interval: Interval,\n        description: Optional[str] = None,\n        currency: Optional[Currency] = None,\n        invoice_limit: Optional[int] = None,\n        send_invoices: bool = False,\n        send_sms: bool = False,\n    ) -&gt; Response:\n        \"\"\"Create a plan on your integration\n\n        Args:\n            name: Name of plan\n            amount: Amount should be in kobo if currency is ``Currency.NGN``, pesewas,\n                if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR``\n            interval: Any value from the ``Interval`` enum.\n            description: A description for this plan\n            currency: Currency in which amount is set. Any of the value from\n                the ``Currency`` enum\n            invoice_limit: Number of invoices to raise during subscription to this plan.\n                Can be overridden by specifying an ``invoice_limit`` while subscribing\n            send_invoices: Set to ``False`` if you don't want invoices to be sent to your customers\n            send_sms: Set to ``False`` if you don't want text messages to be sent to your customers\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        interval = validate_interval(interval)\n        amount = validate_amount(amount)\n\n        url = self._parse_url(\"/plan/\")\n\n        payload = {\n            \"name\": name,\n            \"amount\": amount,\n            \"interval\": interval,\n        }\n        optional_params = [\n            (\"send_invoices\", send_invoices),\n            (\"send_sms\", send_sms),\n            (\"description\", description),\n            (\"currency\", currency),\n            (\"invoice_limit\", invoice_limit),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return self._handle_request(HTTPMethod.POST, url, payload)\n\n    def get_plans(\n        self,\n        page: int = 1,\n        pagination: int = 50,\n        status: Optional[Status] = None,\n        interval: Optional[Interval] = None,\n        amount: Optional[int] = None,\n    ) -&gt; Response:\n        \"\"\"Fetch plans available on your integration.\n\n        Args:\n            page: Specifies exactly what page you want to retrieve.\n                If not specified, we use a default value of 1.\n            pagination: Specifies how many records you want to retrieve per page.\n                If not specified, we use a default value of 50.\n            status: Filter list by plans with specified status\n            interval: Filter list by plans with specified interval\n            amount: Filter list by plans with specified amount ( kobo if currency\n                is ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``,\n                and cents, if currency is ``Currency.ZAR``)\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        if amount:\n            amount = validate_amount(amount)\n\n        url = self._parse_url(f\"/plan/?perPage={pagination}\")\n        query_params = [\n            (\"page\", page),\n            (\"status\", status),\n            (\"interval\", interval),\n            (\"amount\", amount),\n        ]\n        url = append_query_params(query_params, url)\n        return self._handle_request(HTTPMethod.GET, url)\n\n    def get_plan(self, id_or_code: str) -&gt; Response:\n        \"\"\"Get details of a plan on your integration.\n\n        Args:\n            id_or_code: The plan ``ID`` or ``code`` you want to fetch\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._parse_url(\"/plan/{}/\".format(id_or_code))\n        return self._handle_request(HTTPMethod.GET, url)\n\n    def update(\n        self,\n        id_or_code: str,\n        name: Optional[str],\n        amount: Optional[int],\n        interval: Optional[Interval],\n        description: Optional[str] = None,\n        currency: Optional[Currency] = None,\n        invoice_limit: Optional[int] = None,\n        send_invoices: bool = False,\n        send_sms: bool = False,\n    ) -&gt; Response:\n        \"\"\"\n\n        Args:\n            id_or_code: Plan's ID or code\n            name: Name of plan\n            amount: Amount should be in kobo if currency is\n                ``Currency.NGN`` and pesewas for ``Currency.GHS``\n            interval: Any value from the ``Interval`` enum.\n            description: A description for this plan.\n            currency: Any value from the ``Currency`` enum.\n            invoice_limit: Number of invoices to raise during subscription to this plan.\n                Can be overridden by specifying an ``invoice_limit`` while subscribing.\n            send_invoices: Set to ``False`` if you don't want invoices\n                to be sent to your customers\n            send_sms: Set to ``False`` if you don't want text messages to\n                be sent to your customers\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        interval = validate_interval(interval)\n        amount = validate_amount(amount)\n\n        url = self._parse_url(\"/plan/{}/\".format(id_or_code))\n        payload = {\n            \"name\": name,\n            \"amount\": amount,\n            \"interval\": interval,\n        }\n\n        optional_params = [\n            (\"send_invoices\", send_invoices),\n            (\"send_sms\", send_sms),\n            (\"description\", description),\n            (\"currency\", currency),\n            (\"invoice_limit\", invoice_limit),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return self._handle_request(HTTPMethod.PUT, url, payload)\n</code></pre>"},{"location":"reference/plans/#pypaystack2.api.plans.Plan.create","title":"<code>create(name, amount, interval, description=None, currency=None, invoice_limit=None, send_invoices=False, send_sms=False)</code>","text":"<p>Create a plan on your integration</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of plan</p> required <code>amount</code> <code>int</code> <p>Amount should be in kobo if currency is <code>Currency.NGN</code>, pesewas, if currency is <code>Currency.GHS</code>, and cents, if currency is <code>Currency.ZAR</code></p> required <code>interval</code> <code>Interval</code> <p>Any value from the <code>Interval</code> enum.</p> required <code>description</code> <code>Optional[str]</code> <p>A description for this plan</p> <code>None</code> <code>currency</code> <code>Optional[Currency]</code> <p>Currency in which amount is set. Any of the value from the <code>Currency</code> enum</p> <code>None</code> <code>invoice_limit</code> <code>Optional[int]</code> <p>Number of invoices to raise during subscription to this plan. Can be overridden by specifying an <code>invoice_limit</code> while subscribing</p> <code>None</code> <code>send_invoices</code> <code>bool</code> <p>Set to <code>False</code> if you don't want invoices to be sent to your customers</p> <code>False</code> <code>send_sms</code> <code>bool</code> <p>Set to <code>False</code> if you don't want text messages to be sent to your customers</p> <code>False</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/plans.py</code> <pre><code>def create(\n    self,\n    name: str,\n    amount: int,\n    interval: Interval,\n    description: Optional[str] = None,\n    currency: Optional[Currency] = None,\n    invoice_limit: Optional[int] = None,\n    send_invoices: bool = False,\n    send_sms: bool = False,\n) -&gt; Response:\n    \"\"\"Create a plan on your integration\n\n    Args:\n        name: Name of plan\n        amount: Amount should be in kobo if currency is ``Currency.NGN``, pesewas,\n            if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR``\n        interval: Any value from the ``Interval`` enum.\n        description: A description for this plan\n        currency: Currency in which amount is set. Any of the value from\n            the ``Currency`` enum\n        invoice_limit: Number of invoices to raise during subscription to this plan.\n            Can be overridden by specifying an ``invoice_limit`` while subscribing\n        send_invoices: Set to ``False`` if you don't want invoices to be sent to your customers\n        send_sms: Set to ``False`` if you don't want text messages to be sent to your customers\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    interval = validate_interval(interval)\n    amount = validate_amount(amount)\n\n    url = self._parse_url(\"/plan/\")\n\n    payload = {\n        \"name\": name,\n        \"amount\": amount,\n        \"interval\": interval,\n    }\n    optional_params = [\n        (\"send_invoices\", send_invoices),\n        (\"send_sms\", send_sms),\n        (\"description\", description),\n        (\"currency\", currency),\n        (\"invoice_limit\", invoice_limit),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/plans/#pypaystack2.api.plans.Plan.get_plan","title":"<code>get_plan(id_or_code)</code>","text":"<p>Get details of a plan on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>id_or_code</code> <code>str</code> <p>The plan <code>ID</code> or <code>code</code> you want to fetch</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/plans.py</code> <pre><code>def get_plan(self, id_or_code: str) -&gt; Response:\n    \"\"\"Get details of a plan on your integration.\n\n    Args:\n        id_or_code: The plan ``ID`` or ``code`` you want to fetch\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._parse_url(\"/plan/{}/\".format(id_or_code))\n    return self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/plans/#pypaystack2.api.plans.Plan.get_plans","title":"<code>get_plans(page=1, pagination=50, status=None, interval=None, amount=None)</code>","text":"<p>Fetch plans available on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>int</code> <p>Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1.</p> <code>1</code> <code>pagination</code> <code>int</code> <p>Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50.</p> <code>50</code> <code>status</code> <code>Optional[Status]</code> <p>Filter list by plans with specified status</p> <code>None</code> <code>interval</code> <code>Optional[Interval]</code> <p>Filter list by plans with specified interval</p> <code>None</code> <code>amount</code> <code>Optional[int]</code> <p>Filter list by plans with specified amount ( kobo if currency is <code>Currency.NGN</code>, pesewas, if currency is <code>Currency.GHS</code>, and cents, if currency is <code>Currency.ZAR</code>)</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/plans.py</code> <pre><code>def get_plans(\n    self,\n    page: int = 1,\n    pagination: int = 50,\n    status: Optional[Status] = None,\n    interval: Optional[Interval] = None,\n    amount: Optional[int] = None,\n) -&gt; Response:\n    \"\"\"Fetch plans available on your integration.\n\n    Args:\n        page: Specifies exactly what page you want to retrieve.\n            If not specified, we use a default value of 1.\n        pagination: Specifies how many records you want to retrieve per page.\n            If not specified, we use a default value of 50.\n        status: Filter list by plans with specified status\n        interval: Filter list by plans with specified interval\n        amount: Filter list by plans with specified amount ( kobo if currency\n            is ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``,\n            and cents, if currency is ``Currency.ZAR``)\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    if amount:\n        amount = validate_amount(amount)\n\n    url = self._parse_url(f\"/plan/?perPage={pagination}\")\n    query_params = [\n        (\"page\", page),\n        (\"status\", status),\n        (\"interval\", interval),\n        (\"amount\", amount),\n    ]\n    url = append_query_params(query_params, url)\n    return self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/plans/#pypaystack2.api.plans.Plan.update","title":"<code>update(id_or_code, name, amount, interval, description=None, currency=None, invoice_limit=None, send_invoices=False, send_sms=False)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>id_or_code</code> <code>str</code> <p>Plan's ID or code</p> required <code>name</code> <code>Optional[str]</code> <p>Name of plan</p> required <code>amount</code> <code>Optional[int]</code> <p>Amount should be in kobo if currency is <code>Currency.NGN</code> and pesewas for <code>Currency.GHS</code></p> required <code>interval</code> <code>Optional[Interval]</code> <p>Any value from the <code>Interval</code> enum.</p> required <code>description</code> <code>Optional[str]</code> <p>A description for this plan.</p> <code>None</code> <code>currency</code> <code>Optional[Currency]</code> <p>Any value from the <code>Currency</code> enum.</p> <code>None</code> <code>invoice_limit</code> <code>Optional[int]</code> <p>Number of invoices to raise during subscription to this plan. Can be overridden by specifying an <code>invoice_limit</code> while subscribing.</p> <code>None</code> <code>send_invoices</code> <code>bool</code> <p>Set to <code>False</code> if you don't want invoices to be sent to your customers</p> <code>False</code> <code>send_sms</code> <code>bool</code> <p>Set to <code>False</code> if you don't want text messages to be sent to your customers</p> <code>False</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/plans.py</code> <pre><code>def update(\n    self,\n    id_or_code: str,\n    name: Optional[str],\n    amount: Optional[int],\n    interval: Optional[Interval],\n    description: Optional[str] = None,\n    currency: Optional[Currency] = None,\n    invoice_limit: Optional[int] = None,\n    send_invoices: bool = False,\n    send_sms: bool = False,\n) -&gt; Response:\n    \"\"\"\n\n    Args:\n        id_or_code: Plan's ID or code\n        name: Name of plan\n        amount: Amount should be in kobo if currency is\n            ``Currency.NGN`` and pesewas for ``Currency.GHS``\n        interval: Any value from the ``Interval`` enum.\n        description: A description for this plan.\n        currency: Any value from the ``Currency`` enum.\n        invoice_limit: Number of invoices to raise during subscription to this plan.\n            Can be overridden by specifying an ``invoice_limit`` while subscribing.\n        send_invoices: Set to ``False`` if you don't want invoices\n            to be sent to your customers\n        send_sms: Set to ``False`` if you don't want text messages to\n            be sent to your customers\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    interval = validate_interval(interval)\n    amount = validate_amount(amount)\n\n    url = self._parse_url(\"/plan/{}/\".format(id_or_code))\n    payload = {\n        \"name\": name,\n        \"amount\": amount,\n        \"interval\": interval,\n    }\n\n    optional_params = [\n        (\"send_invoices\", send_invoices),\n        (\"send_sms\", send_sms),\n        (\"description\", description),\n        (\"currency\", currency),\n        (\"invoice_limit\", invoice_limit),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return self._handle_request(HTTPMethod.PUT, url, payload)\n</code></pre>"},{"location":"reference/products/","title":"Products","text":""},{"location":"reference/products/#pypaystack2.api.products.AsyncProduct","title":"<code>AsyncProduct</code>","text":"<p>               Bases: <code>BaseAsyncAPI</code></p> <p>Provides a wrapper for paystack Products API</p> <p>The Products API allows you to create and manage inventories on your integration. https://paystack.com/docs/api/product/</p> Source code in <code>src/pypaystack2/api/products.py</code> <pre><code>class AsyncProduct(BaseAsyncAPI):\n    \"\"\"Provides a wrapper for paystack Products API\n\n    The Products API allows you to create and manage inventories on your integration.\n    https://paystack.com/docs/api/product/\n    \"\"\"\n\n    async def create(\n        self,\n        name: str,\n        description: str,\n        price: int,\n        currency: Currency,\n        unlimited: Optional[bool] = None,\n        quantity: Optional[int] = None,\n    ) -&gt; Response:\n        \"\"\"Create a product on your integration\n\n        Args:\n            name: Name of product\n            description: A description for this product\n            price: Price should be in kobo if currency is ``Currency.NGN``, pesewas,\n                if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR``\n            currency: Any value from the ``Currency`` enum\n            unlimited: Set to ``True`` if the product has unlimited stock.\n                Leave as ``False`` if the product has limited stock\n            quantity: Number of products in stock. Use if unlimited is ``False``\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n\n        Raises:\n            InvalidDataError: When unlimited is set to True and quantity has a value.\n        \"\"\"\n\n        if unlimited is True and quantity is not None:\n            raise InvalidDataException(\n                \"You can't have unlimited set to True and have a quantity value.\"\n            )\n\n        url = self._parse_url(\"/product\")\n\n        payload = {\n            \"name\": name,\n            \"description\": description,\n            \"price\": price,\n            \"currency\": currency,\n        }\n        optional_params = [\n            (\"unlimited\", unlimited),\n            (\"quantity\", quantity),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return await self._handle_request(HTTPMethod.POST, url, payload)\n\n    async def get_products(\n        self,\n        page: int = 1,\n        pagination: int = 50,\n        start_date: Optional[str] = None,\n        end_date: Optional[str] = None,\n    ) -&gt; Response:\n        \"\"\"Fetches products available on your integration.\n\n        Args:\n            page: Specifies exactly what page you want to retrieve.\n                If not specified we use a default value of 1.\n            pagination: Specifies how many records you want to retrieve per page.\n                If not specified we use a default value of 50.\n            start_date: A timestamp from which to start listing product e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            end_date: timestamp at which to stop listing product e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(\"/product?perPage=\" + str(pagination))\n        query_params = [\n            (\"page\", page),\n            (\"start_date\", start_date),\n            (\"end_date\", end_date),\n        ]\n        url = append_query_params(query_params, url)\n        return await self._handle_request(HTTPMethod.GET, url)\n\n    async def get_product(self, id: str) -&gt; Response:\n        \"\"\"Get details of a product on your integration.\n\n        Args:\n            id: The product ``ID`` you want to fetch\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/product/{id}\")\n        return await self._handle_request(HTTPMethod.GET, url)\n\n    async def update(\n        self,\n        id: str,\n        name: str,\n        description: str,\n        price: int,\n        currency: Currency,\n        unlimited: Optional[bool] = None,\n        quantity: Optional[int] = None,\n    ) -&gt; Response:\n        \"\"\"Update a product details on your integration\n\n        Args:\n            id: Product ID\n            name: Name of product\n            description: A description for this product\n            price: Price should be in kobo if currency is ``Currency.NGN``, pesewas,\n                if currency is GHS, and cents, if currency is ``Currency.ZAR``\n            currency: Any value from the ``Currency`` enum\n            unlimited: Set to ``True`` if the product has unlimited stock.\n                Leave as ``False`` if the product has limited stock\n            quantity: Number of products in stock. Use if unlimited is ``False``\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n\n        Raises:\n            InvalidDataError: When unlimited is set to True and quantity has a value.\n        \"\"\"\n\n        if unlimited is True and quantity is not None:\n            raise InvalidDataException(\n                \"You can't have unlimited set to True and quantity have a value.\"\n            )\n        url = self._parse_url(f\"/product/{id}\")\n        payload = {\n            \"name\": name,\n            \"description\": description,\n            \"price\": price,\n            \"currency\": currency,\n        }\n        optional_params = [\n            (\"unlimited\", unlimited),\n            (\"quantity\", quantity),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return await self._handle_request(HTTPMethod.PUT, url, payload)\n</code></pre>"},{"location":"reference/products/#pypaystack2.api.products.AsyncProduct.create","title":"<code>create(name, description, price, currency, unlimited=None, quantity=None)</code>  <code>async</code>","text":"<p>Create a product on your integration</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of product</p> required <code>description</code> <code>str</code> <p>A description for this product</p> required <code>price</code> <code>int</code> <p>Price should be in kobo if currency is <code>Currency.NGN</code>, pesewas, if currency is <code>Currency.GHS</code>, and cents, if currency is <code>Currency.ZAR</code></p> required <code>currency</code> <code>Currency</code> <p>Any value from the <code>Currency</code> enum</p> required <code>unlimited</code> <code>Optional[bool]</code> <p>Set to <code>True</code> if the product has unlimited stock. Leave as <code>False</code> if the product has limited stock</p> <code>None</code> <code>quantity</code> <code>Optional[int]</code> <p>Number of products in stock. Use if unlimited is <code>False</code></p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> <p>Raises:</p> Type Description <code>InvalidDataError</code> <p>When unlimited is set to True and quantity has a value.</p> Source code in <code>src/pypaystack2/api/products.py</code> <pre><code>async def create(\n    self,\n    name: str,\n    description: str,\n    price: int,\n    currency: Currency,\n    unlimited: Optional[bool] = None,\n    quantity: Optional[int] = None,\n) -&gt; Response:\n    \"\"\"Create a product on your integration\n\n    Args:\n        name: Name of product\n        description: A description for this product\n        price: Price should be in kobo if currency is ``Currency.NGN``, pesewas,\n            if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR``\n        currency: Any value from the ``Currency`` enum\n        unlimited: Set to ``True`` if the product has unlimited stock.\n            Leave as ``False`` if the product has limited stock\n        quantity: Number of products in stock. Use if unlimited is ``False``\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n\n    Raises:\n        InvalidDataError: When unlimited is set to True and quantity has a value.\n    \"\"\"\n\n    if unlimited is True and quantity is not None:\n        raise InvalidDataException(\n            \"You can't have unlimited set to True and have a quantity value.\"\n        )\n\n    url = self._parse_url(\"/product\")\n\n    payload = {\n        \"name\": name,\n        \"description\": description,\n        \"price\": price,\n        \"currency\": currency,\n    }\n    optional_params = [\n        (\"unlimited\", unlimited),\n        (\"quantity\", quantity),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return await self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/products/#pypaystack2.api.products.AsyncProduct.get_product","title":"<code>get_product(id)</code>  <code>async</code>","text":"<p>Get details of a product on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The product <code>ID</code> you want to fetch</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/products.py</code> <pre><code>async def get_product(self, id: str) -&gt; Response:\n    \"\"\"Get details of a product on your integration.\n\n    Args:\n        id: The product ``ID`` you want to fetch\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/product/{id}\")\n    return await self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/products/#pypaystack2.api.products.AsyncProduct.get_products","title":"<code>get_products(page=1, pagination=50, start_date=None, end_date=None)</code>  <code>async</code>","text":"<p>Fetches products available on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>int</code> <p>Specifies exactly what page you want to retrieve. If not specified we use a default value of 1.</p> <code>1</code> <code>pagination</code> <code>int</code> <p>Specifies how many records you want to retrieve per page. If not specified we use a default value of 50.</p> <code>50</code> <code>start_date</code> <code>Optional[str]</code> <p>A timestamp from which to start listing product e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>end_date</code> <code>Optional[str]</code> <p>timestamp at which to stop listing product e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/products.py</code> <pre><code>async def get_products(\n    self,\n    page: int = 1,\n    pagination: int = 50,\n    start_date: Optional[str] = None,\n    end_date: Optional[str] = None,\n) -&gt; Response:\n    \"\"\"Fetches products available on your integration.\n\n    Args:\n        page: Specifies exactly what page you want to retrieve.\n            If not specified we use a default value of 1.\n        pagination: Specifies how many records you want to retrieve per page.\n            If not specified we use a default value of 50.\n        start_date: A timestamp from which to start listing product e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        end_date: timestamp at which to stop listing product e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(\"/product?perPage=\" + str(pagination))\n    query_params = [\n        (\"page\", page),\n        (\"start_date\", start_date),\n        (\"end_date\", end_date),\n    ]\n    url = append_query_params(query_params, url)\n    return await self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/products/#pypaystack2.api.products.AsyncProduct.update","title":"<code>update(id, name, description, price, currency, unlimited=None, quantity=None)</code>  <code>async</code>","text":"<p>Update a product details on your integration</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>Product ID</p> required <code>name</code> <code>str</code> <p>Name of product</p> required <code>description</code> <code>str</code> <p>A description for this product</p> required <code>price</code> <code>int</code> <p>Price should be in kobo if currency is <code>Currency.NGN</code>, pesewas, if currency is GHS, and cents, if currency is <code>Currency.ZAR</code></p> required <code>currency</code> <code>Currency</code> <p>Any value from the <code>Currency</code> enum</p> required <code>unlimited</code> <code>Optional[bool]</code> <p>Set to <code>True</code> if the product has unlimited stock. Leave as <code>False</code> if the product has limited stock</p> <code>None</code> <code>quantity</code> <code>Optional[int]</code> <p>Number of products in stock. Use if unlimited is <code>False</code></p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> <p>Raises:</p> Type Description <code>InvalidDataError</code> <p>When unlimited is set to True and quantity has a value.</p> Source code in <code>src/pypaystack2/api/products.py</code> <pre><code>async def update(\n    self,\n    id: str,\n    name: str,\n    description: str,\n    price: int,\n    currency: Currency,\n    unlimited: Optional[bool] = None,\n    quantity: Optional[int] = None,\n) -&gt; Response:\n    \"\"\"Update a product details on your integration\n\n    Args:\n        id: Product ID\n        name: Name of product\n        description: A description for this product\n        price: Price should be in kobo if currency is ``Currency.NGN``, pesewas,\n            if currency is GHS, and cents, if currency is ``Currency.ZAR``\n        currency: Any value from the ``Currency`` enum\n        unlimited: Set to ``True`` if the product has unlimited stock.\n            Leave as ``False`` if the product has limited stock\n        quantity: Number of products in stock. Use if unlimited is ``False``\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n\n    Raises:\n        InvalidDataError: When unlimited is set to True and quantity has a value.\n    \"\"\"\n\n    if unlimited is True and quantity is not None:\n        raise InvalidDataException(\n            \"You can't have unlimited set to True and quantity have a value.\"\n        )\n    url = self._parse_url(f\"/product/{id}\")\n    payload = {\n        \"name\": name,\n        \"description\": description,\n        \"price\": price,\n        \"currency\": currency,\n    }\n    optional_params = [\n        (\"unlimited\", unlimited),\n        (\"quantity\", quantity),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return await self._handle_request(HTTPMethod.PUT, url, payload)\n</code></pre>"},{"location":"reference/products/#pypaystack2.api.products.Product","title":"<code>Product</code>","text":"<p>               Bases: <code>BaseAPI</code></p> <p>Provides a wrapper for paystack Products API</p> <p>The Products API allows you to create and manage inventories on your integration. https://paystack.com/docs/api/product/</p> Source code in <code>src/pypaystack2/api/products.py</code> <pre><code>class Product(BaseAPI):\n    \"\"\"Provides a wrapper for paystack Products API\n\n    The Products API allows you to create and manage inventories on your integration.\n    https://paystack.com/docs/api/product/\n    \"\"\"\n\n    def create(\n        self,\n        name: str,\n        description: str,\n        price: int,\n        currency: Currency,\n        unlimited: Optional[bool] = None,\n        quantity: Optional[int] = None,\n    ) -&gt; Response:\n        \"\"\"Create a product on your integration\n\n        Args:\n            name: Name of product\n            description: A description for this product\n            price: Price should be in kobo if currency is ``Currency.NGN``, pesewas,\n                if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR``\n            currency: Any value from the ``Currency`` enum\n            unlimited: Set to ``True`` if the product has unlimited stock.\n                Leave as ``False`` if the product has limited stock\n            quantity: Number of products in stock. Use if unlimited is ``False``\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n\n        Raises:\n            InvalidDataError: When unlimited is set to True and quantity has a value.\n        \"\"\"\n\n        if unlimited is True and quantity is not None:\n            raise InvalidDataException(\n                \"You can't have unlimited set to True and have a quantity value.\"\n            )\n\n        url = self._parse_url(\"/product\")\n\n        payload = {\n            \"name\": name,\n            \"description\": description,\n            \"price\": price,\n            \"currency\": currency,\n        }\n        optional_params = [\n            (\"unlimited\", unlimited),\n            (\"quantity\", quantity),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return self._handle_request(HTTPMethod.POST, url, payload)\n\n    def get_products(\n        self,\n        page: int = 1,\n        pagination: int = 50,\n        start_date: Optional[str] = None,\n        end_date: Optional[str] = None,\n    ) -&gt; Response:\n        \"\"\"Fetches products available on your integration.\n\n        Args:\n            page: Specifies exactly what page you want to retrieve.\n                If not specified we use a default value of 1.\n            pagination: Specifies how many records you want to retrieve per page.\n                If not specified we use a default value of 50.\n            start_date: A timestamp from which to start listing product e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            end_date: timestamp at which to stop listing product e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(\"/product?perPage=\" + str(pagination))\n        query_params = [\n            (\"page\", page),\n            (\"start_date\", start_date),\n            (\"end_date\", end_date),\n        ]\n        url = append_query_params(query_params, url)\n        return self._handle_request(HTTPMethod.GET, url)\n\n    def get_product(self, id: str) -&gt; Response:\n        \"\"\"Get details of a product on your integration.\n\n        Args:\n            id: The product ``ID`` you want to fetch\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/product/{id}\")\n        return self._handle_request(HTTPMethod.GET, url)\n\n    def update(\n        self,\n        id: str,\n        name: str,\n        description: str,\n        price: int,\n        currency: Currency,\n        unlimited: Optional[bool] = None,\n        quantity: Optional[int] = None,\n    ) -&gt; Response:\n        \"\"\"Update a product details on your integration\n\n        Args:\n            id: Product ID\n            name: Name of product\n            description: A description for this product\n            price: Price should be in kobo if currency is ``Currency.NGN``, pesewas,\n                if currency is GHS, and cents, if currency is ``Currency.ZAR``\n            currency: Any value from the ``Currency`` enum\n            unlimited: Set to ``True`` if the product has unlimited stock.\n                Leave as ``False`` if the product has limited stock\n            quantity: Number of products in stock. Use if unlimited is ``False``\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n\n        Raises:\n            InvalidDataError: When unlimited is set to True and quantity has a value.\n        \"\"\"\n\n        if unlimited is True and quantity is not None:\n            raise InvalidDataException(\n                \"You can't have unlimited set to True and quantity have a value.\"\n            )\n        url = self._parse_url(f\"/product/{id}\")\n        payload = {\n            \"name\": name,\n            \"description\": description,\n            \"price\": price,\n            \"currency\": currency,\n        }\n        optional_params = [\n            (\"unlimited\", unlimited),\n            (\"quantity\", quantity),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return self._handle_request(HTTPMethod.PUT, url, payload)\n</code></pre>"},{"location":"reference/products/#pypaystack2.api.products.Product.create","title":"<code>create(name, description, price, currency, unlimited=None, quantity=None)</code>","text":"<p>Create a product on your integration</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of product</p> required <code>description</code> <code>str</code> <p>A description for this product</p> required <code>price</code> <code>int</code> <p>Price should be in kobo if currency is <code>Currency.NGN</code>, pesewas, if currency is <code>Currency.GHS</code>, and cents, if currency is <code>Currency.ZAR</code></p> required <code>currency</code> <code>Currency</code> <p>Any value from the <code>Currency</code> enum</p> required <code>unlimited</code> <code>Optional[bool]</code> <p>Set to <code>True</code> if the product has unlimited stock. Leave as <code>False</code> if the product has limited stock</p> <code>None</code> <code>quantity</code> <code>Optional[int]</code> <p>Number of products in stock. Use if unlimited is <code>False</code></p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> <p>Raises:</p> Type Description <code>InvalidDataError</code> <p>When unlimited is set to True and quantity has a value.</p> Source code in <code>src/pypaystack2/api/products.py</code> <pre><code>def create(\n    self,\n    name: str,\n    description: str,\n    price: int,\n    currency: Currency,\n    unlimited: Optional[bool] = None,\n    quantity: Optional[int] = None,\n) -&gt; Response:\n    \"\"\"Create a product on your integration\n\n    Args:\n        name: Name of product\n        description: A description for this product\n        price: Price should be in kobo if currency is ``Currency.NGN``, pesewas,\n            if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR``\n        currency: Any value from the ``Currency`` enum\n        unlimited: Set to ``True`` if the product has unlimited stock.\n            Leave as ``False`` if the product has limited stock\n        quantity: Number of products in stock. Use if unlimited is ``False``\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n\n    Raises:\n        InvalidDataError: When unlimited is set to True and quantity has a value.\n    \"\"\"\n\n    if unlimited is True and quantity is not None:\n        raise InvalidDataException(\n            \"You can't have unlimited set to True and have a quantity value.\"\n        )\n\n    url = self._parse_url(\"/product\")\n\n    payload = {\n        \"name\": name,\n        \"description\": description,\n        \"price\": price,\n        \"currency\": currency,\n    }\n    optional_params = [\n        (\"unlimited\", unlimited),\n        (\"quantity\", quantity),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/products/#pypaystack2.api.products.Product.get_product","title":"<code>get_product(id)</code>","text":"<p>Get details of a product on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The product <code>ID</code> you want to fetch</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/products.py</code> <pre><code>def get_product(self, id: str) -&gt; Response:\n    \"\"\"Get details of a product on your integration.\n\n    Args:\n        id: The product ``ID`` you want to fetch\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/product/{id}\")\n    return self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/products/#pypaystack2.api.products.Product.get_products","title":"<code>get_products(page=1, pagination=50, start_date=None, end_date=None)</code>","text":"<p>Fetches products available on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>int</code> <p>Specifies exactly what page you want to retrieve. If not specified we use a default value of 1.</p> <code>1</code> <code>pagination</code> <code>int</code> <p>Specifies how many records you want to retrieve per page. If not specified we use a default value of 50.</p> <code>50</code> <code>start_date</code> <code>Optional[str]</code> <p>A timestamp from which to start listing product e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>end_date</code> <code>Optional[str]</code> <p>timestamp at which to stop listing product e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/products.py</code> <pre><code>def get_products(\n    self,\n    page: int = 1,\n    pagination: int = 50,\n    start_date: Optional[str] = None,\n    end_date: Optional[str] = None,\n) -&gt; Response:\n    \"\"\"Fetches products available on your integration.\n\n    Args:\n        page: Specifies exactly what page you want to retrieve.\n            If not specified we use a default value of 1.\n        pagination: Specifies how many records you want to retrieve per page.\n            If not specified we use a default value of 50.\n        start_date: A timestamp from which to start listing product e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        end_date: timestamp at which to stop listing product e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(\"/product?perPage=\" + str(pagination))\n    query_params = [\n        (\"page\", page),\n        (\"start_date\", start_date),\n        (\"end_date\", end_date),\n    ]\n    url = append_query_params(query_params, url)\n    return self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/products/#pypaystack2.api.products.Product.update","title":"<code>update(id, name, description, price, currency, unlimited=None, quantity=None)</code>","text":"<p>Update a product details on your integration</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>Product ID</p> required <code>name</code> <code>str</code> <p>Name of product</p> required <code>description</code> <code>str</code> <p>A description for this product</p> required <code>price</code> <code>int</code> <p>Price should be in kobo if currency is <code>Currency.NGN</code>, pesewas, if currency is GHS, and cents, if currency is <code>Currency.ZAR</code></p> required <code>currency</code> <code>Currency</code> <p>Any value from the <code>Currency</code> enum</p> required <code>unlimited</code> <code>Optional[bool]</code> <p>Set to <code>True</code> if the product has unlimited stock. Leave as <code>False</code> if the product has limited stock</p> <code>None</code> <code>quantity</code> <code>Optional[int]</code> <p>Number of products in stock. Use if unlimited is <code>False</code></p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> <p>Raises:</p> Type Description <code>InvalidDataError</code> <p>When unlimited is set to True and quantity has a value.</p> Source code in <code>src/pypaystack2/api/products.py</code> <pre><code>def update(\n    self,\n    id: str,\n    name: str,\n    description: str,\n    price: int,\n    currency: Currency,\n    unlimited: Optional[bool] = None,\n    quantity: Optional[int] = None,\n) -&gt; Response:\n    \"\"\"Update a product details on your integration\n\n    Args:\n        id: Product ID\n        name: Name of product\n        description: A description for this product\n        price: Price should be in kobo if currency is ``Currency.NGN``, pesewas,\n            if currency is GHS, and cents, if currency is ``Currency.ZAR``\n        currency: Any value from the ``Currency`` enum\n        unlimited: Set to ``True`` if the product has unlimited stock.\n            Leave as ``False`` if the product has limited stock\n        quantity: Number of products in stock. Use if unlimited is ``False``\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n\n    Raises:\n        InvalidDataError: When unlimited is set to True and quantity has a value.\n    \"\"\"\n\n    if unlimited is True and quantity is not None:\n        raise InvalidDataException(\n            \"You can't have unlimited set to True and quantity have a value.\"\n        )\n    url = self._parse_url(f\"/product/{id}\")\n    payload = {\n        \"name\": name,\n        \"description\": description,\n        \"price\": price,\n        \"currency\": currency,\n    }\n    optional_params = [\n        (\"unlimited\", unlimited),\n        (\"quantity\", quantity),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return self._handle_request(HTTPMethod.PUT, url, payload)\n</code></pre>"},{"location":"reference/refunds/","title":"Refunds","text":""},{"location":"reference/refunds/#pypaystack2.api.refunds.AsyncRefund","title":"<code>AsyncRefund</code>","text":"<p>               Bases: <code>BaseAsyncAPI</code></p> <p>Provides a wrapper for paystack Refunds API</p> <p>The Refunds API allows you to create and manage transaction refunds. https://paystack.com/docs/api/refund/</p> Source code in <code>src/pypaystack2/api/refunds.py</code> <pre><code>class AsyncRefund(BaseAsyncAPI):\n    \"\"\"Provides a wrapper for paystack Refunds API\n\n    The Refunds API allows you to create and manage transaction refunds.\n    https://paystack.com/docs/api/refund/\n    \"\"\"\n\n    async def create(\n        self,\n        transaction: str,\n        amount: Optional[int] = None,\n        currency: Optional[Currency] = None,\n        customer_note: Optional[str] = None,\n        merchant_note: Optional[str] = None,\n    ) -&gt; Response:\n        \"\"\"Initiate a refund on your integration\n\n        Args:\n            transaction: Transaction reference or id\n            amount: Amount ( in kobo if currency is NGN, pesewas, if currency is\n                GHS, and cents, if currency is ZAR ) to be refunded to the\n                customer. Amount is optional(defaults to original\n                transaction amount) and cannot be more than the original\n                transaction amount\n            currency: Any value from the ``Currency`` enum\n            customer_note: Customer reason\n            merchant_note: Merchant reason\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        if amount is not None:\n            amount = validate_amount(amount)\n        url = self._parse_url(\"/refund\")\n        payload = {\"transaction\": transaction}\n        optional_params = [\n            (\"amount\", amount),\n            (\"currency\", currency),\n            (\"customer_note\", customer_note),\n            (\"merchant_note\", merchant_note),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return await self._handle_request(HTTPMethod.POST, url, payload)\n\n    async def get_refunds(\n        self,\n        reference: Optional[str] = None,\n        currency: Optional[Currency] = None,\n        pagination: int = 50,\n        page: int = 1,\n        start_date: Optional[str] = None,\n        end_date: Optional[str] = None,\n    ) -&gt; Response:\n        \"\"\"Fetch refunds available on your integration.\n\n        Args:\n            reference: Identifier for transaction to be refunded\n            currency: Any value from the ``Currency`` enum\n            pagination: Specifies how many records you want to retrieve per page.\n                If not specified we use a default value of 50.\n            page: Specifies exactly what refund you want to page.\n                If not specified we use a default value of 1.\n            start_date: A timestamp from which to start listing refund e.g. 2016-09-21\n            end_date: A timestamp at which to stop listing refund e.g. 2016-09-21\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/refund?perPage={pagination}\")\n        query_params = [\n            (\"reference\", reference),\n            (\"currency\", currency),\n            (\"page\", page),\n            (\"start_date\", start_date),\n            (\"end_date\", end_date),\n        ]\n        url = append_query_params(query_params, url)\n        return await self._handle_request(HTTPMethod.GET, url)\n\n    async def get_refund(self, reference: str) -&gt; Response:\n        \"\"\"Get details of a refund on your integration.\n\n        Args:\n            reference: Identifier for transaction to be refunded\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/refund/{reference}\")\n        return await self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/refunds/#pypaystack2.api.refunds.AsyncRefund.create","title":"<code>create(transaction, amount=None, currency=None, customer_note=None, merchant_note=None)</code>  <code>async</code>","text":"<p>Initiate a refund on your integration</p> <p>Parameters:</p> Name Type Description Default <code>transaction</code> <code>str</code> <p>Transaction reference or id</p> required <code>amount</code> <code>Optional[int]</code> <p>Amount ( in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR ) to be refunded to the customer. Amount is optional(defaults to original transaction amount) and cannot be more than the original transaction amount</p> <code>None</code> <code>currency</code> <code>Optional[Currency]</code> <p>Any value from the <code>Currency</code> enum</p> <code>None</code> <code>customer_note</code> <code>Optional[str]</code> <p>Customer reason</p> <code>None</code> <code>merchant_note</code> <code>Optional[str]</code> <p>Merchant reason</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/refunds.py</code> <pre><code>async def create(\n    self,\n    transaction: str,\n    amount: Optional[int] = None,\n    currency: Optional[Currency] = None,\n    customer_note: Optional[str] = None,\n    merchant_note: Optional[str] = None,\n) -&gt; Response:\n    \"\"\"Initiate a refund on your integration\n\n    Args:\n        transaction: Transaction reference or id\n        amount: Amount ( in kobo if currency is NGN, pesewas, if currency is\n            GHS, and cents, if currency is ZAR ) to be refunded to the\n            customer. Amount is optional(defaults to original\n            transaction amount) and cannot be more than the original\n            transaction amount\n        currency: Any value from the ``Currency`` enum\n        customer_note: Customer reason\n        merchant_note: Merchant reason\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    if amount is not None:\n        amount = validate_amount(amount)\n    url = self._parse_url(\"/refund\")\n    payload = {\"transaction\": transaction}\n    optional_params = [\n        (\"amount\", amount),\n        (\"currency\", currency),\n        (\"customer_note\", customer_note),\n        (\"merchant_note\", merchant_note),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return await self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/refunds/#pypaystack2.api.refunds.AsyncRefund.get_refund","title":"<code>get_refund(reference)</code>  <code>async</code>","text":"<p>Get details of a refund on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>reference</code> <code>str</code> <p>Identifier for transaction to be refunded</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/refunds.py</code> <pre><code>async def get_refund(self, reference: str) -&gt; Response:\n    \"\"\"Get details of a refund on your integration.\n\n    Args:\n        reference: Identifier for transaction to be refunded\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/refund/{reference}\")\n    return await self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/refunds/#pypaystack2.api.refunds.AsyncRefund.get_refunds","title":"<code>get_refunds(reference=None, currency=None, pagination=50, page=1, start_date=None, end_date=None)</code>  <code>async</code>","text":"<p>Fetch refunds available on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>reference</code> <code>Optional[str]</code> <p>Identifier for transaction to be refunded</p> <code>None</code> <code>currency</code> <code>Optional[Currency]</code> <p>Any value from the <code>Currency</code> enum</p> <code>None</code> <code>pagination</code> <code>int</code> <p>Specifies how many records you want to retrieve per page. If not specified we use a default value of 50.</p> <code>50</code> <code>page</code> <code>int</code> <p>Specifies exactly what refund you want to page. If not specified we use a default value of 1.</p> <code>1</code> <code>start_date</code> <code>Optional[str]</code> <p>A timestamp from which to start listing refund e.g. 2016-09-21</p> <code>None</code> <code>end_date</code> <code>Optional[str]</code> <p>A timestamp at which to stop listing refund e.g. 2016-09-21</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/refunds.py</code> <pre><code>async def get_refunds(\n    self,\n    reference: Optional[str] = None,\n    currency: Optional[Currency] = None,\n    pagination: int = 50,\n    page: int = 1,\n    start_date: Optional[str] = None,\n    end_date: Optional[str] = None,\n) -&gt; Response:\n    \"\"\"Fetch refunds available on your integration.\n\n    Args:\n        reference: Identifier for transaction to be refunded\n        currency: Any value from the ``Currency`` enum\n        pagination: Specifies how many records you want to retrieve per page.\n            If not specified we use a default value of 50.\n        page: Specifies exactly what refund you want to page.\n            If not specified we use a default value of 1.\n        start_date: A timestamp from which to start listing refund e.g. 2016-09-21\n        end_date: A timestamp at which to stop listing refund e.g. 2016-09-21\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/refund?perPage={pagination}\")\n    query_params = [\n        (\"reference\", reference),\n        (\"currency\", currency),\n        (\"page\", page),\n        (\"start_date\", start_date),\n        (\"end_date\", end_date),\n    ]\n    url = append_query_params(query_params, url)\n    return await self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/refunds/#pypaystack2.api.refunds.Refund","title":"<code>Refund</code>","text":"<p>               Bases: <code>BaseAPI</code></p> <p>Provides a wrapper for paystack Refunds API</p> <p>The Refunds API allows you to create and manage transaction refunds. https://paystack.com/docs/api/refund/</p> Source code in <code>src/pypaystack2/api/refunds.py</code> <pre><code>class Refund(BaseAPI):\n    \"\"\"Provides a wrapper for paystack Refunds API\n\n    The Refunds API allows you to create and manage transaction refunds.\n    https://paystack.com/docs/api/refund/\n    \"\"\"\n\n    def create(\n        self,\n        transaction: str,\n        amount: Optional[int] = None,\n        currency: Optional[Currency] = None,\n        customer_note: Optional[str] = None,\n        merchant_note: Optional[str] = None,\n    ) -&gt; Response:\n        \"\"\"Initiate a refund on your integration\n\n        Args:\n            transaction: Transaction reference or id\n            amount: Amount ( in kobo if currency is NGN, pesewas, if currency is\n                GHS, and cents, if currency is ZAR ) to be refunded to the\n                customer. Amount is optional(defaults to original\n                transaction amount) and cannot be more than the original\n                transaction amount\n            currency: Any value from the ``Currency`` enum\n            customer_note: Customer reason\n            merchant_note: Merchant reason\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        if amount is not None:\n            amount = validate_amount(amount)\n        url = self._parse_url(\"/refund\")\n        payload = {\"transaction\": transaction}\n        optional_params = [\n            (\"amount\", amount),\n            (\"currency\", currency),\n            (\"customer_note\", customer_note),\n            (\"merchant_note\", merchant_note),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return self._handle_request(HTTPMethod.POST, url, payload)\n\n    def get_refunds(\n        self,\n        reference: Optional[str] = None,\n        currency: Optional[Currency] = None,\n        pagination: int = 50,\n        page: int = 1,\n        start_date: Optional[str] = None,\n        end_date: Optional[str] = None,\n    ) -&gt; Response:\n        \"\"\"Fetch refunds available on your integration.\n\n        Args:\n            reference: Identifier for transaction to be refunded\n            currency: Any value from the ``Currency`` enum\n            pagination: Specifies how many records you want to retrieve per page.\n                If not specified we use a default value of 50.\n            page: Specifies exactly what refund you want to page.\n                If not specified we use a default value of 1.\n            start_date: A timestamp from which to start listing refund e.g. 2016-09-21\n            end_date: A timestamp at which to stop listing refund e.g. 2016-09-21\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/refund?perPage={pagination}\")\n        query_params = [\n            (\"reference\", reference),\n            (\"currency\", currency),\n            (\"page\", page),\n            (\"start_date\", start_date),\n            (\"end_date\", end_date),\n        ]\n        url = append_query_params(query_params, url)\n        return self._handle_request(HTTPMethod.GET, url)\n\n    def get_refund(self, reference: str) -&gt; Response:\n        \"\"\"Get details of a refund on your integration.\n\n        Args:\n            reference: Identifier for transaction to be refunded\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/refund/{reference}\")\n        return self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/refunds/#pypaystack2.api.refunds.Refund.create","title":"<code>create(transaction, amount=None, currency=None, customer_note=None, merchant_note=None)</code>","text":"<p>Initiate a refund on your integration</p> <p>Parameters:</p> Name Type Description Default <code>transaction</code> <code>str</code> <p>Transaction reference or id</p> required <code>amount</code> <code>Optional[int]</code> <p>Amount ( in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR ) to be refunded to the customer. Amount is optional(defaults to original transaction amount) and cannot be more than the original transaction amount</p> <code>None</code> <code>currency</code> <code>Optional[Currency]</code> <p>Any value from the <code>Currency</code> enum</p> <code>None</code> <code>customer_note</code> <code>Optional[str]</code> <p>Customer reason</p> <code>None</code> <code>merchant_note</code> <code>Optional[str]</code> <p>Merchant reason</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/refunds.py</code> <pre><code>def create(\n    self,\n    transaction: str,\n    amount: Optional[int] = None,\n    currency: Optional[Currency] = None,\n    customer_note: Optional[str] = None,\n    merchant_note: Optional[str] = None,\n) -&gt; Response:\n    \"\"\"Initiate a refund on your integration\n\n    Args:\n        transaction: Transaction reference or id\n        amount: Amount ( in kobo if currency is NGN, pesewas, if currency is\n            GHS, and cents, if currency is ZAR ) to be refunded to the\n            customer. Amount is optional(defaults to original\n            transaction amount) and cannot be more than the original\n            transaction amount\n        currency: Any value from the ``Currency`` enum\n        customer_note: Customer reason\n        merchant_note: Merchant reason\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    if amount is not None:\n        amount = validate_amount(amount)\n    url = self._parse_url(\"/refund\")\n    payload = {\"transaction\": transaction}\n    optional_params = [\n        (\"amount\", amount),\n        (\"currency\", currency),\n        (\"customer_note\", customer_note),\n        (\"merchant_note\", merchant_note),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/refunds/#pypaystack2.api.refunds.Refund.get_refund","title":"<code>get_refund(reference)</code>","text":"<p>Get details of a refund on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>reference</code> <code>str</code> <p>Identifier for transaction to be refunded</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/refunds.py</code> <pre><code>def get_refund(self, reference: str) -&gt; Response:\n    \"\"\"Get details of a refund on your integration.\n\n    Args:\n        reference: Identifier for transaction to be refunded\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/refund/{reference}\")\n    return self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/refunds/#pypaystack2.api.refunds.Refund.get_refunds","title":"<code>get_refunds(reference=None, currency=None, pagination=50, page=1, start_date=None, end_date=None)</code>","text":"<p>Fetch refunds available on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>reference</code> <code>Optional[str]</code> <p>Identifier for transaction to be refunded</p> <code>None</code> <code>currency</code> <code>Optional[Currency]</code> <p>Any value from the <code>Currency</code> enum</p> <code>None</code> <code>pagination</code> <code>int</code> <p>Specifies how many records you want to retrieve per page. If not specified we use a default value of 50.</p> <code>50</code> <code>page</code> <code>int</code> <p>Specifies exactly what refund you want to page. If not specified we use a default value of 1.</p> <code>1</code> <code>start_date</code> <code>Optional[str]</code> <p>A timestamp from which to start listing refund e.g. 2016-09-21</p> <code>None</code> <code>end_date</code> <code>Optional[str]</code> <p>A timestamp at which to stop listing refund e.g. 2016-09-21</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/refunds.py</code> <pre><code>def get_refunds(\n    self,\n    reference: Optional[str] = None,\n    currency: Optional[Currency] = None,\n    pagination: int = 50,\n    page: int = 1,\n    start_date: Optional[str] = None,\n    end_date: Optional[str] = None,\n) -&gt; Response:\n    \"\"\"Fetch refunds available on your integration.\n\n    Args:\n        reference: Identifier for transaction to be refunded\n        currency: Any value from the ``Currency`` enum\n        pagination: Specifies how many records you want to retrieve per page.\n            If not specified we use a default value of 50.\n        page: Specifies exactly what refund you want to page.\n            If not specified we use a default value of 1.\n        start_date: A timestamp from which to start listing refund e.g. 2016-09-21\n        end_date: A timestamp at which to stop listing refund e.g. 2016-09-21\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/refund?perPage={pagination}\")\n    query_params = [\n        (\"reference\", reference),\n        (\"currency\", currency),\n        (\"page\", page),\n        (\"start_date\", start_date),\n        (\"end_date\", end_date),\n    ]\n    url = append_query_params(query_params, url)\n    return self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/settlements/","title":"Settlements","text":""},{"location":"reference/settlements/#pypaystack2.api.settlements.AsyncSettlement","title":"<code>AsyncSettlement</code>","text":"<p>               Bases: <code>BaseAsyncAPI</code></p> <p>Provides a wrapper for paystack Settlement API</p> <p>The Settlements API allows you gain insights into payouts made by Paystack to your bank account. https://paystack.com/docs/api/settlement/</p> Source code in <code>src/pypaystack2/api/settlements.py</code> <pre><code>class AsyncSettlement(BaseAsyncAPI):\n    \"\"\"Provides a wrapper for paystack Settlement API\n\n    The Settlements API allows you gain insights into payouts made by Paystack to your bank account.\n    https://paystack.com/docs/api/settlement/\n    \"\"\"\n\n    async def get_settlements(\n        self,\n        page: int = 1,\n        pagination: int = 50,\n        start_date: Optional[str] = None,\n        end_date: Optional[str] = None,\n        subaccount: Optional[str] = None,\n    ) -&gt; Response:\n        \"\"\"Fetch settlements made to your settlement accounts.\n\n        Args:\n            page: Specifies exactly what page you want to retrieve.\n                If not specified we use a default value of 1.\n            pagination: Specifies how many records you want to retrieve per page.\n                If not specified we use a default value of 50.\n            start_date: A timestamp from which to start listing settlements e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            end_date: A timestamp at which to stop listing settlements e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            subaccount: Provide a subaccount ID to export only settlements for that subaccount.\n                Set to ``none`` to export only transactions for the account.\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/settlement?perPage={pagination}\")\n        query_params = [\n            (\"subaccount\", subaccount),\n            (\"page\", page),\n            (\"start_date\", start_date),\n            (\"end_date\", end_date),\n        ]\n        url = append_query_params(query_params, url)\n        return await self._handle_request(HTTPMethod.GET, url)\n\n    async def get_settlement_transactions(\n        self,\n        id: str,\n        pagination: int = 50,\n        page: int = 1,\n        start_date: Optional[str] = None,\n        end_date: Optional[str] = None,\n    ) -&gt; Response:\n        \"\"\"Get the transactions that make up a particular settlement\n\n        Args:\n            id: The settlement ID in which you want to fetch its transactions\n            pagination: Specifies how many records you want to retrieve per page. If not specified we\n                use a default value of 50.\n            page: Specifies exactly what page you want to retrieve. If not specified we use a default value of 1.\n            start_date: A timestamp from which to start listing settlement transactions\n                e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            end_date: A timestamp at which to stop listing settlement transactions\n                e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/settlement/{id}/transactions?perPage={pagination}\")\n        query_params = [\n            (\"page\", page),\n            (\"start_date\", start_date),\n            (\"end_date\", end_date),\n        ]\n        url = append_query_params(query_params, url)\n        return await self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/settlements/#pypaystack2.api.settlements.AsyncSettlement.get_settlement_transactions","title":"<code>get_settlement_transactions(id, pagination=50, page=1, start_date=None, end_date=None)</code>  <code>async</code>","text":"<p>Get the transactions that make up a particular settlement</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The settlement ID in which you want to fetch its transactions</p> required <code>pagination</code> <code>int</code> <p>Specifies how many records you want to retrieve per page. If not specified we use a default value of 50.</p> <code>50</code> <code>page</code> <code>int</code> <p>Specifies exactly what page you want to retrieve. If not specified we use a default value of 1.</p> <code>1</code> <code>start_date</code> <code>Optional[str]</code> <p>A timestamp from which to start listing settlement transactions e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>end_date</code> <code>Optional[str]</code> <p>A timestamp at which to stop listing settlement transactions e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/settlements.py</code> <pre><code>async def get_settlement_transactions(\n    self,\n    id: str,\n    pagination: int = 50,\n    page: int = 1,\n    start_date: Optional[str] = None,\n    end_date: Optional[str] = None,\n) -&gt; Response:\n    \"\"\"Get the transactions that make up a particular settlement\n\n    Args:\n        id: The settlement ID in which you want to fetch its transactions\n        pagination: Specifies how many records you want to retrieve per page. If not specified we\n            use a default value of 50.\n        page: Specifies exactly what page you want to retrieve. If not specified we use a default value of 1.\n        start_date: A timestamp from which to start listing settlement transactions\n            e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        end_date: A timestamp at which to stop listing settlement transactions\n            e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/settlement/{id}/transactions?perPage={pagination}\")\n    query_params = [\n        (\"page\", page),\n        (\"start_date\", start_date),\n        (\"end_date\", end_date),\n    ]\n    url = append_query_params(query_params, url)\n    return await self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/settlements/#pypaystack2.api.settlements.AsyncSettlement.get_settlements","title":"<code>get_settlements(page=1, pagination=50, start_date=None, end_date=None, subaccount=None)</code>  <code>async</code>","text":"<p>Fetch settlements made to your settlement accounts.</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>int</code> <p>Specifies exactly what page you want to retrieve. If not specified we use a default value of 1.</p> <code>1</code> <code>pagination</code> <code>int</code> <p>Specifies how many records you want to retrieve per page. If not specified we use a default value of 50.</p> <code>50</code> <code>start_date</code> <code>Optional[str]</code> <p>A timestamp from which to start listing settlements e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>end_date</code> <code>Optional[str]</code> <p>A timestamp at which to stop listing settlements e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>subaccount</code> <code>Optional[str]</code> <p>Provide a subaccount ID to export only settlements for that subaccount. Set to <code>none</code> to export only transactions for the account.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/settlements.py</code> <pre><code>async def get_settlements(\n    self,\n    page: int = 1,\n    pagination: int = 50,\n    start_date: Optional[str] = None,\n    end_date: Optional[str] = None,\n    subaccount: Optional[str] = None,\n) -&gt; Response:\n    \"\"\"Fetch settlements made to your settlement accounts.\n\n    Args:\n        page: Specifies exactly what page you want to retrieve.\n            If not specified we use a default value of 1.\n        pagination: Specifies how many records you want to retrieve per page.\n            If not specified we use a default value of 50.\n        start_date: A timestamp from which to start listing settlements e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        end_date: A timestamp at which to stop listing settlements e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        subaccount: Provide a subaccount ID to export only settlements for that subaccount.\n            Set to ``none`` to export only transactions for the account.\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/settlement?perPage={pagination}\")\n    query_params = [\n        (\"subaccount\", subaccount),\n        (\"page\", page),\n        (\"start_date\", start_date),\n        (\"end_date\", end_date),\n    ]\n    url = append_query_params(query_params, url)\n    return await self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/settlements/#pypaystack2.api.settlements.Settlement","title":"<code>Settlement</code>","text":"<p>               Bases: <code>BaseAPI</code></p> <p>Provides a wrapper for paystack Settlement API</p> <p>The Settlements API allows you gain insights into payouts made by Paystack to your bank account. https://paystack.com/docs/api/settlement/</p> Source code in <code>src/pypaystack2/api/settlements.py</code> <pre><code>class Settlement(BaseAPI):\n    \"\"\"Provides a wrapper for paystack Settlement API\n\n    The Settlements API allows you gain insights into payouts made by Paystack to your bank account.\n    https://paystack.com/docs/api/settlement/\n    \"\"\"\n\n    def get_settlements(\n        self,\n        page: int = 1,\n        pagination: int = 50,\n        start_date: Optional[str] = None,\n        end_date: Optional[str] = None,\n        subaccount: Optional[str] = None,\n    ) -&gt; Response:\n        \"\"\"Fetch settlements made to your settlement accounts.\n\n        Args:\n            page: Specifies exactly what page you want to retrieve.\n                If not specified we use a default value of 1.\n            pagination: Specifies how many records you want to retrieve per page.\n                If not specified we use a default value of 50.\n            start_date: A timestamp from which to start listing settlements e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            end_date: A timestamp at which to stop listing settlements e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            subaccount: Provide a subaccount ID to export only settlements for that subaccount.\n                Set to ``none`` to export only transactions for the account.\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/settlement?perPage={pagination}\")\n        query_params = [\n            (\"subaccount\", subaccount),\n            (\"page\", page),\n            (\"start_date\", start_date),\n            (\"end_date\", end_date),\n        ]\n        url = append_query_params(query_params, url)\n        return self._handle_request(HTTPMethod.GET, url)\n\n    def get_settlement_transactions(\n        self,\n        id: str,\n        pagination: int = 50,\n        page: int = 1,\n        start_date: Optional[str] = None,\n        end_date: Optional[str] = None,\n    ) -&gt; Response:\n        \"\"\"Get the transactions that make up a particular settlement\n\n        Args:\n            id: The settlement ID in which you want to fetch its transactions\n            pagination: Specifies how many records you want to retrieve per page. If not specified we\n                use a default value of 50.\n            page: Specifies exactly what page you want to retrieve. If not specified we use a default value of 1.\n            start_date: A timestamp from which to start listing settlement transactions\n                e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            end_date: A timestamp at which to stop listing settlement transactions\n                e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/settlement/{id}/transactions?perPage={pagination}\")\n        query_params = [\n            (\"page\", page),\n            (\"start_date\", start_date),\n            (\"end_date\", end_date),\n        ]\n        url = append_query_params(query_params, url)\n        return self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/settlements/#pypaystack2.api.settlements.Settlement.get_settlement_transactions","title":"<code>get_settlement_transactions(id, pagination=50, page=1, start_date=None, end_date=None)</code>","text":"<p>Get the transactions that make up a particular settlement</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The settlement ID in which you want to fetch its transactions</p> required <code>pagination</code> <code>int</code> <p>Specifies how many records you want to retrieve per page. If not specified we use a default value of 50.</p> <code>50</code> <code>page</code> <code>int</code> <p>Specifies exactly what page you want to retrieve. If not specified we use a default value of 1.</p> <code>1</code> <code>start_date</code> <code>Optional[str]</code> <p>A timestamp from which to start listing settlement transactions e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>end_date</code> <code>Optional[str]</code> <p>A timestamp at which to stop listing settlement transactions e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/settlements.py</code> <pre><code>def get_settlement_transactions(\n    self,\n    id: str,\n    pagination: int = 50,\n    page: int = 1,\n    start_date: Optional[str] = None,\n    end_date: Optional[str] = None,\n) -&gt; Response:\n    \"\"\"Get the transactions that make up a particular settlement\n\n    Args:\n        id: The settlement ID in which you want to fetch its transactions\n        pagination: Specifies how many records you want to retrieve per page. If not specified we\n            use a default value of 50.\n        page: Specifies exactly what page you want to retrieve. If not specified we use a default value of 1.\n        start_date: A timestamp from which to start listing settlement transactions\n            e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        end_date: A timestamp at which to stop listing settlement transactions\n            e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/settlement/{id}/transactions?perPage={pagination}\")\n    query_params = [\n        (\"page\", page),\n        (\"start_date\", start_date),\n        (\"end_date\", end_date),\n    ]\n    url = append_query_params(query_params, url)\n    return self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/settlements/#pypaystack2.api.settlements.Settlement.get_settlements","title":"<code>get_settlements(page=1, pagination=50, start_date=None, end_date=None, subaccount=None)</code>","text":"<p>Fetch settlements made to your settlement accounts.</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>int</code> <p>Specifies exactly what page you want to retrieve. If not specified we use a default value of 1.</p> <code>1</code> <code>pagination</code> <code>int</code> <p>Specifies how many records you want to retrieve per page. If not specified we use a default value of 50.</p> <code>50</code> <code>start_date</code> <code>Optional[str]</code> <p>A timestamp from which to start listing settlements e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>end_date</code> <code>Optional[str]</code> <p>A timestamp at which to stop listing settlements e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>subaccount</code> <code>Optional[str]</code> <p>Provide a subaccount ID to export only settlements for that subaccount. Set to <code>none</code> to export only transactions for the account.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/settlements.py</code> <pre><code>def get_settlements(\n    self,\n    page: int = 1,\n    pagination: int = 50,\n    start_date: Optional[str] = None,\n    end_date: Optional[str] = None,\n    subaccount: Optional[str] = None,\n) -&gt; Response:\n    \"\"\"Fetch settlements made to your settlement accounts.\n\n    Args:\n        page: Specifies exactly what page you want to retrieve.\n            If not specified we use a default value of 1.\n        pagination: Specifies how many records you want to retrieve per page.\n            If not specified we use a default value of 50.\n        start_date: A timestamp from which to start listing settlements e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        end_date: A timestamp at which to stop listing settlements e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        subaccount: Provide a subaccount ID to export only settlements for that subaccount.\n            Set to ``none`` to export only transactions for the account.\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/settlement?perPage={pagination}\")\n    query_params = [\n        (\"subaccount\", subaccount),\n        (\"page\", page),\n        (\"start_date\", start_date),\n        (\"end_date\", end_date),\n    ]\n    url = append_query_params(query_params, url)\n    return self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/splits/","title":"Splits","text":""},{"location":"reference/splits/#pypaystack2.api.splits.AsyncTransactionSplit","title":"<code>AsyncTransactionSplit</code>","text":"<p>               Bases: <code>BaseAsyncAPI</code></p> <p>Provides a wrapper for paystack Transaction Splits API</p> <p>The Transaction Splits API enables merchants split the settlement for a transaction across their payout account, and one or more Subaccounts. https://paystack.com/docs/api/split/</p> Source code in <code>src/pypaystack2/api/splits.py</code> <pre><code>class AsyncTransactionSplit(BaseAsyncAPI):\n    \"\"\"Provides a wrapper for paystack Transaction Splits API\n\n    The Transaction Splits API enables merchants split the settlement for a transaction\n    across their payout account, and one or more Subaccounts.\n    https://paystack.com/docs/api/split/\n    \"\"\"\n\n    async def create(\n        self,\n        name: str,\n        type: TransactionSplit,\n        currency: Currency,\n        subaccounts: list[SplitAccount],\n        bearer_type: Bearer,\n        bearer_subaccount: str,\n    ) -&gt; Response:\n        \"\"\"Create a split payment on your integration\n\n        Args:\n            name: Name of the transaction split\n            type: The type of transaction split you want to create.\n                Any value from the ``SplitType`` enum\n            currency: Any value from the ``Currency`` enum\n            subaccounts: A list of dictionaries containing subaccount code and\n                number of shares: ``[{subaccount: 'ACT_xxxxxxxxxx', share: xxx},{...}]``\n            bearer_type: Any value from the ``Bearer`` enum\n            bearer_subaccount: Subaccount code\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n        subaccounts = [account.dict for account in subaccounts]\n\n        url = self._parse_url(\"/split\")\n        payload = {\n            \"name\": name,\n            \"type\": type,\n            \"currency\": currency,\n            \"subaccounts\": subaccounts,\n            \"bearer_type\": bearer_type,\n            \"bearer_subaccount\": bearer_subaccount,\n        }\n        return await self._handle_request(HTTPMethod.POST, url, payload)\n\n    async def get_splits(\n        self,\n        name: Optional[str] = None,\n        sort_by: Optional[str] = None,\n        page: Optional[int] = None,\n        start_date: Optional[str] = None,\n        end_date: Optional[str] = None,\n        active: bool = True,\n        pagination: int = 50,\n    ) -&gt; Response:\n        \"\"\"Get/search for the transaction splits available on your integration.\n\n        Args:\n            name: The name of the split\n            sort_by: Sort by name, defaults to createdAt date\n            page: Page number to view. If not specify we use a default value of 1.\n            start_date: A timestamp from which to start listing splits e.g. 2019-09-24T00:00:05.000Z, 2019-09-21\n            end_date: A timestamp at which to stop listing splits e.g. 2019-09-24T00:00:05.000Z, 2019-09-21\n            active: Flag to filter by active\n            pagination: Number of splits per page. If not specified we use a default value of 50.\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/split?perPage={pagination}\")\n        query_params = [\n            (\"name\", name),\n            (\"sort_by\", sort_by),\n            (\"page\", page),\n            (\"from\", start_date),\n            (\"to\", end_date),\n            (\"active\", active),\n        ]\n        url = append_query_params(query_params, url)\n\n        return await self._handle_request(HTTPMethod.GET, url)\n\n    async def get_split(self, id: str) -&gt; Response:\n        \"\"\"Get details of a split on your integration.\n\n        Args:\n            id: The id of the split\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._parse_url(f\"/split/{id}/\")\n        return await self._handle_request(HTTPMethod.GET, url)\n\n    async def update(\n        self,\n        id: str,\n        name: str,\n        active: bool,\n        bearer_type: Optional[Bearer],\n        bearer_subaccount: Optional[str],\n    ) -&gt; Response:\n        \"\"\"Update a transaction split details on your integration\n\n        Args:\n            id: Split ID\n            name: Name of the transaction split\n            active: Flag for active\n            bearer_type: Any value from the Bearer enum\n            bearer_subaccount: Subaccount code of a subaccount in the split group.\n                This should be specified only if the bearer_type\n                is ``Bearer.subaccount``\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        if bearer_subaccount:\n            if bearer_type != Bearer.SUB_ACCOUNT:\n                raise InvalidDataException(\n                    \"`bearer_subaccount` can only have a value if `bearer_type` is `Bearer.SUBACCOUNT`\"\n                )\n\n        payload = {\n            \"name\": name,\n            \"active\": active,\n        }\n        optional_params = [\n            (\"bearer_type\", bearer_type),\n            (\"bearer_subaccount\", bearer_subaccount),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        url = self._parse_url(f\"/split/{id}/\")\n        return await self._handle_request(HTTPMethod.PUT, url, payload)\n\n    async def add_or_update(self, id: str, subaccount: str, share: int) -&gt; Response:\n        \"\"\"\n        Add a Subaccount to a Transaction Split, or update\n        the share of an existing Subaccount in a Transaction Split\n\n        Args:\n         id: Split ID\n         subaccount: This is the subaccount code\n         share: This is the transaction share for the subaccount\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        share = validate_amount(share)\n        payload = {\"subaccount\": subaccount, \"share\": share}\n        url = self._parse_url(f\"/split/{id}/subaccount/add\")\n        return await self._handle_request(HTTPMethod.POST, url, payload)\n\n    async def remove(self, id: str, subaccount: str) -&gt; Response:\n        \"\"\"Remove a subaccount from a transaction split\n\n        Args:\n            id: Split ID\n            subaccount: This is the subaccount code\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        payload = {\"subaccount\": subaccount}\n        url = self._parse_url(f\"/split/{id}/subaccount/remove\")\n        return await self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/splits/#pypaystack2.api.splits.AsyncTransactionSplit.add_or_update","title":"<code>add_or_update(id, subaccount, share)</code>  <code>async</code>","text":"<p>Add a Subaccount to a Transaction Split, or update the share of an existing Subaccount in a Transaction Split</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>Split ID</p> required <code>subaccount</code> <code>str</code> <p>This is the subaccount code</p> required <code>share</code> <code>int</code> <p>This is the transaction share for the subaccount</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/splits.py</code> <pre><code>async def add_or_update(self, id: str, subaccount: str, share: int) -&gt; Response:\n    \"\"\"\n    Add a Subaccount to a Transaction Split, or update\n    the share of an existing Subaccount in a Transaction Split\n\n    Args:\n     id: Split ID\n     subaccount: This is the subaccount code\n     share: This is the transaction share for the subaccount\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    share = validate_amount(share)\n    payload = {\"subaccount\": subaccount, \"share\": share}\n    url = self._parse_url(f\"/split/{id}/subaccount/add\")\n    return await self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/splits/#pypaystack2.api.splits.AsyncTransactionSplit.create","title":"<code>create(name, type, currency, subaccounts, bearer_type, bearer_subaccount)</code>  <code>async</code>","text":"<p>Create a split payment on your integration</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the transaction split</p> required <code>type</code> <code>TransactionSplit</code> <p>The type of transaction split you want to create. Any value from the <code>SplitType</code> enum</p> required <code>currency</code> <code>Currency</code> <p>Any value from the <code>Currency</code> enum</p> required <code>subaccounts</code> <code>list[SplitAccount]</code> <p>A list of dictionaries containing subaccount code and number of shares: <code>[{subaccount: 'ACT_xxxxxxxxxx', share: xxx},{...}]</code></p> required <code>bearer_type</code> <code>Bearer</code> <p>Any value from the <code>Bearer</code> enum</p> required <code>bearer_subaccount</code> <code>str</code> <p>Subaccount code</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/splits.py</code> <pre><code>async def create(\n    self,\n    name: str,\n    type: TransactionSplit,\n    currency: Currency,\n    subaccounts: list[SplitAccount],\n    bearer_type: Bearer,\n    bearer_subaccount: str,\n) -&gt; Response:\n    \"\"\"Create a split payment on your integration\n\n    Args:\n        name: Name of the transaction split\n        type: The type of transaction split you want to create.\n            Any value from the ``SplitType`` enum\n        currency: Any value from the ``Currency`` enum\n        subaccounts: A list of dictionaries containing subaccount code and\n            number of shares: ``[{subaccount: 'ACT_xxxxxxxxxx', share: xxx},{...}]``\n        bearer_type: Any value from the ``Bearer`` enum\n        bearer_subaccount: Subaccount code\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n    subaccounts = [account.dict for account in subaccounts]\n\n    url = self._parse_url(\"/split\")\n    payload = {\n        \"name\": name,\n        \"type\": type,\n        \"currency\": currency,\n        \"subaccounts\": subaccounts,\n        \"bearer_type\": bearer_type,\n        \"bearer_subaccount\": bearer_subaccount,\n    }\n    return await self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/splits/#pypaystack2.api.splits.AsyncTransactionSplit.get_split","title":"<code>get_split(id)</code>  <code>async</code>","text":"<p>Get details of a split on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The id of the split</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/splits.py</code> <pre><code>async def get_split(self, id: str) -&gt; Response:\n    \"\"\"Get details of a split on your integration.\n\n    Args:\n        id: The id of the split\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._parse_url(f\"/split/{id}/\")\n    return await self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/splits/#pypaystack2.api.splits.AsyncTransactionSplit.get_splits","title":"<code>get_splits(name=None, sort_by=None, page=None, start_date=None, end_date=None, active=True, pagination=50)</code>  <code>async</code>","text":"<p>Get/search for the transaction splits available on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the split</p> <code>None</code> <code>sort_by</code> <code>Optional[str]</code> <p>Sort by name, defaults to createdAt date</p> <code>None</code> <code>page</code> <code>Optional[int]</code> <p>Page number to view. If not specify we use a default value of 1.</p> <code>None</code> <code>start_date</code> <code>Optional[str]</code> <p>A timestamp from which to start listing splits e.g. 2019-09-24T00:00:05.000Z, 2019-09-21</p> <code>None</code> <code>end_date</code> <code>Optional[str]</code> <p>A timestamp at which to stop listing splits e.g. 2019-09-24T00:00:05.000Z, 2019-09-21</p> <code>None</code> <code>active</code> <code>bool</code> <p>Flag to filter by active</p> <code>True</code> <code>pagination</code> <code>int</code> <p>Number of splits per page. If not specified we use a default value of 50.</p> <code>50</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/splits.py</code> <pre><code>async def get_splits(\n    self,\n    name: Optional[str] = None,\n    sort_by: Optional[str] = None,\n    page: Optional[int] = None,\n    start_date: Optional[str] = None,\n    end_date: Optional[str] = None,\n    active: bool = True,\n    pagination: int = 50,\n) -&gt; Response:\n    \"\"\"Get/search for the transaction splits available on your integration.\n\n    Args:\n        name: The name of the split\n        sort_by: Sort by name, defaults to createdAt date\n        page: Page number to view. If not specify we use a default value of 1.\n        start_date: A timestamp from which to start listing splits e.g. 2019-09-24T00:00:05.000Z, 2019-09-21\n        end_date: A timestamp at which to stop listing splits e.g. 2019-09-24T00:00:05.000Z, 2019-09-21\n        active: Flag to filter by active\n        pagination: Number of splits per page. If not specified we use a default value of 50.\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/split?perPage={pagination}\")\n    query_params = [\n        (\"name\", name),\n        (\"sort_by\", sort_by),\n        (\"page\", page),\n        (\"from\", start_date),\n        (\"to\", end_date),\n        (\"active\", active),\n    ]\n    url = append_query_params(query_params, url)\n\n    return await self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/splits/#pypaystack2.api.splits.AsyncTransactionSplit.remove","title":"<code>remove(id, subaccount)</code>  <code>async</code>","text":"<p>Remove a subaccount from a transaction split</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>Split ID</p> required <code>subaccount</code> <code>str</code> <p>This is the subaccount code</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/splits.py</code> <pre><code>async def remove(self, id: str, subaccount: str) -&gt; Response:\n    \"\"\"Remove a subaccount from a transaction split\n\n    Args:\n        id: Split ID\n        subaccount: This is the subaccount code\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    payload = {\"subaccount\": subaccount}\n    url = self._parse_url(f\"/split/{id}/subaccount/remove\")\n    return await self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/splits/#pypaystack2.api.splits.AsyncTransactionSplit.update","title":"<code>update(id, name, active, bearer_type, bearer_subaccount)</code>  <code>async</code>","text":"<p>Update a transaction split details on your integration</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>Split ID</p> required <code>name</code> <code>str</code> <p>Name of the transaction split</p> required <code>active</code> <code>bool</code> <p>Flag for active</p> required <code>bearer_type</code> <code>Optional[Bearer]</code> <p>Any value from the Bearer enum</p> required <code>bearer_subaccount</code> <code>Optional[str]</code> <p>Subaccount code of a subaccount in the split group. This should be specified only if the bearer_type is <code>Bearer.subaccount</code></p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/splits.py</code> <pre><code>async def update(\n    self,\n    id: str,\n    name: str,\n    active: bool,\n    bearer_type: Optional[Bearer],\n    bearer_subaccount: Optional[str],\n) -&gt; Response:\n    \"\"\"Update a transaction split details on your integration\n\n    Args:\n        id: Split ID\n        name: Name of the transaction split\n        active: Flag for active\n        bearer_type: Any value from the Bearer enum\n        bearer_subaccount: Subaccount code of a subaccount in the split group.\n            This should be specified only if the bearer_type\n            is ``Bearer.subaccount``\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    if bearer_subaccount:\n        if bearer_type != Bearer.SUB_ACCOUNT:\n            raise InvalidDataException(\n                \"`bearer_subaccount` can only have a value if `bearer_type` is `Bearer.SUBACCOUNT`\"\n            )\n\n    payload = {\n        \"name\": name,\n        \"active\": active,\n    }\n    optional_params = [\n        (\"bearer_type\", bearer_type),\n        (\"bearer_subaccount\", bearer_subaccount),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    url = self._parse_url(f\"/split/{id}/\")\n    return await self._handle_request(HTTPMethod.PUT, url, payload)\n</code></pre>"},{"location":"reference/splits/#pypaystack2.api.splits.TransactionSplit","title":"<code>TransactionSplit</code>","text":"<p>               Bases: <code>BaseAPI</code></p> <p>Provides a wrapper for paystack Transaction Splits API</p> <p>The Transaction Splits API enables merchants split the settlement for a transaction across their payout account, and one or more Subaccounts. https://paystack.com/docs/api/split/</p> Source code in <code>src/pypaystack2/api/splits.py</code> <pre><code>class TransactionSplit(BaseAPI):\n    \"\"\"Provides a wrapper for paystack Transaction Splits API\n\n    The Transaction Splits API enables merchants split the settlement for a transaction\n    across their payout account, and one or more Subaccounts.\n    https://paystack.com/docs/api/split/\n    \"\"\"\n\n    def create(\n        self,\n        name: str,\n        type: Split,\n        currency: Currency,\n        subaccounts: list[SplitAccount],\n        bearer_type: Bearer,\n        bearer_subaccount: str,\n    ) -&gt; Response:\n        \"\"\"Create a split payment on your integration\n\n        Args:\n            name: Name of the transaction split\n            type: The type of transaction split you want to create.\n                Any value from the ``SplitType`` enum\n            currency: Any value from the ``Currency`` enum\n            subaccounts: A list of dictionaries containing subaccount code and\n                number of shares: ``[{subaccount: 'ACT_xxxxxxxxxx', share: xxx},{...}]``\n            bearer_type: Any value from the ``Bearer`` enum\n            bearer_subaccount: Subaccount code\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n        subaccounts = [account.dict for account in subaccounts]\n\n        url = self._parse_url(\"/split\")\n        payload = {\n            \"name\": name,\n            \"type\": type,\n            \"currency\": currency,\n            \"subaccounts\": subaccounts,\n            \"bearer_type\": bearer_type,\n            \"bearer_subaccount\": bearer_subaccount,\n        }\n        return self._handle_request(HTTPMethod.POST, url, payload)\n\n    def get_splits(\n        self,\n        name: str,\n        sort_by: Optional[str],\n        page: Optional[int],\n        start_date: Optional[str],\n        end_date: Optional[str],\n        active: bool = True,\n        pagination: int = 50,\n    ) -&gt; Response:\n        \"\"\"Get/search for the transaction splits available on your integration.\n\n        Args:\n            name: The name of the split\n            sort_by: Sort by name, defaults to createdAt date\n            page: Page number to view. If not specify we use a default value of 1.\n            start_date: A timestamp from which to start listing splits e.g. 2019-09-24T00:00:05.000Z, 2019-09-21\n            end_date: A timestamp at which to stop listing splits e.g. 2019-09-24T00:00:05.000Z, 2019-09-21\n            active: Flag to filter by active\n            pagination: Number of splits per page. If not specified we use a default value of 50.\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/split?perPage={pagination}\")\n        query_params = [\n            (\"name\", name),\n            (\"sort_by\", sort_by),\n            (\"page\", page),\n            (\"from\", start_date),\n            (\"to\", end_date),\n            (\"active\", active),\n        ]\n        url = append_query_params(query_params, url)\n\n        return self._handle_request(HTTPMethod.GET, url)\n\n    def get_split(self, id: str) -&gt; Response:\n        \"\"\"Get details of a split on your integration.\n\n        Args:\n            id: The id of the split\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._parse_url(f\"/split/{id}/\")\n        return self._handle_request(HTTPMethod.GET, url)\n\n    def update(\n        self,\n        id: str,\n        name: str,\n        active: bool,\n        bearer_type: Optional[Bearer],\n        bearer_subaccount: Optional[str],\n    ) -&gt; Response:\n        \"\"\"Update a transaction split details on your integration\n\n        Args:\n            id: Split ID\n            name: Name of the transaction split\n            active: Flag for active\n            bearer_type: Any value from the Bearer enum\n            bearer_subaccount: Subaccount code of a subaccount in the split group.\n                This should be specified only if the bearer_type\n                is ``Bearer.subaccount``\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        if bearer_subaccount:\n            if bearer_type != Bearer.SUB_ACCOUNT:\n                raise InvalidDataException(\n                    \"`bearer_subaccount` can only have a value if `bearer_type` is `Bearer.SUBACCOUNT`\"\n                )\n\n        payload = {\n            \"name\": name,\n            \"active\": active,\n        }\n        optional_params = [\n            (\"bearer_type\", bearer_type),\n            (\"bearer_subaccount\", bearer_subaccount),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        url = self._parse_url(f\"/split/{id}/\")\n        return self._handle_request(HTTPMethod.PUT, url, payload)\n\n    def add_or_update(self, id: str, subaccount: str, share: int) -&gt; Response:\n        \"\"\"\n        Add a Subaccount to a Transaction Split, or update\n        the share of an existing Subaccount in a Transaction Split\n\n        Args:\n         id: Split ID\n         subaccount: This is the subaccount code\n         share: This is the transaction share for the subaccount\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        share = validate_amount(share)\n        payload = {\"subaccount\": subaccount, \"share\": share}\n        url = self._parse_url(f\"/split/{id}/subaccount/add\")\n        return self._handle_request(HTTPMethod.POST, url, payload)\n\n    def remove(self, id: str, subaccount: str) -&gt; Response:\n        \"\"\"Remove a subaccount from a transaction split\n\n        Args:\n            id: Split ID\n            subaccount: This is the subaccount code\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        payload = {\"subaccount\": subaccount}\n        url = self._parse_url(f\"/split/{id}/subaccount/remove\")\n        return self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/splits/#pypaystack2.api.splits.TransactionSplit.add_or_update","title":"<code>add_or_update(id, subaccount, share)</code>","text":"<p>Add a Subaccount to a Transaction Split, or update the share of an existing Subaccount in a Transaction Split</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>Split ID</p> required <code>subaccount</code> <code>str</code> <p>This is the subaccount code</p> required <code>share</code> <code>int</code> <p>This is the transaction share for the subaccount</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/splits.py</code> <pre><code>def add_or_update(self, id: str, subaccount: str, share: int) -&gt; Response:\n    \"\"\"\n    Add a Subaccount to a Transaction Split, or update\n    the share of an existing Subaccount in a Transaction Split\n\n    Args:\n     id: Split ID\n     subaccount: This is the subaccount code\n     share: This is the transaction share for the subaccount\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    share = validate_amount(share)\n    payload = {\"subaccount\": subaccount, \"share\": share}\n    url = self._parse_url(f\"/split/{id}/subaccount/add\")\n    return self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/splits/#pypaystack2.api.splits.TransactionSplit.create","title":"<code>create(name, type, currency, subaccounts, bearer_type, bearer_subaccount)</code>","text":"<p>Create a split payment on your integration</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the transaction split</p> required <code>type</code> <code>Split</code> <p>The type of transaction split you want to create. Any value from the <code>SplitType</code> enum</p> required <code>currency</code> <code>Currency</code> <p>Any value from the <code>Currency</code> enum</p> required <code>subaccounts</code> <code>list[SplitAccount]</code> <p>A list of dictionaries containing subaccount code and number of shares: <code>[{subaccount: 'ACT_xxxxxxxxxx', share: xxx},{...}]</code></p> required <code>bearer_type</code> <code>Bearer</code> <p>Any value from the <code>Bearer</code> enum</p> required <code>bearer_subaccount</code> <code>str</code> <p>Subaccount code</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/splits.py</code> <pre><code>def create(\n    self,\n    name: str,\n    type: Split,\n    currency: Currency,\n    subaccounts: list[SplitAccount],\n    bearer_type: Bearer,\n    bearer_subaccount: str,\n) -&gt; Response:\n    \"\"\"Create a split payment on your integration\n\n    Args:\n        name: Name of the transaction split\n        type: The type of transaction split you want to create.\n            Any value from the ``SplitType`` enum\n        currency: Any value from the ``Currency`` enum\n        subaccounts: A list of dictionaries containing subaccount code and\n            number of shares: ``[{subaccount: 'ACT_xxxxxxxxxx', share: xxx},{...}]``\n        bearer_type: Any value from the ``Bearer`` enum\n        bearer_subaccount: Subaccount code\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n    subaccounts = [account.dict for account in subaccounts]\n\n    url = self._parse_url(\"/split\")\n    payload = {\n        \"name\": name,\n        \"type\": type,\n        \"currency\": currency,\n        \"subaccounts\": subaccounts,\n        \"bearer_type\": bearer_type,\n        \"bearer_subaccount\": bearer_subaccount,\n    }\n    return self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/splits/#pypaystack2.api.splits.TransactionSplit.get_split","title":"<code>get_split(id)</code>","text":"<p>Get details of a split on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The id of the split</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/splits.py</code> <pre><code>def get_split(self, id: str) -&gt; Response:\n    \"\"\"Get details of a split on your integration.\n\n    Args:\n        id: The id of the split\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._parse_url(f\"/split/{id}/\")\n    return self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/splits/#pypaystack2.api.splits.TransactionSplit.get_splits","title":"<code>get_splits(name, sort_by, page, start_date, end_date, active=True, pagination=50)</code>","text":"<p>Get/search for the transaction splits available on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the split</p> required <code>sort_by</code> <code>Optional[str]</code> <p>Sort by name, defaults to createdAt date</p> required <code>page</code> <code>Optional[int]</code> <p>Page number to view. If not specify we use a default value of 1.</p> required <code>start_date</code> <code>Optional[str]</code> <p>A timestamp from which to start listing splits e.g. 2019-09-24T00:00:05.000Z, 2019-09-21</p> required <code>end_date</code> <code>Optional[str]</code> <p>A timestamp at which to stop listing splits e.g. 2019-09-24T00:00:05.000Z, 2019-09-21</p> required <code>active</code> <code>bool</code> <p>Flag to filter by active</p> <code>True</code> <code>pagination</code> <code>int</code> <p>Number of splits per page. If not specified we use a default value of 50.</p> <code>50</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/splits.py</code> <pre><code>def get_splits(\n    self,\n    name: str,\n    sort_by: Optional[str],\n    page: Optional[int],\n    start_date: Optional[str],\n    end_date: Optional[str],\n    active: bool = True,\n    pagination: int = 50,\n) -&gt; Response:\n    \"\"\"Get/search for the transaction splits available on your integration.\n\n    Args:\n        name: The name of the split\n        sort_by: Sort by name, defaults to createdAt date\n        page: Page number to view. If not specify we use a default value of 1.\n        start_date: A timestamp from which to start listing splits e.g. 2019-09-24T00:00:05.000Z, 2019-09-21\n        end_date: A timestamp at which to stop listing splits e.g. 2019-09-24T00:00:05.000Z, 2019-09-21\n        active: Flag to filter by active\n        pagination: Number of splits per page. If not specified we use a default value of 50.\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/split?perPage={pagination}\")\n    query_params = [\n        (\"name\", name),\n        (\"sort_by\", sort_by),\n        (\"page\", page),\n        (\"from\", start_date),\n        (\"to\", end_date),\n        (\"active\", active),\n    ]\n    url = append_query_params(query_params, url)\n\n    return self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/splits/#pypaystack2.api.splits.TransactionSplit.remove","title":"<code>remove(id, subaccount)</code>","text":"<p>Remove a subaccount from a transaction split</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>Split ID</p> required <code>subaccount</code> <code>str</code> <p>This is the subaccount code</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/splits.py</code> <pre><code>def remove(self, id: str, subaccount: str) -&gt; Response:\n    \"\"\"Remove a subaccount from a transaction split\n\n    Args:\n        id: Split ID\n        subaccount: This is the subaccount code\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    payload = {\"subaccount\": subaccount}\n    url = self._parse_url(f\"/split/{id}/subaccount/remove\")\n    return self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/splits/#pypaystack2.api.splits.TransactionSplit.update","title":"<code>update(id, name, active, bearer_type, bearer_subaccount)</code>","text":"<p>Update a transaction split details on your integration</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>Split ID</p> required <code>name</code> <code>str</code> <p>Name of the transaction split</p> required <code>active</code> <code>bool</code> <p>Flag for active</p> required <code>bearer_type</code> <code>Optional[Bearer]</code> <p>Any value from the Bearer enum</p> required <code>bearer_subaccount</code> <code>Optional[str]</code> <p>Subaccount code of a subaccount in the split group. This should be specified only if the bearer_type is <code>Bearer.subaccount</code></p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/splits.py</code> <pre><code>def update(\n    self,\n    id: str,\n    name: str,\n    active: bool,\n    bearer_type: Optional[Bearer],\n    bearer_subaccount: Optional[str],\n) -&gt; Response:\n    \"\"\"Update a transaction split details on your integration\n\n    Args:\n        id: Split ID\n        name: Name of the transaction split\n        active: Flag for active\n        bearer_type: Any value from the Bearer enum\n        bearer_subaccount: Subaccount code of a subaccount in the split group.\n            This should be specified only if the bearer_type\n            is ``Bearer.subaccount``\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    if bearer_subaccount:\n        if bearer_type != Bearer.SUB_ACCOUNT:\n            raise InvalidDataException(\n                \"`bearer_subaccount` can only have a value if `bearer_type` is `Bearer.SUBACCOUNT`\"\n            )\n\n    payload = {\n        \"name\": name,\n        \"active\": active,\n    }\n    optional_params = [\n        (\"bearer_type\", bearer_type),\n        (\"bearer_subaccount\", bearer_subaccount),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    url = self._parse_url(f\"/split/{id}/\")\n    return self._handle_request(HTTPMethod.PUT, url, payload)\n</code></pre>"},{"location":"reference/subaccounts/","title":"Subaccounts","text":""},{"location":"reference/subaccounts/#pypaystack2.api.subaccounts.AsyncSubAccount","title":"<code>AsyncSubAccount</code>","text":"<p>               Bases: <code>BaseAsyncAPI</code></p> <p>Provides a wrapper for paystack Subaccounts API</p> <p>The Subaccounts API allows you to create and manage subaccounts on your integration. Subaccounts can be used to split payment between two accounts (your main account and a sub account). https://paystack.com/docs/api/subaccount/</p> Source code in <code>src/pypaystack2/api/subaccounts.py</code> <pre><code>class AsyncSubAccount(BaseAsyncAPI):\n    \"\"\"Provides a wrapper for paystack Subaccounts API\n\n    The Subaccounts API allows you to create and manage subaccounts on your integration.\n    Subaccounts can be used to split payment between two accounts\n    (your main account and a sub account).\n    https://paystack.com/docs/api/subaccount/\n    \"\"\"\n\n    async def create(\n        self,\n        business_name: str,\n        settlement_bank: str,\n        account_number: str,\n        percentage_charge: float,\n        description: str,\n        primary_contact_email: Optional[str] = None,\n        primary_contact_name: Optional[str] = None,\n        primary_contact_phone: Optional[str] = None,\n        metadata: Optional[dict] = None,\n    ) -&gt; Response:\n        \"\"\"Create a subacount on your integration.\n\n        Args:\n            business_name: Name of business for subaccount\n            settlement_bank: Bank Code for the bank. You can get the\n                list of Bank Codes by calling the ``.get_banks``\n                method from the Miscellaneous API wrapper\n            account_number: Bank Account Number\n            percentage_charge: The default percentage charged when receiving on behalf of this subaccount\n            description: A description for this subaccount\n            primary_contact_email: A contact email for the subaccount\n            primary_contact_name: A name for the contact person for this subaccount\n            primary_contact_phone: A phone number to call for this subaccount\n            metadata: Add a custom_fields attribute which has a list of dictionaries if\n                you would like the fields to be added to your transaction when\n                displayed on the dashboard.\n                Sample: ``{\"custom_fields\":[{\"display_name\":\"Cart ID\",\n                \"variable_name\": \"cart_id\",\"value\": \"8393\"}]}``\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(\"/subaccount\")\n        payload = {\n            \"business_name\": business_name,\n            \"settlement_bank\": settlement_bank,\n            \"account_number\": account_number,\n            \"percentage_charge\": percentage_charge,\n            \"description\": description,\n        }\n        optional_params = [\n            (\"primary_contact_email\", primary_contact_email),\n            (\"primary_contact_name\", primary_contact_name),\n            (\"primary_contact_phone\", primary_contact_phone),\n            (\"metadata\", metadata),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return await self._handle_request(HTTPMethod.POST, url, payload)\n\n    async def get_subaccounts(\n        self, start_date: str, end_date: str, page: int = 1, pagination: int = 50\n    ) -&gt; Response:\n        \"\"\"Fetch subaccounts available on your integration.\n\n        Args:\n            start_date: A timestamp from which to start listing subaccounts e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            end_date: A timestamp at which to stop listing subaccounts e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            page: Specifies exactly what page you want to retrieve. If not specified we use a default value of 1.\n            pagination: Specifies how many records you want to retrieve per page.\n                If not specified we use a default value of 50.\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._parse_url(f\"/subaccount?perPage={pagination}\")\n        query_params = [\n            (\"from\", start_date),\n            (\"to\", end_date),\n            (\"page\", page),\n        ]\n        url = append_query_params(query_params, url)\n        return self._handle_request(HTTPMethod.GET, url)\n\n    async def get_subaccount(self, id_or_code: str) -&gt; Response:\n        \"\"\"Get details of a subaccount on your integration.\n\n        Args:\n            id_or_code: The subaccount ``ID`` or ``code`` you want to fetch\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/subaccount/{id_or_code}\")\n        return await self._handle_request(HTTPMethod.GET, url)\n\n    async def update(\n        self,\n        id_or_code: str,\n        business_name: str,\n        settlement_bank: str,\n        account_number: Optional[str] = None,\n        active: Optional[bool] = None,\n        percentage_charge: Optional[float] = None,\n        description: Optional[str] = None,\n        primary_contact_email: Optional[str] = None,\n        primary_contact_name: Optional[str] = None,\n        primary_contact_phone: Optional[str] = None,\n        settlement_schedule: Optional[Schedule] = None,\n        metadata: Optional[dict] = None,\n    ) -&gt; Response:\n        \"\"\"Update a subaccount details on your integration.\n\n        Args:\n            id_or_code: Subaccount's ID or code\n            business_name: Name of business for subaccount\n            settlement_bank: Bank Code for the bank. You can get the\n                list of Bank Codes by calling the ``.get_banks``\n                method from the Miscellaneous API wrapper\n            account_number: Bank Account Number\n            active: Activate or deactivate a subaccount.\n            percentage_charge: The default percentage charged when\n                receiving on behalf of this subaccount\n            description: A description for this subaccount\n            primary_contact_email: A contact email for the subaccount\n            primary_contact_name: A name for the contact person for this subaccount\n            primary_contact_phone: A phone number to call for this subaccount\n            settlement_schedule: ``Schedule.AUTO`` means payout is T+1 and manual means payout to the\n                subaccount should only be made when requested.\n                Defaults to ``Schedule.AUTO``\n            metadata: Add a custom_fields attribute which has a list of dictionaries if you would\n                like the fields to be added to your transaction when displayed on the\n                dashboard. Sample: ``{\"custom_fields\":[{\"display_name\":\"Cart ID\",\n                \"variable_name\": \"cart_id\",\"value\": \"8393\"}]}``\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        payload = {\n            \"id_or_code\": id_or_code,\n            \"business_name\": business_name,\n            \"settlement_bank\": settlement_bank,\n        }\n        optional_params = [\n            (\"account_number\", account_number),\n            (\"active\", active),\n            (\"percentage_charge\", percentage_charge),\n            (\"description\", description),\n            (\"primary_contact_email\", primary_contact_email),\n            (\"primary_contact_name\", primary_contact_name),\n            (\"primary_contact_phone\", primary_contact_phone),\n            (\"settlement_schedule\", settlement_schedule),\n            (\"metadata\", metadata),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        url = self._parse_url(f\"/subaccount/{id_or_code}\")\n        return await self._handle_request(HTTPMethod.PUT, url, payload)\n</code></pre>"},{"location":"reference/subaccounts/#pypaystack2.api.subaccounts.AsyncSubAccount.create","title":"<code>create(business_name, settlement_bank, account_number, percentage_charge, description, primary_contact_email=None, primary_contact_name=None, primary_contact_phone=None, metadata=None)</code>  <code>async</code>","text":"<p>Create a subacount on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>business_name</code> <code>str</code> <p>Name of business for subaccount</p> required <code>settlement_bank</code> <code>str</code> <p>Bank Code for the bank. You can get the list of Bank Codes by calling the <code>.get_banks</code> method from the Miscellaneous API wrapper</p> required <code>account_number</code> <code>str</code> <p>Bank Account Number</p> required <code>percentage_charge</code> <code>float</code> <p>The default percentage charged when receiving on behalf of this subaccount</p> required <code>description</code> <code>str</code> <p>A description for this subaccount</p> required <code>primary_contact_email</code> <code>Optional[str]</code> <p>A contact email for the subaccount</p> <code>None</code> <code>primary_contact_name</code> <code>Optional[str]</code> <p>A name for the contact person for this subaccount</p> <code>None</code> <code>primary_contact_phone</code> <code>Optional[str]</code> <p>A phone number to call for this subaccount</p> <code>None</code> <code>metadata</code> <code>Optional[dict]</code> <p>Add a custom_fields attribute which has a list of dictionaries if you would like the fields to be added to your transaction when displayed on the dashboard. Sample: <code>{\"custom_fields\":[{\"display_name\":\"Cart ID\", \"variable_name\": \"cart_id\",\"value\": \"8393\"}]}</code></p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/subaccounts.py</code> <pre><code>async def create(\n    self,\n    business_name: str,\n    settlement_bank: str,\n    account_number: str,\n    percentage_charge: float,\n    description: str,\n    primary_contact_email: Optional[str] = None,\n    primary_contact_name: Optional[str] = None,\n    primary_contact_phone: Optional[str] = None,\n    metadata: Optional[dict] = None,\n) -&gt; Response:\n    \"\"\"Create a subacount on your integration.\n\n    Args:\n        business_name: Name of business for subaccount\n        settlement_bank: Bank Code for the bank. You can get the\n            list of Bank Codes by calling the ``.get_banks``\n            method from the Miscellaneous API wrapper\n        account_number: Bank Account Number\n        percentage_charge: The default percentage charged when receiving on behalf of this subaccount\n        description: A description for this subaccount\n        primary_contact_email: A contact email for the subaccount\n        primary_contact_name: A name for the contact person for this subaccount\n        primary_contact_phone: A phone number to call for this subaccount\n        metadata: Add a custom_fields attribute which has a list of dictionaries if\n            you would like the fields to be added to your transaction when\n            displayed on the dashboard.\n            Sample: ``{\"custom_fields\":[{\"display_name\":\"Cart ID\",\n            \"variable_name\": \"cart_id\",\"value\": \"8393\"}]}``\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(\"/subaccount\")\n    payload = {\n        \"business_name\": business_name,\n        \"settlement_bank\": settlement_bank,\n        \"account_number\": account_number,\n        \"percentage_charge\": percentage_charge,\n        \"description\": description,\n    }\n    optional_params = [\n        (\"primary_contact_email\", primary_contact_email),\n        (\"primary_contact_name\", primary_contact_name),\n        (\"primary_contact_phone\", primary_contact_phone),\n        (\"metadata\", metadata),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return await self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/subaccounts/#pypaystack2.api.subaccounts.AsyncSubAccount.get_subaccount","title":"<code>get_subaccount(id_or_code)</code>  <code>async</code>","text":"<p>Get details of a subaccount on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>id_or_code</code> <code>str</code> <p>The subaccount <code>ID</code> or <code>code</code> you want to fetch</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/subaccounts.py</code> <pre><code>async def get_subaccount(self, id_or_code: str) -&gt; Response:\n    \"\"\"Get details of a subaccount on your integration.\n\n    Args:\n        id_or_code: The subaccount ``ID`` or ``code`` you want to fetch\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/subaccount/{id_or_code}\")\n    return await self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/subaccounts/#pypaystack2.api.subaccounts.AsyncSubAccount.get_subaccounts","title":"<code>get_subaccounts(start_date, end_date, page=1, pagination=50)</code>  <code>async</code>","text":"<p>Fetch subaccounts available on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>start_date</code> <code>str</code> <p>A timestamp from which to start listing subaccounts e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> required <code>end_date</code> <code>str</code> <p>A timestamp at which to stop listing subaccounts e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> required <code>page</code> <code>int</code> <p>Specifies exactly what page you want to retrieve. If not specified we use a default value of 1.</p> <code>1</code> <code>pagination</code> <code>int</code> <p>Specifies how many records you want to retrieve per page. If not specified we use a default value of 50.</p> <code>50</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/subaccounts.py</code> <pre><code>async def get_subaccounts(\n    self, start_date: str, end_date: str, page: int = 1, pagination: int = 50\n) -&gt; Response:\n    \"\"\"Fetch subaccounts available on your integration.\n\n    Args:\n        start_date: A timestamp from which to start listing subaccounts e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        end_date: A timestamp at which to stop listing subaccounts e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        page: Specifies exactly what page you want to retrieve. If not specified we use a default value of 1.\n        pagination: Specifies how many records you want to retrieve per page.\n            If not specified we use a default value of 50.\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._parse_url(f\"/subaccount?perPage={pagination}\")\n    query_params = [\n        (\"from\", start_date),\n        (\"to\", end_date),\n        (\"page\", page),\n    ]\n    url = append_query_params(query_params, url)\n    return self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/subaccounts/#pypaystack2.api.subaccounts.AsyncSubAccount.update","title":"<code>update(id_or_code, business_name, settlement_bank, account_number=None, active=None, percentage_charge=None, description=None, primary_contact_email=None, primary_contact_name=None, primary_contact_phone=None, settlement_schedule=None, metadata=None)</code>  <code>async</code>","text":"<p>Update a subaccount details on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>id_or_code</code> <code>str</code> <p>Subaccount's ID or code</p> required <code>business_name</code> <code>str</code> <p>Name of business for subaccount</p> required <code>settlement_bank</code> <code>str</code> <p>Bank Code for the bank. You can get the list of Bank Codes by calling the <code>.get_banks</code> method from the Miscellaneous API wrapper</p> required <code>account_number</code> <code>Optional[str]</code> <p>Bank Account Number</p> <code>None</code> <code>active</code> <code>Optional[bool]</code> <p>Activate or deactivate a subaccount.</p> <code>None</code> <code>percentage_charge</code> <code>Optional[float]</code> <p>The default percentage charged when receiving on behalf of this subaccount</p> <code>None</code> <code>description</code> <code>Optional[str]</code> <p>A description for this subaccount</p> <code>None</code> <code>primary_contact_email</code> <code>Optional[str]</code> <p>A contact email for the subaccount</p> <code>None</code> <code>primary_contact_name</code> <code>Optional[str]</code> <p>A name for the contact person for this subaccount</p> <code>None</code> <code>primary_contact_phone</code> <code>Optional[str]</code> <p>A phone number to call for this subaccount</p> <code>None</code> <code>settlement_schedule</code> <code>Optional[Schedule]</code> <p><code>Schedule.AUTO</code> means payout is T+1 and manual means payout to the subaccount should only be made when requested. Defaults to <code>Schedule.AUTO</code></p> <code>None</code> <code>metadata</code> <code>Optional[dict]</code> <p>Add a custom_fields attribute which has a list of dictionaries if you would like the fields to be added to your transaction when displayed on the dashboard. Sample: <code>{\"custom_fields\":[{\"display_name\":\"Cart ID\", \"variable_name\": \"cart_id\",\"value\": \"8393\"}]}</code></p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/subaccounts.py</code> <pre><code>async def update(\n    self,\n    id_or_code: str,\n    business_name: str,\n    settlement_bank: str,\n    account_number: Optional[str] = None,\n    active: Optional[bool] = None,\n    percentage_charge: Optional[float] = None,\n    description: Optional[str] = None,\n    primary_contact_email: Optional[str] = None,\n    primary_contact_name: Optional[str] = None,\n    primary_contact_phone: Optional[str] = None,\n    settlement_schedule: Optional[Schedule] = None,\n    metadata: Optional[dict] = None,\n) -&gt; Response:\n    \"\"\"Update a subaccount details on your integration.\n\n    Args:\n        id_or_code: Subaccount's ID or code\n        business_name: Name of business for subaccount\n        settlement_bank: Bank Code for the bank. You can get the\n            list of Bank Codes by calling the ``.get_banks``\n            method from the Miscellaneous API wrapper\n        account_number: Bank Account Number\n        active: Activate or deactivate a subaccount.\n        percentage_charge: The default percentage charged when\n            receiving on behalf of this subaccount\n        description: A description for this subaccount\n        primary_contact_email: A contact email for the subaccount\n        primary_contact_name: A name for the contact person for this subaccount\n        primary_contact_phone: A phone number to call for this subaccount\n        settlement_schedule: ``Schedule.AUTO`` means payout is T+1 and manual means payout to the\n            subaccount should only be made when requested.\n            Defaults to ``Schedule.AUTO``\n        metadata: Add a custom_fields attribute which has a list of dictionaries if you would\n            like the fields to be added to your transaction when displayed on the\n            dashboard. Sample: ``{\"custom_fields\":[{\"display_name\":\"Cart ID\",\n            \"variable_name\": \"cart_id\",\"value\": \"8393\"}]}``\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    payload = {\n        \"id_or_code\": id_or_code,\n        \"business_name\": business_name,\n        \"settlement_bank\": settlement_bank,\n    }\n    optional_params = [\n        (\"account_number\", account_number),\n        (\"active\", active),\n        (\"percentage_charge\", percentage_charge),\n        (\"description\", description),\n        (\"primary_contact_email\", primary_contact_email),\n        (\"primary_contact_name\", primary_contact_name),\n        (\"primary_contact_phone\", primary_contact_phone),\n        (\"settlement_schedule\", settlement_schedule),\n        (\"metadata\", metadata),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    url = self._parse_url(f\"/subaccount/{id_or_code}\")\n    return await self._handle_request(HTTPMethod.PUT, url, payload)\n</code></pre>"},{"location":"reference/subaccounts/#pypaystack2.api.subaccounts.SubAccount","title":"<code>SubAccount</code>","text":"<p>               Bases: <code>BaseAPI</code></p> <p>Provides a wrapper for paystack Subaccounts API</p> <p>The Subaccounts API allows you to create and manage subaccounts on your integration. Subaccounts can be used to split payment between two accounts (your main account and a sub account). https://paystack.com/docs/api/subaccount/</p> Source code in <code>src/pypaystack2/api/subaccounts.py</code> <pre><code>class SubAccount(BaseAPI):\n    \"\"\"Provides a wrapper for paystack Subaccounts API\n\n    The Subaccounts API allows you to create and manage subaccounts on your integration.\n    Subaccounts can be used to split payment between two accounts\n    (your main account and a sub account).\n    https://paystack.com/docs/api/subaccount/\n    \"\"\"\n\n    def create(\n        self,\n        business_name: str,\n        settlement_bank: str,\n        account_number: str,\n        percentage_charge: float,\n        description: Optional[str] = None,\n        primary_contact_email: Optional[str] = None,\n        primary_contact_name: Optional[str] = None,\n        primary_contact_phone: Optional[str] = None,\n        metadata: Optional[dict] = None,\n    ) -&gt; Response:\n        \"\"\"Create a subacount on your integration.\n\n        Args:\n            business_name: Name of business for subaccount\n            settlement_bank: Bank Code for the bank. You can get the\n                list of Bank Codes by calling the ``.get_banks``\n                method from the Miscellaneous API wrapper\n            account_number: Bank Account Number\n            percentage_charge: The default percentage charged when receiving on behalf of this subaccount\n            description: A description for this subaccount\n            primary_contact_email: A contact email for the subaccount\n            primary_contact_name: A name for the contact person for this subaccount\n            primary_contact_phone: A phone number to call for this subaccount\n            metadata: Add a custom_fields attribute which has a list of dictionaries if\n                you would like the fields to be added to your transaction when\n                displayed on the dashboard.\n                Sample: ``{\"custom_fields\":[{\"display_name\":\"Cart ID\",\n                \"variable_name\": \"cart_id\",\"value\": \"8393\"}]}``\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(\"/subaccount\")\n        payload = {\n            \"business_name\": business_name,\n            \"settlement_bank\": settlement_bank,\n            \"account_number\": account_number,\n            \"percentage_charge\": percentage_charge,\n            \"description\": description,\n        }\n        optional_params = [\n            (\"primary_contact_email\", primary_contact_email),\n            (\"primary_contact_name\", primary_contact_name),\n            (\"primary_contact_phone\", primary_contact_phone),\n            (\"metadata\", metadata),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return self._handle_request(HTTPMethod.POST, url, payload)\n\n    def get_subaccounts(\n        self, start_date: str, end_date: str, page: int = 1, pagination: int = 50\n    ) -&gt; Response:\n        \"\"\"Fetch subaccounts available on your integration.\n\n        Args:\n            start_date: A timestamp from which to start listing subaccounts e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            end_date: A timestamp at which to stop listing subaccounts e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            page: Specifies exactly what page you want to retrieve. If not specified we use a default value of 1.\n            pagination: Specifies how many records you want to retrieve per page.\n                If not specified we use a default value of 50.\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._parse_url(f\"/subaccount?perPage={pagination}\")\n        query_params = [\n            (\"from\", start_date),\n            (\"to\", end_date),\n            (\"page\", page),\n        ]\n        url = append_query_params(query_params, url)\n        return self._handle_request(HTTPMethod.GET, url)\n\n    def get_subaccount(self, id_or_code: str) -&gt; Response:\n        \"\"\"Get details of a subaccount on your integration.\n\n        Args:\n            id_or_code: The subaccount ``ID`` or ``code`` you want to fetch\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/subaccount/{id_or_code}\")\n        return self._handle_request(HTTPMethod.GET, url)\n\n    def update(\n        self,\n        id_or_code: str,\n        business_name: str,\n        settlement_bank: str,\n        account_number: Optional[str] = None,\n        active: Optional[bool] = None,\n        percentage_charge: Optional[float] = None,\n        description: Optional[str] = None,\n        primary_contact_email: Optional[str] = None,\n        primary_contact_name: Optional[str] = None,\n        primary_contact_phone: Optional[str] = None,\n        settlement_schedule: Optional[Schedule] = None,\n        metadata: Optional[dict] = None,\n    ) -&gt; Response:\n        \"\"\"Update a subaccount details on your integration.\n\n        Args:\n            id_or_code: Subaccount's ID or code\n            business_name: Name of business for subaccount\n            settlement_bank: Bank Code for the bank. You can get the\n                list of Bank Codes by calling the ``.get_banks``\n                method from the Miscellaneous API wrapper\n            account_number: Bank Account Number\n            active: Activate or deactivate a subaccount.\n            percentage_charge: The default percentage charged when\n                receiving on behalf of this subaccount\n            description: A description for this subaccount\n            primary_contact_email: A contact email for the subaccount\n            primary_contact_name: A name for the contact person for this subaccount\n            primary_contact_phone: A phone number to call for this subaccount\n            settlement_schedule: ``Schedule.AUTO`` means payout is T+1 and manual means payout to the\n                subaccount should only be made when requested.\n                Defaults to ``Schedule.AUTO``\n            metadata: Add a custom_fields attribute which has a list of dictionaries if you would\n                like the fields to be added to your transaction when displayed on the\n                dashboard. Sample: ``{\"custom_fields\":[{\"display_name\":\"Cart ID\",\n                \"variable_name\": \"cart_id\",\"value\": \"8393\"}]}``\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        payload = {\n            \"id_or_code\": id_or_code,\n            \"business_name\": business_name,\n            \"settlement_bank\": settlement_bank,\n        }\n        optional_params = [\n            (\"account_number\", account_number),\n            (\"active\", active),\n            (\"percentage_charge\", percentage_charge),\n            (\"description\", description),\n            (\"primary_contact_email\", primary_contact_email),\n            (\"primary_contact_name\", primary_contact_name),\n            (\"primary_contact_phone\", primary_contact_phone),\n            (\"settlement_schedule\", settlement_schedule),\n            (\"metadata\", metadata),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        url = self._parse_url(f\"/subaccount/{id_or_code}\")\n        return self._handle_request(HTTPMethod.PUT, url, payload)\n</code></pre>"},{"location":"reference/subaccounts/#pypaystack2.api.subaccounts.SubAccount.create","title":"<code>create(business_name, settlement_bank, account_number, percentage_charge, description=None, primary_contact_email=None, primary_contact_name=None, primary_contact_phone=None, metadata=None)</code>","text":"<p>Create a subacount on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>business_name</code> <code>str</code> <p>Name of business for subaccount</p> required <code>settlement_bank</code> <code>str</code> <p>Bank Code for the bank. You can get the list of Bank Codes by calling the <code>.get_banks</code> method from the Miscellaneous API wrapper</p> required <code>account_number</code> <code>str</code> <p>Bank Account Number</p> required <code>percentage_charge</code> <code>float</code> <p>The default percentage charged when receiving on behalf of this subaccount</p> required <code>description</code> <code>Optional[str]</code> <p>A description for this subaccount</p> <code>None</code> <code>primary_contact_email</code> <code>Optional[str]</code> <p>A contact email for the subaccount</p> <code>None</code> <code>primary_contact_name</code> <code>Optional[str]</code> <p>A name for the contact person for this subaccount</p> <code>None</code> <code>primary_contact_phone</code> <code>Optional[str]</code> <p>A phone number to call for this subaccount</p> <code>None</code> <code>metadata</code> <code>Optional[dict]</code> <p>Add a custom_fields attribute which has a list of dictionaries if you would like the fields to be added to your transaction when displayed on the dashboard. Sample: <code>{\"custom_fields\":[{\"display_name\":\"Cart ID\", \"variable_name\": \"cart_id\",\"value\": \"8393\"}]}</code></p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/subaccounts.py</code> <pre><code>def create(\n    self,\n    business_name: str,\n    settlement_bank: str,\n    account_number: str,\n    percentage_charge: float,\n    description: Optional[str] = None,\n    primary_contact_email: Optional[str] = None,\n    primary_contact_name: Optional[str] = None,\n    primary_contact_phone: Optional[str] = None,\n    metadata: Optional[dict] = None,\n) -&gt; Response:\n    \"\"\"Create a subacount on your integration.\n\n    Args:\n        business_name: Name of business for subaccount\n        settlement_bank: Bank Code for the bank. You can get the\n            list of Bank Codes by calling the ``.get_banks``\n            method from the Miscellaneous API wrapper\n        account_number: Bank Account Number\n        percentage_charge: The default percentage charged when receiving on behalf of this subaccount\n        description: A description for this subaccount\n        primary_contact_email: A contact email for the subaccount\n        primary_contact_name: A name for the contact person for this subaccount\n        primary_contact_phone: A phone number to call for this subaccount\n        metadata: Add a custom_fields attribute which has a list of dictionaries if\n            you would like the fields to be added to your transaction when\n            displayed on the dashboard.\n            Sample: ``{\"custom_fields\":[{\"display_name\":\"Cart ID\",\n            \"variable_name\": \"cart_id\",\"value\": \"8393\"}]}``\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(\"/subaccount\")\n    payload = {\n        \"business_name\": business_name,\n        \"settlement_bank\": settlement_bank,\n        \"account_number\": account_number,\n        \"percentage_charge\": percentage_charge,\n        \"description\": description,\n    }\n    optional_params = [\n        (\"primary_contact_email\", primary_contact_email),\n        (\"primary_contact_name\", primary_contact_name),\n        (\"primary_contact_phone\", primary_contact_phone),\n        (\"metadata\", metadata),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/subaccounts/#pypaystack2.api.subaccounts.SubAccount.get_subaccount","title":"<code>get_subaccount(id_or_code)</code>","text":"<p>Get details of a subaccount on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>id_or_code</code> <code>str</code> <p>The subaccount <code>ID</code> or <code>code</code> you want to fetch</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/subaccounts.py</code> <pre><code>def get_subaccount(self, id_or_code: str) -&gt; Response:\n    \"\"\"Get details of a subaccount on your integration.\n\n    Args:\n        id_or_code: The subaccount ``ID`` or ``code`` you want to fetch\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/subaccount/{id_or_code}\")\n    return self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/subaccounts/#pypaystack2.api.subaccounts.SubAccount.get_subaccounts","title":"<code>get_subaccounts(start_date, end_date, page=1, pagination=50)</code>","text":"<p>Fetch subaccounts available on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>start_date</code> <code>str</code> <p>A timestamp from which to start listing subaccounts e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> required <code>end_date</code> <code>str</code> <p>A timestamp at which to stop listing subaccounts e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> required <code>page</code> <code>int</code> <p>Specifies exactly what page you want to retrieve. If not specified we use a default value of 1.</p> <code>1</code> <code>pagination</code> <code>int</code> <p>Specifies how many records you want to retrieve per page. If not specified we use a default value of 50.</p> <code>50</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/subaccounts.py</code> <pre><code>def get_subaccounts(\n    self, start_date: str, end_date: str, page: int = 1, pagination: int = 50\n) -&gt; Response:\n    \"\"\"Fetch subaccounts available on your integration.\n\n    Args:\n        start_date: A timestamp from which to start listing subaccounts e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        end_date: A timestamp at which to stop listing subaccounts e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        page: Specifies exactly what page you want to retrieve. If not specified we use a default value of 1.\n        pagination: Specifies how many records you want to retrieve per page.\n            If not specified we use a default value of 50.\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._parse_url(f\"/subaccount?perPage={pagination}\")\n    query_params = [\n        (\"from\", start_date),\n        (\"to\", end_date),\n        (\"page\", page),\n    ]\n    url = append_query_params(query_params, url)\n    return self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/subaccounts/#pypaystack2.api.subaccounts.SubAccount.update","title":"<code>update(id_or_code, business_name, settlement_bank, account_number=None, active=None, percentage_charge=None, description=None, primary_contact_email=None, primary_contact_name=None, primary_contact_phone=None, settlement_schedule=None, metadata=None)</code>","text":"<p>Update a subaccount details on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>id_or_code</code> <code>str</code> <p>Subaccount's ID or code</p> required <code>business_name</code> <code>str</code> <p>Name of business for subaccount</p> required <code>settlement_bank</code> <code>str</code> <p>Bank Code for the bank. You can get the list of Bank Codes by calling the <code>.get_banks</code> method from the Miscellaneous API wrapper</p> required <code>account_number</code> <code>Optional[str]</code> <p>Bank Account Number</p> <code>None</code> <code>active</code> <code>Optional[bool]</code> <p>Activate or deactivate a subaccount.</p> <code>None</code> <code>percentage_charge</code> <code>Optional[float]</code> <p>The default percentage charged when receiving on behalf of this subaccount</p> <code>None</code> <code>description</code> <code>Optional[str]</code> <p>A description for this subaccount</p> <code>None</code> <code>primary_contact_email</code> <code>Optional[str]</code> <p>A contact email for the subaccount</p> <code>None</code> <code>primary_contact_name</code> <code>Optional[str]</code> <p>A name for the contact person for this subaccount</p> <code>None</code> <code>primary_contact_phone</code> <code>Optional[str]</code> <p>A phone number to call for this subaccount</p> <code>None</code> <code>settlement_schedule</code> <code>Optional[Schedule]</code> <p><code>Schedule.AUTO</code> means payout is T+1 and manual means payout to the subaccount should only be made when requested. Defaults to <code>Schedule.AUTO</code></p> <code>None</code> <code>metadata</code> <code>Optional[dict]</code> <p>Add a custom_fields attribute which has a list of dictionaries if you would like the fields to be added to your transaction when displayed on the dashboard. Sample: <code>{\"custom_fields\":[{\"display_name\":\"Cart ID\", \"variable_name\": \"cart_id\",\"value\": \"8393\"}]}</code></p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/subaccounts.py</code> <pre><code>def update(\n    self,\n    id_or_code: str,\n    business_name: str,\n    settlement_bank: str,\n    account_number: Optional[str] = None,\n    active: Optional[bool] = None,\n    percentage_charge: Optional[float] = None,\n    description: Optional[str] = None,\n    primary_contact_email: Optional[str] = None,\n    primary_contact_name: Optional[str] = None,\n    primary_contact_phone: Optional[str] = None,\n    settlement_schedule: Optional[Schedule] = None,\n    metadata: Optional[dict] = None,\n) -&gt; Response:\n    \"\"\"Update a subaccount details on your integration.\n\n    Args:\n        id_or_code: Subaccount's ID or code\n        business_name: Name of business for subaccount\n        settlement_bank: Bank Code for the bank. You can get the\n            list of Bank Codes by calling the ``.get_banks``\n            method from the Miscellaneous API wrapper\n        account_number: Bank Account Number\n        active: Activate or deactivate a subaccount.\n        percentage_charge: The default percentage charged when\n            receiving on behalf of this subaccount\n        description: A description for this subaccount\n        primary_contact_email: A contact email for the subaccount\n        primary_contact_name: A name for the contact person for this subaccount\n        primary_contact_phone: A phone number to call for this subaccount\n        settlement_schedule: ``Schedule.AUTO`` means payout is T+1 and manual means payout to the\n            subaccount should only be made when requested.\n            Defaults to ``Schedule.AUTO``\n        metadata: Add a custom_fields attribute which has a list of dictionaries if you would\n            like the fields to be added to your transaction when displayed on the\n            dashboard. Sample: ``{\"custom_fields\":[{\"display_name\":\"Cart ID\",\n            \"variable_name\": \"cart_id\",\"value\": \"8393\"}]}``\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    payload = {\n        \"id_or_code\": id_or_code,\n        \"business_name\": business_name,\n        \"settlement_bank\": settlement_bank,\n    }\n    optional_params = [\n        (\"account_number\", account_number),\n        (\"active\", active),\n        (\"percentage_charge\", percentage_charge),\n        (\"description\", description),\n        (\"primary_contact_email\", primary_contact_email),\n        (\"primary_contact_name\", primary_contact_name),\n        (\"primary_contact_phone\", primary_contact_phone),\n        (\"settlement_schedule\", settlement_schedule),\n        (\"metadata\", metadata),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    url = self._parse_url(f\"/subaccount/{id_or_code}\")\n    return self._handle_request(HTTPMethod.PUT, url, payload)\n</code></pre>"},{"location":"reference/subscriptions/","title":"Subscriptions","text":""},{"location":"reference/subscriptions/#pypaystack2.api.subscriptions.AsyncSubscription","title":"<code>AsyncSubscription</code>","text":"<p>               Bases: <code>BaseAsyncAPI</code></p> <p>Provides a wrapper for paystack Subscriptions API</p> <p>The Subscriptions API allows you to create and manage recurring payment on your integration. https://paystack.com/docs/api/subscription/</p> Source code in <code>src/pypaystack2/api/subscriptions.py</code> <pre><code>class AsyncSubscription(BaseAsyncAPI):\n    \"\"\"Provides a wrapper for paystack Subscriptions API\n\n    The Subscriptions API allows you to create and manage recurring\n    payment on your integration.\n    https://paystack.com/docs/api/subscription/\n    \"\"\"\n\n    async def create(\n        self,\n        customer: str,\n        plan: str,\n        authorization: Optional[str] = None,\n        start_date: Optional[str] = None,\n    ) -&gt; Response:\n        \"\"\"Create a subscription on your integration\n\n        Note:\n            Email Token\n                paystack creates an email token on each subscription to allow customers\n                cancel their subscriptions from within the invoices sent to their mailboxes.\n                Since they are not authorized, the email tokens are what we use to authenticate\n                the requests over the API.\n\n        Args:\n            customer: Customer's email address or customer code\n            plan: Plan code\n            authorization: If customer has multiple authorizations, you can set\n                the desired authorization you wish to use for this\n                subscription here. If this is not supplied, the\n                customer's most recent authorization would be used\n            start_date: Set the date for the first debit. (ISO 8601 format) e.g. 2017-05-16T00:30:13+01:00\n\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(\"/subscription\")\n\n        payload = {\"customer\": customer, \"plan\": plan}\n        optional_params = [\n            (\"start_date\", start_date),\n            (\"authorization\", authorization),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return await self._handle_request(HTTPMethod.POST, url, payload)\n\n    async def get_subscriptions(\n        self,\n        page: int = 1,\n        pagination: int = 50,\n        customer: Optional[int] = None,\n        plan: Optional[str] = None,\n    ) -&gt; Response:\n        \"\"\"Fetch subscriptions available on your integration.\n\n        Args:\n            page: Specifies exactly what page you want to retrieve.\n                If not specified we use a default value of 1.\n            pagination: Specifies how many records you want to retrieve per page.\n                If not specified we use a default value of 50.\n            customer: Filter by Customer ID\n            plan: Filter by Plan ID\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(\"/subscription/?perPage=\" + str(pagination))\n        query_params = [\n            (\"page\", page),\n            (\"customer\", customer),\n            (\"plan\", plan),\n        ]\n        url = append_query_params(query_params, url)\n        return await self._handle_request(HTTPMethod.GET, url)\n\n    async def get_subscription(self, id_or_code: str) -&gt; Response:\n        \"\"\"Fetch details of a subscription on your integration.\n\n        Args:\n            id_or_code: The subscription ``ID`` or ``code`` you want to fetch\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/subscription/{id_or_code}\")\n        return await self._handle_request(HTTPMethod.GET, url)\n\n    async def enable(self, code: str, token: str) -&gt; Response:\n        \"\"\"Enable a subscription on your integration\n\n        Args:\n            code: Subscription code\n            token: Email token\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(\"/subscription/enable\")\n        payload = {\n            \"code\": code,\n            \"token\": token,\n        }\n        return await self._handle_request(HTTPMethod.POST, url, payload)\n\n    async def disable(self, code: str, token: str) -&gt; Response:\n        \"\"\"Disable a subscription on your integration\n\n        Args:\n            code: Subscription code\n            token: Email token\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._parse_url(\"/subscription/disable\")\n        payload = {\n            \"code\": code,\n            \"token\": token,\n        }\n        return await self._handle_request(HTTPMethod.POST, url, payload)\n\n    async def get_update_link(self, code: str) -&gt; Response:\n        \"\"\"Generate a link for updating the card on a subscription\n\n        Args:\n            code: Subscription code\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/subscription/{code}/manage/link/\")\n        return await self._handle_request(HTTPMethod.GET, url)\n\n    async def send_update_link(self, code: str) -&gt; Response:\n        \"\"\"Email a customer a link for updating the card on their subscription\n\n        Args:\n            code: Subscription code\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/subscription/{code}/manage/email/\")\n        return await self._handle_request(HTTPMethod.POST, url, None)\n</code></pre>"},{"location":"reference/subscriptions/#pypaystack2.api.subscriptions.AsyncSubscription.create","title":"<code>create(customer, plan, authorization=None, start_date=None)</code>  <code>async</code>","text":"<p>Create a subscription on your integration</p> Note <p>Email Token     paystack creates an email token on each subscription to allow customers     cancel their subscriptions from within the invoices sent to their mailboxes.     Since they are not authorized, the email tokens are what we use to authenticate     the requests over the API.</p> <p>Parameters:</p> Name Type Description Default <code>customer</code> <code>str</code> <p>Customer's email address or customer code</p> required <code>plan</code> <code>str</code> <p>Plan code</p> required <code>authorization</code> <code>Optional[str]</code> <p>If customer has multiple authorizations, you can set the desired authorization you wish to use for this subscription here. If this is not supplied, the customer's most recent authorization would be used</p> <code>None</code> <code>start_date</code> <code>Optional[str]</code> <p>Set the date for the first debit. (ISO 8601 format) e.g. 2017-05-16T00:30:13+01:00</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/subscriptions.py</code> <pre><code>async def create(\n    self,\n    customer: str,\n    plan: str,\n    authorization: Optional[str] = None,\n    start_date: Optional[str] = None,\n) -&gt; Response:\n    \"\"\"Create a subscription on your integration\n\n    Note:\n        Email Token\n            paystack creates an email token on each subscription to allow customers\n            cancel their subscriptions from within the invoices sent to their mailboxes.\n            Since they are not authorized, the email tokens are what we use to authenticate\n            the requests over the API.\n\n    Args:\n        customer: Customer's email address or customer code\n        plan: Plan code\n        authorization: If customer has multiple authorizations, you can set\n            the desired authorization you wish to use for this\n            subscription here. If this is not supplied, the\n            customer's most recent authorization would be used\n        start_date: Set the date for the first debit. (ISO 8601 format) e.g. 2017-05-16T00:30:13+01:00\n\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(\"/subscription\")\n\n    payload = {\"customer\": customer, \"plan\": plan}\n    optional_params = [\n        (\"start_date\", start_date),\n        (\"authorization\", authorization),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return await self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/subscriptions/#pypaystack2.api.subscriptions.AsyncSubscription.disable","title":"<code>disable(code, token)</code>  <code>async</code>","text":"<p>Disable a subscription on your integration</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>Subscription code</p> required <code>token</code> <code>str</code> <p>Email token</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/subscriptions.py</code> <pre><code>async def disable(self, code: str, token: str) -&gt; Response:\n    \"\"\"Disable a subscription on your integration\n\n    Args:\n        code: Subscription code\n        token: Email token\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._parse_url(\"/subscription/disable\")\n    payload = {\n        \"code\": code,\n        \"token\": token,\n    }\n    return await self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/subscriptions/#pypaystack2.api.subscriptions.AsyncSubscription.enable","title":"<code>enable(code, token)</code>  <code>async</code>","text":"<p>Enable a subscription on your integration</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>Subscription code</p> required <code>token</code> <code>str</code> <p>Email token</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/subscriptions.py</code> <pre><code>async def enable(self, code: str, token: str) -&gt; Response:\n    \"\"\"Enable a subscription on your integration\n\n    Args:\n        code: Subscription code\n        token: Email token\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(\"/subscription/enable\")\n    payload = {\n        \"code\": code,\n        \"token\": token,\n    }\n    return await self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/subscriptions/#pypaystack2.api.subscriptions.AsyncSubscription.get_subscription","title":"<code>get_subscription(id_or_code)</code>  <code>async</code>","text":"<p>Fetch details of a subscription on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>id_or_code</code> <code>str</code> <p>The subscription <code>ID</code> or <code>code</code> you want to fetch</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/subscriptions.py</code> <pre><code>async def get_subscription(self, id_or_code: str) -&gt; Response:\n    \"\"\"Fetch details of a subscription on your integration.\n\n    Args:\n        id_or_code: The subscription ``ID`` or ``code`` you want to fetch\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/subscription/{id_or_code}\")\n    return await self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/subscriptions/#pypaystack2.api.subscriptions.AsyncSubscription.get_subscriptions","title":"<code>get_subscriptions(page=1, pagination=50, customer=None, plan=None)</code>  <code>async</code>","text":"<p>Fetch subscriptions available on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>int</code> <p>Specifies exactly what page you want to retrieve. If not specified we use a default value of 1.</p> <code>1</code> <code>pagination</code> <code>int</code> <p>Specifies how many records you want to retrieve per page. If not specified we use a default value of 50.</p> <code>50</code> <code>customer</code> <code>Optional[int]</code> <p>Filter by Customer ID</p> <code>None</code> <code>plan</code> <code>Optional[str]</code> <p>Filter by Plan ID</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/subscriptions.py</code> <pre><code>async def get_subscriptions(\n    self,\n    page: int = 1,\n    pagination: int = 50,\n    customer: Optional[int] = None,\n    plan: Optional[str] = None,\n) -&gt; Response:\n    \"\"\"Fetch subscriptions available on your integration.\n\n    Args:\n        page: Specifies exactly what page you want to retrieve.\n            If not specified we use a default value of 1.\n        pagination: Specifies how many records you want to retrieve per page.\n            If not specified we use a default value of 50.\n        customer: Filter by Customer ID\n        plan: Filter by Plan ID\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(\"/subscription/?perPage=\" + str(pagination))\n    query_params = [\n        (\"page\", page),\n        (\"customer\", customer),\n        (\"plan\", plan),\n    ]\n    url = append_query_params(query_params, url)\n    return await self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/subscriptions/#pypaystack2.api.subscriptions.AsyncSubscription.get_update_link","title":"<code>get_update_link(code)</code>  <code>async</code>","text":"<p>Generate a link for updating the card on a subscription</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>Subscription code</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/subscriptions.py</code> <pre><code>async def get_update_link(self, code: str) -&gt; Response:\n    \"\"\"Generate a link for updating the card on a subscription\n\n    Args:\n        code: Subscription code\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/subscription/{code}/manage/link/\")\n    return await self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/subscriptions/#pypaystack2.api.subscriptions.AsyncSubscription.send_update_link","title":"<code>send_update_link(code)</code>  <code>async</code>","text":"<p>Email a customer a link for updating the card on their subscription</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>Subscription code</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/subscriptions.py</code> <pre><code>async def send_update_link(self, code: str) -&gt; Response:\n    \"\"\"Email a customer a link for updating the card on their subscription\n\n    Args:\n        code: Subscription code\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/subscription/{code}/manage/email/\")\n    return await self._handle_request(HTTPMethod.POST, url, None)\n</code></pre>"},{"location":"reference/subscriptions/#pypaystack2.api.subscriptions.Subscription","title":"<code>Subscription</code>","text":"<p>               Bases: <code>BaseAPI</code></p> <p>Provides a wrapper for paystack Subscriptions API</p> <p>The Subscriptions API allows you to create and manage recurring payment on your integration. https://paystack.com/docs/api/subscription/</p> Source code in <code>src/pypaystack2/api/subscriptions.py</code> <pre><code>class Subscription(BaseAPI):\n    \"\"\"Provides a wrapper for paystack Subscriptions API\n\n    The Subscriptions API allows you to create and manage recurring\n    payment on your integration.\n    https://paystack.com/docs/api/subscription/\n    \"\"\"\n\n    def create(\n        self,\n        customer: str,\n        plan: str,\n        authorization: Optional[str] = None,\n        start_date: Optional[str] = None,\n    ) -&gt; Response:\n        \"\"\"Create a subscription on your integration\n\n        Note:\n            Email Token\n                paystack creates an email token on each subscription to allow customers\n                cancel their subscriptions from within the invoices sent to their mailboxes.\n                Since they are not authorized, the email tokens are what we use to authenticate\n                the requests over the API.\n\n        Args:\n            customer: Customer's email address or customer code\n            plan: Plan code\n            authorization: If customer has multiple authorizations, you can set\n                the desired authorization you wish to use for this\n                subscription here. If this is not supplied, the\n                customer's most recent authorization would be used\n            start_date: Set the date for the first debit. (ISO 8601 format) e.g. 2017-05-16T00:30:13+01:00\n\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(\"/subscription\")\n\n        payload = {\"customer\": customer, \"plan\": plan}\n        optional_params = [\n            (\"start_date\", start_date),\n            (\"authorization\", authorization),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return self._handle_request(HTTPMethod.POST, url, payload)\n\n    def get_subscriptions(\n        self,\n        page: int = 1,\n        pagination: int = 50,\n        customer: Optional[int] = None,\n        plan: Optional[str] = None,\n    ) -&gt; Response:\n        \"\"\"Fetch subscriptions available on your integration.\n\n        Args:\n            page: Specifies exactly what page you want to retrieve.\n                If not specified we use a default value of 1.\n            pagination: Specifies how many records you want to retrieve per page.\n                If not specified we use a default value of 50.\n            customer: Filter by Customer ID\n            plan: Filter by Plan ID\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(\"/subscription/?perPage=\" + str(pagination))\n        query_params = [\n            (\"page\", page),\n            (\"customer\", customer),\n            (\"plan\", plan),\n        ]\n        url = append_query_params(query_params, url)\n        return self._handle_request(HTTPMethod.GET, url)\n\n    def get_subscription(self, id_or_code: str) -&gt; Response:\n        \"\"\"Fetch details of a subscription on your integration.\n\n        Args:\n            id_or_code: The subscription ``ID`` or ``code`` you want to fetch\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/subscription/{id_or_code}\")\n        return self._handle_request(HTTPMethod.GET, url)\n\n    def enable(self, code: str, token: str) -&gt; Response:\n        \"\"\"Enable a subscription on your integration\n\n        Args:\n            code: Subscription code\n            token: Email token\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(\"/subscription/enable\")\n        payload = {\n            \"code\": code,\n            \"token\": token,\n        }\n        return self._handle_request(HTTPMethod.POST, url, payload)\n\n    def disable(self, code: str, token: str) -&gt; Response:\n        \"\"\"Disable a subscription on your integration\n\n        Args:\n            code: Subscription code\n            token: Email token\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._parse_url(\"/subscription/disable\")\n        payload = {\n            \"code\": code,\n            \"token\": token,\n        }\n        return self._handle_request(HTTPMethod.POST, url, payload)\n\n    def get_update_link(self, code: str) -&gt; Response:\n        \"\"\"Generate a link for updating the card on a subscription\n\n        Args:\n            code: Subscription code\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/subscription/{code}/manage/link/\")\n        return self._handle_request(HTTPMethod.GET, url)\n\n    def send_update_link(self, code: str) -&gt; Response:\n        \"\"\"Email a customer a link for updating the card on their subscription\n\n        Args:\n            code: Subscription code\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/subscription/{code}/manage/email/\")\n        return self._handle_request(HTTPMethod.POST, url, None)\n</code></pre>"},{"location":"reference/subscriptions/#pypaystack2.api.subscriptions.Subscription.create","title":"<code>create(customer, plan, authorization=None, start_date=None)</code>","text":"<p>Create a subscription on your integration</p> Note <p>Email Token     paystack creates an email token on each subscription to allow customers     cancel their subscriptions from within the invoices sent to their mailboxes.     Since they are not authorized, the email tokens are what we use to authenticate     the requests over the API.</p> <p>Parameters:</p> Name Type Description Default <code>customer</code> <code>str</code> <p>Customer's email address or customer code</p> required <code>plan</code> <code>str</code> <p>Plan code</p> required <code>authorization</code> <code>Optional[str]</code> <p>If customer has multiple authorizations, you can set the desired authorization you wish to use for this subscription here. If this is not supplied, the customer's most recent authorization would be used</p> <code>None</code> <code>start_date</code> <code>Optional[str]</code> <p>Set the date for the first debit. (ISO 8601 format) e.g. 2017-05-16T00:30:13+01:00</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/subscriptions.py</code> <pre><code>def create(\n    self,\n    customer: str,\n    plan: str,\n    authorization: Optional[str] = None,\n    start_date: Optional[str] = None,\n) -&gt; Response:\n    \"\"\"Create a subscription on your integration\n\n    Note:\n        Email Token\n            paystack creates an email token on each subscription to allow customers\n            cancel their subscriptions from within the invoices sent to their mailboxes.\n            Since they are not authorized, the email tokens are what we use to authenticate\n            the requests over the API.\n\n    Args:\n        customer: Customer's email address or customer code\n        plan: Plan code\n        authorization: If customer has multiple authorizations, you can set\n            the desired authorization you wish to use for this\n            subscription here. If this is not supplied, the\n            customer's most recent authorization would be used\n        start_date: Set the date for the first debit. (ISO 8601 format) e.g. 2017-05-16T00:30:13+01:00\n\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(\"/subscription\")\n\n    payload = {\"customer\": customer, \"plan\": plan}\n    optional_params = [\n        (\"start_date\", start_date),\n        (\"authorization\", authorization),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/subscriptions/#pypaystack2.api.subscriptions.Subscription.disable","title":"<code>disable(code, token)</code>","text":"<p>Disable a subscription on your integration</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>Subscription code</p> required <code>token</code> <code>str</code> <p>Email token</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/subscriptions.py</code> <pre><code>def disable(self, code: str, token: str) -&gt; Response:\n    \"\"\"Disable a subscription on your integration\n\n    Args:\n        code: Subscription code\n        token: Email token\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._parse_url(\"/subscription/disable\")\n    payload = {\n        \"code\": code,\n        \"token\": token,\n    }\n    return self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/subscriptions/#pypaystack2.api.subscriptions.Subscription.enable","title":"<code>enable(code, token)</code>","text":"<p>Enable a subscription on your integration</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>Subscription code</p> required <code>token</code> <code>str</code> <p>Email token</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/subscriptions.py</code> <pre><code>def enable(self, code: str, token: str) -&gt; Response:\n    \"\"\"Enable a subscription on your integration\n\n    Args:\n        code: Subscription code\n        token: Email token\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(\"/subscription/enable\")\n    payload = {\n        \"code\": code,\n        \"token\": token,\n    }\n    return self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/subscriptions/#pypaystack2.api.subscriptions.Subscription.get_subscription","title":"<code>get_subscription(id_or_code)</code>","text":"<p>Fetch details of a subscription on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>id_or_code</code> <code>str</code> <p>The subscription <code>ID</code> or <code>code</code> you want to fetch</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/subscriptions.py</code> <pre><code>def get_subscription(self, id_or_code: str) -&gt; Response:\n    \"\"\"Fetch details of a subscription on your integration.\n\n    Args:\n        id_or_code: The subscription ``ID`` or ``code`` you want to fetch\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/subscription/{id_or_code}\")\n    return self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/subscriptions/#pypaystack2.api.subscriptions.Subscription.get_subscriptions","title":"<code>get_subscriptions(page=1, pagination=50, customer=None, plan=None)</code>","text":"<p>Fetch subscriptions available on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>int</code> <p>Specifies exactly what page you want to retrieve. If not specified we use a default value of 1.</p> <code>1</code> <code>pagination</code> <code>int</code> <p>Specifies how many records you want to retrieve per page. If not specified we use a default value of 50.</p> <code>50</code> <code>customer</code> <code>Optional[int]</code> <p>Filter by Customer ID</p> <code>None</code> <code>plan</code> <code>Optional[str]</code> <p>Filter by Plan ID</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/subscriptions.py</code> <pre><code>def get_subscriptions(\n    self,\n    page: int = 1,\n    pagination: int = 50,\n    customer: Optional[int] = None,\n    plan: Optional[str] = None,\n) -&gt; Response:\n    \"\"\"Fetch subscriptions available on your integration.\n\n    Args:\n        page: Specifies exactly what page you want to retrieve.\n            If not specified we use a default value of 1.\n        pagination: Specifies how many records you want to retrieve per page.\n            If not specified we use a default value of 50.\n        customer: Filter by Customer ID\n        plan: Filter by Plan ID\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(\"/subscription/?perPage=\" + str(pagination))\n    query_params = [\n        (\"page\", page),\n        (\"customer\", customer),\n        (\"plan\", plan),\n    ]\n    url = append_query_params(query_params, url)\n    return self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/subscriptions/#pypaystack2.api.subscriptions.Subscription.get_update_link","title":"<code>get_update_link(code)</code>","text":"<p>Generate a link for updating the card on a subscription</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>Subscription code</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/subscriptions.py</code> <pre><code>def get_update_link(self, code: str) -&gt; Response:\n    \"\"\"Generate a link for updating the card on a subscription\n\n    Args:\n        code: Subscription code\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/subscription/{code}/manage/link/\")\n    return self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/subscriptions/#pypaystack2.api.subscriptions.Subscription.send_update_link","title":"<code>send_update_link(code)</code>","text":"<p>Email a customer a link for updating the card on their subscription</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>Subscription code</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/subscriptions.py</code> <pre><code>def send_update_link(self, code: str) -&gt; Response:\n    \"\"\"Email a customer a link for updating the card on their subscription\n\n    Args:\n        code: Subscription code\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/subscription/{code}/manage/email/\")\n    return self._handle_request(HTTPMethod.POST, url, None)\n</code></pre>"},{"location":"reference/terminals/","title":"Terminals","text":""},{"location":"reference/terminals/#pypaystack2.api.terminals.AsyncTerminal","title":"<code>AsyncTerminal</code>","text":"<p>               Bases: <code>BaseAsyncAPI</code></p> <p>Provides a wrapper for paystack Terminal API</p> <p>The Terminal API allows you to create and manage recurring payment on your integration. https://paystack.com/docs/api/terminal/</p> Source code in <code>src/pypaystack2/api/terminals.py</code> <pre><code>class AsyncTerminal(BaseAsyncAPI):\n    \"\"\"Provides a wrapper for paystack Terminal API\n\n    The Terminal API allows you to create and manage recurring\n    payment on your integration.\n    https://paystack.com/docs/api/terminal/\n    \"\"\"\n\n    async def send_event(\n        self,\n        terminal_id: str,\n        type: TerminalEvent,\n        action: TerminalEventAction,\n        data: dict,\n    ) -&gt; Response:\n        \"\"\"Send an event from your application to the Paystack Terminal\n\n        Args:\n            terminal_id: The ID of the Terminal the event should be sent to.\n            type: The type of event to push. Paystack currently supports `TerminalEventType.INVOICE` and\n                `TerminalEventType.TRANSACTION`.\n            action: The action the Terminal needs to perform. For the `TerminalEventType.INVOICE` type,\n                the action can either be `TerminalEventAction.PROCESS` or TerminalEventAction.VIEW.\n                For the `TerminalEventType.TRANSACTION` type, the action can either be\n                `TerminalEventAction.PROCESS` or `TerminalEventAction.PRINT`.\n            data: The parameters needed to perform the specified action. For the invoice type, you need to\n                pass the invoice id and offline reference: {id: invoice_id, reference: offline_reference}.\n                For the transaction type, you can pass the transaction id: {id: transaction_id}\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n        supported_actions_mapping = {\n            TerminalEvent.TRANSACTION: {\n                TerminalEventAction.PROCESS,\n                TerminalEventAction.PRINT,\n            },\n            TerminalEvent.INVOICE: {\n                TerminalEventAction.PROCESS,\n                TerminalEventAction.VIEW,\n            },\n        }\n        if action not in supported_actions_mapping[type]:\n            raise InvalidDataException(\n                f\"Terminal Event: {type} does not support Terminal Event Action: {action}\"\n            )\n\n        url = self._parse_url(f\"/terminal/{terminal_id}/event\")\n\n        payload = {\n            \"type\": type,\n            \"action\": action,\n            \"data\": data,\n        }\n        return await self._handle_request(HTTPMethod.POST, url, payload)\n\n    async def get_event_status(self, terminal_id: str, event_id: str) -&gt; Response:\n        \"\"\"Check the status of an event sent to the Terminal\n\n        Args:\n            terminal_id: The ID of the Terminal the event was sent to.\n            event_id: The ID of the event that was sent to the Terminal\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._parse_url(f\"/terminal/{terminal_id}/event/{event_id}\")\n        return await self._handle_request(HTTPMethod.GET, url)\n\n    async def get_terminal_status(self, terminal_id: str) -&gt; Response:\n        \"\"\"Check the availability of a Terminal before sending an event to it.\n\n        Args:\n            terminal_id: The ID of the Terminal you want to check\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._parse_url(f\"/terminal/{terminal_id}/presence\")\n        return await self._handle_request(HTTPMethod.GET, url)\n\n    async def get_terminals(\n        self,\n        pagination: int = 50,\n        next: Optional[str] = None,\n        previous: Optional[str] = None,\n    ) -&gt; Response:\n        \"\"\"List the Terminals available on your integration\n\n        Args:\n            pagination: Specifies how many records you want to retrieve per page. If not specified, it defaults to 50.\n            next: Specifies how many records you want to retrieve per page. If not specified\n                we use a default value of 50.\n            previous: A cursor that indicates your place in the list. It should be used to fetch the\n                previous page of the list after an initial next request\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._parse_url(f\"/terminal?perPage={pagination}\")\n        query_params = [\n            (\"next\", next),\n            (\"previous\", previous),\n        ]\n        url = append_query_params(query_params, url)\n        return await self._handle_request(HTTPMethod.GET, url)\n\n    async def get_terminal(self, terminal_id: str) -&gt; Response:\n        \"\"\"Get the details of a Terminal\n\n        Args:\n            terminal_id: The ID of the Terminal the event was sent to.\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._parse_url(f\"/terminal/{terminal_id}/\")\n        return await self._handle_request(HTTPMethod.GET, url)\n\n    async def update_terminal(\n        self, terminal_id: str, name: str, address: str\n    ) -&gt; Response:\n        \"\"\"Update the details of a Terminal\n\n        Args:\n            terminal_id: The ID of the Terminal you want to update\n            name: Name of the terminal\n            address: The address of the Terminal\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._parse_url(f\"/terminal/{terminal_id}\")\n\n        payload = {\"name\": name, \"address\": address}\n        return await self._handle_request(HTTPMethod.PUT, url, payload)\n\n    async def commission_terminal(self, serial_number: str) -&gt; Response:\n        \"\"\"Activate your debug device by linking it to your integration\n\n        Args:\n            serial_number: Device Serial Number\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(\"/terminal/commission_device\")\n\n        payload = {\n            \"serial_number\": serial_number,\n        }\n        return await self._handle_request(\"POST\", url, payload)\n\n    async def decommission_terminal(self, serial_number: str) -&gt; Response:\n        \"\"\"Unlink your debug device from your integration\n\n        Args:\n            serial_number: Device Serial Number\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._parse_url(\"/terminal/decommission_device\")\n\n        payload = {\n            \"serial_number\": serial_number,\n        }\n        return await self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/terminals/#pypaystack2.api.terminals.AsyncTerminal.commission_terminal","title":"<code>commission_terminal(serial_number)</code>  <code>async</code>","text":"<p>Activate your debug device by linking it to your integration</p> <p>Parameters:</p> Name Type Description Default <code>serial_number</code> <code>str</code> <p>Device Serial Number</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/terminals.py</code> <pre><code>async def commission_terminal(self, serial_number: str) -&gt; Response:\n    \"\"\"Activate your debug device by linking it to your integration\n\n    Args:\n        serial_number: Device Serial Number\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(\"/terminal/commission_device\")\n\n    payload = {\n        \"serial_number\": serial_number,\n    }\n    return await self._handle_request(\"POST\", url, payload)\n</code></pre>"},{"location":"reference/terminals/#pypaystack2.api.terminals.AsyncTerminal.decommission_terminal","title":"<code>decommission_terminal(serial_number)</code>  <code>async</code>","text":"<p>Unlink your debug device from your integration</p> <p>Parameters:</p> Name Type Description Default <code>serial_number</code> <code>str</code> <p>Device Serial Number</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/terminals.py</code> <pre><code>async def decommission_terminal(self, serial_number: str) -&gt; Response:\n    \"\"\"Unlink your debug device from your integration\n\n    Args:\n        serial_number: Device Serial Number\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._parse_url(\"/terminal/decommission_device\")\n\n    payload = {\n        \"serial_number\": serial_number,\n    }\n    return await self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/terminals/#pypaystack2.api.terminals.AsyncTerminal.get_event_status","title":"<code>get_event_status(terminal_id, event_id)</code>  <code>async</code>","text":"<p>Check the status of an event sent to the Terminal</p> <p>Parameters:</p> Name Type Description Default <code>terminal_id</code> <code>str</code> <p>The ID of the Terminal the event was sent to.</p> required <code>event_id</code> <code>str</code> <p>The ID of the event that was sent to the Terminal</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/terminals.py</code> <pre><code>async def get_event_status(self, terminal_id: str, event_id: str) -&gt; Response:\n    \"\"\"Check the status of an event sent to the Terminal\n\n    Args:\n        terminal_id: The ID of the Terminal the event was sent to.\n        event_id: The ID of the event that was sent to the Terminal\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._parse_url(f\"/terminal/{terminal_id}/event/{event_id}\")\n    return await self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/terminals/#pypaystack2.api.terminals.AsyncTerminal.get_terminal","title":"<code>get_terminal(terminal_id)</code>  <code>async</code>","text":"<p>Get the details of a Terminal</p> <p>Parameters:</p> Name Type Description Default <code>terminal_id</code> <code>str</code> <p>The ID of the Terminal the event was sent to.</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/terminals.py</code> <pre><code>async def get_terminal(self, terminal_id: str) -&gt; Response:\n    \"\"\"Get the details of a Terminal\n\n    Args:\n        terminal_id: The ID of the Terminal the event was sent to.\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._parse_url(f\"/terminal/{terminal_id}/\")\n    return await self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/terminals/#pypaystack2.api.terminals.AsyncTerminal.get_terminal_status","title":"<code>get_terminal_status(terminal_id)</code>  <code>async</code>","text":"<p>Check the availability of a Terminal before sending an event to it.</p> <p>Parameters:</p> Name Type Description Default <code>terminal_id</code> <code>str</code> <p>The ID of the Terminal you want to check</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/terminals.py</code> <pre><code>async def get_terminal_status(self, terminal_id: str) -&gt; Response:\n    \"\"\"Check the availability of a Terminal before sending an event to it.\n\n    Args:\n        terminal_id: The ID of the Terminal you want to check\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._parse_url(f\"/terminal/{terminal_id}/presence\")\n    return await self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/terminals/#pypaystack2.api.terminals.AsyncTerminal.get_terminals","title":"<code>get_terminals(pagination=50, next=None, previous=None)</code>  <code>async</code>","text":"<p>List the Terminals available on your integration</p> <p>Parameters:</p> Name Type Description Default <code>pagination</code> <code>int</code> <p>Specifies how many records you want to retrieve per page. If not specified, it defaults to 50.</p> <code>50</code> <code>next</code> <code>Optional[str]</code> <p>Specifies how many records you want to retrieve per page. If not specified we use a default value of 50.</p> <code>None</code> <code>previous</code> <code>Optional[str]</code> <p>A cursor that indicates your place in the list. It should be used to fetch the previous page of the list after an initial next request</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/terminals.py</code> <pre><code>async def get_terminals(\n    self,\n    pagination: int = 50,\n    next: Optional[str] = None,\n    previous: Optional[str] = None,\n) -&gt; Response:\n    \"\"\"List the Terminals available on your integration\n\n    Args:\n        pagination: Specifies how many records you want to retrieve per page. If not specified, it defaults to 50.\n        next: Specifies how many records you want to retrieve per page. If not specified\n            we use a default value of 50.\n        previous: A cursor that indicates your place in the list. It should be used to fetch the\n            previous page of the list after an initial next request\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._parse_url(f\"/terminal?perPage={pagination}\")\n    query_params = [\n        (\"next\", next),\n        (\"previous\", previous),\n    ]\n    url = append_query_params(query_params, url)\n    return await self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/terminals/#pypaystack2.api.terminals.AsyncTerminal.send_event","title":"<code>send_event(terminal_id, type, action, data)</code>  <code>async</code>","text":"<p>Send an event from your application to the Paystack Terminal</p> <p>Parameters:</p> Name Type Description Default <code>terminal_id</code> <code>str</code> <p>The ID of the Terminal the event should be sent to.</p> required <code>type</code> <code>TerminalEvent</code> <p>The type of event to push. Paystack currently supports <code>TerminalEventType.INVOICE</code> and <code>TerminalEventType.TRANSACTION</code>.</p> required <code>action</code> <code>TerminalEventAction</code> <p>The action the Terminal needs to perform. For the <code>TerminalEventType.INVOICE</code> type, the action can either be <code>TerminalEventAction.PROCESS</code> or TerminalEventAction.VIEW. For the <code>TerminalEventType.TRANSACTION</code> type, the action can either be <code>TerminalEventAction.PROCESS</code> or <code>TerminalEventAction.PRINT</code>.</p> required <code>data</code> <code>dict</code> <p>The parameters needed to perform the specified action. For the invoice type, you need to pass the invoice id and offline reference: {id: invoice_id, reference: offline_reference}. For the transaction type, you can pass the transaction id: {id: transaction_id}</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/terminals.py</code> <pre><code>async def send_event(\n    self,\n    terminal_id: str,\n    type: TerminalEvent,\n    action: TerminalEventAction,\n    data: dict,\n) -&gt; Response:\n    \"\"\"Send an event from your application to the Paystack Terminal\n\n    Args:\n        terminal_id: The ID of the Terminal the event should be sent to.\n        type: The type of event to push. Paystack currently supports `TerminalEventType.INVOICE` and\n            `TerminalEventType.TRANSACTION`.\n        action: The action the Terminal needs to perform. For the `TerminalEventType.INVOICE` type,\n            the action can either be `TerminalEventAction.PROCESS` or TerminalEventAction.VIEW.\n            For the `TerminalEventType.TRANSACTION` type, the action can either be\n            `TerminalEventAction.PROCESS` or `TerminalEventAction.PRINT`.\n        data: The parameters needed to perform the specified action. For the invoice type, you need to\n            pass the invoice id and offline reference: {id: invoice_id, reference: offline_reference}.\n            For the transaction type, you can pass the transaction id: {id: transaction_id}\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n    supported_actions_mapping = {\n        TerminalEvent.TRANSACTION: {\n            TerminalEventAction.PROCESS,\n            TerminalEventAction.PRINT,\n        },\n        TerminalEvent.INVOICE: {\n            TerminalEventAction.PROCESS,\n            TerminalEventAction.VIEW,\n        },\n    }\n    if action not in supported_actions_mapping[type]:\n        raise InvalidDataException(\n            f\"Terminal Event: {type} does not support Terminal Event Action: {action}\"\n        )\n\n    url = self._parse_url(f\"/terminal/{terminal_id}/event\")\n\n    payload = {\n        \"type\": type,\n        \"action\": action,\n        \"data\": data,\n    }\n    return await self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/terminals/#pypaystack2.api.terminals.AsyncTerminal.update_terminal","title":"<code>update_terminal(terminal_id, name, address)</code>  <code>async</code>","text":"<p>Update the details of a Terminal</p> <p>Parameters:</p> Name Type Description Default <code>terminal_id</code> <code>str</code> <p>The ID of the Terminal you want to update</p> required <code>name</code> <code>str</code> <p>Name of the terminal</p> required <code>address</code> <code>str</code> <p>The address of the Terminal</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/terminals.py</code> <pre><code>async def update_terminal(\n    self, terminal_id: str, name: str, address: str\n) -&gt; Response:\n    \"\"\"Update the details of a Terminal\n\n    Args:\n        terminal_id: The ID of the Terminal you want to update\n        name: Name of the terminal\n        address: The address of the Terminal\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._parse_url(f\"/terminal/{terminal_id}\")\n\n    payload = {\"name\": name, \"address\": address}\n    return await self._handle_request(HTTPMethod.PUT, url, payload)\n</code></pre>"},{"location":"reference/terminals/#pypaystack2.api.terminals.Terminal","title":"<code>Terminal</code>","text":"<p>               Bases: <code>BaseAPI</code></p> <p>Provides a wrapper for paystack Terminal API</p> <p>The Terminal API allows you to build delightful in-person payment experiences. https://paystack.com/docs/api/terminal/</p> Source code in <code>src/pypaystack2/api/terminals.py</code> <pre><code>class Terminal(BaseAPI):\n    \"\"\"Provides a wrapper for paystack Terminal API\n\n    The Terminal API allows you to build delightful in-person payment experiences.\n    https://paystack.com/docs/api/terminal/\n    \"\"\"\n\n    def send_event(\n        self,\n        terminal_id: str,\n        type: TerminalEvent,\n        action: TerminalEventAction,\n        data: dict,\n    ) -&gt; Response:\n        \"\"\"Send an event from your application to the Paystack Terminal\n\n        Args:\n            terminal_id: The ID of the Terminal the event should be sent to.\n            type: The type of event to push. Paystack currently supports `TerminalEventType.INVOICE` and\n                `TerminalEventType.TRANSACTION`.\n            action: The action the Terminal needs to perform. For the `TerminalEventType.INVOICE` type,\n                the action can either be `TerminalEventAction.PROCESS` or TerminalEventAction.VIEW.\n                For the `TerminalEventType.TRANSACTION` type, the action can either be\n                `TerminalEventAction.PROCESS` or `TerminalEventAction.PRINT`.\n            data: The parameters needed to perform the specified action. For the invoice type, you need to\n                pass the invoice id and offline reference: {id: invoice_id, reference: offline_reference}.\n                For the transaction type, you can pass the transaction id: {id: transaction_id}\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n        supported_actions_mapping = {\n            TerminalEvent.TRANSACTION: {\n                TerminalEventAction.PROCESS,\n                TerminalEventAction.PRINT,\n            },\n            TerminalEvent.INVOICE: {\n                TerminalEventAction.PROCESS,\n                TerminalEventAction.VIEW,\n            },\n        }\n        if action not in supported_actions_mapping[type]:\n            raise InvalidDataException(\n                f\"Terminal Event: {type} does not support Terminal Event Action: {action}\"\n            )\n\n        url = self._parse_url(f\"/terminal/{terminal_id}/event\")\n\n        payload = {\n            \"type\": type,\n            \"action\": action,\n            \"data\": data,\n        }\n        return self._handle_request(HTTPMethod.POST, url, payload)\n\n    def get_event_status(self, terminal_id: str, event_id: str) -&gt; Response:\n        \"\"\"Check the status of an event sent to the Terminal\n\n        Args:\n            terminal_id: The ID of the Terminal the event was sent to.\n            event_id: The ID of the event that was sent to the Terminal\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._parse_url(f\"/terminal/{terminal_id}/event/{event_id}\")\n        return self._handle_request(HTTPMethod.GET, url)\n\n    def get_terminal_status(self, terminal_id: str) -&gt; Response:\n        \"\"\"Check the availability of a Terminal before sending an event to it.\n\n        Args:\n            terminal_id: The ID of the Terminal you want to check\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._parse_url(f\"/terminal/{terminal_id}/presence\")\n        return self._handle_request(HTTPMethod.GET, url)\n\n    def get_terminals(\n        self,\n        pagination: int = 50,\n        next: Optional[str] = None,\n        previous: Optional[str] = None,\n    ) -&gt; Response:\n        \"\"\"List the Terminals available on your integration\n\n        Args:\n            pagination: Specifies how many records you want to retrieve per page. If not specified, it defaults to 50.\n            next: Specifies how many records you want to retrieve per page. If not specified\n                we use a default value of 50.\n            previous: A cursor that indicates your place in the list. It should be used to fetch the\n                previous page of the list after an initial next request\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._parse_url(f\"/terminal?perPage={pagination}\")\n        query_params = [\n            (\"next\", next),\n            (\"previous\", previous),\n        ]\n        url = append_query_params(query_params, url)\n        return self._handle_request(HTTPMethod.GET, url)\n\n    def get_terminal(self, terminal_id: str) -&gt; Response:\n        \"\"\"Get the details of a Terminal\n\n        Args:\n            terminal_id: The ID of the Terminal the event was sent to.\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._parse_url(f\"/terminal/{terminal_id}/\")\n        return self._handle_request(HTTPMethod.GET, url)\n\n    def update_terminal(self, terminal_id: str, name: str, address: str) -&gt; Response:\n        \"\"\"Update the details of a Terminal\n\n        Args:\n            terminal_id: The ID of the Terminal you want to update\n            name: Name of the terminal\n            address: The address of the Terminal\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._parse_url(f\"/terminal/{terminal_id}\")\n\n        payload = {\"name\": name, \"address\": address}\n        return self._handle_request(HTTPMethod.PUT, url, payload)\n\n    def commission_terminal(self, serial_number: str) -&gt; Response:\n        \"\"\"Activate your debug device by linking it to your integration\n\n        Args:\n            serial_number: Device Serial Number\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(\"/terminal/commission_device\")\n\n        payload = {\n            \"serial_number\": serial_number,\n        }\n        return self._handle_request(HTTPMethod.POST, url, payload)\n\n    def decommission_terminal(self, serial_number: str) -&gt; Response:\n        \"\"\"Unlink your debug device from your integration\n\n        Args:\n            serial_number: Device Serial Number\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._parse_url(\"/terminal/decommission_device\")\n\n        payload = {\n            \"serial_number\": serial_number,\n        }\n        return self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/terminals/#pypaystack2.api.terminals.Terminal.commission_terminal","title":"<code>commission_terminal(serial_number)</code>","text":"<p>Activate your debug device by linking it to your integration</p> <p>Parameters:</p> Name Type Description Default <code>serial_number</code> <code>str</code> <p>Device Serial Number</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/terminals.py</code> <pre><code>def commission_terminal(self, serial_number: str) -&gt; Response:\n    \"\"\"Activate your debug device by linking it to your integration\n\n    Args:\n        serial_number: Device Serial Number\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(\"/terminal/commission_device\")\n\n    payload = {\n        \"serial_number\": serial_number,\n    }\n    return self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/terminals/#pypaystack2.api.terminals.Terminal.decommission_terminal","title":"<code>decommission_terminal(serial_number)</code>","text":"<p>Unlink your debug device from your integration</p> <p>Parameters:</p> Name Type Description Default <code>serial_number</code> <code>str</code> <p>Device Serial Number</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/terminals.py</code> <pre><code>def decommission_terminal(self, serial_number: str) -&gt; Response:\n    \"\"\"Unlink your debug device from your integration\n\n    Args:\n        serial_number: Device Serial Number\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._parse_url(\"/terminal/decommission_device\")\n\n    payload = {\n        \"serial_number\": serial_number,\n    }\n    return self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/terminals/#pypaystack2.api.terminals.Terminal.get_event_status","title":"<code>get_event_status(terminal_id, event_id)</code>","text":"<p>Check the status of an event sent to the Terminal</p> <p>Parameters:</p> Name Type Description Default <code>terminal_id</code> <code>str</code> <p>The ID of the Terminal the event was sent to.</p> required <code>event_id</code> <code>str</code> <p>The ID of the event that was sent to the Terminal</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/terminals.py</code> <pre><code>def get_event_status(self, terminal_id: str, event_id: str) -&gt; Response:\n    \"\"\"Check the status of an event sent to the Terminal\n\n    Args:\n        terminal_id: The ID of the Terminal the event was sent to.\n        event_id: The ID of the event that was sent to the Terminal\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._parse_url(f\"/terminal/{terminal_id}/event/{event_id}\")\n    return self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/terminals/#pypaystack2.api.terminals.Terminal.get_terminal","title":"<code>get_terminal(terminal_id)</code>","text":"<p>Get the details of a Terminal</p> <p>Parameters:</p> Name Type Description Default <code>terminal_id</code> <code>str</code> <p>The ID of the Terminal the event was sent to.</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/terminals.py</code> <pre><code>def get_terminal(self, terminal_id: str) -&gt; Response:\n    \"\"\"Get the details of a Terminal\n\n    Args:\n        terminal_id: The ID of the Terminal the event was sent to.\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._parse_url(f\"/terminal/{terminal_id}/\")\n    return self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/terminals/#pypaystack2.api.terminals.Terminal.get_terminal_status","title":"<code>get_terminal_status(terminal_id)</code>","text":"<p>Check the availability of a Terminal before sending an event to it.</p> <p>Parameters:</p> Name Type Description Default <code>terminal_id</code> <code>str</code> <p>The ID of the Terminal you want to check</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/terminals.py</code> <pre><code>def get_terminal_status(self, terminal_id: str) -&gt; Response:\n    \"\"\"Check the availability of a Terminal before sending an event to it.\n\n    Args:\n        terminal_id: The ID of the Terminal you want to check\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._parse_url(f\"/terminal/{terminal_id}/presence\")\n    return self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/terminals/#pypaystack2.api.terminals.Terminal.get_terminals","title":"<code>get_terminals(pagination=50, next=None, previous=None)</code>","text":"<p>List the Terminals available on your integration</p> <p>Parameters:</p> Name Type Description Default <code>pagination</code> <code>int</code> <p>Specifies how many records you want to retrieve per page. If not specified, it defaults to 50.</p> <code>50</code> <code>next</code> <code>Optional[str]</code> <p>Specifies how many records you want to retrieve per page. If not specified we use a default value of 50.</p> <code>None</code> <code>previous</code> <code>Optional[str]</code> <p>A cursor that indicates your place in the list. It should be used to fetch the previous page of the list after an initial next request</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/terminals.py</code> <pre><code>def get_terminals(\n    self,\n    pagination: int = 50,\n    next: Optional[str] = None,\n    previous: Optional[str] = None,\n) -&gt; Response:\n    \"\"\"List the Terminals available on your integration\n\n    Args:\n        pagination: Specifies how many records you want to retrieve per page. If not specified, it defaults to 50.\n        next: Specifies how many records you want to retrieve per page. If not specified\n            we use a default value of 50.\n        previous: A cursor that indicates your place in the list. It should be used to fetch the\n            previous page of the list after an initial next request\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._parse_url(f\"/terminal?perPage={pagination}\")\n    query_params = [\n        (\"next\", next),\n        (\"previous\", previous),\n    ]\n    url = append_query_params(query_params, url)\n    return self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/terminals/#pypaystack2.api.terminals.Terminal.send_event","title":"<code>send_event(terminal_id, type, action, data)</code>","text":"<p>Send an event from your application to the Paystack Terminal</p> <p>Parameters:</p> Name Type Description Default <code>terminal_id</code> <code>str</code> <p>The ID of the Terminal the event should be sent to.</p> required <code>type</code> <code>TerminalEvent</code> <p>The type of event to push. Paystack currently supports <code>TerminalEventType.INVOICE</code> and <code>TerminalEventType.TRANSACTION</code>.</p> required <code>action</code> <code>TerminalEventAction</code> <p>The action the Terminal needs to perform. For the <code>TerminalEventType.INVOICE</code> type, the action can either be <code>TerminalEventAction.PROCESS</code> or TerminalEventAction.VIEW. For the <code>TerminalEventType.TRANSACTION</code> type, the action can either be <code>TerminalEventAction.PROCESS</code> or <code>TerminalEventAction.PRINT</code>.</p> required <code>data</code> <code>dict</code> <p>The parameters needed to perform the specified action. For the invoice type, you need to pass the invoice id and offline reference: {id: invoice_id, reference: offline_reference}. For the transaction type, you can pass the transaction id: {id: transaction_id}</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/terminals.py</code> <pre><code>def send_event(\n    self,\n    terminal_id: str,\n    type: TerminalEvent,\n    action: TerminalEventAction,\n    data: dict,\n) -&gt; Response:\n    \"\"\"Send an event from your application to the Paystack Terminal\n\n    Args:\n        terminal_id: The ID of the Terminal the event should be sent to.\n        type: The type of event to push. Paystack currently supports `TerminalEventType.INVOICE` and\n            `TerminalEventType.TRANSACTION`.\n        action: The action the Terminal needs to perform. For the `TerminalEventType.INVOICE` type,\n            the action can either be `TerminalEventAction.PROCESS` or TerminalEventAction.VIEW.\n            For the `TerminalEventType.TRANSACTION` type, the action can either be\n            `TerminalEventAction.PROCESS` or `TerminalEventAction.PRINT`.\n        data: The parameters needed to perform the specified action. For the invoice type, you need to\n            pass the invoice id and offline reference: {id: invoice_id, reference: offline_reference}.\n            For the transaction type, you can pass the transaction id: {id: transaction_id}\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n    supported_actions_mapping = {\n        TerminalEvent.TRANSACTION: {\n            TerminalEventAction.PROCESS,\n            TerminalEventAction.PRINT,\n        },\n        TerminalEvent.INVOICE: {\n            TerminalEventAction.PROCESS,\n            TerminalEventAction.VIEW,\n        },\n    }\n    if action not in supported_actions_mapping[type]:\n        raise InvalidDataException(\n            f\"Terminal Event: {type} does not support Terminal Event Action: {action}\"\n        )\n\n    url = self._parse_url(f\"/terminal/{terminal_id}/event\")\n\n    payload = {\n        \"type\": type,\n        \"action\": action,\n        \"data\": data,\n    }\n    return self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/terminals/#pypaystack2.api.terminals.Terminal.update_terminal","title":"<code>update_terminal(terminal_id, name, address)</code>","text":"<p>Update the details of a Terminal</p> <p>Parameters:</p> Name Type Description Default <code>terminal_id</code> <code>str</code> <p>The ID of the Terminal you want to update</p> required <code>name</code> <code>str</code> <p>Name of the terminal</p> required <code>address</code> <code>str</code> <p>The address of the Terminal</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/terminals.py</code> <pre><code>def update_terminal(self, terminal_id: str, name: str, address: str) -&gt; Response:\n    \"\"\"Update the details of a Terminal\n\n    Args:\n        terminal_id: The ID of the Terminal you want to update\n        name: Name of the terminal\n        address: The address of the Terminal\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._parse_url(f\"/terminal/{terminal_id}\")\n\n    payload = {\"name\": name, \"address\": address}\n    return self._handle_request(HTTPMethod.PUT, url, payload)\n</code></pre>"},{"location":"reference/transactions/","title":"Transactions","text":""},{"location":"reference/transactions/#pypaystack2.api.transactions.AsyncTransaction","title":"<code>AsyncTransaction</code>","text":"<p>               Bases: <code>BaseAsyncAPI</code></p> <p>Provides a wrapper for paystack Transactions API</p> <p>The Transactions API allows you to create and manage payments on your integration. https://paystack.com/docs/api/transaction/</p> Source code in <code>src/pypaystack2/api/transactions.py</code> <pre><code>class AsyncTransaction(BaseAsyncAPI):\n    \"\"\"Provides a wrapper for paystack Transactions API\n\n    The Transactions API allows you to create and manage payments on your integration.\n    https://paystack.com/docs/api/transaction/\n    \"\"\"\n\n    async def initialize(\n        self,\n        amount: int,\n        email: str,\n        currency: Optional[Currency] = None,\n        reference: Optional[str] = None,\n        callback_url: Optional[str] = None,\n        plan: Optional[str] = None,\n        invoice_limit: Optional[int] = None,\n        metadata: Optional[dict] = None,\n        channels: Optional[list[Channel]] = None,\n        split_code: Optional[str] = None,\n        subaccount: Optional[str] = None,\n        transfer_charge: Optional[int] = None,\n        bearer: Optional[Bearer] = None,\n    ) -&gt; Response:\n        \"\"\"Initialize a transaction from your backend\n\n        Args:\n            amount: Amount should be in kobo if currency is ``Currency.NGN``, pesewas,\n                if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR``\n            email: Customer's email address\n            currency: Any value from the ``Currency`` enum.\n            reference: Unique transaction reference. Only ``-, ., =`` and alphanumeric characters allowed.\n            callback_url: Fully qualified url, e.g. ``https://example.com/`` . Use this to override the callback url\n                provided on the dashboard for this transaction\n            plan: If transaction is to create a subscription to a predefined plan, provide plan code here.\n                This would invalidate the value provided in ``amount``\n            invoice_limit: Number of times to charge customer during subscription to plan\n            metadata: A dictionary of additional info. check out this link\n                for more information. https://paystack.com/docs/payments/metadata\n            channels: A list of ``Channel`` enum values to control what channels you want to make available\n                to the user to make a payment with\n            split_code: The split code of the transaction split. e.g. SPL_98WF13Eb3w\n            subaccount: The code for the subaccount that owns the payment. e.g. ACCT_8f4s1eq7ml6rlzj\n            transfer_charge: An amount used to override the split configuration for a single split payment. If set,\n                the amount specified goes to the main account regardless of the split configuration.\n            bearer: Any value from the ``Bearer`` enum. Who bears Paystack charges?\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n\n        Raises:\n            InvalidDataError: When email is not provided.\n        \"\"\"\n        amount = validate_amount(amount)\n\n        if not email:\n            raise InvalidDataException(\n                \"Customer's Email is required for initialization\"\n            )\n\n        url = self._parse_url(\"/transaction/initialize\")\n        payload = {\n            \"email\": email,\n            \"amount\": amount,\n        }\n\n        optional_params = [\n            (\"currency\", currency),\n            (\"reference\", reference),\n            (\"callback_url\", callback_url),\n            (\"plan\", plan),\n            (\"invoice_limit\", invoice_limit),\n            (\"metadata\", metadata),\n            (\"channels\", channels),\n            (\"split_code\", split_code),\n            (\"subaccount\", subaccount),\n            (\"transfer_charge\", transfer_charge),\n            (\"bearer\", bearer),\n        ]\n        payload = add_to_payload(optional_params, payload)\n\n        return await self._handle_request(HTTPMethod.POST, url, payload)\n\n    async def verify(self, reference: str) -&gt; Response:\n        \"\"\"Confirm the status of a transaction\n\n        Args:\n            reference: The transaction reference used to intiate the transaction\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        reference = str(reference)\n        url = self._parse_url(f\"/transaction/verify/{reference}\")\n        return await self._handle_request(HTTPMethod.GET, url)\n\n    async def get_transactions(\n        self,\n        customer: Optional[str] = None,\n        start_date: Optional[str] = None,\n        end_date: Optional[str] = None,\n        status: Optional[TransactionStatus] = None,\n        page: Optional[int] = None,\n        amount: Optional[int] = None,\n        pagination: int = 50,\n    ) -&gt; Response:\n        \"\"\"Fetch transactions carried out on your integration.\n\n        Args:\n            customer: Specify an ID for the customer whose transactions you want to retrieve\n            start_date: A timestamp from which to start listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            end_date: A timestamp at which to stop listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            status: Filter transactions by status. any value from the ``TransactionStatus`` enum\n            page: Specify exactly what page you want to retrieve.\n                If not specified, we use a default value of 1.\n            amount: Optional[int]\n                Filter transactions by amount. Specify the amount (in kobo if currency is\n                ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``, and cents, if\n                currency is ``Currency.ZAR``)\n            pagination: Specifies how many records you want to retrieve per page. If not specified, we\n                use a default value of 50.\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/transaction/?perPage={pagination}\")\n        query_params = [\n            (\"page\", page),\n            (\"customer\", customer),\n            (\"status\", status),\n            (\"from\", start_date),\n            (\"to\", end_date),\n            (\"amount\", amount),\n        ]\n        url = append_query_params(query_params, url)\n\n        return await self._handle_request(HTTPMethod.GET, url)\n\n    async def get_transaction(self, id: str) -&gt; Response:\n        \"\"\"Get details of a transaction carried out on your integration.\n\n        Args:\n            id: An ID for the transaction to fetch\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/transaction/{id}/\")\n        return await self._handle_request(HTTPMethod.GET, url)\n\n    async def charge(\n        self,\n        amount: int,\n        email: str,\n        auth_code: str,\n        reference: Optional[str] = None,\n        currency: Optional[Currency] = None,\n        metadata: Optional[dict] = None,\n        channels: Optional[list[Channel]] = None,\n        subaccount: Optional[str] = None,\n        transaction_charge: Optional[int] = None,\n        bearer: Optional[Bearer] = None,\n        queue: bool = False,\n    ) -&gt; Response:\n        \"\"\"\n        All authorizations marked as reusable can be charged with this\n        endpoint whenever you need to receive payments.\n\n        Args:\n            amount: amount to charge.\n            email: Customer's email address\n            auth_code: Valid authorization code to charge\n            reference: Unique transaction reference. Only ``-, ., =`` and alphanumeric\n                characters allowed.\n            currency: Currency in which amount should be charged. Any value from the\n                ``Currency`` enum.\n            metadata: Add a custom_fields attribute which has an array of objects if\n                you would like the fields to be added to your transaction when\n                displayed on the dashboard.\n                Sample: ``{\"custom_fields\":[{\"display_name\":\"Cart ID\",\n                \"variable_name\": \"cart_id\",\"value\": \"8393\"}]}``\n            channels: A list of ``Channel`` enum values to control what channels you want to make available\n                to the user to make a payment with\n            subaccount: The code for the subaccount that owns the payment. e.g. ACCT_8f4s1eq7ml6rlzj\n            transaction_charge: A flat fee to charge the subaccount for this transaction (in kobo if currency is NGN,\n                pesewas, if currency is GHS, and cents, if currency is ZAR). This overrides the split\n                percentage set when the subaccount was created. Ideally, you will need to use this if\n                you are splitting in flat rates (since subaccount creation only allows for percentage split).\n                e.g., 7000 for a 70 naira\n            bearer: Who bears Paystack charges? any value from the ``Beaer`` enum\n            queue: If you are making a scheduled charge call, it is a good idea to queue them so the processing\n                system does not get overloaded causing transaction processing errors. Set ``queue=True`` to\n                take advantage of our queued charging.\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        amount = validate_amount(amount)\n\n        if not email:\n            raise InvalidDataException(\"Customer's Email is required to charge\")\n\n        if not auth_code:\n            raise InvalidDataException(\"Customer's Auth code is required to charge\")\n\n        url = self._parse_url(\"/transaction/charge_authorization\")\n        payload = {\n            \"authorization_code\": auth_code,\n            \"email\": email,\n            \"amount\": amount,\n        }\n        optional_params = [\n            (\"reference\", reference),\n            (\"currency\", currency),\n            (\"metadata\", metadata),\n            (\"channels\", channels),\n            (\"subaccount\", subaccount),\n            (\"transaction_charge\", transaction_charge),\n            (\"bearer\", bearer),\n            (\"queue\", queue),\n        ]\n        payload = add_to_payload(optional_params, payload)\n\n        return await self._handle_request(HTTPMethod.POST, url, payload)\n\n    async def get_timeline(self, id_or_ref: str) -&gt; Response:\n        \"\"\"View the timeline of a transaction\n\n        Args:\n            id_or_ref: The ID or the reference of the transaction\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/transaction/timeline/{id_or_ref}\")\n        return await self._handle_request(HTTPMethod.GET, url)\n\n    async def totals(\n        self,\n        page: Optional[int] = None,\n        start_date: Optional[str] = None,\n        end_date: Optional[str] = None,\n        pagination: int = 50,\n    ) -&gt; Response:\n        \"\"\"Total amount received on your account\n\n        Args:\n            page: Specifies exactly what page you want to retrieve.\n                If not specified, we use a default value of 1.\n            start_date: A timestamp from which to start listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            end_date: A timestamp at which to stop listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            pagination: Specifies how many records you want to retrieve per page.\n                If not specified, we use a default value of 50.\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/transaction/totals/?perPage={pagination}\")\n        query_params = [\n            (\"page\", page),\n            (\"from\", start_date),\n            (\"to\", end_date),\n        ]\n        url = append_query_params(query_params, url)\n        return await self._handle_request(HTTPMethod.GET, url)\n\n    async def export(\n        self,\n        page: Optional[int] = None,\n        start_date: Optional[str] = None,\n        end_date: Optional[str] = None,\n        customer: Optional[str] = None,\n        status: Optional[TransactionStatus] = None,\n        currency: Optional[Currency] = None,\n        amount: Optional[int] = None,\n        settled: Optional[bool] = None,\n        settlement: Optional[str] = None,\n        payment_page: Optional[str] = None,\n        pagination: int = 50,\n    ) -&gt; Response:\n        \"\"\"Fetch transactions carried out on your integration.\n\n        Args:\n            page: Specifies exactly what page you want to retrieve.\n                If not specified, we use a default value of 1.\n            start_date: A timestamp from which to start listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            end_date: A timestamp at which to stop listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            customer: Specify an ID for the customer whose transactions you want to retrieve\n            status: Filter transactions by status. Any value from the ``TransactionStatus`` enum\n            currency: Specify the transaction currency to export. Any value from the ``Currency`` enum\n            amount: Filter transactions by amount. Specify the amount, in\n                kobo if currency is ``Currency.NGN``, pesewas, if currency\n                is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR``\n            settled: Set to ``True`` to export only settled transactions. ``False`` for\n                pending transactions. Leave undefined to export all transaction\n            settlement: An ID for the settlement whose transactions we should export\n            payment_page: Optional[int]\n                Specify a payment page's id to export only transactions conducted on said page\n            pagination: int\n                Specifies how many records you want to retrieve per page.\n                If not specified, we use a default value of 50.\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        if amount:\n            amount = validate_amount(amount)\n        url = self._parse_url(f\"/transaction/export/?perPage={pagination}\")\n        query_params = [\n            (\"page\", page),\n            (\"from\", start_date),\n            (\"to\", end_date),\n            (\"customer\", customer),\n            (\"status\", status),\n            (\"currency\", currency),\n            (\"settled\", settled),\n            (\"settlement\", settlement),\n            (\"payment_page\", payment_page),\n        ]\n        url = append_query_params(query_params, url)\n        return await self._handle_request(HTTPMethod.GET, url)\n\n    async def partial_debit(\n        self,\n        auth_code: str,\n        currency: Currency,\n        amount: int,\n        email: str,\n        reference: Optional[str] = None,\n        at_least: Optional[int] = None,\n    ) -&gt; Response:\n        \"\"\"Retrieve part of a payment from a customer\n\n        Args:\n            auth_code: Authorization Code\n            currency: Specify the currency you want to debit. Any value\n                from the ``Currency`` enum.\n            amount: Amount should be in kobo if currency is ``Currency.NGN``, pesewas,\n                if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR``\n            email: Customer's email address (attached to the authorization code)\n            reference: Unique transaction reference. Only `-, ., =`\n                 and alphanumeric characters allowed.\n            at_least: Minimum amount to charge\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n\n        Raises:\n            InvalidDataError: When Customer's email is not provided. When Customer's auth code is not provided.\n        \"\"\"\n        amount = validate_amount(amount)\n        if at_least:\n            at_least = validate_amount(at_least)\n\n        if not email:\n            raise InvalidDataException(\"Customer's Email is required to charge\")\n\n        if not auth_code:\n            raise InvalidDataException(\"Customer's Auth code is required to charge\")\n\n        url = self._parse_url(\"/transaction/partial_debit\")\n        payload = {\n            \"authorization_code\": auth_code,\n            \"currency\": currency,\n            \"amount\": amount,\n            \"email\": email,\n        }\n        optional_params = [(\"reference\", reference), (\"at_least\", at_least)]\n        payload = add_to_payload(optional_params, payload)\n\n        return await self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/transactions/#pypaystack2.api.transactions.AsyncTransaction.charge","title":"<code>charge(amount, email, auth_code, reference=None, currency=None, metadata=None, channels=None, subaccount=None, transaction_charge=None, bearer=None, queue=False)</code>  <code>async</code>","text":"<p>All authorizations marked as reusable can be charged with this endpoint whenever you need to receive payments.</p> <p>Parameters:</p> Name Type Description Default <code>amount</code> <code>int</code> <p>amount to charge.</p> required <code>email</code> <code>str</code> <p>Customer's email address</p> required <code>auth_code</code> <code>str</code> <p>Valid authorization code to charge</p> required <code>reference</code> <code>Optional[str]</code> <p>Unique transaction reference. Only <code>-, ., =</code> and alphanumeric characters allowed.</p> <code>None</code> <code>currency</code> <code>Optional[Currency]</code> <p>Currency in which amount should be charged. Any value from the <code>Currency</code> enum.</p> <code>None</code> <code>metadata</code> <code>Optional[dict]</code> <p>Add a custom_fields attribute which has an array of objects if you would like the fields to be added to your transaction when displayed on the dashboard. Sample: <code>{\"custom_fields\":[{\"display_name\":\"Cart ID\", \"variable_name\": \"cart_id\",\"value\": \"8393\"}]}</code></p> <code>None</code> <code>channels</code> <code>Optional[list[Channel]]</code> <p>A list of <code>Channel</code> enum values to control what channels you want to make available to the user to make a payment with</p> <code>None</code> <code>subaccount</code> <code>Optional[str]</code> <p>The code for the subaccount that owns the payment. e.g. ACCT_8f4s1eq7ml6rlzj</p> <code>None</code> <code>transaction_charge</code> <code>Optional[int]</code> <p>A flat fee to charge the subaccount for this transaction (in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR). This overrides the split percentage set when the subaccount was created. Ideally, you will need to use this if you are splitting in flat rates (since subaccount creation only allows for percentage split). e.g., 7000 for a 70 naira</p> <code>None</code> <code>bearer</code> <code>Optional[Bearer]</code> <p>Who bears Paystack charges? any value from the <code>Beaer</code> enum</p> <code>None</code> <code>queue</code> <code>bool</code> <p>If you are making a scheduled charge call, it is a good idea to queue them so the processing system does not get overloaded causing transaction processing errors. Set <code>queue=True</code> to take advantage of our queued charging.</p> <code>False</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/transactions.py</code> <pre><code>async def charge(\n    self,\n    amount: int,\n    email: str,\n    auth_code: str,\n    reference: Optional[str] = None,\n    currency: Optional[Currency] = None,\n    metadata: Optional[dict] = None,\n    channels: Optional[list[Channel]] = None,\n    subaccount: Optional[str] = None,\n    transaction_charge: Optional[int] = None,\n    bearer: Optional[Bearer] = None,\n    queue: bool = False,\n) -&gt; Response:\n    \"\"\"\n    All authorizations marked as reusable can be charged with this\n    endpoint whenever you need to receive payments.\n\n    Args:\n        amount: amount to charge.\n        email: Customer's email address\n        auth_code: Valid authorization code to charge\n        reference: Unique transaction reference. Only ``-, ., =`` and alphanumeric\n            characters allowed.\n        currency: Currency in which amount should be charged. Any value from the\n            ``Currency`` enum.\n        metadata: Add a custom_fields attribute which has an array of objects if\n            you would like the fields to be added to your transaction when\n            displayed on the dashboard.\n            Sample: ``{\"custom_fields\":[{\"display_name\":\"Cart ID\",\n            \"variable_name\": \"cart_id\",\"value\": \"8393\"}]}``\n        channels: A list of ``Channel`` enum values to control what channels you want to make available\n            to the user to make a payment with\n        subaccount: The code for the subaccount that owns the payment. e.g. ACCT_8f4s1eq7ml6rlzj\n        transaction_charge: A flat fee to charge the subaccount for this transaction (in kobo if currency is NGN,\n            pesewas, if currency is GHS, and cents, if currency is ZAR). This overrides the split\n            percentage set when the subaccount was created. Ideally, you will need to use this if\n            you are splitting in flat rates (since subaccount creation only allows for percentage split).\n            e.g., 7000 for a 70 naira\n        bearer: Who bears Paystack charges? any value from the ``Beaer`` enum\n        queue: If you are making a scheduled charge call, it is a good idea to queue them so the processing\n            system does not get overloaded causing transaction processing errors. Set ``queue=True`` to\n            take advantage of our queued charging.\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    amount = validate_amount(amount)\n\n    if not email:\n        raise InvalidDataException(\"Customer's Email is required to charge\")\n\n    if not auth_code:\n        raise InvalidDataException(\"Customer's Auth code is required to charge\")\n\n    url = self._parse_url(\"/transaction/charge_authorization\")\n    payload = {\n        \"authorization_code\": auth_code,\n        \"email\": email,\n        \"amount\": amount,\n    }\n    optional_params = [\n        (\"reference\", reference),\n        (\"currency\", currency),\n        (\"metadata\", metadata),\n        (\"channels\", channels),\n        (\"subaccount\", subaccount),\n        (\"transaction_charge\", transaction_charge),\n        (\"bearer\", bearer),\n        (\"queue\", queue),\n    ]\n    payload = add_to_payload(optional_params, payload)\n\n    return await self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/transactions/#pypaystack2.api.transactions.AsyncTransaction.export","title":"<code>export(page=None, start_date=None, end_date=None, customer=None, status=None, currency=None, amount=None, settled=None, settlement=None, payment_page=None, pagination=50)</code>  <code>async</code>","text":"<p>Fetch transactions carried out on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>Optional[int]</code> <p>Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1.</p> <code>None</code> <code>start_date</code> <code>Optional[str]</code> <p>A timestamp from which to start listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>end_date</code> <code>Optional[str]</code> <p>A timestamp at which to stop listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>customer</code> <code>Optional[str]</code> <p>Specify an ID for the customer whose transactions you want to retrieve</p> <code>None</code> <code>status</code> <code>Optional[TransactionStatus]</code> <p>Filter transactions by status. Any value from the <code>TransactionStatus</code> enum</p> <code>None</code> <code>currency</code> <code>Optional[Currency]</code> <p>Specify the transaction currency to export. Any value from the <code>Currency</code> enum</p> <code>None</code> <code>amount</code> <code>Optional[int]</code> <p>Filter transactions by amount. Specify the amount, in kobo if currency is <code>Currency.NGN</code>, pesewas, if currency is <code>Currency.GHS</code>, and cents, if currency is <code>Currency.ZAR</code></p> <code>None</code> <code>settled</code> <code>Optional[bool]</code> <p>Set to <code>True</code> to export only settled transactions. <code>False</code> for pending transactions. Leave undefined to export all transaction</p> <code>None</code> <code>settlement</code> <code>Optional[str]</code> <p>An ID for the settlement whose transactions we should export</p> <code>None</code> <code>payment_page</code> <code>Optional[str]</code> <p>Optional[int] Specify a payment page's id to export only transactions conducted on said page</p> <code>None</code> <code>pagination</code> <code>int</code> <p>int Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50.</p> <code>50</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/transactions.py</code> <pre><code>async def export(\n    self,\n    page: Optional[int] = None,\n    start_date: Optional[str] = None,\n    end_date: Optional[str] = None,\n    customer: Optional[str] = None,\n    status: Optional[TransactionStatus] = None,\n    currency: Optional[Currency] = None,\n    amount: Optional[int] = None,\n    settled: Optional[bool] = None,\n    settlement: Optional[str] = None,\n    payment_page: Optional[str] = None,\n    pagination: int = 50,\n) -&gt; Response:\n    \"\"\"Fetch transactions carried out on your integration.\n\n    Args:\n        page: Specifies exactly what page you want to retrieve.\n            If not specified, we use a default value of 1.\n        start_date: A timestamp from which to start listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        end_date: A timestamp at which to stop listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        customer: Specify an ID for the customer whose transactions you want to retrieve\n        status: Filter transactions by status. Any value from the ``TransactionStatus`` enum\n        currency: Specify the transaction currency to export. Any value from the ``Currency`` enum\n        amount: Filter transactions by amount. Specify the amount, in\n            kobo if currency is ``Currency.NGN``, pesewas, if currency\n            is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR``\n        settled: Set to ``True`` to export only settled transactions. ``False`` for\n            pending transactions. Leave undefined to export all transaction\n        settlement: An ID for the settlement whose transactions we should export\n        payment_page: Optional[int]\n            Specify a payment page's id to export only transactions conducted on said page\n        pagination: int\n            Specifies how many records you want to retrieve per page.\n            If not specified, we use a default value of 50.\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    if amount:\n        amount = validate_amount(amount)\n    url = self._parse_url(f\"/transaction/export/?perPage={pagination}\")\n    query_params = [\n        (\"page\", page),\n        (\"from\", start_date),\n        (\"to\", end_date),\n        (\"customer\", customer),\n        (\"status\", status),\n        (\"currency\", currency),\n        (\"settled\", settled),\n        (\"settlement\", settlement),\n        (\"payment_page\", payment_page),\n    ]\n    url = append_query_params(query_params, url)\n    return await self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/transactions/#pypaystack2.api.transactions.AsyncTransaction.get_timeline","title":"<code>get_timeline(id_or_ref)</code>  <code>async</code>","text":"<p>View the timeline of a transaction</p> <p>Parameters:</p> Name Type Description Default <code>id_or_ref</code> <code>str</code> <p>The ID or the reference of the transaction</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/transactions.py</code> <pre><code>async def get_timeline(self, id_or_ref: str) -&gt; Response:\n    \"\"\"View the timeline of a transaction\n\n    Args:\n        id_or_ref: The ID or the reference of the transaction\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/transaction/timeline/{id_or_ref}\")\n    return await self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/transactions/#pypaystack2.api.transactions.AsyncTransaction.get_transaction","title":"<code>get_transaction(id)</code>  <code>async</code>","text":"<p>Get details of a transaction carried out on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>An ID for the transaction to fetch</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/transactions.py</code> <pre><code>async def get_transaction(self, id: str) -&gt; Response:\n    \"\"\"Get details of a transaction carried out on your integration.\n\n    Args:\n        id: An ID for the transaction to fetch\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/transaction/{id}/\")\n    return await self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/transactions/#pypaystack2.api.transactions.AsyncTransaction.get_transactions","title":"<code>get_transactions(customer=None, start_date=None, end_date=None, status=None, page=None, amount=None, pagination=50)</code>  <code>async</code>","text":"<p>Fetch transactions carried out on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>customer</code> <code>Optional[str]</code> <p>Specify an ID for the customer whose transactions you want to retrieve</p> <code>None</code> <code>start_date</code> <code>Optional[str]</code> <p>A timestamp from which to start listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>end_date</code> <code>Optional[str]</code> <p>A timestamp at which to stop listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>status</code> <code>Optional[TransactionStatus]</code> <p>Filter transactions by status. any value from the <code>TransactionStatus</code> enum</p> <code>None</code> <code>page</code> <code>Optional[int]</code> <p>Specify exactly what page you want to retrieve. If not specified, we use a default value of 1.</p> <code>None</code> <code>amount</code> <code>Optional[int]</code> <p>Optional[int] Filter transactions by amount. Specify the amount (in kobo if currency is <code>Currency.NGN</code>, pesewas, if currency is <code>Currency.GHS</code>, and cents, if currency is <code>Currency.ZAR</code>)</p> <code>None</code> <code>pagination</code> <code>int</code> <p>Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50.</p> <code>50</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/transactions.py</code> <pre><code>async def get_transactions(\n    self,\n    customer: Optional[str] = None,\n    start_date: Optional[str] = None,\n    end_date: Optional[str] = None,\n    status: Optional[TransactionStatus] = None,\n    page: Optional[int] = None,\n    amount: Optional[int] = None,\n    pagination: int = 50,\n) -&gt; Response:\n    \"\"\"Fetch transactions carried out on your integration.\n\n    Args:\n        customer: Specify an ID for the customer whose transactions you want to retrieve\n        start_date: A timestamp from which to start listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        end_date: A timestamp at which to stop listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        status: Filter transactions by status. any value from the ``TransactionStatus`` enum\n        page: Specify exactly what page you want to retrieve.\n            If not specified, we use a default value of 1.\n        amount: Optional[int]\n            Filter transactions by amount. Specify the amount (in kobo if currency is\n            ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``, and cents, if\n            currency is ``Currency.ZAR``)\n        pagination: Specifies how many records you want to retrieve per page. If not specified, we\n            use a default value of 50.\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/transaction/?perPage={pagination}\")\n    query_params = [\n        (\"page\", page),\n        (\"customer\", customer),\n        (\"status\", status),\n        (\"from\", start_date),\n        (\"to\", end_date),\n        (\"amount\", amount),\n    ]\n    url = append_query_params(query_params, url)\n\n    return await self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/transactions/#pypaystack2.api.transactions.AsyncTransaction.initialize","title":"<code>initialize(amount, email, currency=None, reference=None, callback_url=None, plan=None, invoice_limit=None, metadata=None, channels=None, split_code=None, subaccount=None, transfer_charge=None, bearer=None)</code>  <code>async</code>","text":"<p>Initialize a transaction from your backend</p> <p>Parameters:</p> Name Type Description Default <code>amount</code> <code>int</code> <p>Amount should be in kobo if currency is <code>Currency.NGN</code>, pesewas, if currency is <code>Currency.GHS</code>, and cents, if currency is <code>Currency.ZAR</code></p> required <code>email</code> <code>str</code> <p>Customer's email address</p> required <code>currency</code> <code>Optional[Currency]</code> <p>Any value from the <code>Currency</code> enum.</p> <code>None</code> <code>reference</code> <code>Optional[str]</code> <p>Unique transaction reference. Only <code>-, ., =</code> and alphanumeric characters allowed.</p> <code>None</code> <code>callback_url</code> <code>Optional[str]</code> <p>Fully qualified url, e.g. <code>https://example.com/</code> . Use this to override the callback url provided on the dashboard for this transaction</p> <code>None</code> <code>plan</code> <code>Optional[str]</code> <p>If transaction is to create a subscription to a predefined plan, provide plan code here. This would invalidate the value provided in <code>amount</code></p> <code>None</code> <code>invoice_limit</code> <code>Optional[int]</code> <p>Number of times to charge customer during subscription to plan</p> <code>None</code> <code>metadata</code> <code>Optional[dict]</code> <p>A dictionary of additional info. check out this link for more information. https://paystack.com/docs/payments/metadata</p> <code>None</code> <code>channels</code> <code>Optional[list[Channel]]</code> <p>A list of <code>Channel</code> enum values to control what channels you want to make available to the user to make a payment with</p> <code>None</code> <code>split_code</code> <code>Optional[str]</code> <p>The split code of the transaction split. e.g. SPL_98WF13Eb3w</p> <code>None</code> <code>subaccount</code> <code>Optional[str]</code> <p>The code for the subaccount that owns the payment. e.g. ACCT_8f4s1eq7ml6rlzj</p> <code>None</code> <code>transfer_charge</code> <code>Optional[int]</code> <p>An amount used to override the split configuration for a single split payment. If set, the amount specified goes to the main account regardless of the split configuration.</p> <code>None</code> <code>bearer</code> <code>Optional[Bearer]</code> <p>Any value from the <code>Bearer</code> enum. Who bears Paystack charges?</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> <p>Raises:</p> Type Description <code>InvalidDataError</code> <p>When email is not provided.</p> Source code in <code>src/pypaystack2/api/transactions.py</code> <pre><code>async def initialize(\n    self,\n    amount: int,\n    email: str,\n    currency: Optional[Currency] = None,\n    reference: Optional[str] = None,\n    callback_url: Optional[str] = None,\n    plan: Optional[str] = None,\n    invoice_limit: Optional[int] = None,\n    metadata: Optional[dict] = None,\n    channels: Optional[list[Channel]] = None,\n    split_code: Optional[str] = None,\n    subaccount: Optional[str] = None,\n    transfer_charge: Optional[int] = None,\n    bearer: Optional[Bearer] = None,\n) -&gt; Response:\n    \"\"\"Initialize a transaction from your backend\n\n    Args:\n        amount: Amount should be in kobo if currency is ``Currency.NGN``, pesewas,\n            if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR``\n        email: Customer's email address\n        currency: Any value from the ``Currency`` enum.\n        reference: Unique transaction reference. Only ``-, ., =`` and alphanumeric characters allowed.\n        callback_url: Fully qualified url, e.g. ``https://example.com/`` . Use this to override the callback url\n            provided on the dashboard for this transaction\n        plan: If transaction is to create a subscription to a predefined plan, provide plan code here.\n            This would invalidate the value provided in ``amount``\n        invoice_limit: Number of times to charge customer during subscription to plan\n        metadata: A dictionary of additional info. check out this link\n            for more information. https://paystack.com/docs/payments/metadata\n        channels: A list of ``Channel`` enum values to control what channels you want to make available\n            to the user to make a payment with\n        split_code: The split code of the transaction split. e.g. SPL_98WF13Eb3w\n        subaccount: The code for the subaccount that owns the payment. e.g. ACCT_8f4s1eq7ml6rlzj\n        transfer_charge: An amount used to override the split configuration for a single split payment. If set,\n            the amount specified goes to the main account regardless of the split configuration.\n        bearer: Any value from the ``Bearer`` enum. Who bears Paystack charges?\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n\n    Raises:\n        InvalidDataError: When email is not provided.\n    \"\"\"\n    amount = validate_amount(amount)\n\n    if not email:\n        raise InvalidDataException(\n            \"Customer's Email is required for initialization\"\n        )\n\n    url = self._parse_url(\"/transaction/initialize\")\n    payload = {\n        \"email\": email,\n        \"amount\": amount,\n    }\n\n    optional_params = [\n        (\"currency\", currency),\n        (\"reference\", reference),\n        (\"callback_url\", callback_url),\n        (\"plan\", plan),\n        (\"invoice_limit\", invoice_limit),\n        (\"metadata\", metadata),\n        (\"channels\", channels),\n        (\"split_code\", split_code),\n        (\"subaccount\", subaccount),\n        (\"transfer_charge\", transfer_charge),\n        (\"bearer\", bearer),\n    ]\n    payload = add_to_payload(optional_params, payload)\n\n    return await self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/transactions/#pypaystack2.api.transactions.AsyncTransaction.partial_debit","title":"<code>partial_debit(auth_code, currency, amount, email, reference=None, at_least=None)</code>  <code>async</code>","text":"<p>Retrieve part of a payment from a customer</p> <p>Parameters:</p> Name Type Description Default <code>auth_code</code> <code>str</code> <p>Authorization Code</p> required <code>currency</code> <code>Currency</code> <p>Specify the currency you want to debit. Any value from the <code>Currency</code> enum.</p> required <code>amount</code> <code>int</code> <p>Amount should be in kobo if currency is <code>Currency.NGN</code>, pesewas, if currency is <code>Currency.GHS</code>, and cents, if currency is <code>Currency.ZAR</code></p> required <code>email</code> <code>str</code> <p>Customer's email address (attached to the authorization code)</p> required <code>reference</code> <code>Optional[str]</code> <p>Unique transaction reference. Only <code>-, ., =</code>  and alphanumeric characters allowed.</p> <code>None</code> <code>at_least</code> <code>Optional[int]</code> <p>Minimum amount to charge</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> <p>Raises:</p> Type Description <code>InvalidDataError</code> <p>When Customer's email is not provided. When Customer's auth code is not provided.</p> Source code in <code>src/pypaystack2/api/transactions.py</code> <pre><code>async def partial_debit(\n    self,\n    auth_code: str,\n    currency: Currency,\n    amount: int,\n    email: str,\n    reference: Optional[str] = None,\n    at_least: Optional[int] = None,\n) -&gt; Response:\n    \"\"\"Retrieve part of a payment from a customer\n\n    Args:\n        auth_code: Authorization Code\n        currency: Specify the currency you want to debit. Any value\n            from the ``Currency`` enum.\n        amount: Amount should be in kobo if currency is ``Currency.NGN``, pesewas,\n            if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR``\n        email: Customer's email address (attached to the authorization code)\n        reference: Unique transaction reference. Only `-, ., =`\n             and alphanumeric characters allowed.\n        at_least: Minimum amount to charge\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n\n    Raises:\n        InvalidDataError: When Customer's email is not provided. When Customer's auth code is not provided.\n    \"\"\"\n    amount = validate_amount(amount)\n    if at_least:\n        at_least = validate_amount(at_least)\n\n    if not email:\n        raise InvalidDataException(\"Customer's Email is required to charge\")\n\n    if not auth_code:\n        raise InvalidDataException(\"Customer's Auth code is required to charge\")\n\n    url = self._parse_url(\"/transaction/partial_debit\")\n    payload = {\n        \"authorization_code\": auth_code,\n        \"currency\": currency,\n        \"amount\": amount,\n        \"email\": email,\n    }\n    optional_params = [(\"reference\", reference), (\"at_least\", at_least)]\n    payload = add_to_payload(optional_params, payload)\n\n    return await self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/transactions/#pypaystack2.api.transactions.AsyncTransaction.totals","title":"<code>totals(page=None, start_date=None, end_date=None, pagination=50)</code>  <code>async</code>","text":"<p>Total amount received on your account</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>Optional[int]</code> <p>Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1.</p> <code>None</code> <code>start_date</code> <code>Optional[str]</code> <p>A timestamp from which to start listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>end_date</code> <code>Optional[str]</code> <p>A timestamp at which to stop listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>pagination</code> <code>int</code> <p>Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50.</p> <code>50</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/transactions.py</code> <pre><code>async def totals(\n    self,\n    page: Optional[int] = None,\n    start_date: Optional[str] = None,\n    end_date: Optional[str] = None,\n    pagination: int = 50,\n) -&gt; Response:\n    \"\"\"Total amount received on your account\n\n    Args:\n        page: Specifies exactly what page you want to retrieve.\n            If not specified, we use a default value of 1.\n        start_date: A timestamp from which to start listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        end_date: A timestamp at which to stop listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        pagination: Specifies how many records you want to retrieve per page.\n            If not specified, we use a default value of 50.\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/transaction/totals/?perPage={pagination}\")\n    query_params = [\n        (\"page\", page),\n        (\"from\", start_date),\n        (\"to\", end_date),\n    ]\n    url = append_query_params(query_params, url)\n    return await self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/transactions/#pypaystack2.api.transactions.AsyncTransaction.verify","title":"<code>verify(reference)</code>  <code>async</code>","text":"<p>Confirm the status of a transaction</p> <p>Parameters:</p> Name Type Description Default <code>reference</code> <code>str</code> <p>The transaction reference used to intiate the transaction</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/transactions.py</code> <pre><code>async def verify(self, reference: str) -&gt; Response:\n    \"\"\"Confirm the status of a transaction\n\n    Args:\n        reference: The transaction reference used to intiate the transaction\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    reference = str(reference)\n    url = self._parse_url(f\"/transaction/verify/{reference}\")\n    return await self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/transactions/#pypaystack2.api.transactions.Transaction","title":"<code>Transaction</code>","text":"<p>               Bases: <code>BaseAPI</code></p> <p>Provides a wrapper for paystack Transactions API</p> <p>The Transactions API allows you to create and manage payments on your integration. see https://paystack.com/docs/api/transaction/</p> Source code in <code>src/pypaystack2/api/transactions.py</code> <pre><code>class Transaction(BaseAPI):\n    \"\"\"Provides a wrapper for paystack Transactions API\n\n    The Transactions API allows you to create and manage payments on your integration.\n    see https://paystack.com/docs/api/transaction/\n    \"\"\"\n\n    def initialize(\n        self,\n        amount: int,\n        email: str,\n        currency: Optional[Currency] = None,\n        reference: Optional[str] = None,\n        callback_url: Optional[str] = None,\n        plan: Optional[str] = None,\n        invoice_limit: Optional[int] = None,\n        metadata: Optional[dict] = None,\n        channels: Optional[list[Channel]] = None,\n        split_code: Optional[str] = None,\n        subaccount: Optional[str] = None,\n        transfer_charge: Optional[int] = None,\n        bearer: Optional[Bearer] = None,\n    ) -&gt; Response:\n        \"\"\"Initialize a transaction from your backend\n\n        Args:\n            amount: Amount should be in kobo if currency is ``Currency.NGN``, pesewas,\n                if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR``\n            email: Customer's email address\n            currency: Any value from the ``Currency`` enum.\n            reference: Unique transaction reference. Only ``-, ., =`` and alphanumeric characters allowed.\n            callback_url: Fully qualified url, e.g. ``https://example.com/`` . Use this to override the callback url\n                provided on the dashboard for this transaction\n            plan: If transaction is to create a subscription to a predefined plan, provide plan code here.\n                This would invalidate the value provided in ``amount``\n            invoice_limit: Number of times to charge customer during subscription to plan\n            metadata: A dictionary of additional info. check out this link\n                for more information. https://paystack.com/docs/payments/metadata\n            channels: A list of ``Channel`` enum values to control what channels you want to make available\n                to the user to make a payment with\n            split_code: The split code of the transaction split. e.g. SPL_98WF13Eb3w\n            subaccount: The code for the subaccount that owns the payment. e.g. ACCT_8f4s1eq7ml6rlzj\n            transfer_charge: An amount used to override the split configuration for a single split payment. If set,\n                the amount specified goes to the main account regardless of the split configuration.\n            bearer: Any value from the ``Bearer`` enum. Who bears Paystack charges?\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n\n        Raises:\n            InvalidDataError: When email is not provided.\n        \"\"\"\n        amount = validate_amount(amount)\n\n        if not email:\n            raise InvalidDataException(\n                \"Customer's Email is required for initialization\"\n            )\n\n        url = self._parse_url(\"/transaction/initialize\")\n        payload = {\n            \"email\": email,\n            \"amount\": amount,\n        }\n\n        optional_params = [\n            (\"currency\", currency),\n            (\"reference\", reference),\n            (\"callback_url\", callback_url),\n            (\"plan\", plan),\n            (\"invoice_limit\", invoice_limit),\n            (\"metadata\", metadata),\n            (\"channels\", channels),\n            (\"split_code\", split_code),\n            (\"subaccount\", subaccount),\n            (\"transfer_charge\", transfer_charge),\n            (\"bearer\", bearer),\n        ]\n        payload = add_to_payload(optional_params, payload)\n\n        return self._handle_request(HTTPMethod.POST, url, payload)\n\n    def verify(self, reference: str) -&gt; Response:\n        \"\"\"Confirm the status of a transaction\n\n        Args:\n            reference: The transaction reference used to intiate the transaction\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        reference = str(reference)\n        url = self._parse_url(f\"/transaction/verify/{reference}\")\n        return self._handle_request(HTTPMethod.GET, url)\n\n    def get_transactions(\n        self,\n        customer: Optional[str] = None,\n        start_date: Optional[str] = None,\n        end_date: Optional[str] = None,\n        status: Optional[TransactionStatus] = None,\n        page: Optional[int] = None,\n        amount: Optional[int] = None,\n        pagination: int = 50,\n    ) -&gt; Response:\n        \"\"\"Fetch transactions carried out on your integration.\n\n        Args:\n            customer: Specify an ID for the customer whose transactions you want to retrieve\n            start_date: A timestamp from which to start listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            end_date: A timestamp at which to stop listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            status: Filter transactions by status. any value from the ``TransactionStatus`` enum\n            page: Specify exactly what page you want to retrieve.\n                If not specified, we use a default value of 1.\n            amount: Optional[int]\n                Filter transactions by amount. Specify the amount (in kobo if currency is\n                ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``, and cents, if\n                currency is ``Currency.ZAR``)\n            pagination: Specifies how many records you want to retrieve per page. If not specified, we\n                use a default value of 50.\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/transaction/?perPage={pagination}\")\n        query_params = [\n            (\"page\", page),\n            (\"customer\", customer),\n            (\"status\", status),\n            (\"from\", start_date),\n            (\"to\", end_date),\n            (\"amount\", amount),\n        ]\n        url = append_query_params(query_params, url)\n\n        return self._handle_request(HTTPMethod.GET, url)\n\n    def get_transaction(self, id: str) -&gt; Response:\n        \"\"\"Get details of a transaction carried out on your integration.\n\n        Args:\n            id: An ID for the transaction to fetch\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/transaction/{id}/\")\n        return self._handle_request(HTTPMethod.GET, url)\n\n    def charge(\n        self,\n        amount: int,\n        email: str,\n        auth_code: str,\n        reference: Optional[str] = None,\n        currency: Optional[Currency] = None,\n        metadata: Optional[dict] = None,\n        channels: Optional[list[Channel]] = None,\n        subaccount: Optional[str] = None,\n        transaction_charge: Optional[int] = None,\n        bearer: Optional[Bearer] = None,\n        queue: bool = False,\n    ) -&gt; Response:\n        \"\"\"\n        All authorizations marked as reusable can be charged with this\n        endpoint whenever you need to receive payments.\n\n        Args:\n            amount: amount to charge.\n            email: Customer's email address\n            auth_code: Valid authorization code to charge\n            reference: Unique transaction reference. Only ``-, ., =`` and alphanumeric\n                characters allowed.\n            currency: Currency in which amount should be charged. Any value from the\n                ``Currency`` enum.\n            metadata: Add a custom_fields attribute which has an array of objects if\n                you would like the fields to be added to your transaction when\n                displayed on the dashboard.\n                Sample: ``{\"custom_fields\":[{\"display_name\":\"Cart ID\",\n                \"variable_name\": \"cart_id\",\"value\": \"8393\"}]}``\n            channels: A list of ``Channel`` enum values to control what channels you want to make available\n                to the user to make a payment with\n            subaccount: The code for the subaccount that owns the payment. e.g. ACCT_8f4s1eq7ml6rlzj\n            transaction_charge: A flat fee to charge the subaccount for this transaction (in kobo if currency is NGN,\n                pesewas, if currency is GHS, and cents, if currency is ZAR). This overrides the split\n                percentage set when the subaccount was created. Ideally, you will need to use this if\n                you are splitting in flat rates (since subaccount creation only allows for percentage split).\n                e.g., 7000 for a 70 naira\n            bearer: Who bears Paystack charges? any value from the ``Beaer`` enum\n            queue: If you are making a scheduled charge call, it is a good idea to queue them so the processing\n                system does not get overloaded causing transaction processing errors. Set ``queue=True`` to\n                take advantage of our queued charging.\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        amount = validate_amount(amount)\n\n        if not email:\n            raise InvalidDataException(\"Customer's Email is required to charge\")\n\n        if not auth_code:\n            raise InvalidDataException(\"Customer's Auth code is required to charge\")\n\n        url = self._parse_url(\"/transaction/charge_authorization\")\n        payload = {\n            \"authorization_code\": auth_code,\n            \"email\": email,\n            \"amount\": amount,\n        }\n        optional_params = [\n            (\"reference\", reference),\n            (\"currency\", currency),\n            (\"metadata\", metadata),\n            (\"channels\", channels),\n            (\"subaccount\", subaccount),\n            (\"transaction_charge\", transaction_charge),\n            (\"bearer\", bearer),\n            (\"queue\", queue),\n        ]\n        payload = add_to_payload(optional_params, payload)\n\n        return self._handle_request(HTTPMethod.POST, url, payload)\n\n    def get_timeline(self, id_or_ref: str) -&gt; Response:\n        \"\"\"View the timeline of a transaction\n\n        Args:\n            id_or_ref: The ID or the reference of the transaction\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/transaction/timeline/{id_or_ref}\")\n        return self._handle_request(HTTPMethod.GET, url)\n\n    def totals(\n        self,\n        page: Optional[int] = None,\n        start_date: Optional[str] = None,\n        end_date: Optional[str] = None,\n        pagination: int = 50,\n    ) -&gt; Response:\n        \"\"\"Total amount received on your account\n\n        Args:\n            page: Specifies exactly what page you want to retrieve.\n                If not specified, we use a default value of 1.\n            start_date: A timestamp from which to start listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            end_date: A timestamp at which to stop listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            pagination: Specifies how many records you want to retrieve per page.\n                If not specified, we use a default value of 50.\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/transaction/totals/?perPage={pagination}\")\n        query_params = [\n            (\"page\", page),\n            (\"from\", start_date),\n            (\"to\", end_date),\n        ]\n        url = append_query_params(query_params, url)\n        return self._handle_request(HTTPMethod.GET, url)\n\n    def export(\n        self,\n        page: Optional[int] = None,\n        start_date: Optional[str] = None,\n        end_date: Optional[str] = None,\n        customer: Optional[str] = None,\n        status: Optional[TransactionStatus] = None,\n        currency: Optional[Currency] = None,\n        amount: Optional[int] = None,\n        settled: Optional[bool] = None,\n        settlement: Optional[str] = None,\n        payment_page: Optional[str] = None,\n        pagination: int = 50,\n    ) -&gt; Response:\n        \"\"\"Fetch transactions carried out on your integration.\n\n        Args:\n            page: Specifies exactly what page you want to retrieve.\n                If not specified, we use a default value of 1.\n            start_date: A timestamp from which to start listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            end_date: A timestamp at which to stop listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            customer: Specify an ID for the customer whose transactions you want to retrieve\n            status: Filter transactions by status. Any value from the ``TransactionStatus`` enum\n            currency: Specify the transaction currency to export. Any value from the ``Currency`` enum\n            amount: Filter transactions by amount. Specify the amount, in\n                kobo if currency is ``Currency.NGN``, pesewas, if currency\n                is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR``\n            settled: Set to ``True`` to export only settled transactions. ``False`` for\n                pending transactions. Leave undefined to export all transaction\n            settlement: An ID for the settlement whose transactions we should export\n            payment_page: Optional[int]\n                Specify a payment page's id to export only transactions conducted on said page\n            pagination: int\n                Specifies how many records you want to retrieve per page.\n                If not specified, we use a default value of 50.\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        if amount:\n            amount = validate_amount(amount)\n        url = self._parse_url(f\"/transaction/export/?perPage={pagination}\")\n        query_params = [\n            (\"page\", page),\n            (\"from\", start_date),\n            (\"to\", end_date),\n            (\"customer\", customer),\n            (\"status\", status),\n            (\"currency\", currency),\n            (\"settled\", settled),\n            (\"settlement\", settlement),\n            (\"payment_page\", payment_page),\n        ]\n        url = append_query_params(query_params, url)\n        return self._handle_request(HTTPMethod.GET, url)\n\n    def partial_debit(\n        self,\n        auth_code: str,\n        currency: Currency,\n        amount: int,\n        email: str,\n        reference: Optional[str] = None,\n        at_least: Optional[int] = None,\n    ) -&gt; Response:\n        \"\"\"Retrieve part of a payment from a customer\n\n        Args:\n            auth_code: Authorization Code\n            currency: Specify the currency you want to debit. Any value\n                from the ``Currency`` enum.\n            amount: Amount should be in kobo if currency is ``Currency.NGN``, pesewas,\n                if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR``\n            email: Customer's email address (attached to the authorization code)\n            reference: Unique transaction reference. Only `-, ., =`\n                 and alphanumeric characters allowed.\n            at_least: Minimum amount to charge\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n\n        Raises:\n            InvalidDataError: When Customer's email is not provided. When Customer's auth code is not provided.\n        \"\"\"\n        amount = validate_amount(amount)\n        if at_least:\n            at_least = validate_amount(at_least)\n\n        if not email:\n            raise InvalidDataException(\"Customer's Email is required to charge\")\n\n        if not auth_code:\n            raise InvalidDataException(\"Customer's Auth code is required to charge\")\n\n        url = self._parse_url(\"/transaction/partial_debit\")\n        payload = {\n            \"authorization_code\": auth_code,\n            \"currency\": currency,\n            \"amount\": amount,\n            \"email\": email,\n        }\n        optional_params = [(\"reference\", reference), (\"at_least\", at_least)]\n        payload = add_to_payload(optional_params, payload)\n\n        return self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/transactions/#pypaystack2.api.transactions.Transaction.charge","title":"<code>charge(amount, email, auth_code, reference=None, currency=None, metadata=None, channels=None, subaccount=None, transaction_charge=None, bearer=None, queue=False)</code>","text":"<p>All authorizations marked as reusable can be charged with this endpoint whenever you need to receive payments.</p> <p>Parameters:</p> Name Type Description Default <code>amount</code> <code>int</code> <p>amount to charge.</p> required <code>email</code> <code>str</code> <p>Customer's email address</p> required <code>auth_code</code> <code>str</code> <p>Valid authorization code to charge</p> required <code>reference</code> <code>Optional[str]</code> <p>Unique transaction reference. Only <code>-, ., =</code> and alphanumeric characters allowed.</p> <code>None</code> <code>currency</code> <code>Optional[Currency]</code> <p>Currency in which amount should be charged. Any value from the <code>Currency</code> enum.</p> <code>None</code> <code>metadata</code> <code>Optional[dict]</code> <p>Add a custom_fields attribute which has an array of objects if you would like the fields to be added to your transaction when displayed on the dashboard. Sample: <code>{\"custom_fields\":[{\"display_name\":\"Cart ID\", \"variable_name\": \"cart_id\",\"value\": \"8393\"}]}</code></p> <code>None</code> <code>channels</code> <code>Optional[list[Channel]]</code> <p>A list of <code>Channel</code> enum values to control what channels you want to make available to the user to make a payment with</p> <code>None</code> <code>subaccount</code> <code>Optional[str]</code> <p>The code for the subaccount that owns the payment. e.g. ACCT_8f4s1eq7ml6rlzj</p> <code>None</code> <code>transaction_charge</code> <code>Optional[int]</code> <p>A flat fee to charge the subaccount for this transaction (in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR). This overrides the split percentage set when the subaccount was created. Ideally, you will need to use this if you are splitting in flat rates (since subaccount creation only allows for percentage split). e.g., 7000 for a 70 naira</p> <code>None</code> <code>bearer</code> <code>Optional[Bearer]</code> <p>Who bears Paystack charges? any value from the <code>Beaer</code> enum</p> <code>None</code> <code>queue</code> <code>bool</code> <p>If you are making a scheduled charge call, it is a good idea to queue them so the processing system does not get overloaded causing transaction processing errors. Set <code>queue=True</code> to take advantage of our queued charging.</p> <code>False</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/transactions.py</code> <pre><code>def charge(\n    self,\n    amount: int,\n    email: str,\n    auth_code: str,\n    reference: Optional[str] = None,\n    currency: Optional[Currency] = None,\n    metadata: Optional[dict] = None,\n    channels: Optional[list[Channel]] = None,\n    subaccount: Optional[str] = None,\n    transaction_charge: Optional[int] = None,\n    bearer: Optional[Bearer] = None,\n    queue: bool = False,\n) -&gt; Response:\n    \"\"\"\n    All authorizations marked as reusable can be charged with this\n    endpoint whenever you need to receive payments.\n\n    Args:\n        amount: amount to charge.\n        email: Customer's email address\n        auth_code: Valid authorization code to charge\n        reference: Unique transaction reference. Only ``-, ., =`` and alphanumeric\n            characters allowed.\n        currency: Currency in which amount should be charged. Any value from the\n            ``Currency`` enum.\n        metadata: Add a custom_fields attribute which has an array of objects if\n            you would like the fields to be added to your transaction when\n            displayed on the dashboard.\n            Sample: ``{\"custom_fields\":[{\"display_name\":\"Cart ID\",\n            \"variable_name\": \"cart_id\",\"value\": \"8393\"}]}``\n        channels: A list of ``Channel`` enum values to control what channels you want to make available\n            to the user to make a payment with\n        subaccount: The code for the subaccount that owns the payment. e.g. ACCT_8f4s1eq7ml6rlzj\n        transaction_charge: A flat fee to charge the subaccount for this transaction (in kobo if currency is NGN,\n            pesewas, if currency is GHS, and cents, if currency is ZAR). This overrides the split\n            percentage set when the subaccount was created. Ideally, you will need to use this if\n            you are splitting in flat rates (since subaccount creation only allows for percentage split).\n            e.g., 7000 for a 70 naira\n        bearer: Who bears Paystack charges? any value from the ``Beaer`` enum\n        queue: If you are making a scheduled charge call, it is a good idea to queue them so the processing\n            system does not get overloaded causing transaction processing errors. Set ``queue=True`` to\n            take advantage of our queued charging.\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    amount = validate_amount(amount)\n\n    if not email:\n        raise InvalidDataException(\"Customer's Email is required to charge\")\n\n    if not auth_code:\n        raise InvalidDataException(\"Customer's Auth code is required to charge\")\n\n    url = self._parse_url(\"/transaction/charge_authorization\")\n    payload = {\n        \"authorization_code\": auth_code,\n        \"email\": email,\n        \"amount\": amount,\n    }\n    optional_params = [\n        (\"reference\", reference),\n        (\"currency\", currency),\n        (\"metadata\", metadata),\n        (\"channels\", channels),\n        (\"subaccount\", subaccount),\n        (\"transaction_charge\", transaction_charge),\n        (\"bearer\", bearer),\n        (\"queue\", queue),\n    ]\n    payload = add_to_payload(optional_params, payload)\n\n    return self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/transactions/#pypaystack2.api.transactions.Transaction.export","title":"<code>export(page=None, start_date=None, end_date=None, customer=None, status=None, currency=None, amount=None, settled=None, settlement=None, payment_page=None, pagination=50)</code>","text":"<p>Fetch transactions carried out on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>Optional[int]</code> <p>Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1.</p> <code>None</code> <code>start_date</code> <code>Optional[str]</code> <p>A timestamp from which to start listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>end_date</code> <code>Optional[str]</code> <p>A timestamp at which to stop listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>customer</code> <code>Optional[str]</code> <p>Specify an ID for the customer whose transactions you want to retrieve</p> <code>None</code> <code>status</code> <code>Optional[TransactionStatus]</code> <p>Filter transactions by status. Any value from the <code>TransactionStatus</code> enum</p> <code>None</code> <code>currency</code> <code>Optional[Currency]</code> <p>Specify the transaction currency to export. Any value from the <code>Currency</code> enum</p> <code>None</code> <code>amount</code> <code>Optional[int]</code> <p>Filter transactions by amount. Specify the amount, in kobo if currency is <code>Currency.NGN</code>, pesewas, if currency is <code>Currency.GHS</code>, and cents, if currency is <code>Currency.ZAR</code></p> <code>None</code> <code>settled</code> <code>Optional[bool]</code> <p>Set to <code>True</code> to export only settled transactions. <code>False</code> for pending transactions. Leave undefined to export all transaction</p> <code>None</code> <code>settlement</code> <code>Optional[str]</code> <p>An ID for the settlement whose transactions we should export</p> <code>None</code> <code>payment_page</code> <code>Optional[str]</code> <p>Optional[int] Specify a payment page's id to export only transactions conducted on said page</p> <code>None</code> <code>pagination</code> <code>int</code> <p>int Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50.</p> <code>50</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/transactions.py</code> <pre><code>def export(\n    self,\n    page: Optional[int] = None,\n    start_date: Optional[str] = None,\n    end_date: Optional[str] = None,\n    customer: Optional[str] = None,\n    status: Optional[TransactionStatus] = None,\n    currency: Optional[Currency] = None,\n    amount: Optional[int] = None,\n    settled: Optional[bool] = None,\n    settlement: Optional[str] = None,\n    payment_page: Optional[str] = None,\n    pagination: int = 50,\n) -&gt; Response:\n    \"\"\"Fetch transactions carried out on your integration.\n\n    Args:\n        page: Specifies exactly what page you want to retrieve.\n            If not specified, we use a default value of 1.\n        start_date: A timestamp from which to start listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        end_date: A timestamp at which to stop listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        customer: Specify an ID for the customer whose transactions you want to retrieve\n        status: Filter transactions by status. Any value from the ``TransactionStatus`` enum\n        currency: Specify the transaction currency to export. Any value from the ``Currency`` enum\n        amount: Filter transactions by amount. Specify the amount, in\n            kobo if currency is ``Currency.NGN``, pesewas, if currency\n            is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR``\n        settled: Set to ``True`` to export only settled transactions. ``False`` for\n            pending transactions. Leave undefined to export all transaction\n        settlement: An ID for the settlement whose transactions we should export\n        payment_page: Optional[int]\n            Specify a payment page's id to export only transactions conducted on said page\n        pagination: int\n            Specifies how many records you want to retrieve per page.\n            If not specified, we use a default value of 50.\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    if amount:\n        amount = validate_amount(amount)\n    url = self._parse_url(f\"/transaction/export/?perPage={pagination}\")\n    query_params = [\n        (\"page\", page),\n        (\"from\", start_date),\n        (\"to\", end_date),\n        (\"customer\", customer),\n        (\"status\", status),\n        (\"currency\", currency),\n        (\"settled\", settled),\n        (\"settlement\", settlement),\n        (\"payment_page\", payment_page),\n    ]\n    url = append_query_params(query_params, url)\n    return self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/transactions/#pypaystack2.api.transactions.Transaction.get_timeline","title":"<code>get_timeline(id_or_ref)</code>","text":"<p>View the timeline of a transaction</p> <p>Parameters:</p> Name Type Description Default <code>id_or_ref</code> <code>str</code> <p>The ID or the reference of the transaction</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/transactions.py</code> <pre><code>def get_timeline(self, id_or_ref: str) -&gt; Response:\n    \"\"\"View the timeline of a transaction\n\n    Args:\n        id_or_ref: The ID or the reference of the transaction\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/transaction/timeline/{id_or_ref}\")\n    return self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/transactions/#pypaystack2.api.transactions.Transaction.get_transaction","title":"<code>get_transaction(id)</code>","text":"<p>Get details of a transaction carried out on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>An ID for the transaction to fetch</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/transactions.py</code> <pre><code>def get_transaction(self, id: str) -&gt; Response:\n    \"\"\"Get details of a transaction carried out on your integration.\n\n    Args:\n        id: An ID for the transaction to fetch\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/transaction/{id}/\")\n    return self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/transactions/#pypaystack2.api.transactions.Transaction.get_transactions","title":"<code>get_transactions(customer=None, start_date=None, end_date=None, status=None, page=None, amount=None, pagination=50)</code>","text":"<p>Fetch transactions carried out on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>customer</code> <code>Optional[str]</code> <p>Specify an ID for the customer whose transactions you want to retrieve</p> <code>None</code> <code>start_date</code> <code>Optional[str]</code> <p>A timestamp from which to start listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>end_date</code> <code>Optional[str]</code> <p>A timestamp at which to stop listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>status</code> <code>Optional[TransactionStatus]</code> <p>Filter transactions by status. any value from the <code>TransactionStatus</code> enum</p> <code>None</code> <code>page</code> <code>Optional[int]</code> <p>Specify exactly what page you want to retrieve. If not specified, we use a default value of 1.</p> <code>None</code> <code>amount</code> <code>Optional[int]</code> <p>Optional[int] Filter transactions by amount. Specify the amount (in kobo if currency is <code>Currency.NGN</code>, pesewas, if currency is <code>Currency.GHS</code>, and cents, if currency is <code>Currency.ZAR</code>)</p> <code>None</code> <code>pagination</code> <code>int</code> <p>Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50.</p> <code>50</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/transactions.py</code> <pre><code>def get_transactions(\n    self,\n    customer: Optional[str] = None,\n    start_date: Optional[str] = None,\n    end_date: Optional[str] = None,\n    status: Optional[TransactionStatus] = None,\n    page: Optional[int] = None,\n    amount: Optional[int] = None,\n    pagination: int = 50,\n) -&gt; Response:\n    \"\"\"Fetch transactions carried out on your integration.\n\n    Args:\n        customer: Specify an ID for the customer whose transactions you want to retrieve\n        start_date: A timestamp from which to start listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        end_date: A timestamp at which to stop listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        status: Filter transactions by status. any value from the ``TransactionStatus`` enum\n        page: Specify exactly what page you want to retrieve.\n            If not specified, we use a default value of 1.\n        amount: Optional[int]\n            Filter transactions by amount. Specify the amount (in kobo if currency is\n            ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``, and cents, if\n            currency is ``Currency.ZAR``)\n        pagination: Specifies how many records you want to retrieve per page. If not specified, we\n            use a default value of 50.\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/transaction/?perPage={pagination}\")\n    query_params = [\n        (\"page\", page),\n        (\"customer\", customer),\n        (\"status\", status),\n        (\"from\", start_date),\n        (\"to\", end_date),\n        (\"amount\", amount),\n    ]\n    url = append_query_params(query_params, url)\n\n    return self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/transactions/#pypaystack2.api.transactions.Transaction.initialize","title":"<code>initialize(amount, email, currency=None, reference=None, callback_url=None, plan=None, invoice_limit=None, metadata=None, channels=None, split_code=None, subaccount=None, transfer_charge=None, bearer=None)</code>","text":"<p>Initialize a transaction from your backend</p> <p>Parameters:</p> Name Type Description Default <code>amount</code> <code>int</code> <p>Amount should be in kobo if currency is <code>Currency.NGN</code>, pesewas, if currency is <code>Currency.GHS</code>, and cents, if currency is <code>Currency.ZAR</code></p> required <code>email</code> <code>str</code> <p>Customer's email address</p> required <code>currency</code> <code>Optional[Currency]</code> <p>Any value from the <code>Currency</code> enum.</p> <code>None</code> <code>reference</code> <code>Optional[str]</code> <p>Unique transaction reference. Only <code>-, ., =</code> and alphanumeric characters allowed.</p> <code>None</code> <code>callback_url</code> <code>Optional[str]</code> <p>Fully qualified url, e.g. <code>https://example.com/</code> . Use this to override the callback url provided on the dashboard for this transaction</p> <code>None</code> <code>plan</code> <code>Optional[str]</code> <p>If transaction is to create a subscription to a predefined plan, provide plan code here. This would invalidate the value provided in <code>amount</code></p> <code>None</code> <code>invoice_limit</code> <code>Optional[int]</code> <p>Number of times to charge customer during subscription to plan</p> <code>None</code> <code>metadata</code> <code>Optional[dict]</code> <p>A dictionary of additional info. check out this link for more information. https://paystack.com/docs/payments/metadata</p> <code>None</code> <code>channels</code> <code>Optional[list[Channel]]</code> <p>A list of <code>Channel</code> enum values to control what channels you want to make available to the user to make a payment with</p> <code>None</code> <code>split_code</code> <code>Optional[str]</code> <p>The split code of the transaction split. e.g. SPL_98WF13Eb3w</p> <code>None</code> <code>subaccount</code> <code>Optional[str]</code> <p>The code for the subaccount that owns the payment. e.g. ACCT_8f4s1eq7ml6rlzj</p> <code>None</code> <code>transfer_charge</code> <code>Optional[int]</code> <p>An amount used to override the split configuration for a single split payment. If set, the amount specified goes to the main account regardless of the split configuration.</p> <code>None</code> <code>bearer</code> <code>Optional[Bearer]</code> <p>Any value from the <code>Bearer</code> enum. Who bears Paystack charges?</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> <p>Raises:</p> Type Description <code>InvalidDataError</code> <p>When email is not provided.</p> Source code in <code>src/pypaystack2/api/transactions.py</code> <pre><code>def initialize(\n    self,\n    amount: int,\n    email: str,\n    currency: Optional[Currency] = None,\n    reference: Optional[str] = None,\n    callback_url: Optional[str] = None,\n    plan: Optional[str] = None,\n    invoice_limit: Optional[int] = None,\n    metadata: Optional[dict] = None,\n    channels: Optional[list[Channel]] = None,\n    split_code: Optional[str] = None,\n    subaccount: Optional[str] = None,\n    transfer_charge: Optional[int] = None,\n    bearer: Optional[Bearer] = None,\n) -&gt; Response:\n    \"\"\"Initialize a transaction from your backend\n\n    Args:\n        amount: Amount should be in kobo if currency is ``Currency.NGN``, pesewas,\n            if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR``\n        email: Customer's email address\n        currency: Any value from the ``Currency`` enum.\n        reference: Unique transaction reference. Only ``-, ., =`` and alphanumeric characters allowed.\n        callback_url: Fully qualified url, e.g. ``https://example.com/`` . Use this to override the callback url\n            provided on the dashboard for this transaction\n        plan: If transaction is to create a subscription to a predefined plan, provide plan code here.\n            This would invalidate the value provided in ``amount``\n        invoice_limit: Number of times to charge customer during subscription to plan\n        metadata: A dictionary of additional info. check out this link\n            for more information. https://paystack.com/docs/payments/metadata\n        channels: A list of ``Channel`` enum values to control what channels you want to make available\n            to the user to make a payment with\n        split_code: The split code of the transaction split. e.g. SPL_98WF13Eb3w\n        subaccount: The code for the subaccount that owns the payment. e.g. ACCT_8f4s1eq7ml6rlzj\n        transfer_charge: An amount used to override the split configuration for a single split payment. If set,\n            the amount specified goes to the main account regardless of the split configuration.\n        bearer: Any value from the ``Bearer`` enum. Who bears Paystack charges?\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n\n    Raises:\n        InvalidDataError: When email is not provided.\n    \"\"\"\n    amount = validate_amount(amount)\n\n    if not email:\n        raise InvalidDataException(\n            \"Customer's Email is required for initialization\"\n        )\n\n    url = self._parse_url(\"/transaction/initialize\")\n    payload = {\n        \"email\": email,\n        \"amount\": amount,\n    }\n\n    optional_params = [\n        (\"currency\", currency),\n        (\"reference\", reference),\n        (\"callback_url\", callback_url),\n        (\"plan\", plan),\n        (\"invoice_limit\", invoice_limit),\n        (\"metadata\", metadata),\n        (\"channels\", channels),\n        (\"split_code\", split_code),\n        (\"subaccount\", subaccount),\n        (\"transfer_charge\", transfer_charge),\n        (\"bearer\", bearer),\n    ]\n    payload = add_to_payload(optional_params, payload)\n\n    return self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/transactions/#pypaystack2.api.transactions.Transaction.partial_debit","title":"<code>partial_debit(auth_code, currency, amount, email, reference=None, at_least=None)</code>","text":"<p>Retrieve part of a payment from a customer</p> <p>Parameters:</p> Name Type Description Default <code>auth_code</code> <code>str</code> <p>Authorization Code</p> required <code>currency</code> <code>Currency</code> <p>Specify the currency you want to debit. Any value from the <code>Currency</code> enum.</p> required <code>amount</code> <code>int</code> <p>Amount should be in kobo if currency is <code>Currency.NGN</code>, pesewas, if currency is <code>Currency.GHS</code>, and cents, if currency is <code>Currency.ZAR</code></p> required <code>email</code> <code>str</code> <p>Customer's email address (attached to the authorization code)</p> required <code>reference</code> <code>Optional[str]</code> <p>Unique transaction reference. Only <code>-, ., =</code>  and alphanumeric characters allowed.</p> <code>None</code> <code>at_least</code> <code>Optional[int]</code> <p>Minimum amount to charge</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> <p>Raises:</p> Type Description <code>InvalidDataError</code> <p>When Customer's email is not provided. When Customer's auth code is not provided.</p> Source code in <code>src/pypaystack2/api/transactions.py</code> <pre><code>def partial_debit(\n    self,\n    auth_code: str,\n    currency: Currency,\n    amount: int,\n    email: str,\n    reference: Optional[str] = None,\n    at_least: Optional[int] = None,\n) -&gt; Response:\n    \"\"\"Retrieve part of a payment from a customer\n\n    Args:\n        auth_code: Authorization Code\n        currency: Specify the currency you want to debit. Any value\n            from the ``Currency`` enum.\n        amount: Amount should be in kobo if currency is ``Currency.NGN``, pesewas,\n            if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR``\n        email: Customer's email address (attached to the authorization code)\n        reference: Unique transaction reference. Only `-, ., =`\n             and alphanumeric characters allowed.\n        at_least: Minimum amount to charge\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n\n    Raises:\n        InvalidDataError: When Customer's email is not provided. When Customer's auth code is not provided.\n    \"\"\"\n    amount = validate_amount(amount)\n    if at_least:\n        at_least = validate_amount(at_least)\n\n    if not email:\n        raise InvalidDataException(\"Customer's Email is required to charge\")\n\n    if not auth_code:\n        raise InvalidDataException(\"Customer's Auth code is required to charge\")\n\n    url = self._parse_url(\"/transaction/partial_debit\")\n    payload = {\n        \"authorization_code\": auth_code,\n        \"currency\": currency,\n        \"amount\": amount,\n        \"email\": email,\n    }\n    optional_params = [(\"reference\", reference), (\"at_least\", at_least)]\n    payload = add_to_payload(optional_params, payload)\n\n    return self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/transactions/#pypaystack2.api.transactions.Transaction.totals","title":"<code>totals(page=None, start_date=None, end_date=None, pagination=50)</code>","text":"<p>Total amount received on your account</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>Optional[int]</code> <p>Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1.</p> <code>None</code> <code>start_date</code> <code>Optional[str]</code> <p>A timestamp from which to start listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>end_date</code> <code>Optional[str]</code> <p>A timestamp at which to stop listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>pagination</code> <code>int</code> <p>Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50.</p> <code>50</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/transactions.py</code> <pre><code>def totals(\n    self,\n    page: Optional[int] = None,\n    start_date: Optional[str] = None,\n    end_date: Optional[str] = None,\n    pagination: int = 50,\n) -&gt; Response:\n    \"\"\"Total amount received on your account\n\n    Args:\n        page: Specifies exactly what page you want to retrieve.\n            If not specified, we use a default value of 1.\n        start_date: A timestamp from which to start listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        end_date: A timestamp at which to stop listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        pagination: Specifies how many records you want to retrieve per page.\n            If not specified, we use a default value of 50.\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/transaction/totals/?perPage={pagination}\")\n    query_params = [\n        (\"page\", page),\n        (\"from\", start_date),\n        (\"to\", end_date),\n    ]\n    url = append_query_params(query_params, url)\n    return self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/transactions/#pypaystack2.api.transactions.Transaction.verify","title":"<code>verify(reference)</code>","text":"<p>Confirm the status of a transaction</p> <p>Parameters:</p> Name Type Description Default <code>reference</code> <code>str</code> <p>The transaction reference used to intiate the transaction</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/transactions.py</code> <pre><code>def verify(self, reference: str) -&gt; Response:\n    \"\"\"Confirm the status of a transaction\n\n    Args:\n        reference: The transaction reference used to intiate the transaction\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    reference = str(reference)\n    url = self._parse_url(f\"/transaction/verify/{reference}\")\n    return self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/transfer_recipients/","title":"Transfer recipients","text":""},{"location":"reference/transfer_recipients/#pypaystack2.api.transfer_recipients.AsyncTransferRecipient","title":"<code>AsyncTransferRecipient</code>","text":"<p>               Bases: <code>BaseAsyncAPI</code></p> <p>Provides a wrapper for paystack Transfer Receipts API</p> <p>The Transfer Recipients API allows you to create and manage beneficiaries that you send money to. https://paystack.com/docs/api/transfer-recipient/</p> Note <p>Feature Availability     This feature is only available to businesses in Nigeria and Ghana.</p> Source code in <code>src/pypaystack2/api/transfer_recipients.py</code> <pre><code>class AsyncTransferRecipient(BaseAsyncAPI):\n    \"\"\"Provides a wrapper for paystack Transfer Receipts API\n\n    The Transfer Recipients API allows you to create and manage beneficiaries that you send money to.\n    https://paystack.com/docs/api/transfer-recipient/\n\n    Note:\n        Feature Availability\n            This feature is only available to businesses in Nigeria and Ghana.\n    \"\"\"\n\n    async def create(\n        self,\n        type: TransferRecipient,\n        name: str,\n        account_number: str,\n        bank_code: Optional[str] = None,\n        description: Optional[str] = None,\n        currency: Optional[Currency] = None,\n        auth_code: Optional[str] = None,\n        metadata: Optional[dict] = None,\n    ) -&gt; Response:\n        \"\"\"\n        Creates a new recipient. A duplicate account number will lead to the\n        retrieval of the existing record.\n\n        Args:\n            type: Recipient Type. any value from the ``TRType`` enum\n            name: A name for the recipient\n            account_number: Required if ``type`` is ``TRType.NUBAN`` or ``TRType.BASA``\n            bank_code: Required if ``type`` is ``TRType.NUBAN`` or ``TRType.BASA``.\n                You can get the list of Bank Codes by calling the ``.get_banks``\n                method from the Miscellaneous API wrapper.\n            description: description\n            currency: currency\n            auth_code: auth code\n            metadata: metadata\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n        # FIXME: type is a keyword arg, might replace\n        # if it raises issues.\n        if type == RecipientType.NUBAN or type == RecipientType.BASA:\n            if bank_code is None:\n                raise InvalidDataException(\n                    \"`bank_code` is required if type is `TRType.NUBAN` or `TRType.BASA`\"\n                )\n\n        url = self._parse_url(\"/transferrecipient\")\n\n        payload = {\n            \"type\": type,\n            \"name\": name,\n            \"account_number\": account_number,\n        }\n        optional_params = [\n            (\"bank_code\", bank_code),\n            (\"description\", description),\n            (\"currency\", currency),\n            (\"authorization_code\", auth_code),\n            (\"metadata\", metadata),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return await self._handle_request(HTTPMethod.POST, url, payload)\n\n    async def bulk_create(self, batch: list[Recipient]) -&gt; Response:\n        # TODO: create a pydantic model\n        # for batch using the fields below.\n        # type: RecipientType,\n        # name: str,\n        # account_number: str,\n        # bank_code: Optional[str] = None,\n        # description: Optional[str] = None,\n        # currency: Optional[utils.Currency] = None,\n        # auth_code: Optional[str] = None,\n        # metadata: Optional[Mapping] = None,\n        \"\"\"\n        Create multiple transfer recipients in batches. A duplicate account\n        number will lead to the retrieval of the existing record.\n\n        Ars:\n            batch: A list of dictionaries of transfer recipients. Each dictionary should contain\n                ``type``, ``name``, and ``bank_code``. Any Create Transfer Recipient param\n                can also be passed.\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n        # FIXME: type is a keyword arg, might replace\n        # if it raises issues.\n\n        batch = [item.dict for item in batch]\n\n        url = self._parse_url(\"/transferrecipient/bulk\")\n\n        payload = {\n            \"batch\": batch,\n        }\n        return await self._handle_request(HTTPMethod.POST, url, payload)\n\n    async def get_transfer_recipients(\n        self,\n        page: int = 1,\n        pagination: int = 50,\n        start_date: Optional[str] = None,\n        end_date: Optional[str] = None,\n    ) -&gt; Response:\n        \"\"\"Fetch transfer recipients available on your integration\n\n        Args:\n            page: Specifies exactly what page you want to retrieve.\n                If not specified, we use a default value of 1.\n            pagination: Specifies how many records you want to retrieve per page.\n                If not specified, we use a default value of 50.\n            start_date: A timestamp from which to start listing transfer recipients\n                e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            end_date: A timestamp at which to stop listing transfer recipients e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._parse_url(f\"/transferrecipient?perPage={pagination}\")\n        query_params = [\n            (\"page\", page),\n            (\"from\", start_date),\n            (\"to\", end_date),\n        ]\n        url = append_query_params(query_params, url)\n        return await self._handle_request(HTTPMethod.GET, url)\n\n    async def get_transfer_recipient(self, id_or_code: str) -&gt; Response:\n        \"\"\"Fetch the details of a transfer recipient\n\n        Args:\n            id_or_code: An ID or code for the recipient whose details you want to receive.\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._parse_url(f\"/transferrecipient/{id_or_code}\")\n        return await self._handle_request(HTTPMethod.GET, url)\n\n    async def update(\n        self, id_or_code: str, name: str, email: Optional[str] = None\n    ) -&gt; Response:\n        \"\"\"\n        Update an existing recipient. An duplicate account number will lead\n        to the retrieval of the existing record.\n\n        Args:\n            id_or_code: Transfer Recipient's ID or code\n            name: A name for the recipient\n            email: Email address of the recipient\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/transferrecipient/{id_or_code}\")\n        payload = {\"name\": name}\n        optional_params = [(\"email\", email)]\n        payload = add_to_payload(optional_params, payload)\n        return await self._handle_request(HTTPMethod.PUT, url, payload)\n\n    async def delete(self, id_or_code: str) -&gt; Response:\n        \"\"\"Deletes a transfer recipient (sets the transfer recipient to inactive)\n\n        Args:\n            id_or_code: An ID or code for the recipient who you want to delete.\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/transferrecipient/{id_or_code}\")\n        return await self._handle_request(HTTPMethod.DELETE, url)\n</code></pre>"},{"location":"reference/transfer_recipients/#pypaystack2.api.transfer_recipients.AsyncTransferRecipient.bulk_create","title":"<code>bulk_create(batch)</code>  <code>async</code>","text":"<p>Create multiple transfer recipients in batches. A duplicate account number will lead to the retrieval of the existing record.</p> Ars <p>batch: A list of dictionaries of transfer recipients. Each dictionary should contain     <code>type</code>, <code>name</code>, and <code>bank_code</code>. Any Create Transfer Recipient param     can also be passed.</p> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/transfer_recipients.py</code> <pre><code>async def bulk_create(self, batch: list[Recipient]) -&gt; Response:\n    # TODO: create a pydantic model\n    # for batch using the fields below.\n    # type: RecipientType,\n    # name: str,\n    # account_number: str,\n    # bank_code: Optional[str] = None,\n    # description: Optional[str] = None,\n    # currency: Optional[utils.Currency] = None,\n    # auth_code: Optional[str] = None,\n    # metadata: Optional[Mapping] = None,\n    \"\"\"\n    Create multiple transfer recipients in batches. A duplicate account\n    number will lead to the retrieval of the existing record.\n\n    Ars:\n        batch: A list of dictionaries of transfer recipients. Each dictionary should contain\n            ``type``, ``name``, and ``bank_code``. Any Create Transfer Recipient param\n            can also be passed.\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n    # FIXME: type is a keyword arg, might replace\n    # if it raises issues.\n\n    batch = [item.dict for item in batch]\n\n    url = self._parse_url(\"/transferrecipient/bulk\")\n\n    payload = {\n        \"batch\": batch,\n    }\n    return await self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/transfer_recipients/#pypaystack2.api.transfer_recipients.AsyncTransferRecipient.create","title":"<code>create(type, name, account_number, bank_code=None, description=None, currency=None, auth_code=None, metadata=None)</code>  <code>async</code>","text":"<p>Creates a new recipient. A duplicate account number will lead to the retrieval of the existing record.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>TransferRecipient</code> <p>Recipient Type. any value from the <code>TRType</code> enum</p> required <code>name</code> <code>str</code> <p>A name for the recipient</p> required <code>account_number</code> <code>str</code> <p>Required if <code>type</code> is <code>TRType.NUBAN</code> or <code>TRType.BASA</code></p> required <code>bank_code</code> <code>Optional[str]</code> <p>Required if <code>type</code> is <code>TRType.NUBAN</code> or <code>TRType.BASA</code>. You can get the list of Bank Codes by calling the <code>.get_banks</code> method from the Miscellaneous API wrapper.</p> <code>None</code> <code>description</code> <code>Optional[str]</code> <p>description</p> <code>None</code> <code>currency</code> <code>Optional[Currency]</code> <p>currency</p> <code>None</code> <code>auth_code</code> <code>Optional[str]</code> <p>auth code</p> <code>None</code> <code>metadata</code> <code>Optional[dict]</code> <p>metadata</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/transfer_recipients.py</code> <pre><code>async def create(\n    self,\n    type: TransferRecipient,\n    name: str,\n    account_number: str,\n    bank_code: Optional[str] = None,\n    description: Optional[str] = None,\n    currency: Optional[Currency] = None,\n    auth_code: Optional[str] = None,\n    metadata: Optional[dict] = None,\n) -&gt; Response:\n    \"\"\"\n    Creates a new recipient. A duplicate account number will lead to the\n    retrieval of the existing record.\n\n    Args:\n        type: Recipient Type. any value from the ``TRType`` enum\n        name: A name for the recipient\n        account_number: Required if ``type`` is ``TRType.NUBAN`` or ``TRType.BASA``\n        bank_code: Required if ``type`` is ``TRType.NUBAN`` or ``TRType.BASA``.\n            You can get the list of Bank Codes by calling the ``.get_banks``\n            method from the Miscellaneous API wrapper.\n        description: description\n        currency: currency\n        auth_code: auth code\n        metadata: metadata\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n    # FIXME: type is a keyword arg, might replace\n    # if it raises issues.\n    if type == RecipientType.NUBAN or type == RecipientType.BASA:\n        if bank_code is None:\n            raise InvalidDataException(\n                \"`bank_code` is required if type is `TRType.NUBAN` or `TRType.BASA`\"\n            )\n\n    url = self._parse_url(\"/transferrecipient\")\n\n    payload = {\n        \"type\": type,\n        \"name\": name,\n        \"account_number\": account_number,\n    }\n    optional_params = [\n        (\"bank_code\", bank_code),\n        (\"description\", description),\n        (\"currency\", currency),\n        (\"authorization_code\", auth_code),\n        (\"metadata\", metadata),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return await self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/transfer_recipients/#pypaystack2.api.transfer_recipients.AsyncTransferRecipient.delete","title":"<code>delete(id_or_code)</code>  <code>async</code>","text":"<p>Deletes a transfer recipient (sets the transfer recipient to inactive)</p> <p>Parameters:</p> Name Type Description Default <code>id_or_code</code> <code>str</code> <p>An ID or code for the recipient who you want to delete.</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/transfer_recipients.py</code> <pre><code>async def delete(self, id_or_code: str) -&gt; Response:\n    \"\"\"Deletes a transfer recipient (sets the transfer recipient to inactive)\n\n    Args:\n        id_or_code: An ID or code for the recipient who you want to delete.\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/transferrecipient/{id_or_code}\")\n    return await self._handle_request(HTTPMethod.DELETE, url)\n</code></pre>"},{"location":"reference/transfer_recipients/#pypaystack2.api.transfer_recipients.AsyncTransferRecipient.get_transfer_recipient","title":"<code>get_transfer_recipient(id_or_code)</code>  <code>async</code>","text":"<p>Fetch the details of a transfer recipient</p> <p>Parameters:</p> Name Type Description Default <code>id_or_code</code> <code>str</code> <p>An ID or code for the recipient whose details you want to receive.</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/transfer_recipients.py</code> <pre><code>async def get_transfer_recipient(self, id_or_code: str) -&gt; Response:\n    \"\"\"Fetch the details of a transfer recipient\n\n    Args:\n        id_or_code: An ID or code for the recipient whose details you want to receive.\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._parse_url(f\"/transferrecipient/{id_or_code}\")\n    return await self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/transfer_recipients/#pypaystack2.api.transfer_recipients.AsyncTransferRecipient.get_transfer_recipients","title":"<code>get_transfer_recipients(page=1, pagination=50, start_date=None, end_date=None)</code>  <code>async</code>","text":"<p>Fetch transfer recipients available on your integration</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>int</code> <p>Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1.</p> <code>1</code> <code>pagination</code> <code>int</code> <p>Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50.</p> <code>50</code> <code>start_date</code> <code>Optional[str]</code> <p>A timestamp from which to start listing transfer recipients e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>end_date</code> <code>Optional[str]</code> <p>A timestamp at which to stop listing transfer recipients e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/transfer_recipients.py</code> <pre><code>async def get_transfer_recipients(\n    self,\n    page: int = 1,\n    pagination: int = 50,\n    start_date: Optional[str] = None,\n    end_date: Optional[str] = None,\n) -&gt; Response:\n    \"\"\"Fetch transfer recipients available on your integration\n\n    Args:\n        page: Specifies exactly what page you want to retrieve.\n            If not specified, we use a default value of 1.\n        pagination: Specifies how many records you want to retrieve per page.\n            If not specified, we use a default value of 50.\n        start_date: A timestamp from which to start listing transfer recipients\n            e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        end_date: A timestamp at which to stop listing transfer recipients e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._parse_url(f\"/transferrecipient?perPage={pagination}\")\n    query_params = [\n        (\"page\", page),\n        (\"from\", start_date),\n        (\"to\", end_date),\n    ]\n    url = append_query_params(query_params, url)\n    return await self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/transfer_recipients/#pypaystack2.api.transfer_recipients.AsyncTransferRecipient.update","title":"<code>update(id_or_code, name, email=None)</code>  <code>async</code>","text":"<p>Update an existing recipient. An duplicate account number will lead to the retrieval of the existing record.</p> <p>Parameters:</p> Name Type Description Default <code>id_or_code</code> <code>str</code> <p>Transfer Recipient's ID or code</p> required <code>name</code> <code>str</code> <p>A name for the recipient</p> required <code>email</code> <code>Optional[str]</code> <p>Email address of the recipient</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/transfer_recipients.py</code> <pre><code>async def update(\n    self, id_or_code: str, name: str, email: Optional[str] = None\n) -&gt; Response:\n    \"\"\"\n    Update an existing recipient. An duplicate account number will lead\n    to the retrieval of the existing record.\n\n    Args:\n        id_or_code: Transfer Recipient's ID or code\n        name: A name for the recipient\n        email: Email address of the recipient\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/transferrecipient/{id_or_code}\")\n    payload = {\"name\": name}\n    optional_params = [(\"email\", email)]\n    payload = add_to_payload(optional_params, payload)\n    return await self._handle_request(HTTPMethod.PUT, url, payload)\n</code></pre>"},{"location":"reference/transfer_recipients/#pypaystack2.api.transfer_recipients.TransferRecipient","title":"<code>TransferRecipient</code>","text":"<p>               Bases: <code>BaseAPI</code></p> <p>Provides a wrapper for paystack Transfer Receipts API</p> <p>The Transfer Recipients API allows you to create and manage beneficiaries that you send money to. https://paystack.com/docs/api/transfer-recipient/</p> Note <p>Feature Availability     This feature is only available to businesses in Nigeria and Ghana.</p> Source code in <code>src/pypaystack2/api/transfer_recipients.py</code> <pre><code>class TransferRecipient(BaseAPI):\n    \"\"\"Provides a wrapper for paystack Transfer Receipts API\n\n    The Transfer Recipients API allows you to create and manage beneficiaries that you send money to.\n    https://paystack.com/docs/api/transfer-recipient/\n\n    Note:\n        Feature Availability\n            This feature is only available to businesses in Nigeria and Ghana.\n    \"\"\"\n\n    def create(\n        self,\n        type: RecipientType,\n        name: str,\n        account_number: str,\n        bank_code: Optional[str] = None,\n        description: Optional[str] = None,\n        currency: Optional[Currency] = None,\n        auth_code: Optional[str] = None,\n        metadata: Optional[dict] = None,\n    ) -&gt; Response:\n        \"\"\"\n        Creates a new recipient. A duplicate account number will lead to the\n        retrieval of the existing record.\n\n        Args:\n            type: Recipient Type. any value from the ``TRType`` enum\n            name: A name for the recipient\n            account_number: Required if ``type`` is ``TRType.NUBAN`` or ``TRType.BASA``\n            bank_code: Required if ``type`` is ``TRType.NUBAN`` or ``TRType.BASA``.\n                You can get the list of Bank Codes by calling the ``.get_banks``\n                method from the Miscellaneous API wrapper.\n            description: description\n            currency: currency\n            auth_code: auth code\n            metadata: metadata\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n        # FIXME: type is a keyword arg, might replace\n        # if it raises issues.\n        if type == RecipientType.NUBAN or type == RecipientType.BASA:\n            if bank_code is None:\n                raise InvalidDataException(\n                    \"`bank_code` is required if type is `TRType.NUBAN` or `TRType.BASA`\"\n                )\n\n        url = self._parse_url(\"/transferrecipient\")\n\n        payload = {\n            \"type\": type,\n            \"name\": name,\n            \"account_number\": account_number,\n        }\n        optional_params = [\n            (\"bank_code\", bank_code),\n            (\"description\", description),\n            (\"currency\", currency),\n            (\"authorization_code\", auth_code),\n            (\"metadata\", metadata),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return self._handle_request(HTTPMethod.POST, url, payload)\n\n    def bulk_create(self, batch: list[Recipient]) -&gt; Response:\n        # TODO: create a pydantic model\n        # for batch using the fields below.\n        # type: RecipientType,\n        # name: str,\n        # account_number: str,\n        # bank_code: Optional[str] = None,\n        # description: Optional[str] = None,\n        # currency: Optional[utils.Currency] = None,\n        # auth_code: Optional[str] = None,\n        # metadata: Optional[Mapping] = None,\n        \"\"\"\n        Create multiple transfer recipients in batches. A duplicate account\n        number will lead to the retrieval of the existing record.\n\n        Ars:\n            batch: A list of dictionaries of transfer recipients. Each dictionary should contain\n                ``type``, ``name``, and ``bank_code``. Any Create Transfer Recipient param\n                can also be passed.\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n        batch = [item.dict for item in batch]\n\n        url = self._parse_url(\"/transferrecipient/bulk\")\n\n        payload = {\n            \"batch\": batch,\n        }\n        return self._handle_request(HTTPMethod.POST, url, payload)\n\n    def get_transfer_recipients(\n        self,\n        page: int = 1,\n        pagination: int = 50,\n        start_date: Optional[str] = None,\n        end_date: Optional[str] = None,\n    ) -&gt; Response:\n        \"\"\"Fetch transfer recipients available on your integration\n\n        Args:\n            page: Specifies exactly what page you want to retrieve.\n                If not specified, we use a default value of 1.\n            pagination: Specifies how many records you want to retrieve per page.\n                If not specified, we use a default value of 50.\n            start_date: A timestamp from which to start listing transfer recipients\n                e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            end_date: A timestamp at which to stop listing transfer recipients e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._parse_url(f\"/transferrecipient?perPage={pagination}\")\n        query_params = [\n            (\"page\", page),\n            (\"from\", start_date),\n            (\"to\", end_date),\n        ]\n        url = append_query_params(query_params, url)\n        return self._handle_request(HTTPMethod.GET, url)\n\n    def get_transfer_recipient(self, id_or_code: str) -&gt; Response:\n        \"\"\"Fetch the details of a transfer recipient\n\n        Args:\n            id_or_code: An ID or code for the recipient whose details you want to receive.\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._parse_url(f\"/transferrecipient/{id_or_code}\")\n        return self._handle_request(HTTPMethod.GET, url)\n\n    def update(\n        self, id_or_code: str, name: str, email: Optional[str] = None\n    ) -&gt; Response:\n        \"\"\"\n        Update an existing recipient. An duplicate account number will lead\n        to the retrieval of the existing record.\n\n        Args:\n            id_or_code: Transfer Recipient's ID or code\n            name: A name for the recipient\n            email: Email address of the recipient\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/transferrecipient/{id_or_code}\")\n        payload = {\"name\": name}\n        optional_params = [(\"email\", email)]\n        payload = add_to_payload(optional_params, payload)\n        return self._handle_request(HTTPMethod.PUT, url, payload)\n\n    def delete(self, id_or_code: str) -&gt; Response:\n        \"\"\"Deletes a transfer recipient (sets the transfer recipient to inactive)\n\n        Args:\n            id_or_code: An ID or code for the recipient who you want to delete.\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/transferrecipient/{id_or_code}\")\n        return self._handle_request(HTTPMethod.DELETE, url)\n</code></pre>"},{"location":"reference/transfer_recipients/#pypaystack2.api.transfer_recipients.TransferRecipient.bulk_create","title":"<code>bulk_create(batch)</code>","text":"<p>Create multiple transfer recipients in batches. A duplicate account number will lead to the retrieval of the existing record.</p> Ars <p>batch: A list of dictionaries of transfer recipients. Each dictionary should contain     <code>type</code>, <code>name</code>, and <code>bank_code</code>. Any Create Transfer Recipient param     can also be passed.</p> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/transfer_recipients.py</code> <pre><code>def bulk_create(self, batch: list[Recipient]) -&gt; Response:\n    # TODO: create a pydantic model\n    # for batch using the fields below.\n    # type: RecipientType,\n    # name: str,\n    # account_number: str,\n    # bank_code: Optional[str] = None,\n    # description: Optional[str] = None,\n    # currency: Optional[utils.Currency] = None,\n    # auth_code: Optional[str] = None,\n    # metadata: Optional[Mapping] = None,\n    \"\"\"\n    Create multiple transfer recipients in batches. A duplicate account\n    number will lead to the retrieval of the existing record.\n\n    Ars:\n        batch: A list of dictionaries of transfer recipients. Each dictionary should contain\n            ``type``, ``name``, and ``bank_code``. Any Create Transfer Recipient param\n            can also be passed.\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n    batch = [item.dict for item in batch]\n\n    url = self._parse_url(\"/transferrecipient/bulk\")\n\n    payload = {\n        \"batch\": batch,\n    }\n    return self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/transfer_recipients/#pypaystack2.api.transfer_recipients.TransferRecipient.create","title":"<code>create(type, name, account_number, bank_code=None, description=None, currency=None, auth_code=None, metadata=None)</code>","text":"<p>Creates a new recipient. A duplicate account number will lead to the retrieval of the existing record.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>RecipientType</code> <p>Recipient Type. any value from the <code>TRType</code> enum</p> required <code>name</code> <code>str</code> <p>A name for the recipient</p> required <code>account_number</code> <code>str</code> <p>Required if <code>type</code> is <code>TRType.NUBAN</code> or <code>TRType.BASA</code></p> required <code>bank_code</code> <code>Optional[str]</code> <p>Required if <code>type</code> is <code>TRType.NUBAN</code> or <code>TRType.BASA</code>. You can get the list of Bank Codes by calling the <code>.get_banks</code> method from the Miscellaneous API wrapper.</p> <code>None</code> <code>description</code> <code>Optional[str]</code> <p>description</p> <code>None</code> <code>currency</code> <code>Optional[Currency]</code> <p>currency</p> <code>None</code> <code>auth_code</code> <code>Optional[str]</code> <p>auth code</p> <code>None</code> <code>metadata</code> <code>Optional[dict]</code> <p>metadata</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/transfer_recipients.py</code> <pre><code>def create(\n    self,\n    type: RecipientType,\n    name: str,\n    account_number: str,\n    bank_code: Optional[str] = None,\n    description: Optional[str] = None,\n    currency: Optional[Currency] = None,\n    auth_code: Optional[str] = None,\n    metadata: Optional[dict] = None,\n) -&gt; Response:\n    \"\"\"\n    Creates a new recipient. A duplicate account number will lead to the\n    retrieval of the existing record.\n\n    Args:\n        type: Recipient Type. any value from the ``TRType`` enum\n        name: A name for the recipient\n        account_number: Required if ``type`` is ``TRType.NUBAN`` or ``TRType.BASA``\n        bank_code: Required if ``type`` is ``TRType.NUBAN`` or ``TRType.BASA``.\n            You can get the list of Bank Codes by calling the ``.get_banks``\n            method from the Miscellaneous API wrapper.\n        description: description\n        currency: currency\n        auth_code: auth code\n        metadata: metadata\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n    # FIXME: type is a keyword arg, might replace\n    # if it raises issues.\n    if type == RecipientType.NUBAN or type == RecipientType.BASA:\n        if bank_code is None:\n            raise InvalidDataException(\n                \"`bank_code` is required if type is `TRType.NUBAN` or `TRType.BASA`\"\n            )\n\n    url = self._parse_url(\"/transferrecipient\")\n\n    payload = {\n        \"type\": type,\n        \"name\": name,\n        \"account_number\": account_number,\n    }\n    optional_params = [\n        (\"bank_code\", bank_code),\n        (\"description\", description),\n        (\"currency\", currency),\n        (\"authorization_code\", auth_code),\n        (\"metadata\", metadata),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/transfer_recipients/#pypaystack2.api.transfer_recipients.TransferRecipient.delete","title":"<code>delete(id_or_code)</code>","text":"<p>Deletes a transfer recipient (sets the transfer recipient to inactive)</p> <p>Parameters:</p> Name Type Description Default <code>id_or_code</code> <code>str</code> <p>An ID or code for the recipient who you want to delete.</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/transfer_recipients.py</code> <pre><code>def delete(self, id_or_code: str) -&gt; Response:\n    \"\"\"Deletes a transfer recipient (sets the transfer recipient to inactive)\n\n    Args:\n        id_or_code: An ID or code for the recipient who you want to delete.\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/transferrecipient/{id_or_code}\")\n    return self._handle_request(HTTPMethod.DELETE, url)\n</code></pre>"},{"location":"reference/transfer_recipients/#pypaystack2.api.transfer_recipients.TransferRecipient.get_transfer_recipient","title":"<code>get_transfer_recipient(id_or_code)</code>","text":"<p>Fetch the details of a transfer recipient</p> <p>Parameters:</p> Name Type Description Default <code>id_or_code</code> <code>str</code> <p>An ID or code for the recipient whose details you want to receive.</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/transfer_recipients.py</code> <pre><code>def get_transfer_recipient(self, id_or_code: str) -&gt; Response:\n    \"\"\"Fetch the details of a transfer recipient\n\n    Args:\n        id_or_code: An ID or code for the recipient whose details you want to receive.\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._parse_url(f\"/transferrecipient/{id_or_code}\")\n    return self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/transfer_recipients/#pypaystack2.api.transfer_recipients.TransferRecipient.get_transfer_recipients","title":"<code>get_transfer_recipients(page=1, pagination=50, start_date=None, end_date=None)</code>","text":"<p>Fetch transfer recipients available on your integration</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>int</code> <p>Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1.</p> <code>1</code> <code>pagination</code> <code>int</code> <p>Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50.</p> <code>50</code> <code>start_date</code> <code>Optional[str]</code> <p>A timestamp from which to start listing transfer recipients e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>end_date</code> <code>Optional[str]</code> <p>A timestamp at which to stop listing transfer recipients e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/transfer_recipients.py</code> <pre><code>def get_transfer_recipients(\n    self,\n    page: int = 1,\n    pagination: int = 50,\n    start_date: Optional[str] = None,\n    end_date: Optional[str] = None,\n) -&gt; Response:\n    \"\"\"Fetch transfer recipients available on your integration\n\n    Args:\n        page: Specifies exactly what page you want to retrieve.\n            If not specified, we use a default value of 1.\n        pagination: Specifies how many records you want to retrieve per page.\n            If not specified, we use a default value of 50.\n        start_date: A timestamp from which to start listing transfer recipients\n            e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        end_date: A timestamp at which to stop listing transfer recipients e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._parse_url(f\"/transferrecipient?perPage={pagination}\")\n    query_params = [\n        (\"page\", page),\n        (\"from\", start_date),\n        (\"to\", end_date),\n    ]\n    url = append_query_params(query_params, url)\n    return self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/transfer_recipients/#pypaystack2.api.transfer_recipients.TransferRecipient.update","title":"<code>update(id_or_code, name, email=None)</code>","text":"<p>Update an existing recipient. An duplicate account number will lead to the retrieval of the existing record.</p> <p>Parameters:</p> Name Type Description Default <code>id_or_code</code> <code>str</code> <p>Transfer Recipient's ID or code</p> required <code>name</code> <code>str</code> <p>A name for the recipient</p> required <code>email</code> <code>Optional[str]</code> <p>Email address of the recipient</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/transfer_recipients.py</code> <pre><code>def update(\n    self, id_or_code: str, name: str, email: Optional[str] = None\n) -&gt; Response:\n    \"\"\"\n    Update an existing recipient. An duplicate account number will lead\n    to the retrieval of the existing record.\n\n    Args:\n        id_or_code: Transfer Recipient's ID or code\n        name: A name for the recipient\n        email: Email address of the recipient\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/transferrecipient/{id_or_code}\")\n    payload = {\"name\": name}\n    optional_params = [(\"email\", email)]\n    payload = add_to_payload(optional_params, payload)\n    return self._handle_request(HTTPMethod.PUT, url, payload)\n</code></pre>"},{"location":"reference/transfers/","title":"Transfers","text":""},{"location":"reference/transfers/#pypaystack2.api.transfers.AsyncTransfer","title":"<code>AsyncTransfer</code>","text":"<p>               Bases: <code>BaseAsyncAPI</code></p> <p>Provides a wrapper for paystack Transfers API</p> <p>The Transfers API allows you to automate sending money on your integration https://paystack.com/docs/api/transfer/</p>"},{"location":"reference/transfers/#pypaystack2.api.transfers.AsyncTransfer--note","title":"Note","text":"<p>This feature is only available to businesses in Nigeria and Ghana.</p> Source code in <code>src/pypaystack2/api/transfers.py</code> <pre><code>class AsyncTransfer(BaseAsyncAPI):\n    \"\"\"Provides a wrapper for paystack Transfers API\n\n    The Transfers API allows you to automate sending money on your integration\n    https://paystack.com/docs/api/transfer/\n\n    Note\n    ----\n    This feature is only available to businesses in Nigeria and Ghana.\n    \"\"\"\n\n    async def initiate(\n        self,\n        amount: int,\n        recipient: str,\n        reason: Optional[str] = None,\n        currency: Optional[Currency] = None,\n        reference: Optional[str] = None,\n        source: str = \"balance\",\n    ) -&gt; Response:\n        \"\"\"Initiate transfer\n\n        Args:\n            amount: amount to transfer\n            recipient: the beneficiary of the transfer\n            reason: narration of the transfer\n            currency: transfer currency\n            reference: reference id\n            source: transfer source\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n        amount = validate_amount(amount)\n\n        url = self._parse_url(\"/transfer\")\n\n        payload = {\n            \"amount\": amount,\n            \"recipient\": recipient,\n            \"source\": source,\n        }\n        optional_params = [\n            (\"reason\", reason),\n            (\"reference\", reference),\n            (\"currency\", currency),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return await self._handle_request(HTTPMethod.POST, url, payload)\n\n    async def finalize(\n        self,\n        transfer_code: str,\n        otp: str,\n    ) -&gt; Response:\n        \"\"\"Finalize transfer\n\n        Args:\n            transfer_code: The code for transfer.\n            otp: One time password.\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(\"/transfer/finalize_transfer\")\n\n        payload = {\n            \"transfer_code\": transfer_code,\n            \"otp\": otp,\n        }\n        return await self._handle_request(HTTPMethod.POST, url, payload)\n\n    async def bulk_transfer(\n        self, transfers: list[TransferInstruction], source: str = \"balance\"\n    ) -&gt; Response:\n        \"\"\"Transfer in bulk\n\n        Args:\n            transfers: list of transfer instructions\n            source: source of the funds to transfer\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(\"/transfer/bulk\")\n\n        payload = {\n            \"transfers\": [tx.dict for tx in transfers],\n            \"source\": source,\n        }\n        return await self._handle_request(HTTPMethod.POST, url, payload)\n\n    async def get_transfers(\n        self,\n        page: int = 1,\n        pagination: int = 50,\n        customer: Optional[str] = None,\n        start_date: Optional[str] = None,\n        end_date: Optional[str] = None,\n    ) -&gt; Response:\n        \"\"\"Retrieve transfers made to a customer\n\n        Args:\n            customer: customer id\n            page: Specifies exactly what page you want to retrieve.\n                If not specified, we use a default value of 1.\n            pagination: Specifies how many records you want to retrieve per page.\n                If not specified, we use a default value of 50.\n            start_date: A timestamp from which to start listing refund e.g. 2016-09-21\n            end_date: A timestamp at which to stop listing refund e.g. 2016-09-21\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._parse_url(f\"/transfer?perPage={pagination}\")\n        query_params = [\n            (\"customer\", customer),\n            (\"page\", page),\n            (\"from\", start_date),\n            (\"to\", end_date),\n        ]\n        url = append_query_params(query_params, url)\n        return await self._handle_request(HTTPMethod.GET, url)\n\n    async def get_transfer(\n        self,\n        id_or_code: str,\n    ) -&gt; Response:\n        \"\"\"Retrieve a transfer\n\n        Args:\n            id_or_code: transfer ID or code\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._parse_url(f\"/transfer/{id_or_code}\")\n        return await self._handle_request(HTTPMethod.GET, url)\n\n    async def verify(\n        self,\n        reference: str,\n    ) -&gt; Response:\n        \"\"\"Verify a transfer\n\n        Args:\n            reference: str\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._parse_url(f\"/transfer/verify/{reference}\")\n        return await self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/transfers/#pypaystack2.api.transfers.AsyncTransfer.bulk_transfer","title":"<code>bulk_transfer(transfers, source='balance')</code>  <code>async</code>","text":"<p>Transfer in bulk</p> <p>Parameters:</p> Name Type Description Default <code>transfers</code> <code>list[TransferInstruction]</code> <p>list of transfer instructions</p> required <code>source</code> <code>str</code> <p>source of the funds to transfer</p> <code>'balance'</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/transfers.py</code> <pre><code>async def bulk_transfer(\n    self, transfers: list[TransferInstruction], source: str = \"balance\"\n) -&gt; Response:\n    \"\"\"Transfer in bulk\n\n    Args:\n        transfers: list of transfer instructions\n        source: source of the funds to transfer\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(\"/transfer/bulk\")\n\n    payload = {\n        \"transfers\": [tx.dict for tx in transfers],\n        \"source\": source,\n    }\n    return await self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/transfers/#pypaystack2.api.transfers.AsyncTransfer.finalize","title":"<code>finalize(transfer_code, otp)</code>  <code>async</code>","text":"<p>Finalize transfer</p> <p>Parameters:</p> Name Type Description Default <code>transfer_code</code> <code>str</code> <p>The code for transfer.</p> required <code>otp</code> <code>str</code> <p>One time password.</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/transfers.py</code> <pre><code>async def finalize(\n    self,\n    transfer_code: str,\n    otp: str,\n) -&gt; Response:\n    \"\"\"Finalize transfer\n\n    Args:\n        transfer_code: The code for transfer.\n        otp: One time password.\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(\"/transfer/finalize_transfer\")\n\n    payload = {\n        \"transfer_code\": transfer_code,\n        \"otp\": otp,\n    }\n    return await self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/transfers/#pypaystack2.api.transfers.AsyncTransfer.get_transfer","title":"<code>get_transfer(id_or_code)</code>  <code>async</code>","text":"<p>Retrieve a transfer</p> <p>Parameters:</p> Name Type Description Default <code>id_or_code</code> <code>str</code> <p>transfer ID or code</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/transfers.py</code> <pre><code>async def get_transfer(\n    self,\n    id_or_code: str,\n) -&gt; Response:\n    \"\"\"Retrieve a transfer\n\n    Args:\n        id_or_code: transfer ID or code\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._parse_url(f\"/transfer/{id_or_code}\")\n    return await self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/transfers/#pypaystack2.api.transfers.AsyncTransfer.get_transfers","title":"<code>get_transfers(page=1, pagination=50, customer=None, start_date=None, end_date=None)</code>  <code>async</code>","text":"<p>Retrieve transfers made to a customer</p> <p>Parameters:</p> Name Type Description Default <code>customer</code> <code>Optional[str]</code> <p>customer id</p> <code>None</code> <code>page</code> <code>int</code> <p>Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1.</p> <code>1</code> <code>pagination</code> <code>int</code> <p>Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50.</p> <code>50</code> <code>start_date</code> <code>Optional[str]</code> <p>A timestamp from which to start listing refund e.g. 2016-09-21</p> <code>None</code> <code>end_date</code> <code>Optional[str]</code> <p>A timestamp at which to stop listing refund e.g. 2016-09-21</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/transfers.py</code> <pre><code>async def get_transfers(\n    self,\n    page: int = 1,\n    pagination: int = 50,\n    customer: Optional[str] = None,\n    start_date: Optional[str] = None,\n    end_date: Optional[str] = None,\n) -&gt; Response:\n    \"\"\"Retrieve transfers made to a customer\n\n    Args:\n        customer: customer id\n        page: Specifies exactly what page you want to retrieve.\n            If not specified, we use a default value of 1.\n        pagination: Specifies how many records you want to retrieve per page.\n            If not specified, we use a default value of 50.\n        start_date: A timestamp from which to start listing refund e.g. 2016-09-21\n        end_date: A timestamp at which to stop listing refund e.g. 2016-09-21\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._parse_url(f\"/transfer?perPage={pagination}\")\n    query_params = [\n        (\"customer\", customer),\n        (\"page\", page),\n        (\"from\", start_date),\n        (\"to\", end_date),\n    ]\n    url = append_query_params(query_params, url)\n    return await self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/transfers/#pypaystack2.api.transfers.AsyncTransfer.initiate","title":"<code>initiate(amount, recipient, reason=None, currency=None, reference=None, source='balance')</code>  <code>async</code>","text":"<p>Initiate transfer</p> <p>Parameters:</p> Name Type Description Default <code>amount</code> <code>int</code> <p>amount to transfer</p> required <code>recipient</code> <code>str</code> <p>the beneficiary of the transfer</p> required <code>reason</code> <code>Optional[str]</code> <p>narration of the transfer</p> <code>None</code> <code>currency</code> <code>Optional[Currency]</code> <p>transfer currency</p> <code>None</code> <code>reference</code> <code>Optional[str]</code> <p>reference id</p> <code>None</code> <code>source</code> <code>str</code> <p>transfer source</p> <code>'balance'</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/transfers.py</code> <pre><code>async def initiate(\n    self,\n    amount: int,\n    recipient: str,\n    reason: Optional[str] = None,\n    currency: Optional[Currency] = None,\n    reference: Optional[str] = None,\n    source: str = \"balance\",\n) -&gt; Response:\n    \"\"\"Initiate transfer\n\n    Args:\n        amount: amount to transfer\n        recipient: the beneficiary of the transfer\n        reason: narration of the transfer\n        currency: transfer currency\n        reference: reference id\n        source: transfer source\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n    amount = validate_amount(amount)\n\n    url = self._parse_url(\"/transfer\")\n\n    payload = {\n        \"amount\": amount,\n        \"recipient\": recipient,\n        \"source\": source,\n    }\n    optional_params = [\n        (\"reason\", reason),\n        (\"reference\", reference),\n        (\"currency\", currency),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return await self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/transfers/#pypaystack2.api.transfers.AsyncTransfer.verify","title":"<code>verify(reference)</code>  <code>async</code>","text":"<p>Verify a transfer</p> <p>Parameters:</p> Name Type Description Default <code>reference</code> <code>str</code> <p>str</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/transfers.py</code> <pre><code>async def verify(\n    self,\n    reference: str,\n) -&gt; Response:\n    \"\"\"Verify a transfer\n\n    Args:\n        reference: str\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._parse_url(f\"/transfer/verify/{reference}\")\n    return await self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/transfers/#pypaystack2.api.transfers.Transfer","title":"<code>Transfer</code>","text":"<p>               Bases: <code>BaseAPI</code></p> <p>Provides a wrapper for paystack Transfers API</p> <p>The Transfers API allows you to automate sending money on your integration https://paystack.com/docs/api/transfer/</p>"},{"location":"reference/transfers/#pypaystack2.api.transfers.Transfer--note","title":"Note","text":"<p>This feature is only available to businesses in Nigeria and Ghana.</p> Source code in <code>src/pypaystack2/api/transfers.py</code> <pre><code>class Transfer(BaseAPI):\n    \"\"\"Provides a wrapper for paystack Transfers API\n\n    The Transfers API allows you to automate sending money on your integration\n    https://paystack.com/docs/api/transfer/\n\n    Note\n    ----\n    This feature is only available to businesses in Nigeria and Ghana.\n    \"\"\"\n\n    def initiate(\n        self,\n        amount: int,\n        recipient: str,\n        reason: Optional[str] = None,\n        currency: Optional[Currency] = None,\n        reference: Optional[str] = None,\n        source: str = \"balance\",\n    ) -&gt; Response:\n        \"\"\"Initiate transfer\n\n        Args:\n            amount: amount to transfer\n            recipient: the beneficiary of the transfer\n            reason: narration of the transfer\n            currency: transfer currency\n            reference: reference id\n            source: transfer source\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n        amount = validate_amount(amount)\n\n        url = self._parse_url(\"/transfer\")\n\n        payload = {\n            \"amount\": amount,\n            \"recipient\": recipient,\n            \"source\": source,\n        }\n        optional_params = [\n            (\"reason\", reason),\n            (\"reference\", reference),\n            (\"currency\", currency),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return self._handle_request(HTTPMethod.POST, url, payload)\n\n    def finalize(\n        self,\n        transfer_code: str,\n        otp: str,\n    ) -&gt; Response:\n        \"\"\"Finalize transfer\n\n        Args:\n            transfer_code: The code for transfer.\n            otp: One time password.\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(\"/transfer/finalize_transfer\")\n\n        payload = {\n            \"transfer_code\": transfer_code,\n            \"otp\": otp,\n        }\n        return self._handle_request(HTTPMethod.POST, url, payload)\n\n    def bulk_transfer(\n        self, transfers: list[TransferInstruction], source: str = \"balance\"\n    ) -&gt; Response:\n        \"\"\"Transfer in bulk\n\n        Args:\n            transfers: list of transfer instructions\n            source: source of the funds to transfer\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(\"/transfer/bulk\")\n\n        payload = {\n            \"transfers\": [tx.dict for tx in transfers],\n            \"source\": source,\n        }\n        return self._handle_request(HTTPMethod.POST, url, payload)\n\n    def get_transfers(\n        self,\n        page: int = 1,\n        pagination: int = 50,\n        customer: Optional[str] = None,\n        start_date: Optional[str] = None,\n        end_date: Optional[str] = None,\n    ) -&gt; Response:\n        \"\"\"Retrieve transfers made to a customer\n\n        Args:\n            customer: customer id\n            page: Specifies exactly what page you want to retrieve.\n                If not specified, we use a default value of 1.\n            pagination: Specifies how many records you want to retrieve per page.\n                If not specified, we use a default value of 50.\n            start_date: A timestamp from which to start listing refund e.g. 2016-09-21\n            end_date: A timestamp at which to stop listing refund e.g. 2016-09-21\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._parse_url(f\"/transfer?perPage={pagination}\")\n        query_params = [\n            (\"customer\", customer),\n            (\"page\", page),\n            (\"from\", start_date),\n            (\"to\", end_date),\n        ]\n        url = append_query_params(query_params, url)\n        return self._handle_request(HTTPMethod.GET, url)\n\n    def get_transfer(\n        self,\n        id_or_code: str,\n    ) -&gt; Response:\n        \"\"\"Retrieve a transfer\n\n        Args:\n            id_or_code: transfer ID or code\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._parse_url(f\"/transfer/{id_or_code}\")\n        return self._handle_request(HTTPMethod.GET, url)\n\n    def verify(\n        self,\n        reference: str,\n    ) -&gt; Response:\n        \"\"\"Verify a transfer\n\n        Args:\n            reference: str\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._parse_url(f\"/transfer/verify/{reference}\")\n        return self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/transfers/#pypaystack2.api.transfers.Transfer.bulk_transfer","title":"<code>bulk_transfer(transfers, source='balance')</code>","text":"<p>Transfer in bulk</p> <p>Parameters:</p> Name Type Description Default <code>transfers</code> <code>list[TransferInstruction]</code> <p>list of transfer instructions</p> required <code>source</code> <code>str</code> <p>source of the funds to transfer</p> <code>'balance'</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/transfers.py</code> <pre><code>def bulk_transfer(\n    self, transfers: list[TransferInstruction], source: str = \"balance\"\n) -&gt; Response:\n    \"\"\"Transfer in bulk\n\n    Args:\n        transfers: list of transfer instructions\n        source: source of the funds to transfer\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(\"/transfer/bulk\")\n\n    payload = {\n        \"transfers\": [tx.dict for tx in transfers],\n        \"source\": source,\n    }\n    return self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/transfers/#pypaystack2.api.transfers.Transfer.finalize","title":"<code>finalize(transfer_code, otp)</code>","text":"<p>Finalize transfer</p> <p>Parameters:</p> Name Type Description Default <code>transfer_code</code> <code>str</code> <p>The code for transfer.</p> required <code>otp</code> <code>str</code> <p>One time password.</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/transfers.py</code> <pre><code>def finalize(\n    self,\n    transfer_code: str,\n    otp: str,\n) -&gt; Response:\n    \"\"\"Finalize transfer\n\n    Args:\n        transfer_code: The code for transfer.\n        otp: One time password.\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(\"/transfer/finalize_transfer\")\n\n    payload = {\n        \"transfer_code\": transfer_code,\n        \"otp\": otp,\n    }\n    return self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/transfers/#pypaystack2.api.transfers.Transfer.get_transfer","title":"<code>get_transfer(id_or_code)</code>","text":"<p>Retrieve a transfer</p> <p>Parameters:</p> Name Type Description Default <code>id_or_code</code> <code>str</code> <p>transfer ID or code</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/transfers.py</code> <pre><code>def get_transfer(\n    self,\n    id_or_code: str,\n) -&gt; Response:\n    \"\"\"Retrieve a transfer\n\n    Args:\n        id_or_code: transfer ID or code\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._parse_url(f\"/transfer/{id_or_code}\")\n    return self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/transfers/#pypaystack2.api.transfers.Transfer.get_transfers","title":"<code>get_transfers(page=1, pagination=50, customer=None, start_date=None, end_date=None)</code>","text":"<p>Retrieve transfers made to a customer</p> <p>Parameters:</p> Name Type Description Default <code>customer</code> <code>Optional[str]</code> <p>customer id</p> <code>None</code> <code>page</code> <code>int</code> <p>Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1.</p> <code>1</code> <code>pagination</code> <code>int</code> <p>Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50.</p> <code>50</code> <code>start_date</code> <code>Optional[str]</code> <p>A timestamp from which to start listing refund e.g. 2016-09-21</p> <code>None</code> <code>end_date</code> <code>Optional[str]</code> <p>A timestamp at which to stop listing refund e.g. 2016-09-21</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/transfers.py</code> <pre><code>def get_transfers(\n    self,\n    page: int = 1,\n    pagination: int = 50,\n    customer: Optional[str] = None,\n    start_date: Optional[str] = None,\n    end_date: Optional[str] = None,\n) -&gt; Response:\n    \"\"\"Retrieve transfers made to a customer\n\n    Args:\n        customer: customer id\n        page: Specifies exactly what page you want to retrieve.\n            If not specified, we use a default value of 1.\n        pagination: Specifies how many records you want to retrieve per page.\n            If not specified, we use a default value of 50.\n        start_date: A timestamp from which to start listing refund e.g. 2016-09-21\n        end_date: A timestamp at which to stop listing refund e.g. 2016-09-21\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._parse_url(f\"/transfer?perPage={pagination}\")\n    query_params = [\n        (\"customer\", customer),\n        (\"page\", page),\n        (\"from\", start_date),\n        (\"to\", end_date),\n    ]\n    url = append_query_params(query_params, url)\n    return self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/transfers/#pypaystack2.api.transfers.Transfer.initiate","title":"<code>initiate(amount, recipient, reason=None, currency=None, reference=None, source='balance')</code>","text":"<p>Initiate transfer</p> <p>Parameters:</p> Name Type Description Default <code>amount</code> <code>int</code> <p>amount to transfer</p> required <code>recipient</code> <code>str</code> <p>the beneficiary of the transfer</p> required <code>reason</code> <code>Optional[str]</code> <p>narration of the transfer</p> <code>None</code> <code>currency</code> <code>Optional[Currency]</code> <p>transfer currency</p> <code>None</code> <code>reference</code> <code>Optional[str]</code> <p>reference id</p> <code>None</code> <code>source</code> <code>str</code> <p>transfer source</p> <code>'balance'</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/transfers.py</code> <pre><code>def initiate(\n    self,\n    amount: int,\n    recipient: str,\n    reason: Optional[str] = None,\n    currency: Optional[Currency] = None,\n    reference: Optional[str] = None,\n    source: str = \"balance\",\n) -&gt; Response:\n    \"\"\"Initiate transfer\n\n    Args:\n        amount: amount to transfer\n        recipient: the beneficiary of the transfer\n        reason: narration of the transfer\n        currency: transfer currency\n        reference: reference id\n        source: transfer source\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n    amount = validate_amount(amount)\n\n    url = self._parse_url(\"/transfer\")\n\n    payload = {\n        \"amount\": amount,\n        \"recipient\": recipient,\n        \"source\": source,\n    }\n    optional_params = [\n        (\"reason\", reason),\n        (\"reference\", reference),\n        (\"currency\", currency),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/transfers/#pypaystack2.api.transfers.Transfer.verify","title":"<code>verify(reference)</code>","text":"<p>Verify a transfer</p> <p>Parameters:</p> Name Type Description Default <code>reference</code> <code>str</code> <p>str</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/transfers.py</code> <pre><code>def verify(\n    self,\n    reference: str,\n) -&gt; Response:\n    \"\"\"Verify a transfer\n\n    Args:\n        reference: str\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._parse_url(f\"/transfer/verify/{reference}\")\n    return self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/transfers_control/","title":"Transfers control","text":""},{"location":"reference/transfers_control/#pypaystack2.api.transfers_control.AsyncTransferControl","title":"<code>AsyncTransferControl</code>","text":"<p>               Bases: <code>BaseAsyncAPI</code></p> <p>Provides a wrapper for paystack Transfers Control API</p> <p>The Transfer Control API allows you to manage settings of your transfers. https://paystack.com/docs/api/transfer-control/</p> Source code in <code>src/pypaystack2/api/transfers_control.py</code> <pre><code>class AsyncTransferControl(BaseAsyncAPI):\n    \"\"\"Provides a wrapper for paystack Transfers Control API\n\n    The Transfer Control API allows you to manage settings of your transfers.\n    https://paystack.com/docs/api/transfer-control/\n    \"\"\"\n\n    async def check_balance(self) -&gt; Response:\n        \"\"\"Fetch the available balance on your integration\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._parse_url(\"/balance\")\n        return await self._handle_request(HTTPMethod.GET, url)\n\n    async def get_balance_ledger(self) -&gt; Response:\n        \"\"\"Fetch all pay-ins and pay-outs that occured on your integration\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._parse_url(\"balance/ledger\")\n        return await self._handle_request(HTTPMethod.GET, url)\n\n    async def resend_otp(self, transfer_code: str, reason: Reason) -&gt; Response:\n        \"\"\"\n        Generates a new OTP and sends to customer in the event they are having trouble receiving one.\n\n        Note:\n            Feature Availability\n                This feature is only available to businesses in Nigeria and Ghana.\n\n        Args:\n            transfer_code: Transfer code\n            reason: Any value from the ``Reason`` enum\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n        payload = {\"transfer_code\": transfer_code, \"reason\": reason}\n        url = self._parse_url(\"/transfer/resend_otp\")\n        return await self._handle_request(HTTPMethod.POST, url, payload)\n\n    async def disable_otp(self) -&gt; Response:\n        \"\"\"\n        This is used in the event that you want to be able to complete transfers\n        programmatically without use of OTPs. No arguments required. You will get\n        an OTP to complete the request\n\n        Note:\n            Feature Availability\n                This feature is only available to businesses in Nigeria and Ghana.\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._parse_url(\"/transfer/disable_otp\")\n        return await self._handle_request(HTTPMethod.POST, url)\n\n    async def finalize_disable_otp(self, otp: str) -&gt; Response:\n        \"\"\"Finalize the request to disable OTP on your transfers.\n\n        Note:\n            Feature Availability\n                This feature is only available to businesses in Nigeria and Ghana.\n\n        Args:\n            otp: One time password\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n        payload = {\"otp\": otp}\n        url = self._parse_url(\"/transfer/disable_otp_finalize\")\n        return await self._handle_request(HTTPMethod.POST, url, payload)\n\n    async def enable_otp(self) -&gt; Response:\n        \"\"\"\n        In the event that a customer wants to stop being able to complete transfers\n        programmatically, this endpoint helps turn OTP requirement back on. No\n        arguments required.\n\n        Note:\n            Feature Availability\n                This feature is only available to businesses in Nigeria and Ghana.\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._parse_url(\"/transfer/enable_otp\")\n        return await self._handle_request(HTTPMethod.POST, url)\n</code></pre>"},{"location":"reference/transfers_control/#pypaystack2.api.transfers_control.AsyncTransferControl.check_balance","title":"<code>check_balance()</code>  <code>async</code>","text":"<p>Fetch the available balance on your integration</p> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/transfers_control.py</code> <pre><code>async def check_balance(self) -&gt; Response:\n    \"\"\"Fetch the available balance on your integration\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._parse_url(\"/balance\")\n    return await self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/transfers_control/#pypaystack2.api.transfers_control.AsyncTransferControl.disable_otp","title":"<code>disable_otp()</code>  <code>async</code>","text":"<p>This is used in the event that you want to be able to complete transfers programmatically without use of OTPs. No arguments required. You will get an OTP to complete the request</p> Note <p>Feature Availability     This feature is only available to businesses in Nigeria and Ghana.</p> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/transfers_control.py</code> <pre><code>async def disable_otp(self) -&gt; Response:\n    \"\"\"\n    This is used in the event that you want to be able to complete transfers\n    programmatically without use of OTPs. No arguments required. You will get\n    an OTP to complete the request\n\n    Note:\n        Feature Availability\n            This feature is only available to businesses in Nigeria and Ghana.\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._parse_url(\"/transfer/disable_otp\")\n    return await self._handle_request(HTTPMethod.POST, url)\n</code></pre>"},{"location":"reference/transfers_control/#pypaystack2.api.transfers_control.AsyncTransferControl.enable_otp","title":"<code>enable_otp()</code>  <code>async</code>","text":"<p>In the event that a customer wants to stop being able to complete transfers programmatically, this endpoint helps turn OTP requirement back on. No arguments required.</p> Note <p>Feature Availability     This feature is only available to businesses in Nigeria and Ghana.</p> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/transfers_control.py</code> <pre><code>async def enable_otp(self) -&gt; Response:\n    \"\"\"\n    In the event that a customer wants to stop being able to complete transfers\n    programmatically, this endpoint helps turn OTP requirement back on. No\n    arguments required.\n\n    Note:\n        Feature Availability\n            This feature is only available to businesses in Nigeria and Ghana.\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._parse_url(\"/transfer/enable_otp\")\n    return await self._handle_request(HTTPMethod.POST, url)\n</code></pre>"},{"location":"reference/transfers_control/#pypaystack2.api.transfers_control.AsyncTransferControl.finalize_disable_otp","title":"<code>finalize_disable_otp(otp)</code>  <code>async</code>","text":"<p>Finalize the request to disable OTP on your transfers.</p> Note <p>Feature Availability     This feature is only available to businesses in Nigeria and Ghana.</p> <p>Parameters:</p> Name Type Description Default <code>otp</code> <code>str</code> <p>One time password</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/transfers_control.py</code> <pre><code>async def finalize_disable_otp(self, otp: str) -&gt; Response:\n    \"\"\"Finalize the request to disable OTP on your transfers.\n\n    Note:\n        Feature Availability\n            This feature is only available to businesses in Nigeria and Ghana.\n\n    Args:\n        otp: One time password\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n    payload = {\"otp\": otp}\n    url = self._parse_url(\"/transfer/disable_otp_finalize\")\n    return await self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/transfers_control/#pypaystack2.api.transfers_control.AsyncTransferControl.get_balance_ledger","title":"<code>get_balance_ledger()</code>  <code>async</code>","text":"<p>Fetch all pay-ins and pay-outs that occured on your integration</p> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/transfers_control.py</code> <pre><code>async def get_balance_ledger(self) -&gt; Response:\n    \"\"\"Fetch all pay-ins and pay-outs that occured on your integration\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._parse_url(\"balance/ledger\")\n    return await self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/transfers_control/#pypaystack2.api.transfers_control.AsyncTransferControl.resend_otp","title":"<code>resend_otp(transfer_code, reason)</code>  <code>async</code>","text":"<p>Generates a new OTP and sends to customer in the event they are having trouble receiving one.</p> Note <p>Feature Availability     This feature is only available to businesses in Nigeria and Ghana.</p> <p>Parameters:</p> Name Type Description Default <code>transfer_code</code> <code>str</code> <p>Transfer code</p> required <code>reason</code> <code>Reason</code> <p>Any value from the <code>Reason</code> enum</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/transfers_control.py</code> <pre><code>async def resend_otp(self, transfer_code: str, reason: Reason) -&gt; Response:\n    \"\"\"\n    Generates a new OTP and sends to customer in the event they are having trouble receiving one.\n\n    Note:\n        Feature Availability\n            This feature is only available to businesses in Nigeria and Ghana.\n\n    Args:\n        transfer_code: Transfer code\n        reason: Any value from the ``Reason`` enum\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n    payload = {\"transfer_code\": transfer_code, \"reason\": reason}\n    url = self._parse_url(\"/transfer/resend_otp\")\n    return await self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/transfers_control/#pypaystack2.api.transfers_control.TransferControl","title":"<code>TransferControl</code>","text":"<p>               Bases: <code>BaseAPI</code></p> <p>Provides a wrapper for paystack Transfers Control API</p> <p>The Transfer Control API allows you to manage settings of your transfers. https://paystack.com/docs/api/transfer-control/</p> Source code in <code>src/pypaystack2/api/transfers_control.py</code> <pre><code>class TransferControl(BaseAPI):\n    \"\"\"Provides a wrapper for paystack Transfers Control API\n\n    The Transfer Control API allows you to manage settings of your transfers.\n    https://paystack.com/docs/api/transfer-control/\n    \"\"\"\n\n    def check_balance(self) -&gt; Response:\n        \"\"\"Fetch the available balance on your integration\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._parse_url(\"/balance\")\n        return self._handle_request(HTTPMethod.GET, url)\n\n    def get_balance_ledger(self) -&gt; Response:\n        \"\"\"Fetch all pay-ins and pay-outs that occured on your integration\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._parse_url(\"/balance/ledger\")\n        print(url)\n        return self._handle_request(HTTPMethod.GET, url)\n\n    def resend_otp(self, transfer_code: str, reason: Reason) -&gt; Response:\n        \"\"\"\n        Generates a new OTP and sends to customer in the event they are having trouble receiving one.\n\n        Note:\n            Feature Availability\n                This feature is only available to businesses in Nigeria and Ghana.\n\n        Args:\n            transfer_code: Transfer code\n            reason: Any value from the ``Reason`` enum\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n        payload = {\"transfer_code\": transfer_code, \"reason\": reason}\n        url = self._parse_url(\"/transfer/resend_otp\")\n        return self._handle_request(HTTPMethod.POST, url, payload)\n\n    def disable_otp(self) -&gt; Response:\n        \"\"\"\n        This is used in the event that you want to be able to complete transfers\n        programmatically without use of OTPs. No arguments required. You will get\n        an OTP to complete the request\n\n        Note:\n            Feature Availability\n                This feature is only available to businesses in Nigeria and Ghana.\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._parse_url(\"/transfer/disable_otp\")\n        return self._handle_request(HTTPMethod.POST, url)\n\n    def finalize_disable_otp(self, otp: str) -&gt; Response:\n        \"\"\"Finalize the request to disable OTP on your transfers.\n\n        Note:\n            Feature Availability\n                This feature is only available to businesses in Nigeria and Ghana.\n\n        Args:\n            otp: One time password\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n        payload = {\"otp\": otp}\n        url = self._parse_url(\"/transfer/disable_otp_finalize\")\n        return self._handle_request(HTTPMethod.POST, url, payload)\n\n    def enable_otp(self) -&gt; Response:\n        \"\"\"\n        In the event that a customer wants to stop being able to complete transfers\n        programmatically, this endpoint helps turn OTP requirement back on. No\n        arguments required.\n\n        Note:\n            Feature Availability\n                This feature is only available to businesses in Nigeria and Ghana.\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._parse_url(\"/transfer/enable_otp\")\n        return self._handle_request(HTTPMethod.POST, url)\n</code></pre>"},{"location":"reference/transfers_control/#pypaystack2.api.transfers_control.TransferControl.check_balance","title":"<code>check_balance()</code>","text":"<p>Fetch the available balance on your integration</p> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/transfers_control.py</code> <pre><code>def check_balance(self) -&gt; Response:\n    \"\"\"Fetch the available balance on your integration\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._parse_url(\"/balance\")\n    return self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/transfers_control/#pypaystack2.api.transfers_control.TransferControl.disable_otp","title":"<code>disable_otp()</code>","text":"<p>This is used in the event that you want to be able to complete transfers programmatically without use of OTPs. No arguments required. You will get an OTP to complete the request</p> Note <p>Feature Availability     This feature is only available to businesses in Nigeria and Ghana.</p> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/transfers_control.py</code> <pre><code>def disable_otp(self) -&gt; Response:\n    \"\"\"\n    This is used in the event that you want to be able to complete transfers\n    programmatically without use of OTPs. No arguments required. You will get\n    an OTP to complete the request\n\n    Note:\n        Feature Availability\n            This feature is only available to businesses in Nigeria and Ghana.\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._parse_url(\"/transfer/disable_otp\")\n    return self._handle_request(HTTPMethod.POST, url)\n</code></pre>"},{"location":"reference/transfers_control/#pypaystack2.api.transfers_control.TransferControl.enable_otp","title":"<code>enable_otp()</code>","text":"<p>In the event that a customer wants to stop being able to complete transfers programmatically, this endpoint helps turn OTP requirement back on. No arguments required.</p> Note <p>Feature Availability     This feature is only available to businesses in Nigeria and Ghana.</p> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/transfers_control.py</code> <pre><code>def enable_otp(self) -&gt; Response:\n    \"\"\"\n    In the event that a customer wants to stop being able to complete transfers\n    programmatically, this endpoint helps turn OTP requirement back on. No\n    arguments required.\n\n    Note:\n        Feature Availability\n            This feature is only available to businesses in Nigeria and Ghana.\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._parse_url(\"/transfer/enable_otp\")\n    return self._handle_request(HTTPMethod.POST, url)\n</code></pre>"},{"location":"reference/transfers_control/#pypaystack2.api.transfers_control.TransferControl.finalize_disable_otp","title":"<code>finalize_disable_otp(otp)</code>","text":"<p>Finalize the request to disable OTP on your transfers.</p> Note <p>Feature Availability     This feature is only available to businesses in Nigeria and Ghana.</p> <p>Parameters:</p> Name Type Description Default <code>otp</code> <code>str</code> <p>One time password</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/transfers_control.py</code> <pre><code>def finalize_disable_otp(self, otp: str) -&gt; Response:\n    \"\"\"Finalize the request to disable OTP on your transfers.\n\n    Note:\n        Feature Availability\n            This feature is only available to businesses in Nigeria and Ghana.\n\n    Args:\n        otp: One time password\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n    payload = {\"otp\": otp}\n    url = self._parse_url(\"/transfer/disable_otp_finalize\")\n    return self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/transfers_control/#pypaystack2.api.transfers_control.TransferControl.get_balance_ledger","title":"<code>get_balance_ledger()</code>","text":"<p>Fetch all pay-ins and pay-outs that occured on your integration</p> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/transfers_control.py</code> <pre><code>def get_balance_ledger(self) -&gt; Response:\n    \"\"\"Fetch all pay-ins and pay-outs that occured on your integration\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._parse_url(\"/balance/ledger\")\n    print(url)\n    return self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/transfers_control/#pypaystack2.api.transfers_control.TransferControl.resend_otp","title":"<code>resend_otp(transfer_code, reason)</code>","text":"<p>Generates a new OTP and sends to customer in the event they are having trouble receiving one.</p> Note <p>Feature Availability     This feature is only available to businesses in Nigeria and Ghana.</p> <p>Parameters:</p> Name Type Description Default <code>transfer_code</code> <code>str</code> <p>Transfer code</p> required <code>reason</code> <code>Reason</code> <p>Any value from the <code>Reason</code> enum</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/transfers_control.py</code> <pre><code>def resend_otp(self, transfer_code: str, reason: Reason) -&gt; Response:\n    \"\"\"\n    Generates a new OTP and sends to customer in the event they are having trouble receiving one.\n\n    Note:\n        Feature Availability\n            This feature is only available to businesses in Nigeria and Ghana.\n\n    Args:\n        transfer_code: Transfer code\n        reason: Any value from the ``Reason`` enum\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n    payload = {\"transfer_code\": transfer_code, \"reason\": reason}\n    url = self._parse_url(\"/transfer/resend_otp\")\n    return self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/verification/","title":"Verification","text":""},{"location":"reference/verification/#pypaystack2.api.verification.AsyncVerification","title":"<code>AsyncVerification</code>","text":"<p>               Bases: <code>BaseAsyncAPI</code></p> <p>Provides a wrapper for paystack Verification API</p> <p>The Verification API allows you to perform KYC processes. https://paystack.com/docs/api/verification/</p> Note <p>This feature is only available to businesses in Nigeria.</p> Source code in <code>src/pypaystack2/api/verification.py</code> <pre><code>class AsyncVerification(BaseAsyncAPI):\n    \"\"\"Provides a wrapper for paystack Verification API\n\n    The Verification API allows you to perform KYC processes.\n    https://paystack.com/docs/api/verification/\n\n    Note:\n        This feature is only available to businesses in Nigeria.\n    \"\"\"\n\n    async def resolve_account_number(\n        self,\n        account_number: str,\n        bank_code: str,\n    ) -&gt; Response:\n        \"\"\"Confirm an account belongs to the right customer\n\n        Note:\n            Feature Availability\n                This feature is only available to businesses in Nigeria.\n\n        Args:\n            account_number: Account Number\n            bank_code: You can get the list of bank codes by calling the\n                Miscellaneous API wrapper ``.get_banks`` method.\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._parse_url(\n            f\"/bank/resolve?account_number={account_number}&amp;bank_code={bank_code}\"\n        )\n        return await self._handle_request(HTTPMethod.GET, url)\n\n    async def validate_account(\n        self,\n        account_name: str,\n        account_number: str,\n        account_type: AccountType,\n        bank_code: str,\n        country_code: Country,\n        document_type: Document,\n        document_number: Optional[str] = None,\n    ) -&gt; Response:\n        \"\"\"Confirm the authenticity of a customer's account number before sending money\n\n        Args:\n            account_name: Customer's first and last name registered with their bank\n            account_number: Customer's account number\n            account_type: bank_code: The bank code of the customer\u2019s bank. You can fetch the bank codes by\n                using Miscellaneous API wrapper ``.get_banks`` method.\n            bank_code: The bank code of the customer\u2019s bank\n            country_code: Any value from the ``Country`` enum\n            document_type: Customer\u2019s mode of identity. any value from the\n                ``DocumentType`` enum.\n            document_number: Customer\u2019s mode of identity number\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        payload = {\n            \"account_name\": account_name,\n            \"account_number\": account_number,\n            \"account_type\": account_type,\n            \"bank_code\": bank_code,\n            \"country_code\": country_code,\n            \"document_type\": document_type,\n        }\n        url = self._parse_url(\"/bank/validate\")\n\n        return await self._handle_request(HTTPMethod.POST, url, payload)\n\n    async def resolve_card_bin(self, bin: str) -&gt; Response:\n        \"\"\"Get more information about a customer's card\n\n        Args:\n            bin: First 6 characters of card\n\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/decision/bin/{bin}\")\n        return await self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/verification/#pypaystack2.api.verification.AsyncVerification.resolve_account_number","title":"<code>resolve_account_number(account_number, bank_code)</code>  <code>async</code>","text":"<p>Confirm an account belongs to the right customer</p> Note <p>Feature Availability     This feature is only available to businesses in Nigeria.</p> <p>Parameters:</p> Name Type Description Default <code>account_number</code> <code>str</code> <p>Account Number</p> required <code>bank_code</code> <code>str</code> <p>You can get the list of bank codes by calling the Miscellaneous API wrapper <code>.get_banks</code> method.</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/verification.py</code> <pre><code>async def resolve_account_number(\n    self,\n    account_number: str,\n    bank_code: str,\n) -&gt; Response:\n    \"\"\"Confirm an account belongs to the right customer\n\n    Note:\n        Feature Availability\n            This feature is only available to businesses in Nigeria.\n\n    Args:\n        account_number: Account Number\n        bank_code: You can get the list of bank codes by calling the\n            Miscellaneous API wrapper ``.get_banks`` method.\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._parse_url(\n        f\"/bank/resolve?account_number={account_number}&amp;bank_code={bank_code}\"\n    )\n    return await self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/verification/#pypaystack2.api.verification.AsyncVerification.resolve_card_bin","title":"<code>resolve_card_bin(bin)</code>  <code>async</code>","text":"<p>Get more information about a customer's card</p> <p>Parameters:</p> Name Type Description Default <code>bin</code> <code>str</code> <p>First 6 characters of card</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/verification.py</code> <pre><code>async def resolve_card_bin(self, bin: str) -&gt; Response:\n    \"\"\"Get more information about a customer's card\n\n    Args:\n        bin: First 6 characters of card\n\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/decision/bin/{bin}\")\n    return await self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/verification/#pypaystack2.api.verification.AsyncVerification.validate_account","title":"<code>validate_account(account_name, account_number, account_type, bank_code, country_code, document_type, document_number=None)</code>  <code>async</code>","text":"<p>Confirm the authenticity of a customer's account number before sending money</p> <p>Parameters:</p> Name Type Description Default <code>account_name</code> <code>str</code> <p>Customer's first and last name registered with their bank</p> required <code>account_number</code> <code>str</code> <p>Customer's account number</p> required <code>account_type</code> <code>AccountType</code> <p>bank_code: The bank code of the customer\u2019s bank. You can fetch the bank codes by using Miscellaneous API wrapper <code>.get_banks</code> method.</p> required <code>bank_code</code> <code>str</code> <p>The bank code of the customer\u2019s bank</p> required <code>country_code</code> <code>Country</code> <p>Any value from the <code>Country</code> enum</p> required <code>document_type</code> <code>Document</code> <p>Customer\u2019s mode of identity. any value from the <code>DocumentType</code> enum.</p> required <code>document_number</code> <code>Optional[str]</code> <p>Customer\u2019s mode of identity number</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/verification.py</code> <pre><code>async def validate_account(\n    self,\n    account_name: str,\n    account_number: str,\n    account_type: AccountType,\n    bank_code: str,\n    country_code: Country,\n    document_type: Document,\n    document_number: Optional[str] = None,\n) -&gt; Response:\n    \"\"\"Confirm the authenticity of a customer's account number before sending money\n\n    Args:\n        account_name: Customer's first and last name registered with their bank\n        account_number: Customer's account number\n        account_type: bank_code: The bank code of the customer\u2019s bank. You can fetch the bank codes by\n            using Miscellaneous API wrapper ``.get_banks`` method.\n        bank_code: The bank code of the customer\u2019s bank\n        country_code: Any value from the ``Country`` enum\n        document_type: Customer\u2019s mode of identity. any value from the\n            ``DocumentType`` enum.\n        document_number: Customer\u2019s mode of identity number\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    payload = {\n        \"account_name\": account_name,\n        \"account_number\": account_number,\n        \"account_type\": account_type,\n        \"bank_code\": bank_code,\n        \"country_code\": country_code,\n        \"document_type\": document_type,\n    }\n    url = self._parse_url(\"/bank/validate\")\n\n    return await self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"reference/verification/#pypaystack2.api.verification.Verification","title":"<code>Verification</code>","text":"<p>               Bases: <code>BaseAPI</code></p> <p>Provides a wrapper for paystack Verification API</p> <p>The Verification API allows you to perform KYC processes. https://paystack.com/docs/api/verification/</p> Note <p>This feature is only available to businesses in Nigeria.</p> Source code in <code>src/pypaystack2/api/verification.py</code> <pre><code>class Verification(BaseAPI):\n    \"\"\"Provides a wrapper for paystack Verification API\n\n    The Verification API allows you to perform KYC processes.\n    https://paystack.com/docs/api/verification/\n\n    Note:\n        This feature is only available to businesses in Nigeria.\n    \"\"\"\n\n    def resolve_account_number(\n        self,\n        account_number: str,\n        bank_code: str,\n    ) -&gt; Response:\n        \"\"\"Confirm an account belongs to the right customer\n\n        Note:\n            Feature Availability\n                This feature is only available to businesses in Nigeria.\n\n        Args:\n            account_number: Account Number\n            bank_code: You can get the list of bank codes by calling the\n                Miscellaneous API wrapper ``.get_banks`` method.\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._parse_url(\n            f\"/bank/resolve?account_number={account_number}&amp;bank_code={bank_code}\"\n        )\n        return self._handle_request(HTTPMethod.GET, url)\n\n    def validate_account(\n        self,\n        account_name: str,\n        account_number: str,\n        account_type: AccountType,\n        bank_code: str,\n        country_code: Country,\n        document_type: Document,\n        document_number: Optional[str] = None,\n    ) -&gt; Response:\n        \"\"\"Confirm the authenticity of a customer's account number before sending money\n\n        Args:\n            account_name: Customer's first and last name registered with their bank\n            account_number: Customer's account number\n            account_type: bank_code: The bank code of the customer\u2019s bank. You can fetch the bank codes by\n                using Miscellaneous API wrapper ``.get_banks`` method.\n            bank_code: The bank code of the customer\u2019s bank\n            country_code: Any value from the ``Country`` enum\n            document_type: Customer\u2019s mode of identity. any value from the\n                ``DocumentType`` enum.\n            document_number: Customer\u2019s mode of identity number\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        payload = {\n            \"account_name\": account_name,\n            \"account_number\": account_number,\n            \"account_type\": account_type,\n            \"bank_code\": bank_code,\n            \"country_code\": country_code,\n            \"document_type\": document_type,\n            \"document_number\": document_number,\n        }\n        url = self._parse_url(\"/bank/validate\")\n\n        return self._handle_request(HTTPMethod.POST, url, payload)\n\n    def resolve_card_bin(self, bin: str) -&gt; Response:\n        \"\"\"Get more information about a customer's card\n\n        Args:\n            bin: First 6 characters of card\n\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._parse_url(f\"/decision/bin/{bin}\")\n        return self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/verification/#pypaystack2.api.verification.Verification.resolve_account_number","title":"<code>resolve_account_number(account_number, bank_code)</code>","text":"<p>Confirm an account belongs to the right customer</p> Note <p>Feature Availability     This feature is only available to businesses in Nigeria.</p> <p>Parameters:</p> Name Type Description Default <code>account_number</code> <code>str</code> <p>Account Number</p> required <code>bank_code</code> <code>str</code> <p>You can get the list of bank codes by calling the Miscellaneous API wrapper <code>.get_banks</code> method.</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/verification.py</code> <pre><code>def resolve_account_number(\n    self,\n    account_number: str,\n    bank_code: str,\n) -&gt; Response:\n    \"\"\"Confirm an account belongs to the right customer\n\n    Note:\n        Feature Availability\n            This feature is only available to businesses in Nigeria.\n\n    Args:\n        account_number: Account Number\n        bank_code: You can get the list of bank codes by calling the\n            Miscellaneous API wrapper ``.get_banks`` method.\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._parse_url(\n        f\"/bank/resolve?account_number={account_number}&amp;bank_code={bank_code}\"\n    )\n    return self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/verification/#pypaystack2.api.verification.Verification.resolve_card_bin","title":"<code>resolve_card_bin(bin)</code>","text":"<p>Get more information about a customer's card</p> <p>Parameters:</p> Name Type Description Default <code>bin</code> <code>str</code> <p>First 6 characters of card</p> required <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/verification.py</code> <pre><code>def resolve_card_bin(self, bin: str) -&gt; Response:\n    \"\"\"Get more information about a customer's card\n\n    Args:\n        bin: First 6 characters of card\n\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._parse_url(f\"/decision/bin/{bin}\")\n    return self._handle_request(HTTPMethod.GET, url)\n</code></pre>"},{"location":"reference/verification/#pypaystack2.api.verification.Verification.validate_account","title":"<code>validate_account(account_name, account_number, account_type, bank_code, country_code, document_type, document_number=None)</code>","text":"<p>Confirm the authenticity of a customer's account number before sending money</p> <p>Parameters:</p> Name Type Description Default <code>account_name</code> <code>str</code> <p>Customer's first and last name registered with their bank</p> required <code>account_number</code> <code>str</code> <p>Customer's account number</p> required <code>account_type</code> <code>AccountType</code> <p>bank_code: The bank code of the customer\u2019s bank. You can fetch the bank codes by using Miscellaneous API wrapper <code>.get_banks</code> method.</p> required <code>bank_code</code> <code>str</code> <p>The bank code of the customer\u2019s bank</p> required <code>country_code</code> <code>Country</code> <p>Any value from the <code>Country</code> enum</p> required <code>document_type</code> <code>Document</code> <p>Customer\u2019s mode of identity. any value from the <code>DocumentType</code> enum.</p> required <code>document_number</code> <code>Optional[str]</code> <p>Customer\u2019s mode of identity number</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/api/verification.py</code> <pre><code>def validate_account(\n    self,\n    account_name: str,\n    account_number: str,\n    account_type: AccountType,\n    bank_code: str,\n    country_code: Country,\n    document_type: Document,\n    document_number: Optional[str] = None,\n) -&gt; Response:\n    \"\"\"Confirm the authenticity of a customer's account number before sending money\n\n    Args:\n        account_name: Customer's first and last name registered with their bank\n        account_number: Customer's account number\n        account_type: bank_code: The bank code of the customer\u2019s bank. You can fetch the bank codes by\n            using Miscellaneous API wrapper ``.get_banks`` method.\n        bank_code: The bank code of the customer\u2019s bank\n        country_code: Any value from the ``Country`` enum\n        document_type: Customer\u2019s mode of identity. any value from the\n            ``DocumentType`` enum.\n        document_number: Customer\u2019s mode of identity number\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n\n    payload = {\n        \"account_name\": account_name,\n        \"account_number\": account_number,\n        \"account_type\": account_type,\n        \"bank_code\": bank_code,\n        \"country_code\": country_code,\n        \"document_type\": document_type,\n        \"document_number\": document_number,\n    }\n    url = self._parse_url(\"/bank/validate\")\n\n    return self._handle_request(HTTPMethod.POST, url, payload)\n</code></pre>"},{"location":"tutorials/tutorial1/","title":"Paystack Command line Client","text":"<p>This tutorial aims to expose you to how to use <code>pypaystack2</code> in your python projects for paystack integrations. We'll be building a simple command line application that integrates with paystack's services.</p>"},{"location":"tutorials/tutorial1/#project-setup","title":"Project Setup","text":"<p>We'll start by setting up our project. We'll be using <code>pipenv</code> for managing this project's dependencies and environment. you're free to use your preferred choice like <code>virtualenv</code>, <code>hatch</code> or <code>poetry</code>. if you don't have <code>pipenv</code> installed yet, you can install it with <code>pip install pipenv</code>. it's important to note that <code>pipenv</code> should be installed globally and not within a virtual environment. You're good to proceed if this prerequisite is met.</p> <ul> <li>Create a directory to house our project.</li> </ul> <pre><code>mkdir paystack_cli_client &amp;&amp; cd paystack_cli_client\n</code></pre> <ul> <li>Initialize a virtual environment for the project.</li> </ul> <pre><code>pipenv shell\n</code></pre> <ul> <li>Install the projects dependencies. We'll be needing <code>pypaystack2</code>, <code>python-dotenv</code>, and <code>typer</code>.   <code>pypaystack2</code> package is an API wrapper for paystack's services. <code>python-dotenv</code> helps us manage our   environmental variables and typer makes building command line apps in python super   simple.</li> </ul> <pre><code>pipenv install pypaystack2 python-dotenv typer\n</code></pre> <p>If all work's fine, you're good to proceed.</p>"},{"location":"tutorials/tutorial1/#environmental-variables","title":"Environmental Variables","text":"<p><code>pypaystack2</code> depends on your paystack authorization key that you get from signing up to paystack. Paystack provides you with two pairs. A pair of public and secret keys for live mode and another set for test mode. You can find them in your account settings. Since this is just a tutorial, we'll be using only the test secret key. Create a new file named <code>.env</code> within your project's root directory. Now put in your test secret key in the <code>.env</code> file like so.</p> <pre><code>PAYSTACK_AUTHORIZATION_KEY = \"&lt;your paystack test secret key&gt;\"\n</code></pre> <p>Warning</p> <p>Because this is just a tutorial, no extra measure is made to protect this environmental. In a more serious project or production code, extra care should be taken to protect it and also avoid pushing it to a remote source control.</p>"},{"location":"tutorials/tutorial1/#let-the-games-begin","title":"Let the games begin","text":"<p>It's time to start building! create a new file named <code>main.py</code> in your root directory.</p> <pre><code># root-dir/main.py\nfrom dotenv import load_dotenv\n\nload_dotenv()\n</code></pre> <p>What we have just done is loaded our secret test key within the <code>.env</code> file. You may be wondering why do we need that, here's why <code>pypaystack2</code> needs this key to communicate with paystack's api. alternatively, you can pass your authorization key into any of the api wrappers provided by <code>pypaystack2</code> via their <code>auth_key</code> parameter. Here's a list of all the API wrappers currently available as at the time of writing of this tutorial.</p> <p>Note</p> <p>As of version <code>1.1.3</code>, <code>pypaystack2</code> provided <code>Paystack</code> class which had all the available api wrappers bounded to it. version <code>2.0.0</code> also added <code>AsyncPaystack</code> to provide the asynchronous equivalent. So instead off importing individual wrappers you only have to import the <code>Paystack</code> or <code>AsyncPaystack</code> class.</p> <p>Example:   The old way of doing things   <pre><code>from pypaystack2.uitls import Country\nfrom pypaystack2.api import Miscellaneous\n\nmiscellaneous_wrapper = Miscellaneous(auth_key=\"&lt;paystack secret key&gt;\")\nresponse = miscellaneous_wrapper.get_banks(country=Country.NIGERIA)\nprint(response)\n</code></pre></p> <p>The new way <pre><code>from pypaystack2 import Paystack, Country\n\npaystack = Paystack(auth_key=\"&lt;paystack secret key&gt;\")\nresponse = paystack.miscellaneous.get_banks(country=Country.NIGERIA)\nprint(response)\n</code></pre></p> <p>So in a situation where you don't have your <code>PAYSTACK_AUTHORIZATION_KEY</code> as an environmental variable, you can pass it into any of the API wrappers. e.g.</p> <pre><code># When you don't have PAYSTACK_AUTHORIZATION_KEY(paystack secret key) in your environmental variables\nfrom pypaystack2 import Paystack\n\npaystack = Paystack(auth_key=\"&lt;your test secret key&gt;\")\n\n# When you have PAYSTACK_AUTHORIZATION_KEY(paystack secret key) set in your environmental variables\npaystack = Paystack()\n</code></pre> <p>Note</p> <p>You don't have to provide your authorization key on the instantiation of any of the API wrappers as long as you have it set in your environmental variables like this tutorial does.</p>"},{"location":"tutorials/tutorial1/#on-your-marks","title":"On your marks!","text":"<p>The first feature we'll be implementing for our Paystack Command line Client is the ability to create new customers on our paystack integration. so now update your <code>main.py</code> file with the code below.</p> <pre><code># root-dir/main.py\nfrom dotenv import load_dotenv\nfrom typer import Typer\n\nload_dotenv()\n\napp = Typer()\n\n\n@app.command()\ndef new_customer():\n    print(\"new customer successfully created!\")\n\n\nif __name__ == \"__main__\":\n    app()\n</code></pre> <p>This is a minimum setup to building cli apps with <code>Typer</code>. Now try this in your project's root directory.</p> <pre><code>python main.py --help\n</code></pre> <p>You should see.</p> <pre><code>Usage: main.py [OPTIONS]\n\nOptions:\n--install-completion [bash|zsh|fish|powershell|pwsh]\n                                Install completion for the specified\n                                shell.\n--show-completion [bash|zsh|fish|powershell|pwsh]\n                                Show completion for the specified shell,\n                                to copy it or customize the installation.\n--help                          Show this message and exit.\n</code></pre> <p>You can see that we now have a command line app that's responding to our command in this case <code>--help</code>. Let's try out the custom command we just added.</p> <pre><code>python main.py\n</code></pre> <p>You should see</p> <pre><code>new customer successfully created!\n</code></pre> <p>At the moment, no new customer is actually getting created on your paystack integration. let's bring in <code>pypaystack2</code> to help us get the job done. For this to work, <code>pypaystack2</code> provides wrappers for the restful APIs provided by Paystack. These wrappers are named to closely match the API they wrap and methods on these wrappers correspond to endpoints on the Paystack services you're interested in so in this case, for us to create a customer on our integration, we need to use the <code>Customer</code> API wrapper which connects to Paystack's Customer Services API. More info at Paystack's Customer Services API</p> <pre><code># root-dir/main.py\nfrom typing import Optional\nfrom dotenv import load_dotenv\nfrom pypaystack2 import Paystack\nfrom typer import Typer\n\nload_dotenv()\napp = Typer()\n\npaystack = Paystack()\n\n\n@app.command()\ndef new_customer(\n        email: str,\n        first_name: Optional[str] = None,\n        last_name: Optional[str] = None,\n        phone: Optional[str] = None,\n):\n    response = paystack.customers.create(\n        email=email, first_name=first_name, last_name=last_name, phone=phone\n    )\n    print(response.status_code)\n    print(response.status)\n    print(response.message)\n    print(response.data)\n\n\nif __name__ == \"__main__\":\n    app()\n</code></pre> <p>Note</p> <p>All API wrappers are available on <code>pypaystack</code>. as attributes e.g. <code>paystack.transactions</code> for the Transactions API</p> <p>Now if you run the script again.</p> <pre><code>python main.py\n</code></pre> <p>You get error saying you have a missing argument 'EMAIL'</p> <pre><code>Usage: main.py [OPTIONS] EMAIL\nTry 'main.py --help' for help.\n\nError: Missing argument 'EMAIL'.\n</code></pre> <p>Now let's try out our script with the email of the customer we want to create.</p> <pre><code>python main.py email@example.com\n</code></pre> <p>Now if all goes fine. \"An Internet connection is required\", you should get something similar to this</p> <pre><code>200\nTrue\nCustomer created\n{'transactions': [], 'subscriptions': [], 'authorizations': [], 'first_name': '', 'last_name': '', 'email': 'email@example.com', 'phone': '', 'metadata': None, 'domain': 'test', 'customer_code': 'CUS_kd197ej30zxr34v', 'risk_action': 'default', 'id': 47748473, 'integration': 630606, 'createdAt': '2021-06-20T05:16:20.000Z', 'updatedAt': '2021-06-20T05:16:20.000Z', 'identified': False, 'identifications': None}\n</code></pre> <p>Yay! You've just created a new customer on your integration You can check out the customer's tab in your Paystack account to confirm this.</p> <p>Tip</p> <p>You can also create new customers with a first name and last name like so.</p> <pre><code>python main.py email@example.com --first-name John --last-name Doe\n</code></pre>"},{"location":"tutorials/tutorial1/#what-just-happened","title":"What just happened?","text":"<p>You have just created a new customer on your integration with the CLI app you just built. But how? If you've followed this tutorial to this point, you already know what wrappers are, or you can quickly skim through the chapters before to get a refresher. The right question should be what is the <code>create</code> method on the <code>Customer</code> wrapper for. You guess right if what's on your mind is that it creates a new customer on your integration. So as it was said earlier, all wrappers have methods on them that correspond to an endpoint on paystack and all of these methods will return a <code>Response</code> object based on the response it gets from Paystack. This <code>Response</code> is just a <code>NamedTuple</code> that holds the <code>status,status_code,message</code> and <code>data</code>. So this call</p> <pre><code>response = paystack.customers.create(email=email, first_name=first_name, last_name=last_name, phone=phone)\n</code></pre> <p>in our script returns the <code>Response</code> object just described, and you can access each of these attributes with <code>response.status</code>, <code>response.status_code</code>, <code>response.message</code>, <code>response.data</code></p>"},{"location":"tutorials/tutorial1/#more-commands","title":"More Commands!","text":"<p>Let's add a few more commands to our Paystack Command line Client</p> <pre><code># root-dir/main.py\nfrom typing import Optional\nfrom dotenv import load_dotenv\nfrom pypaystack2 import Paystack\nfrom typer import Typer\n\nload_dotenv()\n\napp = Typer()\n\npaystack = Paystack()\n\n\n@app.command()\ndef new_customer(\n        email: str,\n        first_name: Optional[str] = None,\n        last_name: Optional[str] = None,\n        phone: Optional[str] = None,\n):\n    response = paystack.customers.create(\n        email=email, first_name=first_name, last_name=last_name, phone=phone\n    )\n    print(response.status_code)\n    print(response.status)\n    print(response.message)\n    print(response.data)\n\n\n@app.command()\ndef list_customers():\n    response = paystack.customers.get_customers()\n    print(response.status_code)\n    print(response.status)\n    print(response.message)\n    print(response.data)\n\n\n@app.command()\ndef get_customer(ec: str):\n    response = paystack.customers.get_customer(email_or_code=ec)\n    print(response.status_code)\n    print(response.status)\n    print(response.message)\n    print(response.data)\n\n\n@app.command()\ndef update_customer(code: str, last_name: str, first_name: str):\n    response = paystack.customers.update(\n        code=code, last_name=last_name, first_name=first_name\n    )\n    print(response.status_code)\n    print(response.status)\n    print(response.message)\n    print(response.data)\n\n\nif __name__ == \"__main__\":\n    app()\n</code></pre> <p>We now have 3 new commands for our cli app. you can check them out with</p> <pre><code>python main.py --help\n</code></pre> <p>Now under the available command you should see get-customer, list-customers, new-customer, update-customer</p> <pre><code>Usage: main.py [OPTIONS] COMMAND [ARGS]...\n\n    Options:\n    --install-completion [bash|zsh|fish|powershell|pwsh]\n                                    Install completion for the specified\n                                    shell.\n    --show-completion [bash|zsh|fish|powershell|pwsh]\n                                    Show completion for the specified shell,\n                                    to copy it or customize the installation.\n    --help                          Show this message and exit.\n\n    Commands:\n    get-customer\n    list-customers\n    new-customer\n    update-customer\n</code></pre> <p>You can try out the new command with the following commands</p>"},{"location":"tutorials/tutorial1/#where-to-go-from-here","title":"Where to go from here","text":"<p>It's all in your hands now. We now have a working cli app, but it does not have all the features to make it a fully fledged Paystack command line client you can implement more commands. It also does not handle all the likely exception that can occur, but then, the purpose of the tutorial is to expose you to <code>pypaystack2</code>.You can check out the fully built paystack-cli which can be quite useful for development purposes. Not sure how something works, you can always search the documentation. Good luck on your next project!</p>"}]}