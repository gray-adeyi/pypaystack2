{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"PyPaystack2","text":"A developer friendly client library for Paystack <p>Documentation: https://gray-adeyi.github.io/pypaystack2/</p> <p>Source Code: https://github.com/gray-adeyi/pypaystack2</p> <p>PyPaystack2 is an Open Source Python client library for integrating Paystack into your python projects. It aims at being developer friendly and easy to use.</p> <p>The key features are:</p> <ul> <li>Type hints: All methods provided by PyPaystack2 are type annotated, so you can infer. This improves the   development experience.</li> <li>Async support: PyPaystack2 allow you to also make calls to Paystack API using <code>async/await</code> which is super great,   for example, if your project is in FastAPI where every chance of a performance   improvement adds up.</li> <li>Pydantic: PyPaystack2 now uses pydantic for data presentation. client methods return <code>Response</code> which is   a pydantic model, the data in the response are also presented with pydantic e.g.  <code>Response[Transaction]</code> is   an example of a response that may be returned by client method. This can be interpreted as the response contains   a transaction resource as the data. i.e. <code>Response.data</code> is <code>Transaction</code> which is also a pydantic model</li> <li>Fees Calculation utilities: PyPaystack2 provides utilities for calculating paystack's transaction fees and   converting between base units and subunits of a currency</li> <li>Webhook support &amp; utilities: From PyPaystack2 (&gt;= v3.1.0), you can verify webhook payloads and also run   a tunnel server that forwards webhook events from paystack to your app running on localhost</li> </ul>"},{"location":"#requirements","title":"Requirements","text":"<p>Paypaystack2 <code>&lt;=3.0.0</code> requires a minimum Python version of <code>&gt;=3.11</code>. For python <code>&lt;3.11</code> See older versions of this project</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>$ pip install -U pypaystack2\n# or install with uv\n$ uv add pypaystack2\n# For webhook cli\n$ pip install -U \"pypaystack2[webhook]\"\nor install with uv\n$ uv add \"pypaystack2[webhook\"\n</code></pre>"},{"location":"#examples","title":"Examples","text":""},{"location":"#usage-in-a-synchronous-context","title":"Usage in a synchronous context","text":"<pre><code>Python 3.11.11 (main, Feb 12 2025, 14:51:05) [Clang 19.1.6 ] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt; from pypaystack2 import PaystackClient\n&gt;&gt;&gt; client = PaystackClient() # assumes the environmental variable `PAYSTACK_SECRET_KEY=\"YOUR_PAYSTACK_SECRET_KEY\"` is set. if not, you can alternatively pass it into the `PaystackClient` instantiation like so PaystackClient(secret_key='YOUR_PAYSTACK_SECRET_KEY')\n&gt;&gt;&gt; response = client.customers.get_customer(email_or_code=\"CUS_8x2byd6x3dk5hp0\")\n&gt;&gt;&gt; print(response)\nResponse(\n  status_code=&lt;HTTPStatus.OK: 200&gt;,\n  status=True,\n  message='Customer retrieved',\n  data=Customer(\n    integration=630606,\n    id=87934333,\n    first_name='john',...\n</code></pre> <p>All you need to interact with Paystack's API in your python project is the <code>PaystackClient</code> class it provides bindings to different sub clients that provide methods that let you interact with paystack. The <code>PaystackClient</code> class also provides fees calculation utility methods like <code>to_subunit</code>, <code>to_base_unit</code> and <code>calculate_fee</code>. Every method call on the sub client bindings that makes an HTTP Request to paystack has the same generic return type , which is a Response a pydantic model representing the result of the request. The content of the data attribute may vary based on the request that was made.</p>"},{"location":"#usage-in-an-asynchronous-context","title":"Usage in an asynchronous context","text":"<p><code>AsyncPaystackClient</code> is an asynchronous mirror equivalent of the <code>PaystackClient</code> client. i.e. <code>AsyncPaystackClient</code> provides the same functionality as <code>PaystackClient</code> but is more useful in the context of non-blocking <code>async\\await</code> code. All the bindings on the <code>AsyncPaystackClient</code> are the same as ones in <code>PaystackClient</code> except that the methods on the <code>AsyncPaystackClient</code> are <code>awaitable</code>. Run the async REPL with <code>python -m asyncio</code></p> <pre><code>asyncio REPL 3.11.11 (main, Feb 12 2025, 14:51:05) [Clang 19.1.6 ] on linux\nUse \"await\" directly instead of \"asyncio.run()\".\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt; import asyncio\n&gt;&gt;&gt; from pypaystack2 import AsyncPaystackClient\n&gt;&gt;&gt; paystack = AsyncPaystackClient() # assumes the environmental variable `PAYSTACK_SECRET_KEY=\"YOUR_SECRET_KEY\"` is set. if not, you can alternatively pass it into the `AsyncPaystackClient` instantiation like so AsyncPaystackClient(secret_key='YOUR_SECRET_KEYS')\n&gt;&gt;&gt; response = await paystack.customers.get_customer(email_or_code=\"CUS_8x2byd6x3dk5hp0\")\n&gt;&gt;&gt; print(response)\nResponse(\n  status_code=&lt;HTTPStatus.OK: 200&gt;,\n  status=True,\n  message='Customer retrieved',\n  data=Customer(\n    integration=630606,\n    id=87934333,\n    first_name='john',...\n</code></pre>"},{"location":"#webhook","title":"Webhook","text":"<p>PyPaystack2 now supports verifying the authenticity of a webhook payload and a CLI to make working with webhooks locally seamless</p>"},{"location":"#verifying-a-webhook-payload","title":"Verifying a webhook payload","text":"<pre><code>Python 3.11.13 (main, Sep  2 2025, 14:20:25) [Clang 20.1.4 ] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt; from pypaystack2 import PaystackClient\n&gt;&gt;&gt; client = PaystackClient()\n&gt;&gt;&gt; payload = ... # webhook payload e.g., b'{\"event\": \"customeridentification.success\", \"data\": {\"customer_id\": 324345768, \"customer_code\": \"CUS_e7urjebaoyk1ze2\", \"email\": \"jddae8446e-e54c-42ab-bf37-e5abff14527e@example.com\", \"identification\": {\"country\": \"NG\", \"type\": \"bank_account\", \"bvn\": \"123*****543\", \"account_number\": \"342****22\", \"bank_code\": \"121\"}}}'\n&gt;&gt;&gt; signature = ... # x-paystack-signature e.g., \"5d049eb93c7c71fa098f5215d7297bda401710b62df8b392b9052adf8d1a02ff308f6ca57a1db14ffeabd5b66264e9c42de029b7067b9c71eb9c231fb2a8e383\"\n&gt;&gt;&gt; is_verified_webhook_payload = client.is_verified_webhook_payload(payload,signature)\n&gt;&gt;&gt; print(is_verified_webhook_payload)\nTrue\n</code></pre>"},{"location":"#forward-webhook-events-from-paystack-to-your-app-running-locally","title":"Forward webhook events from paystack to your app running locally","text":"<p>Note: This requires that you install <code>pypaystack2[webhook]</code></p> <pre><code>pypaystack2 webhook start-tunnel-server --addr localhost:8000 --ngrok-auth-token\n</code></pre>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the terms of the MIT license.</p>"},{"location":"#contributors","title":"Contributors","text":"<ul> <li>gray-adeyi</li> </ul>"},{"location":"#related-projects","title":"Related Projects","text":"Name Language Functionality Paystack CLI Python A command line app for interacting with paystack APIs paystack Go A client library for integration paystack in go @gray-adeyi/paystack-sdk Typescript/Javascript A client library for integrating paystack in Javascript runtimes (Node,Deno,Bun) paystack Dart A client library for integration paystack in Dart"},{"location":"#buy-me-a-coffee","title":"Buy me a coffee","text":"<p>https://www.buymeacoffee.com/jigani</p>"},{"location":"explanation/","title":"Explanation","text":"<p>Coming soon!</p>"},{"location":"how-to-guides/","title":"How-To Guides","text":""},{"location":"how-to-guides/#how-to-guide","title":"How to guide","text":"<p>Coming soon.</p>"},{"location":"reference/","title":"Introduction","text":""},{"location":"reference/#pypaystack2-package-reference","title":"Pypaystack2 Package Reference","text":"<p>This is the package-level documentation for the <code>pypaystack2</code> package.</p> <p>The <code>pypaystack2</code> package provides clients for interacting with Paystack's API in your python project it provides <code>PaystackClient</code> and <code>AsyncPaystackClient</code>. The former for working in synchronous contexts and the latter for working in asynchronous contexts. These two classes are considered the main clients and provide bindings to other sub-clients as class attributes. E.g. <code>PaystackClient.apple_pay</code></p> Subpackages <ul> <li><code>pypaystack2.sub_clients</code>: A package containing clients for interacting with specific Paystack's API</li> <li><code>pypaystack2.models</code>: A package containing pydantic model representations of payload and response data the individual models may also be referred to as generic type called <code>PaystackDataModel</code> which serves as a placeholder for the models.</li> </ul> Module <ul> <li><code>pypaystack2.enum</code>: A module containing enums used package wide.</li> </ul> <p>Example usage:</p> <pre><code>from pypaystack2 import PaystackClient\nfrom pypaystack2.enums import Country\n\nclient = PaystackClient() # Assumes your secret key is set in your environmental variables\n# as PAYSTACK_SECRET_KEY. you may also choose to pass the secret key explicitly on instantiation\n# of the client. `client = PaystackClient(secret_key='&lt;your-secret-key&gt;')`\n\n# Initializing a transaction\nresponse = client.transactions.initialize(amount=10_000,email=\"johndoe@example.com\")\nprint(repr(response))\n\n# Get banks\nresponse = client.miscellaneous.get_banks(country=Country.NIGERIA)\nprint(repr(response))\n</code></pre> <p>For more details, refer to the documentation.</p>"},{"location":"reference/#pypaystack2.AsyncPaystackClient","title":"<code>AsyncPaystackClient</code>","text":"<p>               Bases: <code>BaseAsyncAPIClient</code></p> <p>An asynchronous Paystack API client class with all the sub clients supported by pypaystack2.</p> <p>This class has all the individual sub clients classes like <code>AsyncApplePayClient</code>, <code>AsyncBulkChargeClient</code> as bindings to it.</p> <p>Attributes:</p> Name Type Description <code>apple_pay</code> <p>A binding to <code>AsyncApplePayClient</code> providing methods for interacting Paystack's Apple Pay API e.g. <code>PaystackClient.apple_pay.get_domains</code>.</p> <code>bulk_charges</code> <p>A binding to <code>AsyncBulkChargeClient</code> providing methods for interacting Paystack's Bulk charge API e.g. <code>PaystackClient.bulk_charges.initiate</code>.</p> <code>charge</code> <p>A binding to <code>AsyncChargeClient</code> providing methods for interacting Paystack's Charge API e.g. <code>PaystackClient.charge.charge</code>.</p> <code>integration</code> <p>A binding to <code>AsyncIntegrationClient</code> providing methods for interacting Paystack's Integration API e.g. <code>PaystackClient.integration.get_payment_session_timeout</code>.</p> <code>customers</code> <p>A binding to <code>AsyncCustomerClient</code> providing methods for interacting Paystack's Customer API e.g. <code>PaystackClient.customers.create</code>.</p> <code>dedicated_accounts</code> <p>A binding to <code>AsyncDedicatedAccountClient</code> providing methods for interacting Paystack's Dedicated account API e.g. <code>PaystackClient.dedicated_accounts.create</code>.</p> <code>disputes</code> <p>A binding to <code>AsyncDisputeClient</code> providing methods for interacting Paystack's Dispute API e.g. <code>PaystackClient.disputes.</code>.</p> <code>payment_requests</code> <p>A binding to <code>AsyncPaymentRequestClient</code> providing methods for interacting Paystack's Payment request API e.g. <code>PaystackClient.payment_requests.create</code>.</p> <code>miscellaneous</code> <p>A binding to <code>AsyncApplePayClient</code> providing methods for interacting Paystack's Apple Pay API e.g. <code>PaystackClient.miscellaneous.get_banks</code>.</p> <code>payment_pages</code> <p>A binding to <code>AsyncPaymentPageClient</code> providing methods for interacting Paystack's Payment Page API e.g. <code>PaystackClient.payment_pages.create</code>.</p> <code>plans</code> <p>A binding to <code>AsyncPlanClient</code> providing methods for interacting Paystack's Plan API e.g. <code>PaystackClient.plans.get_plans</code>.</p> <code>products</code> <p>A binding to <code>AsyncProductClient</code> providing methods for interacting Paystack's Product API e.g. <code>PaystackClient.products.get_product</code>.</p> <code>refunds</code> <p>A binding to <code>AsyncRefundClient</code> providing methods for interacting Paystack's Refund API e.g. <code>PaystackClient.refunds.create</code>.</p> <code>settlements</code> <p>A binding to <code>AsyncSettlementClient</code> providing methods for interacting Paystack's Settlement API e.g. <code>PaystackClient.settlements.get_settlements</code>.</p> <code>splits</code> <p>A binding to <code>AsyncTransactionSplitClient</code> providing methods for interacting Paystack's Transaction split API e.g. <code>PaystackClient.splits.create</code>.</p> <code>subaccounts</code> <p>A binding to <code>AsyncSubAccountClient</code> providing methods for interacting Paystack's subaccount API e.g. <code>PaystackClient.subaccounts.create</code>.</p> <code>subscriptions</code> <p>A binding to <code>AsyncSubscriptionClient</code> providing methods for interacting Paystack's Subscription API e.g. <code>PaystackClient.subscriptions.create</code>.</p> <code>terminals</code> <p>A binding to <code>AsyncTerminalClient</code> providing methods for interacting Paystack's Terminal API e.g. <code>PaystackClient.terminals.send_event</code>.</p> <code>transactions</code> <p>A binding to <code>AsyncTransactionClient</code> providing methods for interacting Paystack's Transaction API e.g. <code>PaystackClient.transactions.initiate</code>.</p> <code>transfer_recipients</code> <p>A binding to <code>AsyncTransferRecipientClient</code> providing methods for interacting Paystack's Transfer recipients API e.g. <code>PaystackClient.transfer_recipients.create</code>.</p> <code>transfers</code> <p>A binding to <code>AsyncTransferClient</code> providing methods for interacting Paystack's Transfer API e.g. <code>PaystackClient.transfers.finalize</code>.</p> <code>transfer_control</code> <p>A binding to <code>AsyncTransferControlClient</code> providing methods for interacting Paystack's Transfers control API e.g. <code>PaystackClient.transfer_control.check_balance</code>.</p> <code>verification</code> <p>A binding to <code>AsyncVerificationClient</code> providing methods for interacting Paystack's Verification API e.g. <code>PaystackClient.verification.resolve_account_number</code>.</p> Source code in <code>src/pypaystack2/main_clients.py</code> <pre><code>class AsyncPaystackClient(BaseAsyncAPIClient):\n    \"\"\"An asynchronous Paystack API client class with all the sub clients supported by pypaystack2.\n\n    This class has all the individual sub clients classes like `AsyncApplePayClient`, `AsyncBulkChargeClient`\n    as bindings to it.\n\n    Attributes:\n        apple_pay: A binding to `AsyncApplePayClient` providing methods for interacting Paystack's Apple Pay API\n            e.g. `PaystackClient.apple_pay.get_domains`.\n        bulk_charges: A binding to `AsyncBulkChargeClient` providing methods for interacting Paystack's Bulk charge API\n            e.g. `PaystackClient.bulk_charges.initiate`.\n        charge: A binding to `AsyncChargeClient` providing methods for interacting Paystack's Charge API\n            e.g. `PaystackClient.charge.charge`.\n        integration: A binding to `AsyncIntegrationClient` providing methods for interacting Paystack's Integration API\n            e.g. `PaystackClient.integration.get_payment_session_timeout`.\n        customers: A binding to `AsyncCustomerClient` providing methods for interacting Paystack's Customer API\n            e.g. `PaystackClient.customers.create`.\n        dedicated_accounts: A binding to `AsyncDedicatedAccountClient` providing methods for interacting\n            Paystack's Dedicated account API e.g. `PaystackClient.dedicated_accounts.create`.\n        disputes: A binding to `AsyncDisputeClient` providing methods for interacting Paystack's Dispute API\n            e.g. `PaystackClient.disputes.`.\n        payment_requests: A binding to `AsyncPaymentRequestClient` providing methods for interacting Paystack's Payment\n            request API e.g. `PaystackClient.payment_requests.create`.\n        miscellaneous: A binding to `AsyncApplePayClient` providing methods for interacting Paystack's Apple Pay API\n            e.g. `PaystackClient.miscellaneous.get_banks`.\n        payment_pages: A binding to `AsyncPaymentPageClient` providing methods for interacting Paystack's Payment Page\n            API e.g. `PaystackClient.payment_pages.create`.\n        plans: A binding to `AsyncPlanClient` providing methods for interacting Paystack's Plan API\n            e.g. `PaystackClient.plans.get_plans`.\n        products: A binding to `AsyncProductClient` providing methods for interacting Paystack's Product API\n            e.g. `PaystackClient.products.get_product`.\n        refunds: A binding to `AsyncRefundClient` providing methods for interacting Paystack's Refund API\n            e.g. `PaystackClient.refunds.create`.\n        settlements: A binding to `AsyncSettlementClient` providing methods for interacting Paystack's Settlement API\n            e.g. `PaystackClient.settlements.get_settlements`.\n        splits: A binding to `AsyncTransactionSplitClient` providing methods for interacting Paystack's Transaction\n            split API e.g. `PaystackClient.splits.create`.\n        subaccounts: A binding to `AsyncSubAccountClient` providing methods for interacting Paystack's subaccount API\n            e.g. `PaystackClient.subaccounts.create`.\n        subscriptions: A binding to `AsyncSubscriptionClient` providing methods for interacting Paystack's Subscription\n            API e.g. `PaystackClient.subscriptions.create`.\n        terminals: A binding to `AsyncTerminalClient` providing methods for interacting Paystack's Terminal API\n            e.g. `PaystackClient.terminals.send_event`.\n        transactions: A binding to `AsyncTransactionClient` providing methods for interacting Paystack's Transaction\n            API e.g. `PaystackClient.transactions.initiate`.\n        transfer_recipients: A binding to `AsyncTransferRecipientClient` providing methods for interacting Paystack's\n            Transfer recipients API e.g. `PaystackClient.transfer_recipients.create`.\n        transfers: A binding to `AsyncTransferClient` providing methods for interacting Paystack's Transfer API\n            e.g. `PaystackClient.transfers.finalize`.\n        transfer_control: A binding to `AsyncTransferControlClient` providing methods for interacting Paystack's\n            Transfers control API e.g. `PaystackClient.transfer_control.check_balance`.\n        verification: A binding to `AsyncVerificationClient` providing methods for interacting Paystack's Verification\n            API e.g. `PaystackClient.verification.resolve_account_number`.\n    \"\"\"\n\n    def __init__(self, secret_key: str | None = None):\n        super().__init__(secret_key=secret_key)\n        self.apple_pay = AsyncApplePayClient(secret_key=self._secret_key)\n        self.bulk_charges = AsyncBulkChargeClient(secret_key=self._secret_key)\n        self.charge = AsyncChargeClient(secret_key=self._secret_key)\n        self.integration = AsyncIntegrationClient(secret_key=self._secret_key)\n        self.customers = AsyncCustomerClient(secret_key=self._secret_key)\n        self.dedicated_accounts = AsyncDedicatedAccountClient(\n            secret_key=self._secret_key\n        )\n        self.disputes = AsyncDisputeClient(secret_key=self._secret_key)\n        self.payment_requests = AsyncPaymentRequestClient(secret_key=self._secret_key)\n        self.miscellaneous = AsyncMiscellaneousClient(secret_key=self._secret_key)\n        self.payment_pages = AsyncPaymentPageClient(secret_key=self._secret_key)\n        self.plans = AsyncPlanClient(secret_key=self._secret_key)\n        self.products = AsyncProductClient(secret_key=self._secret_key)\n        self.refunds = AsyncRefundClient(secret_key=self._secret_key)\n        self.settlements = AsyncSettlementClient(secret_key=self._secret_key)\n        self.splits = AsyncTransactionSplitClient(secret_key=self._secret_key)\n        self.subaccounts = AsyncSubAccountClient(secret_key=self._secret_key)\n        self.subscriptions = AsyncSubscriptionClient(secret_key=self._secret_key)\n        self.terminals = AsyncTerminalClient(secret_key=self._secret_key)\n        self.transactions = AsyncTransactionClient(secret_key=self._secret_key)\n        self.transfer_recipients = AsyncTransferRecipientClient(\n            secret_key=self._secret_key\n        )\n        self.transfers = AsyncTransferClient(secret_key=self._secret_key)\n        self.transfer_control = AsyncTransferControlClient(secret_key=self._secret_key)\n        self.verification = AsyncVerificationClient(secret_key=self._secret_key)\n</code></pre>"},{"location":"reference/#pypaystack2.PaystackClient","title":"<code>PaystackClient</code>","text":"<p>               Bases: <code>BaseAPIClient</code></p> <p>A Paystack API client class with all the sub clients supported by pypaystack2.</p> <p>This class has all the individual sub clients classes like <code>ApplePayClient</code>, <code>BulkChargeClient</code> as bindings to it.</p> <p>Attributes:</p> Name Type Description <code>apple_pay</code> <code>ApplePayClient</code> <p>A binding to <code>ApplePayClient</code> providing methods for interacting Paystack's Apple Pay API e.g. <code>PaystackClient.apple_pay.get_domains</code>.</p> <code>bulk_charges</code> <code>BulkChargeClient</code> <p>A binding to <code>BulkChargeClient</code> providing methods for interacting Paystack's Bulk charge API e.g. <code>PaystackClient.bulk_charges.initiate</code>.</p> <code>charge</code> <code>ChargeClient</code> <p>A binding to <code>ChargeClient</code> providing methods for interacting Paystack's Charge API e.g. <code>PaystackClient.charge.charge</code>.</p> <code>integration</code> <code>IntegrationClient</code> <p>A binding to <code>IntegrationClient</code> providing methods for interacting Paystack's Integration API e.g. <code>PaystackClient.integration.get_payment_session_timeout</code>.</p> <code>customers</code> <code>CustomerClient</code> <p>A binding to <code>CustomerClient</code> providing methods for interacting Paystack's Customer API e.g. <code>PaystackClient.customers.create</code>.</p> <code>dedicated_accounts</code> <code>DedicatedAccountClient</code> <p>A binding to <code>DedicatedAccountClient</code> providing methods for interacting Paystack's Dedicated account API e.g. <code>PaystackClient.dedicated_accounts.create</code>.</p> <code>disputes</code> <code>DisputeClient</code> <p>A binding to <code>DisputeClient</code> providing methods for interacting Paystack's Dispute API e.g. <code>PaystackClient.disputes.</code>.</p> <code>payment_requests</code> <code>PaymentRequestClient</code> <p>A binding to <code>PaymentRequestClient</code> providing methods for interacting Paystack's Payment request API e.g. <code>PaystackClient.payment_requests.create</code>.</p> <code>miscellaneous</code> <code>MiscellaneousClient</code> <p>A binding to <code>ApplePayClient</code> providing methods for interacting Paystack's Apple Pay API e.g. <code>PaystackClient.miscellaneous.get_banks</code>.</p> <code>payment_pages</code> <code>PaymentPageClient</code> <p>A binding to <code>PaymentPageClient</code> providing methods for interacting Paystack's Payment Page API e.g. <code>PaystackClient.payment_pages.create</code>.</p> <code>plans</code> <code>PlanClient</code> <p>A binding to <code>PlanClient</code> providing methods for interacting Paystack's Plan API e.g. <code>PaystackClient.plans.get_plans</code>.</p> <code>products</code> <code>ProductClient</code> <p>A binding to <code>ProductClient</code> providing methods for interacting Paystack's Product API e.g. <code>PaystackClient.products.get_product</code>.</p> <code>refunds</code> <code>RefundClient</code> <p>A binding to <code>RefundClient</code> providing methods for interacting Paystack's Refund API e.g. <code>PaystackClient.refunds.create</code>.</p> <code>settlements</code> <code>SettlementClient</code> <p>A binding to <code>SettlementClient</code> providing methods for interacting Paystack's Settlement API e.g. <code>PaystackClient.settlements.get_settlements</code>.</p> <code>splits</code> <code>TransactionSplitClient</code> <p>A binding to <code>TransactionSplitClient</code> providing methods for interacting Paystack's Transaction split API e.g. <code>PaystackClient.splits.create</code>.</p> <code>subaccounts</code> <code>SubAccountClient</code> <p>A binding to <code>SubAccountClient</code> providing methods for interacting Paystack's subaccount API e.g. <code>PaystackClient.subaccounts.create</code>.</p> <code>subscriptions</code> <code>SubscriptionClient</code> <p>A binding to <code>SubscriptionClient</code> providing methods for interacting Paystack's Subscription API e.g. <code>PaystackClient.subscriptions.create</code>.</p> <code>terminals</code> <code>TerminalClient</code> <p>A binding to <code>TerminalClient</code> providing methods for interacting Paystack's Terminal API e.g. <code>PaystackClient.terminals.send_event</code>.</p> <code>transactions</code> <code>TransactionClient</code> <p>A binding to <code>TransactionClient</code> providing methods for interacting Paystack's Transaction API e.g. <code>PaystackClient.transactions.initiate</code>.</p> <code>transfer_recipients</code> <code>TransferRecipientClient</code> <p>A binding to <code>TransferRecipientClient</code> providing methods for interacting Paystack's Transfer recipients API e.g. <code>PaystackClient.transfer_recipients.create</code>.</p> <code>transfers</code> <code>TransferClient</code> <p>A binding to <code>TransferClient</code> providing methods for interacting Paystack's Transfer API e.g. <code>PaystackClient.transfers.finalize</code>.</p> <code>transfer_control</code> <code>TransferControlClient</code> <p>A binding to <code>TransferControlClient</code> providing methods for interacting Paystack's Transfers control API e.g. <code>PaystackClient.transfer_control.check_balance</code>.</p> <code>verification</code> <code>VerificationClient</code> <p>A binding to <code>VerificationClient</code> providing methods for interacting Paystack's Verification API e.g. <code>PaystackClient.verification.resolve_account_number</code>.</p> Source code in <code>src/pypaystack2/main_clients.py</code> <pre><code>class PaystackClient(BaseAPIClient):\n    \"\"\"A Paystack API client class with all the sub clients supported by pypaystack2.\n\n    This class has all the individual sub clients classes like `ApplePayClient`, `BulkChargeClient`\n    as bindings to it.\n\n    Attributes:\n        apple_pay: A binding to `ApplePayClient` providing methods for interacting Paystack's Apple Pay API\n            e.g. `PaystackClient.apple_pay.get_domains`.\n        bulk_charges: A binding to `BulkChargeClient` providing methods for interacting Paystack's Bulk charge API\n            e.g. `PaystackClient.bulk_charges.initiate`.\n        charge: A binding to `ChargeClient` providing methods for interacting Paystack's Charge API\n            e.g. `PaystackClient.charge.charge`.\n        integration: A binding to `IntegrationClient` providing methods for interacting Paystack's Integration API\n            e.g. `PaystackClient.integration.get_payment_session_timeout`.\n        customers: A binding to `CustomerClient` providing methods for interacting Paystack's Customer API\n            e.g. `PaystackClient.customers.create`.\n        dedicated_accounts: A binding to `DedicatedAccountClient` providing methods for interacting\n            Paystack's Dedicated account API e.g. `PaystackClient.dedicated_accounts.create`.\n        disputes: A binding to `DisputeClient` providing methods for interacting Paystack's Dispute API\n            e.g. `PaystackClient.disputes.`.\n        payment_requests: A binding to `PaymentRequestClient` providing methods for interacting Paystack's Payment\n            request API e.g. `PaystackClient.payment_requests.create`.\n        miscellaneous: A binding to `ApplePayClient` providing methods for interacting Paystack's Apple Pay API\n            e.g. `PaystackClient.miscellaneous.get_banks`.\n        payment_pages: A binding to `PaymentPageClient` providing methods for interacting Paystack's Payment Page API\n            e.g. `PaystackClient.payment_pages.create`.\n        plans: A binding to `PlanClient` providing methods for interacting Paystack's Plan API\n            e.g. `PaystackClient.plans.get_plans`.\n        products: A binding to `ProductClient` providing methods for interacting Paystack's Product API\n            e.g. `PaystackClient.products.get_product`.\n        refunds: A binding to `RefundClient` providing methods for interacting Paystack's Refund API\n            e.g. `PaystackClient.refunds.create`.\n        settlements: A binding to `SettlementClient` providing methods for interacting Paystack's Settlement API\n            e.g. `PaystackClient.settlements.get_settlements`.\n        splits: A binding to `TransactionSplitClient` providing methods for interacting Paystack's Transaction split API\n            e.g. `PaystackClient.splits.create`.\n        subaccounts: A binding to `SubAccountClient` providing methods for interacting Paystack's subaccount API\n            e.g. `PaystackClient.subaccounts.create`.\n        subscriptions: A binding to `SubscriptionClient` providing methods for interacting Paystack's Subscription API\n            e.g. `PaystackClient.subscriptions.create`.\n        terminals: A binding to `TerminalClient` providing methods for interacting Paystack's Terminal API\n            e.g. `PaystackClient.terminals.send_event`.\n        transactions: A binding to `TransactionClient` providing methods for interacting Paystack's Transaction API\n            e.g. `PaystackClient.transactions.initiate`.\n        transfer_recipients: A binding to `TransferRecipientClient` providing methods for interacting Paystack's\n            Transfer recipients API e.g. `PaystackClient.transfer_recipients.create`.\n        transfers: A binding to `TransferClient` providing methods for interacting Paystack's Transfer API\n            e.g. `PaystackClient.transfers.finalize`.\n        transfer_control: A binding to `TransferControlClient` providing methods for interacting Paystack's\n            Transfers control API e.g. `PaystackClient.transfer_control.check_balance`.\n        verification: A binding to `VerificationClient` providing methods for interacting Paystack's Verification API\n            e.g. `PaystackClient.verification.resolve_account_number`.\n    \"\"\"\n\n    def __init__(self, secret_key: str | None = None):\n        super().__init__(secret_key=secret_key)\n        self.apple_pay: ApplePayClient = ApplePayClient(secret_key=self._secret_key)\n        self.bulk_charges: BulkChargeClient = BulkChargeClient(\n            secret_key=self._secret_key\n        )\n        self.charge: ChargeClient = ChargeClient(secret_key=self._secret_key)\n        self.integration: IntegrationClient = IntegrationClient(\n            secret_key=self._secret_key\n        )\n        self.customers: CustomerClient = CustomerClient(secret_key=self._secret_key)\n        self.dedicated_accounts: DedicatedAccountClient = DedicatedAccountClient(\n            secret_key=self._secret_key\n        )\n        self.disputes: DisputeClient = DisputeClient(secret_key=self._secret_key)\n        self.payment_requests: PaymentRequestClient = PaymentRequestClient(\n            secret_key=self._secret_key\n        )\n        self.miscellaneous: MiscellaneousClient = MiscellaneousClient(\n            secret_key=self._secret_key\n        )\n        self.payment_pages: PaymentPageClient = PaymentPageClient(\n            secret_key=self._secret_key\n        )\n        self.plans: PlanClient = PlanClient(secret_key=self._secret_key)\n        self.products: ProductClient = ProductClient(secret_key=self._secret_key)\n        self.refunds: RefundClient = RefundClient(secret_key=self._secret_key)\n        self.settlements: SettlementClient = SettlementClient(\n            secret_key=self._secret_key\n        )\n        self.splits: TransactionSplitClient = TransactionSplitClient(\n            secret_key=self._secret_key\n        )\n        self.subaccounts: SubAccountClient = SubAccountClient(\n            secret_key=self._secret_key\n        )\n        self.subscriptions: SubscriptionClient = SubscriptionClient(\n            secret_key=self._secret_key\n        )\n        self.terminals: TerminalClient = TerminalClient(secret_key=self._secret_key)\n        self.transactions: TransactionClient = TransactionClient(\n            secret_key=self._secret_key\n        )\n        self.transfer_recipients: TransferRecipientClient = TransferRecipientClient(\n            secret_key=self._secret_key\n        )\n        self.transfers: TransferClient = TransferClient(secret_key=self._secret_key)\n        self.transfer_control: TransferControlClient = TransferControlClient(\n            secret_key=self._secret_key\n        )\n        self.verification: VerificationClient = VerificationClient(\n            secret_key=self._secret_key\n        )\n</code></pre>"},{"location":"reference/#sub-clients-pypaystack2sub_clients","title":"sub-clients <code>pypaystack2.sub_clients</code>","text":"<ul> <li>ApplePay &amp; AsyncApplePay</li> <li>BulkCharge &amp; AsyncBulkCharge</li> <li>Charge &amp; AsyncCharge</li> <li>Integration &amp; AsyncIntegration</li> <li>Customer &amp; AsyncCustomer</li> <li>DedicatedAccount &amp; AsyncDedicatedAccount</li> <li>Dispute &amp; AsyncDispute</li> <li>PaymentRequest &amp; AsyncPaymentRequest</li> <li>Miscellaneous &amp; AsyncMiscellaneous</li> <li>PaymentPage &amp; AsyncPaymentPage</li> <li>Plan &amp; AsyncPlan</li> <li>Product &amp; AsyncProduct</li> <li>Refund &amp; AsyncRefund</li> <li>Settlement &amp; AsyncSettlement</li> <li>Split &amp; AsyncSplit</li> <li>SubAccount &amp; AsyncSubAccount</li> <li>Subscription &amp; AsyncSubscription</li> <li>Terminal &amp; AsyncTerminal</li> <li>Transaction &amp; AsyncTransaction</li> <li>TransferRecipient &amp; AsyncTransferRecipient</li> <li>Transfer &amp; AsyncTransfer</li> <li>TransferControl &amp; AsyncTransferControl</li> <li>Verification &amp; AsyncVerification</li> </ul>"},{"location":"reference/#pypaystack2enums","title":"<code>pypaystack2.enums</code>","text":""},{"location":"reference/#pypaystack2.enums.AccountType","title":"<code>AccountType</code>","text":"<p>               Bases: <code>StrEnum</code></p> <p>Enum of Account types supported by paystack</p> Source code in <code>src/pypaystack2/enums.py</code> <pre><code>class AccountType(StrEnum):\n    \"\"\"Enum of Account types supported by paystack\"\"\"\n\n    PERSONAL = \"personal\"\n    BUSINESS = \"business\"\n</code></pre>"},{"location":"reference/#pypaystack2.enums.BankType","title":"<code>BankType</code>","text":"<p>               Bases: <code>StrEnum</code></p> <p>Enum of bank types</p> Source code in <code>src/pypaystack2/enums.py</code> <pre><code>class BankType(StrEnum):\n    \"\"\"Enum of bank types\"\"\"\n\n    GHIPPS = \"ghipps\"\n    MOBILE_MONEY = \"mobile_money\"\n</code></pre>"},{"location":"reference/#pypaystack2.enums.Bearer","title":"<code>Bearer</code>","text":"<p>               Bases: <code>StrEnum</code></p> <p>Enum for who bears paystack charges</p> Source code in <code>src/pypaystack2/enums.py</code> <pre><code>class Bearer(StrEnum):\n    \"\"\"Enum for who bears paystack charges\"\"\"\n\n    ACCOUNT = \"account\"\n    SUB_ACCOUNT = \"subaccount\"\n    ALL_PROPORTIONAL = \"all-proportional\"\n    ALL = \"all\"\n</code></pre>"},{"location":"reference/#pypaystack2.enums.Channel","title":"<code>Channel</code>","text":"<p>               Bases: <code>StrEnum</code></p> <p>Enum of payment channels supported by paystack</p> Source code in <code>src/pypaystack2/enums.py</code> <pre><code>class Channel(StrEnum):\n    \"\"\"Enum of payment channels supported by paystack\"\"\"\n\n    CARD = \"card\"\n    BANK = \"bank\"\n    USSD = \"ussd\"\n    QR = \"qr\"\n    MOBILE_MONEY = \"mobile_money\"\n    BANK_TRANSFER = \"bank_transfer\"\n</code></pre>"},{"location":"reference/#pypaystack2.enums.Country","title":"<code>Country</code>","text":"<p>               Bases: <code>StrEnum</code></p> <p>Enum of countries supported by paystack</p> Source code in <code>src/pypaystack2/enums.py</code> <pre><code>class Country(StrEnum):\n    \"\"\"Enum of countries supported by paystack\"\"\"\n\n    NIGERIA = \"NG\"\n    GHANA = \"GH\"\n    SOUTH_AFRICA = \"ZA\"\n    KENYA = \"KE\"\n    COTE_D_IVOIRE = \"CI\"\n    EGYPT = \"EG\"\n    RWANDA = \"RW\"\n\n    @staticmethod\n    def get_full(value: str) -&gt; str | None:\n        \"\"\"Returns paystack supported country name in full lowercase\n\n        Args:\n            value: The two-digit iso name of the country.\n\n        Returns:\n            The name of the country in lowercase if it is supported by\n            paystack or none.\n        \"\"\"\n        value = value.lower()\n        return {\n            \"ng\": \"nigeria\",\n            \"gh\": \"ghana\",\n            \"za\": \"south africa\",\n            \"ke\": \"kenya\",\n            \"ci\": \"c\u00f4te d'ivoire\",\n            \"eg\": \"egypt\",\n            \"rw\": \"rwanda\",\n        }.get(value)\n</code></pre>"},{"location":"reference/#pypaystack2.enums.Country.get_full","title":"<code>get_full(value)</code>  <code>staticmethod</code>","text":"<p>Returns paystack supported country name in full lowercase</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>The two-digit iso name of the country.</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>The name of the country in lowercase if it is supported by</p> <code>str | None</code> <p>paystack or none.</p> Source code in <code>src/pypaystack2/enums.py</code> <pre><code>@staticmethod\ndef get_full(value: str) -&gt; str | None:\n    \"\"\"Returns paystack supported country name in full lowercase\n\n    Args:\n        value: The two-digit iso name of the country.\n\n    Returns:\n        The name of the country in lowercase if it is supported by\n        paystack or none.\n    \"\"\"\n    value = value.lower()\n    return {\n        \"ng\": \"nigeria\",\n        \"gh\": \"ghana\",\n        \"za\": \"south africa\",\n        \"ke\": \"kenya\",\n        \"ci\": \"c\u00f4te d'ivoire\",\n        \"eg\": \"egypt\",\n        \"rw\": \"rwanda\",\n    }.get(value)\n</code></pre>"},{"location":"reference/#pypaystack2.enums.Currency","title":"<code>Currency</code>","text":"<p>               Bases: <code>StrEnum</code></p> <p>Enum of currencies supported by paystack.</p> Source code in <code>src/pypaystack2/enums.py</code> <pre><code>class Currency(StrEnum):\n    \"\"\"Enum of currencies supported by paystack.\"\"\"\n\n    NGN = \"NGN\"\n    GHS = \"GHS\"\n    ZAR = \"ZAR\"\n    USD = \"USD\"\n    KES = \"KES\"\n    XOF = \"XOF\"\n    EGP = \"EGP\"\n    RWF = \"RWF\"\n</code></pre>"},{"location":"reference/#pypaystack2.enums.DisputeStatus","title":"<code>DisputeStatus</code>","text":"<p>               Bases: <code>StrEnum</code></p> <p>Enum of dispute status supported by paystack</p> Source code in <code>src/pypaystack2/enums.py</code> <pre><code>class DisputeStatus(StrEnum):\n    \"\"\"Enum of dispute status supported by paystack\"\"\"\n\n    PENDING = \"pending\"\n    RESOLVED = \"resolved\"\n    AWAITING_BANK_FEEDBACK = \"awaiting-bank-feedback\"\n    AWAITING_MERCHANT_FEEDBACK = \"awaiting-merchant-feedback\"\n    ARCHIVED = \"archived\"\n</code></pre>"},{"location":"reference/#pypaystack2.enums.Document","title":"<code>Document</code>","text":"<p>               Bases: <code>StrEnum</code></p> <p>Enum of Document types supported by paystack</p> Source code in <code>src/pypaystack2/enums.py</code> <pre><code>class Document(StrEnum):\n    \"\"\"Enum of Document types supported by paystack\"\"\"\n\n    IDENTITY_NUMBER = \"identityNumber\"\n    PASSPORT_NUMBER = \"passportNumber\"\n    BUSINESS_REGISTRATION_NUMBER = \"businessRegistrationNumber\"\n</code></pre>"},{"location":"reference/#pypaystack2.enums.Gateway","title":"<code>Gateway</code>","text":"<p>               Bases: <code>StrEnum</code></p> <p>Enum of bank gateways supported by paystack</p> Source code in <code>src/pypaystack2/enums.py</code> <pre><code>class Gateway(StrEnum):\n    \"\"\"Enum of bank gateways supported by paystack\"\"\"\n\n    EMANDATE = \"emandate\"\n    DIGITALBANKMANDATE = \"digitalbankmandate\"\n</code></pre>"},{"location":"reference/#pypaystack2.enums.Identification","title":"<code>Identification</code>","text":"<p>               Bases: <code>StrEnum</code></p> <p>Enum of Identification methods supported by paystack</p> Source code in <code>src/pypaystack2/enums.py</code> <pre><code>class Identification(StrEnum):\n    \"\"\"Enum of Identification methods supported by paystack\"\"\"\n\n    BVN = \"bvn\"\n    BANK_ACCOUNT = \"bank_account\"\n</code></pre>"},{"location":"reference/#pypaystack2.enums.Interval","title":"<code>Interval</code>","text":"<p>               Bases: <code>StrEnum</code></p> <p>Enum of intervals supported by paystack.</p> Source code in <code>src/pypaystack2/enums.py</code> <pre><code>class Interval(StrEnum):\n    \"\"\"Enum of intervals supported by paystack.\"\"\"\n\n    HOURLY = \"hourly\"\n    DAILY = \"daily\"\n    WEEKLY = \"weekly\"\n    MONTHLY = \"monthly\"\n    QUARTERLY = \"quarterly\"\n    BIANNUALLY = \"biannually\"\n    ANNUALLY = \"annually\"\n</code></pre>"},{"location":"reference/#pypaystack2.enums.Reason","title":"<code>Reason</code>","text":"<p>               Bases: <code>StrEnum</code></p> <p>Enum of Reset OTP options</p> Source code in <code>src/pypaystack2/enums.py</code> <pre><code>class Reason(StrEnum):\n    \"\"\"Enum of Reset OTP options\"\"\"\n\n    RESEND_OTP = \"resend_otp\"\n    TRANSFER = \"transfer\"\n    DISABLE_OTP = \"disable_otp\"\n</code></pre>"},{"location":"reference/#pypaystack2.enums.RecipientType","title":"<code>RecipientType</code>","text":"<p>               Bases: <code>StrEnum</code></p> <p>Enum of Transfer Recipient types</p> Source code in <code>src/pypaystack2/enums.py</code> <pre><code>class RecipientType(StrEnum):\n    \"\"\"Enum of Transfer Recipient types\"\"\"\n\n    NUBAN = \"nuban\"\n    MOBILE_MONEY = \"mobile_money\"\n    BASA = \"basa\"\n</code></pre>"},{"location":"reference/#pypaystack2.enums.Resolution","title":"<code>Resolution</code>","text":"<p>               Bases: <code>StrEnum</code></p> <p>Enum of Resolutions supported by paystack</p> Source code in <code>src/pypaystack2/enums.py</code> <pre><code>class Resolution(StrEnum):\n    \"\"\"Enum of Resolutions supported by paystack\"\"\"\n\n    MERCHANT_ACCEPTED = \"merchant-accepted\"\n    DECLINED = \"declined\"\n</code></pre>"},{"location":"reference/#pypaystack2.enums.RiskAction","title":"<code>RiskAction</code>","text":"<p>               Bases: <code>StrEnum</code></p> <p>Enum of RiskActions supported by paystack</p> Source code in <code>src/pypaystack2/enums.py</code> <pre><code>class RiskAction(StrEnum):\n    \"\"\"Enum of RiskActions supported by paystack\"\"\"\n\n    DEFAULT = \"default\"\n    WHITELIST = \"allow\"\n    BLACKLIST = \"deny\"\n</code></pre>"},{"location":"reference/#pypaystack2.enums.Schedule","title":"<code>Schedule</code>","text":"<p>               Bases: <code>StrEnum</code></p> <p>Enum of settlement schedules supported by paystack</p> Source code in <code>src/pypaystack2/enums.py</code> <pre><code>class Schedule(StrEnum):\n    \"\"\"Enum of settlement schedules supported by paystack\"\"\"\n\n    AUTO = \"auto\"\n    WEEKLY = \"weekly\"\n    MONTHLY = \"monthly\"\n    MANUAL = \"manual\"\n</code></pre>"},{"location":"reference/#pypaystack2.enums.Split","title":"<code>Split</code>","text":"<p>               Bases: <code>StrEnum</code></p> <p>Enum of split types</p> Source code in <code>src/pypaystack2/enums.py</code> <pre><code>class Split(StrEnum):\n    \"\"\"Enum of split types\"\"\"\n\n    PERCENTAGE = \"percentage\"\n    FLAT = \"flat\"\n</code></pre>"},{"location":"reference/#pypaystack2.enums.Status","title":"<code>Status</code>","text":"<p>               Bases: <code>StrEnum</code></p> <p>Enum of statuses supported by paystack, used by Invoice, Charge &amp; Plan</p> Source code in <code>src/pypaystack2/enums.py</code> <pre><code>class Status(StrEnum):\n    \"\"\"Enum of statuses supported by paystack, used by Invoice, Charge &amp; Plan\"\"\"\n\n    PENDING = \"pending\"\n    SUCCESS = \"success\"\n    FAILED = \"failed\"\n</code></pre>"},{"location":"reference/#pypaystack2.enums.TerminalEvent","title":"<code>TerminalEvent</code>","text":"<p>               Bases: <code>StrEnum</code></p> <p>Enum of the types of events supported by Terminal API</p> Source code in <code>src/pypaystack2/enums.py</code> <pre><code>class TerminalEvent(StrEnum):\n    \"\"\"Enum of the types of events supported by Terminal API\"\"\"\n\n    TRANSACTION = \"transaction\"\n    INVOICE = \"invoice\"\n</code></pre>"},{"location":"reference/#pypaystack2.enums.TransactionStatus","title":"<code>TransactionStatus</code>","text":"<p>               Bases: <code>StrEnum</code></p> <p>Enum of transaction status</p> Source code in <code>src/pypaystack2/enums.py</code> <pre><code>class TransactionStatus(StrEnum):\n    \"\"\"Enum of transaction status\"\"\"\n\n    FAILED = \"failed\"\n    SUCCESS = \"success\"\n    ABANDONED = \"abandoned\"\n</code></pre>"},{"location":"reference/#pypaystack2models","title":"<code>pypaystack2.models</code>","text":""},{"location":"reference/#pypaystack2.models.BulkChargeInstruction","title":"<code>BulkChargeInstruction</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A dataclass for bulk charge instruction.</p> <p>Attributes:</p> Name Type Description <code>authorization</code> <code>str</code> <p>The authorization code of the customer you want to charge.</p> <code>amount</code> <code>int</code> <p>The amount you want to charge.</p> <code>reference</code> <code>str</code> <p>The transaction reference.</p> Source code in <code>src/pypaystack2/models/payload_models.py</code> <pre><code>class BulkChargeInstruction(BaseModel):\n    \"\"\"A dataclass for bulk charge instruction.\n\n    Attributes:\n        authorization: The authorization code of the customer you want to charge.\n        amount: The amount you want to charge.\n        reference: The transaction reference.\n    \"\"\"\n\n    authorization: str\n    amount: int\n    reference: str\n</code></pre>"},{"location":"reference/#pypaystack2.models.LineItem","title":"<code>LineItem</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A dataclass for LineItem.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the product.</p> <code>amount</code> <code>int</code> <p>The price of the product.</p> <code>quantity</code> <code>int</code> <p>The quantity.</p> Source code in <code>src/pypaystack2/models/payload_models.py</code> <pre><code>class LineItem(BaseModel):\n    \"\"\"A dataclass for LineItem.\n\n    Attributes:\n        name: The name of the product.\n        amount: The price of the product.\n        quantity: The quantity.\n    \"\"\"\n\n    name: str\n    amount: int\n    quantity: int\n</code></pre>"},{"location":"reference/#pypaystack2.models.Recipient","title":"<code>Recipient</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A model for representing Transfer Recipients.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>RecipientType</code> <p>Recipient Type. any value from the <code>RecipientType</code> enum</p> <code>name</code> <code>str</code> <p>A name for the recipient</p> <code>account_number</code> <code>str</code> <p>Required if <code>type</code> is <code>RecipientType.NUBAN</code> or <code>RecipientType.BASA</code></p> <code>bank_code</code> <code>str | None</code> <p>Required if <code>type</code> is <code>RecipientType.NUBAN</code> or <code>RecipientType.BASA</code>. You can get the list of Bank Codes by calling the <code>PaystackClient.get_banks</code>.</p> <code>description</code> <code>str | None</code> <p>description</p> <code>currency</code> <code>Currency | None</code> <p>currency</p> <code>auth_code</code> <code>str | None</code> <p>auth code</p> <code>metadata</code> <code>dict[str, Any] | None</code> <p>metadata</p> Source code in <code>src/pypaystack2/models/payload_models.py</code> <pre><code>class Recipient(BaseModel):\n    \"\"\"A model for representing Transfer Recipients.\n\n    Attributes:\n        type: Recipient Type. any value from the `RecipientType` enum\n        name: A name for the recipient\n        account_number: Required if `type` is `RecipientType.NUBAN` or `RecipientType.BASA`\n        bank_code: Required if `type` is `RecipientType.NUBAN` or `RecipientType.BASA`.\n            You can get the list of Bank Codes by calling the `PaystackClient.get_banks`.\n        description: description\n        currency: currency\n        auth_code: auth code\n        metadata: metadata\n    \"\"\"\n\n    type: RecipientType\n    name: str\n    account_number: str\n    bank_code: str | None = None\n    description: str | None = None\n    currency: Currency | None = None\n    auth_code: str | None = None\n    metadata: dict[str, Any] | None = None\n</code></pre>"},{"location":"reference/#pypaystack2.models.Response","title":"<code>Response</code>","text":"<p>               Bases: <code>BaseModel</code>, <code>Generic[PaystackResponseData]</code></p> <p>A pydantic model containing the data gotten from making a request to paystack's API endpoints.</p> <p>All client methods that make API calls to paystack returns an instance of <code>Response</code></p> <p>Attributes:</p> Name Type Description <code>status_code</code> <code>HTTPStatus</code> <p>The response status code</p> <code>status</code> <code>bool</code> <p>A flag for the response status</p> <code>message</code> <code>str</code> <p>Paystack response message</p> <code>data</code> <code>PaystackResponseData</code> <p>Data sent from paystack's server if any. This data is of a generic type called <code>PaystackDataModel</code> indicating that data can either be a pydantic model instance, a list of pydantic model instances or <code>None</code>. The exact type of the data can be determined by looking at the return type of the client method that you called that returns a <code>Response</code>. E.g. <code>PaystackClient.bulk_charges.get_batches</code> method has its return type as <code>Response[list[BulkCharge]]</code>, hence, if you called this method and got a <code>Response</code>, even though <code>Response.data</code> is type hinted as <code>PaystackDataModel</code>, you should expect <code>Response.data</code> to be <code>list[BulkCharge]</code> which is a list of <code>BulkCharge</code> pydantic model instances which is a valid <code>PaystackDataModel</code>. A client method with a return type of <code>Response[None]</code> indicates that no data is expected to be returned from paystack by calling that method, hence, <code>Response.data</code> is <code>None</code>. If <code>Response.data</code> is <code>None</code> when the client method does not explicitly specify that the return type of the method at <code>Response[None]</code>, this is an indicator that the library has failed to serialize the data returned from paystack into the <code>PaystackDataModel</code> (pydantic model) defined by the library. The data that failed to be serialized is still available via <code>Response.raw</code>. You may choose to override the type of <code>Response.data</code> by specifying a custom pydantic model class implemented by you or inheriting the model from the library and overriding the faulty fields and passing the custom class via the <code>alternate_response_model</code> parameter of the client methods that return a Response. As a result of this, they type of data is either an instance  or a list of instances of the custom pydantic model depending on if the client method is supposed to return a list or a single resource.</p> <code>meta</code> <code>dict[str, Any] | None</code> <p>Additional information about the response.</p> <code>type</code> <code>str | None</code> <p>In cases where the response has a status of <code>False</code> or the status code is an error status code. the <code>type</code> field indicates the type of error e.g. <code>api_error</code></p> <code>code</code> <code>str | None</code> <p>In cases where the response has a status of <code>False</code> or the status code is an error status code. the <code>type</code> field indicates the type of error e.g. <code>api_error</code></p> <code>raw</code> <code>dict[str, Any] | list[dict[str, Any]] | bytes | None</code> <p>The original data returned by paystack in native python types i.e. the JSON data returned from paystack REST APIs have only been converted to dicts or list. This is the same data that is further extracted into individual fields such as <code>status</code>, <code>message</code>, <code>data</code> e.t.c and also serialized to pydantic models in the case of <code>Response.data</code>.</p> Source code in <code>src/pypaystack2/models/response_models.py</code> <pre><code>class Response(BaseModel, Generic[PaystackResponseData]):\n    \"\"\"\n    A pydantic model containing the data gotten from making a request to paystack's API endpoints.\n\n    All client methods that make API calls to paystack returns an instance of `Response`\n\n    Attributes:\n        status_code: The response status code\n        status: A flag for the response status\n        message: Paystack response message\n        data: Data sent from paystack's server if any. This data is of a generic type called `PaystackDataModel`\n            indicating that data can either be a pydantic model instance, a list of pydantic model instances or\n            `None`. The exact type of the data can be determined by looking at the return type of the client method\n            that you called that returns a `Response`. E.g. `PaystackClient.bulk_charges.get_batches` method has\n            its return type as `Response[list[BulkCharge]]`, hence, if you called this method and got a `Response`,\n            even though `Response.data` is type hinted as `PaystackDataModel`, you should expect `Response.data` to\n            be `list[BulkCharge]` which is a list of `BulkCharge` pydantic model instances which is a valid\n            `PaystackDataModel`. A client method with a return type of `Response[None]` indicates that no data is\n            expected to be returned from paystack by calling that method, hence, `Response.data` is `None`. If\n            `Response.data` is `None` when the client method does not explicitly specify that the return type of\n            the method at `Response[None]`, this is an indicator that the library has failed to serialize the\n            data returned from paystack into the `PaystackDataModel` (pydantic model) defined by the library.\n            The data that failed to be serialized is still available via `Response.raw`. You may choose to override\n            the type of `Response.data` by specifying a custom pydantic model class implemented by you or inheriting\n            the model from the library and overriding the faulty fields and passing the custom class via the\n            `alternate_response_model` parameter of the client methods that return a Response.\n            As a result of this, they type of data is either an instance  or a list of instances of the custom\n            pydantic model depending on if the client method is supposed to return a list or a single resource.\n        meta: Additional information about the response.\n        type: In cases where the response has a status of `False` or the status code\n            is an error status code. the `type` field indicates the type of error e.g. `api_error`\n        code: In cases where the response has a status of `False` or the status code\n            is an error status code. the `type` field indicates the type of error e.g. `api_error`\n        raw: The original data returned by paystack in native python types i.e. the JSON data returned\n            from paystack REST APIs have only been converted to dicts or list. This is the same data\n            that is further extracted into individual fields such as `status`, `message`, `data` e.t.c\n            and also serialized to pydantic models in the case of `Response.data`.\n    \"\"\"\n\n    status_code: HTTPStatus\n    status: bool\n    message: str\n    data: PaystackResponseData\n    meta: dict[str, Any] | None\n    type: str | None\n    code: str | None\n    raw: dict[str, Any] | list[dict[str, Any]] | bytes | None\n</code></pre>"},{"location":"reference/#pypaystack2.models.SplitAccount","title":"<code>SplitAccount</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A dataclass for SplitAccount.</p> <p>Attributes:</p> Name Type Description <code>subaccount</code> <code>str</code> <p>The id of the sub account.</p> <code>share</code> <code>int | float</code> <p>The share of the split account the sub account should have.</p> Source code in <code>src/pypaystack2/models/payload_models.py</code> <pre><code>class SplitAccount(BaseModel):\n    \"\"\"A dataclass for SplitAccount.\n\n    Attributes:\n        subaccount: The id of the sub account.\n        share: The share of the split account the sub account should have.\n    \"\"\"\n\n    subaccount: str\n    share: int | float\n</code></pre>"},{"location":"reference/#pypaystack2.models.Tax","title":"<code>Tax</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A dataclass for Tax.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the tax.</p> <code>amount</code> <code>int</code> <p>The price of the tax.</p> Source code in <code>src/pypaystack2/models/payload_models.py</code> <pre><code>class Tax(BaseModel):\n    \"\"\"A dataclass for Tax.\n\n    Attributes:\n        name: The name of the tax.\n        amount: The price of the tax.\n    \"\"\"\n\n    name: str\n    amount: int\n</code></pre>"},{"location":"reference/#pypaystack2.models.TransferInstruction","title":"<code>TransferInstruction</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A dataclass for TransferInstruction.</p> <p>Attributes:</p> Name Type Description <code>amount</code> <code>int</code> <p>The amount to be transferred.</p> <code>recipient</code> <code>str</code> <p>The beneficiary of the transaction.</p> <code>reference</code> <code>Optional[str]</code> <p>The reference for the transaction.</p> <code>reason</code> <code>Optional[str]</code> <p>The narration of the transaction.</p> Source code in <code>src/pypaystack2/models/payload_models.py</code> <pre><code>class TransferInstruction(BaseModel):\n    \"\"\"A dataclass for TransferInstruction.\n\n    Attributes:\n        amount: The amount to be transferred.\n        recipient: The beneficiary of the transaction.\n        reference: The reference for the transaction.\n        reason: The narration of the transaction.\n    \"\"\"\n\n    amount: int\n    recipient: str\n    reference: Optional[str]\n    reason: Optional[str]\n</code></pre>"},{"location":"reference/#pypaystack2exceptions","title":"<code>pypaystack2.exceptions</code>","text":""},{"location":"reference/#pypaystack2.exceptions.ClientNetworkError","title":"<code>ClientNetworkError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Custom exception for wrapping httpx-related errors.</p> Source code in <code>src/pypaystack2/exceptions.py</code> <pre><code>class ClientNetworkError(Exception):\n    \"\"\"Custom exception for wrapping httpx-related errors.\"\"\"\n\n    def __init__(self, message: str, original_exception: Exception | None = None):\n        super().__init__(message)\n        self.original_exception = (\n            original_exception  # Store the original exception for debugging\n        )\n</code></pre>"},{"location":"reference/#pypaystack2.exceptions.MissingSecretKeyException","title":"<code>MissingSecretKeyException</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Custom exception raised when we can't find the secret key</p> Source code in <code>src/pypaystack2/exceptions.py</code> <pre><code>class MissingSecretKeyException(Exception):\n    \"\"\"Custom exception raised when we can't find the secret key\"\"\"\n\n    ...\n</code></pre>"},{"location":"reference/apple_pay/","title":"Apple pay","text":""},{"location":"reference/apple_pay/#pypaystack2.sub_clients.sync_clients.apple_pay.ApplePayClient","title":"<code>ApplePayClient</code>","text":"<p>               Bases: <code>BaseAPIClient</code></p> <p>Provides a wrapper for paystack Apple Pay API</p> <p>The Apple Pay API allows you to register your application's top-level domain or subdomain. see https://paystack.com/docs/api/apple-pay/</p> <p>Note   This feature is available to businesses in all markets except South Africa.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/apple_pay.py</code> <pre><code>class ApplePayClient(BaseAPIClient):\n    \"\"\"Provides a wrapper for paystack Apple Pay API\n\n    The Apple Pay API allows you to register your application's top-level domain or subdomain.\n    see https://paystack.com/docs/api/apple-pay/\n\n    Note\n      This feature is available to businesses in all markets except South Africa.\n    \"\"\"\n\n    def register_domain(\n        self,\n        domain_name: str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[None] | Response[PaystackDataModel]:\n        \"\"\"Register a top-level domain or subdomain for your Apple Pay integration.\n\n        Note:\n            * This method can only be called with one domain or subdomain at a time.\n            * This feature is available to businesses in all markets except South Africa.\n\n\n        Args:\n            domain_name: Domain name to be registered.\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(\"/apple-pay/domain\")\n        payload = {\n            \"domainName\": domain_name,\n        }\n        return self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class,\n        )\n\n    def get_domains(\n        self,\n        use_cursor: bool = False,\n        next_: str | None = None,\n        previous: str | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[ApplePayDomains] | Response[PaystackDataModel]:\n        \"\"\"Fetches all registered domains on your integration.\n\n        Note\n            * This feature is available to businesses in all markets except South Africa.\n\n        Args:\n            use_cursor:\n            next_:\n            previous:\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(\"/apple-pay/domain\")\n        query_params = [\n            (\"use_cursor\", use_cursor),\n            (\"next\", next_),\n            (\"previous\", previous),\n        ]\n        url = append_query_params(query_params, url)\n        return self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or ApplePayDomains,\n        )\n\n    def unregister_domain(\n        self,\n        domain_name: str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[None] | Response[PaystackDataModel]:\n        \"\"\"Unregister a top-level domain or subdomain previously used for your Apple Pay integration.\n\n        Args:\n            domain_name: Domain name to be unregistered\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Note\n            * This feature is available to businesses in all markets except South Africa.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(\"/apple-pay/domain\")\n        payload = {\n            \"domainName\": domain_name,\n        }\n        raw_response = httpx.request(\n            HTTPMethod.DELETE, url, json=payload, headers=self._headers\n        )\n        return self._deserialize_response(  # type: ignore\n            raw_response,\n            response_data_model_class=alternate_model_class,\n        )\n</code></pre>"},{"location":"reference/apple_pay/#pypaystack2.sub_clients.sync_clients.apple_pay.ApplePayClient.get_domains","title":"<code>get_domains(use_cursor=False, next_=None, previous=None, alternate_model_class=None)</code>","text":"<p>Fetches all registered domains on your integration.</p> <p>Note     * This feature is available to businesses in all markets except South Africa.</p> <p>Parameters:</p> Name Type Description Default <code>use_cursor</code> <code>bool</code> <code>False</code> <code>next_</code> <code>str | None</code> <code>None</code> <code>previous</code> <code>str | None</code> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[ApplePayDomains] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/apple_pay.py</code> <pre><code>def get_domains(\n    self,\n    use_cursor: bool = False,\n    next_: str | None = None,\n    previous: str | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[ApplePayDomains] | Response[PaystackDataModel]:\n    \"\"\"Fetches all registered domains on your integration.\n\n    Note\n        * This feature is available to businesses in all markets except South Africa.\n\n    Args:\n        use_cursor:\n        next_:\n        previous:\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(\"/apple-pay/domain\")\n    query_params = [\n        (\"use_cursor\", use_cursor),\n        (\"next\", next_),\n        (\"previous\", previous),\n    ]\n    url = append_query_params(query_params, url)\n    return self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or ApplePayDomains,\n    )\n</code></pre>"},{"location":"reference/apple_pay/#pypaystack2.sub_clients.sync_clients.apple_pay.ApplePayClient.register_domain","title":"<code>register_domain(domain_name, alternate_model_class=None)</code>","text":"<p>Register a top-level domain or subdomain for your Apple Pay integration.</p> Note <ul> <li>This method can only be called with one domain or subdomain at a time.</li> <li>This feature is available to businesses in all markets except South Africa.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>domain_name</code> <code>str</code> <p>Domain name to be registered.</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[None] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/apple_pay.py</code> <pre><code>def register_domain(\n    self,\n    domain_name: str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[None] | Response[PaystackDataModel]:\n    \"\"\"Register a top-level domain or subdomain for your Apple Pay integration.\n\n    Note:\n        * This method can only be called with one domain or subdomain at a time.\n        * This feature is available to businesses in all markets except South Africa.\n\n\n    Args:\n        domain_name: Domain name to be registered.\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(\"/apple-pay/domain\")\n    payload = {\n        \"domainName\": domain_name,\n    }\n    return self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class,\n    )\n</code></pre>"},{"location":"reference/apple_pay/#pypaystack2.sub_clients.sync_clients.apple_pay.ApplePayClient.unregister_domain","title":"<code>unregister_domain(domain_name, alternate_model_class=None)</code>","text":"<p>Unregister a top-level domain or subdomain previously used for your Apple Pay integration.</p> <p>Parameters:</p> Name Type Description Default <code>domain_name</code> <code>str</code> <p>Domain name to be unregistered</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Note     * This feature is available to businesses in all markets except South Africa.</p> <p>Returns:</p> Type Description <code>Response[None] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/apple_pay.py</code> <pre><code>def unregister_domain(\n    self,\n    domain_name: str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[None] | Response[PaystackDataModel]:\n    \"\"\"Unregister a top-level domain or subdomain previously used for your Apple Pay integration.\n\n    Args:\n        domain_name: Domain name to be unregistered\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Note\n        * This feature is available to businesses in all markets except South Africa.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(\"/apple-pay/domain\")\n    payload = {\n        \"domainName\": domain_name,\n    }\n    raw_response = httpx.request(\n        HTTPMethod.DELETE, url, json=payload, headers=self._headers\n    )\n    return self._deserialize_response(  # type: ignore\n        raw_response,\n        response_data_model_class=alternate_model_class,\n    )\n</code></pre>"},{"location":"reference/apple_pay/#pypaystack2.sub_clients.async_clients.apple_pay.AsyncApplePayClient","title":"<code>AsyncApplePayClient</code>","text":"<p>               Bases: <code>BaseAsyncAPIClient</code></p> <p>Provides a wrapper for paystack Apple Pay API</p> <p>The Apple Pay API allows you to register your application's top-level domain or subdomain. Visit paystack sub_clients doc</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/apple_pay.py</code> <pre><code>class AsyncApplePayClient(BaseAsyncAPIClient):\n    \"\"\"Provides a wrapper for paystack Apple Pay API\n\n    The Apple Pay API allows you to register your application's top-level domain or subdomain.\n    [Visit paystack sub_clients doc](https://paystack.com/docs/api/apple-pay/)\n    \"\"\"\n\n    async def register_domain(\n        self,\n        domain_name: str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[None] | Response[PaystackDataModel]:\n        \"\"\"Register a top-level domain or subdomain for your Apple Pay integration.\n\n        This method can only be called with one domain or subdomain at a time.\n\n        Args:\n            domain_name: Domain name to be registered.\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(\"/apple-pay/domain\")\n        payload = {\n            \"domainName\": domain_name,\n        }\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class,\n        )\n\n    async def get_domains(\n        self,\n        use_cursor: bool = False,\n        next_: str | None = None,\n        previous: str | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[ApplePayDomains] | Response[PaystackDataModel]:\n        \"\"\"Fetches all registered domains on your integration.\n\n        Note\n            * This feature is available to businesses in all markets except South Africa.\n\n        Args:\n            use_cursor:\n            next_:\n            previous:\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(\"/apple-pay/domain\")\n        query_params = [\n            (\"use_cursor\", use_cursor),\n            (\"next\", next_),\n            (\"previous\", previous),\n        ]\n        url = append_query_params(query_params, url)\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or ApplePayDomains,\n        )\n\n    async def unregister_domain(\n        self,\n        domain_name: str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[None] | Response[PaystackDataModel]:\n        \"\"\"Unregister a top-level domain or subdomain previously used for your Apple Pay integration.\n\n        Args:\n            domain_name: Domain name to be unregistered\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Note\n             * This feature is available to businesses in all markets except South Africa.\n\n         Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(\"/apple-pay/domain\")\n        payload = {\n            \"domainName\": domain_name,\n        }\n        async with httpx.AsyncClient() as client:\n            raw_response = await client.request(\n                HTTPMethod.DELETE, url, json=payload, headers=self._headers\n            )\n        return self._deserialize_response(  # type: ignore\n            raw_response,\n            response_data_model_class=alternate_model_class,\n        )\n</code></pre>"},{"location":"reference/apple_pay/#pypaystack2.sub_clients.async_clients.apple_pay.AsyncApplePayClient.get_domains","title":"<code>get_domains(use_cursor=False, next_=None, previous=None, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Fetches all registered domains on your integration.</p> <p>Note     * This feature is available to businesses in all markets except South Africa.</p> <p>Parameters:</p> Name Type Description Default <code>use_cursor</code> <code>bool</code> <code>False</code> <code>next_</code> <code>str | None</code> <code>None</code> <code>previous</code> <code>str | None</code> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[ApplePayDomains] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/apple_pay.py</code> <pre><code>async def get_domains(\n    self,\n    use_cursor: bool = False,\n    next_: str | None = None,\n    previous: str | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[ApplePayDomains] | Response[PaystackDataModel]:\n    \"\"\"Fetches all registered domains on your integration.\n\n    Note\n        * This feature is available to businesses in all markets except South Africa.\n\n    Args:\n        use_cursor:\n        next_:\n        previous:\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(\"/apple-pay/domain\")\n    query_params = [\n        (\"use_cursor\", use_cursor),\n        (\"next\", next_),\n        (\"previous\", previous),\n    ]\n    url = append_query_params(query_params, url)\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or ApplePayDomains,\n    )\n</code></pre>"},{"location":"reference/apple_pay/#pypaystack2.sub_clients.async_clients.apple_pay.AsyncApplePayClient.register_domain","title":"<code>register_domain(domain_name, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Register a top-level domain or subdomain for your Apple Pay integration.</p> <p>This method can only be called with one domain or subdomain at a time.</p> <p>Parameters:</p> Name Type Description Default <code>domain_name</code> <code>str</code> <p>Domain name to be registered.</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[None] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/apple_pay.py</code> <pre><code>async def register_domain(\n    self,\n    domain_name: str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[None] | Response[PaystackDataModel]:\n    \"\"\"Register a top-level domain or subdomain for your Apple Pay integration.\n\n    This method can only be called with one domain or subdomain at a time.\n\n    Args:\n        domain_name: Domain name to be registered.\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(\"/apple-pay/domain\")\n    payload = {\n        \"domainName\": domain_name,\n    }\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class,\n    )\n</code></pre>"},{"location":"reference/apple_pay/#pypaystack2.sub_clients.async_clients.apple_pay.AsyncApplePayClient.unregister_domain","title":"<code>unregister_domain(domain_name, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Unregister a top-level domain or subdomain previously used for your Apple Pay integration.</p> <p>Parameters:</p> Name Type Description Default <code>domain_name</code> <code>str</code> <p>Domain name to be unregistered</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Note      * This feature is available to businesses in all markets except South Africa.</p> <p>Returns:     A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/apple_pay.py</code> <pre><code>async def unregister_domain(\n    self,\n    domain_name: str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[None] | Response[PaystackDataModel]:\n    \"\"\"Unregister a top-level domain or subdomain previously used for your Apple Pay integration.\n\n    Args:\n        domain_name: Domain name to be unregistered\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Note\n         * This feature is available to businesses in all markets except South Africa.\n\n     Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(\"/apple-pay/domain\")\n    payload = {\n        \"domainName\": domain_name,\n    }\n    async with httpx.AsyncClient() as client:\n        raw_response = await client.request(\n            HTTPMethod.DELETE, url, json=payload, headers=self._headers\n        )\n    return self._deserialize_response(  # type: ignore\n        raw_response,\n        response_data_model_class=alternate_model_class,\n    )\n</code></pre>"},{"location":"reference/bulk_charges/","title":"Bulk charges","text":""},{"location":"reference/bulk_charges/#pypaystack2.sub_clients.sync_clients.bulk_charges.BulkChargeClient","title":"<code>BulkChargeClient</code>","text":"<p>               Bases: <code>BaseAPIClient</code></p> <p>Provides a wrapper for paystack Bulk Charge API</p> <p>The Bulk Charges API allows you to create and manage multiple recurring payments from your customers. https://paystack.com/docs/api/bulk-charge/</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/bulk_charges.py</code> <pre><code>class BulkChargeClient(BaseAPIClient):\n    \"\"\"Provides a wrapper for paystack Bulk Charge API\n\n    The Bulk Charges API allows you to create and manage multiple recurring payments from your customers.\n    https://paystack.com/docs/api/bulk-charge/\n    \"\"\"\n\n    def initiate(\n        self,\n        body: list[BulkChargeInstruction],\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[BulkCharge] | Response[PaystackDataModel]:\n        \"\"\"\n        Send a list of dictionaries with authorization ``codes`` and ``amount``\n        (in kobo if currency is NGN, pesewas, if currency is GHS, and cents,\n        if currency is ZAR ) so paystack can process transactions as a batch.\n\n        Args:\n            body: A list of BulkChargeInstruction.\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(\"/bulkcharge\")\n        payload = [item.model_dump() for item in body]\n        return self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or BulkCharge,\n        )\n\n    def get_batches(\n        self,\n        page: int = 1,\n        pagination: int = 50,\n        start_date: str | None = None,\n        end_date: str | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[list[BulkCharge]] | Response[PaystackDataModel]:\n        \"\"\"This gets all bulk charge batches created by the integration.\n\n        Args:\n            page: Specify exactly what transfer you want to page. If not specified, we use a default value of 1.\n            pagination: Specify how many records you want to retrieve per page.\n                If not specified we use a default value of 50.\n            start_date: A timestamp from which to start listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            end_date: A timestamp at which to stop listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/bulkcharge?perPage={pagination}\")\n        query_params = [\n            (\"page\", page),\n            (\"from\", start_date),\n            (\"to\", end_date),\n        ]\n        url = append_query_params(query_params, url)\n        return self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or BulkCharge,\n        )\n\n    def get_batch(\n        self,\n        id_or_code: str | int,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[BulkCharge] | Response[PaystackDataModel]:\n        \"\"\"\n        This method retrieves a specific batch code. It also returns\n        useful information on its progress by way of the total_charges\n        and pending_charges attributes in the Response.\n\n        Args:\n            id_or_code: An ID or code for the charge whose batches you want to retrieve.\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/bulkcharge/{id_or_code}\")\n        return self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or BulkCharge,\n        )\n\n    def get_charges_in_batch(\n        self,\n        id_or_code: str | int,\n        status: Status,\n        pagination: int = 50,\n        page: int = 1,\n        start_date: str | None = None,\n        end_date: str | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[list[BulkChargeUnitCharge]] | Response[PaystackDataModel]:\n        \"\"\"\n        This method retrieves the charges associated with a specified\n        batch code. Pagination parameters are available. You can also\n        filter by status. Charge statuses can be `Status.PENDING`,\n        `Status.SUCCESS` or `Status.FAILED`.\n\n        Args:\n            id_or_code: An ID or code for the batch whose charges you want to retrieve.\n            status: Any of the values from the Status enum.\n            pagination: Specify how many records you want to retrieve per page.\n                If not specified we use a default value of 50.\n            page: Specify exactly what transfer you want to page. If not specified we use a default value of 1.\n            start_date: A timestamp from which to start listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            end_date: A timestamp at which to stop listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/bulkcharge/{id_or_code}/charges?perPage={pagination}\")\n        query_params = [\n            (\"status\", status),\n            (\"page\", page),\n            (\"from\", start_date),\n            (\"to\", end_date),\n        ]\n        url = append_query_params(query_params, url)\n        return self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or BulkChargeUnitCharge,\n        )\n\n    def pause_batch(\n        self,\n        batch_code: str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[None] | Response[PaystackDataModel]:\n        \"\"\"Use this method to pause processing a batch.\n\n        Args:\n            batch_code: The batch code for the bulk charge you want to pause.\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/bulkcharge/pause/{batch_code}\")\n        return self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class,\n        )\n\n    def resume_batch(\n        self,\n        batch_code: str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[None] | Response[PaystackDataModel]:\n        \"\"\"Use this method to resume processing a batch\n\n        Args:\n            batch_code: The batch code for the bulk charge you want to resume.\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/bulkcharge/resume/{batch_code}\")\n        return self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class,\n        )\n</code></pre>"},{"location":"reference/bulk_charges/#pypaystack2.sub_clients.sync_clients.bulk_charges.BulkChargeClient.get_batch","title":"<code>get_batch(id_or_code, alternate_model_class=None)</code>","text":"<p>This method retrieves a specific batch code. It also returns useful information on its progress by way of the total_charges and pending_charges attributes in the Response.</p> <p>Parameters:</p> Name Type Description Default <code>id_or_code</code> <code>str | int</code> <p>An ID or code for the charge whose batches you want to retrieve.</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[BulkCharge] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/bulk_charges.py</code> <pre><code>def get_batch(\n    self,\n    id_or_code: str | int,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[BulkCharge] | Response[PaystackDataModel]:\n    \"\"\"\n    This method retrieves a specific batch code. It also returns\n    useful information on its progress by way of the total_charges\n    and pending_charges attributes in the Response.\n\n    Args:\n        id_or_code: An ID or code for the charge whose batches you want to retrieve.\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/bulkcharge/{id_or_code}\")\n    return self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or BulkCharge,\n    )\n</code></pre>"},{"location":"reference/bulk_charges/#pypaystack2.sub_clients.sync_clients.bulk_charges.BulkChargeClient.get_batches","title":"<code>get_batches(page=1, pagination=50, start_date=None, end_date=None, alternate_model_class=None)</code>","text":"<p>This gets all bulk charge batches created by the integration.</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>int</code> <p>Specify exactly what transfer you want to page. If not specified, we use a default value of 1.</p> <code>1</code> <code>pagination</code> <code>int</code> <p>Specify how many records you want to retrieve per page. If not specified we use a default value of 50.</p> <code>50</code> <code>start_date</code> <code>str | None</code> <p>A timestamp from which to start listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>end_date</code> <code>str | None</code> <p>A timestamp at which to stop listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[list[BulkCharge]] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/bulk_charges.py</code> <pre><code>def get_batches(\n    self,\n    page: int = 1,\n    pagination: int = 50,\n    start_date: str | None = None,\n    end_date: str | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[list[BulkCharge]] | Response[PaystackDataModel]:\n    \"\"\"This gets all bulk charge batches created by the integration.\n\n    Args:\n        page: Specify exactly what transfer you want to page. If not specified, we use a default value of 1.\n        pagination: Specify how many records you want to retrieve per page.\n            If not specified we use a default value of 50.\n        start_date: A timestamp from which to start listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        end_date: A timestamp at which to stop listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/bulkcharge?perPage={pagination}\")\n    query_params = [\n        (\"page\", page),\n        (\"from\", start_date),\n        (\"to\", end_date),\n    ]\n    url = append_query_params(query_params, url)\n    return self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or BulkCharge,\n    )\n</code></pre>"},{"location":"reference/bulk_charges/#pypaystack2.sub_clients.sync_clients.bulk_charges.BulkChargeClient.get_charges_in_batch","title":"<code>get_charges_in_batch(id_or_code, status, pagination=50, page=1, start_date=None, end_date=None, alternate_model_class=None)</code>","text":"<p>This method retrieves the charges associated with a specified batch code. Pagination parameters are available. You can also filter by status. Charge statuses can be <code>Status.PENDING</code>, <code>Status.SUCCESS</code> or <code>Status.FAILED</code>.</p> <p>Parameters:</p> Name Type Description Default <code>id_or_code</code> <code>str | int</code> <p>An ID or code for the batch whose charges you want to retrieve.</p> required <code>status</code> <code>Status</code> <p>Any of the values from the Status enum.</p> required <code>pagination</code> <code>int</code> <p>Specify how many records you want to retrieve per page. If not specified we use a default value of 50.</p> <code>50</code> <code>page</code> <code>int</code> <p>Specify exactly what transfer you want to page. If not specified we use a default value of 1.</p> <code>1</code> <code>start_date</code> <code>str | None</code> <p>A timestamp from which to start listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>end_date</code> <code>str | None</code> <p>A timestamp at which to stop listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[list[BulkChargeUnitCharge]] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/bulk_charges.py</code> <pre><code>def get_charges_in_batch(\n    self,\n    id_or_code: str | int,\n    status: Status,\n    pagination: int = 50,\n    page: int = 1,\n    start_date: str | None = None,\n    end_date: str | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[list[BulkChargeUnitCharge]] | Response[PaystackDataModel]:\n    \"\"\"\n    This method retrieves the charges associated with a specified\n    batch code. Pagination parameters are available. You can also\n    filter by status. Charge statuses can be `Status.PENDING`,\n    `Status.SUCCESS` or `Status.FAILED`.\n\n    Args:\n        id_or_code: An ID or code for the batch whose charges you want to retrieve.\n        status: Any of the values from the Status enum.\n        pagination: Specify how many records you want to retrieve per page.\n            If not specified we use a default value of 50.\n        page: Specify exactly what transfer you want to page. If not specified we use a default value of 1.\n        start_date: A timestamp from which to start listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        end_date: A timestamp at which to stop listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/bulkcharge/{id_or_code}/charges?perPage={pagination}\")\n    query_params = [\n        (\"status\", status),\n        (\"page\", page),\n        (\"from\", start_date),\n        (\"to\", end_date),\n    ]\n    url = append_query_params(query_params, url)\n    return self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or BulkChargeUnitCharge,\n    )\n</code></pre>"},{"location":"reference/bulk_charges/#pypaystack2.sub_clients.sync_clients.bulk_charges.BulkChargeClient.initiate","title":"<code>initiate(body, alternate_model_class=None)</code>","text":"<p>Send a list of dictionaries with authorization <code>codes</code> and <code>amount</code> (in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR ) so paystack can process transactions as a batch.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>list[BulkChargeInstruction]</code> <p>A list of BulkChargeInstruction.</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[BulkCharge] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/bulk_charges.py</code> <pre><code>def initiate(\n    self,\n    body: list[BulkChargeInstruction],\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[BulkCharge] | Response[PaystackDataModel]:\n    \"\"\"\n    Send a list of dictionaries with authorization ``codes`` and ``amount``\n    (in kobo if currency is NGN, pesewas, if currency is GHS, and cents,\n    if currency is ZAR ) so paystack can process transactions as a batch.\n\n    Args:\n        body: A list of BulkChargeInstruction.\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(\"/bulkcharge\")\n    payload = [item.model_dump() for item in body]\n    return self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or BulkCharge,\n    )\n</code></pre>"},{"location":"reference/bulk_charges/#pypaystack2.sub_clients.sync_clients.bulk_charges.BulkChargeClient.pause_batch","title":"<code>pause_batch(batch_code, alternate_model_class=None)</code>","text":"<p>Use this method to pause processing a batch.</p> <p>Parameters:</p> Name Type Description Default <code>batch_code</code> <code>str</code> <p>The batch code for the bulk charge you want to pause.</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[None] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/bulk_charges.py</code> <pre><code>def pause_batch(\n    self,\n    batch_code: str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[None] | Response[PaystackDataModel]:\n    \"\"\"Use this method to pause processing a batch.\n\n    Args:\n        batch_code: The batch code for the bulk charge you want to pause.\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/bulkcharge/pause/{batch_code}\")\n    return self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class,\n    )\n</code></pre>"},{"location":"reference/bulk_charges/#pypaystack2.sub_clients.sync_clients.bulk_charges.BulkChargeClient.resume_batch","title":"<code>resume_batch(batch_code, alternate_model_class=None)</code>","text":"<p>Use this method to resume processing a batch</p> <p>Parameters:</p> Name Type Description Default <code>batch_code</code> <code>str</code> <p>The batch code for the bulk charge you want to resume.</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[None] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/bulk_charges.py</code> <pre><code>def resume_batch(\n    self,\n    batch_code: str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[None] | Response[PaystackDataModel]:\n    \"\"\"Use this method to resume processing a batch\n\n    Args:\n        batch_code: The batch code for the bulk charge you want to resume.\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/bulkcharge/resume/{batch_code}\")\n    return self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class,\n    )\n</code></pre>"},{"location":"reference/bulk_charges/#pypaystack2.sub_clients.async_clients.bulk_charges.AsyncBulkChargeClient","title":"<code>AsyncBulkChargeClient</code>","text":"<p>               Bases: <code>BaseAsyncAPIClient</code></p> <p>Provides a wrapper for paystack Bulk Charge API</p> <p>The Bulk Charges API allows you to create and manage multiple recurring payments from your customers. https://paystack.com/docs/api/bulk-charge/</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/bulk_charges.py</code> <pre><code>class AsyncBulkChargeClient(BaseAsyncAPIClient):\n    \"\"\"Provides a wrapper for paystack Bulk Charge API\n\n    The Bulk Charges API allows you to create and manage multiple recurring payments from your customers.\n    https://paystack.com/docs/api/bulk-charge/\n    \"\"\"\n\n    async def initiate(\n        self,\n        body: list[BulkChargeInstruction],\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[BulkCharge] | Response[PaystackDataModel]:\n        \"\"\"\n        Send a list of dictionaries with authorization ``codes`` and ``amount``\n        (in kobo if currency is NGN, pesewas, if currency is GHS, and cents,\n        if currency is ZAR ) so paystack can process transactions as a batch.\n\n        Args:\n            body: A list of BulkChargeInstruction.\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(\"/bulkcharge\")\n        payload = [item.model_dump() for item in body]\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or BulkCharge,\n        )\n\n    async def get_batches(\n        self,\n        page: int = 1,\n        pagination: int = 50,\n        start_date: str | None = None,\n        end_date: str | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[list[BulkCharge]] | Response[PaystackDataModel]:\n        \"\"\"This gets all bulk charge batches created by the integration.\n\n        Args:\n            page: Specify exactly what transfer you want to page. If not specified, we use a default value of 1.\n            pagination: Specify how many records you want to retrieve per page.\n                If not specified we use a default value of 50.\n            start_date: A timestamp from which to start listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            end_date: A timestamp at which to stop listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/bulkcharge?perPage={pagination}\")\n        query_params = [\n            (\"page\", page),\n            (\"from\", start_date),\n            (\"to\", end_date),\n        ]\n        url = append_query_params(query_params, url)\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or BulkCharge,\n        )\n\n    async def get_batch(\n        self,\n        id_or_code: str | int,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[BulkCharge] | Response[PaystackDataModel]:\n        \"\"\"\n        This method retrieves a specific batch code. It also returns\n        useful information on its progress by way of the total_charges\n        and pending_charges attributes in the Response.\n\n        Args:\n            id_or_code: An ID or code for the charge whose batches you want to retrieve.\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/bulkcharge/{id_or_code}\")\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or BulkCharge,\n        )\n\n    async def get_charges_in_batch(\n        self,\n        id_or_code: str | int,\n        status: Status,\n        pagination: int = 50,\n        page: int = 1,\n        start_date: str | None = None,\n        end_date: str | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[list[BulkChargeUnitCharge]] | Response[PaystackDataModel]:\n        \"\"\"\n        This method retrieves the charges associated with a specified\n        batch code. Pagination parameters are available. You can also\n        filter by status. Charge statuses can be `Status.PENDING`,\n        `Status.SUCCESS` or `Status.FAILED`.\n\n        Args:\n            id_or_code: An ID or code for the batch whose charges you want to retrieve.\n            status: Any of the values from the Status enum.\n            pagination: Specify how many records you want to retrieve per page.\n                If not specified we use a default value of 50.\n            page: Specify exactly what transfer you want to page. If not specified we use a default value of 1.\n            start_date: A timestamp from which to start listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            end_date: A timestamp at which to stop listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/bulkcharge/{id_or_code}/charges?perPage={pagination}\")\n        query_params = [\n            (\"status\", status),\n            (\"page\", page),\n            (\"from\", start_date),\n            (\"to\", end_date),\n        ]\n        url = append_query_params(query_params, url)\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or BulkChargeUnitCharge,\n        )\n\n    async def pause_batch(\n        self,\n        batch_code: str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[None] | Response[PaystackDataModel]:\n        \"\"\"Use this method to pause processing a batch.\n\n        Args:\n            batch_code: The batch code for the bulk charge you want to pause.\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/bulkcharge/pause/{batch_code}\")\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class,\n        )\n\n    async def resume_batch(\n        self,\n        batch_code: str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[None] | Response[PaystackDataModel]:\n        \"\"\"Use this method to resume processing a batch\n\n        Args:\n            batch_code: The batch code for the bulk charge you want to resume.\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/bulkcharge/resume/{batch_code}\")\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class,\n        )\n</code></pre>"},{"location":"reference/bulk_charges/#pypaystack2.sub_clients.async_clients.bulk_charges.AsyncBulkChargeClient.get_batch","title":"<code>get_batch(id_or_code, alternate_model_class=None)</code>  <code>async</code>","text":"<p>This method retrieves a specific batch code. It also returns useful information on its progress by way of the total_charges and pending_charges attributes in the Response.</p> <p>Parameters:</p> Name Type Description Default <code>id_or_code</code> <code>str | int</code> <p>An ID or code for the charge whose batches you want to retrieve.</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[BulkCharge] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/bulk_charges.py</code> <pre><code>async def get_batch(\n    self,\n    id_or_code: str | int,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[BulkCharge] | Response[PaystackDataModel]:\n    \"\"\"\n    This method retrieves a specific batch code. It also returns\n    useful information on its progress by way of the total_charges\n    and pending_charges attributes in the Response.\n\n    Args:\n        id_or_code: An ID or code for the charge whose batches you want to retrieve.\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/bulkcharge/{id_or_code}\")\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or BulkCharge,\n    )\n</code></pre>"},{"location":"reference/bulk_charges/#pypaystack2.sub_clients.async_clients.bulk_charges.AsyncBulkChargeClient.get_batches","title":"<code>get_batches(page=1, pagination=50, start_date=None, end_date=None, alternate_model_class=None)</code>  <code>async</code>","text":"<p>This gets all bulk charge batches created by the integration.</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>int</code> <p>Specify exactly what transfer you want to page. If not specified, we use a default value of 1.</p> <code>1</code> <code>pagination</code> <code>int</code> <p>Specify how many records you want to retrieve per page. If not specified we use a default value of 50.</p> <code>50</code> <code>start_date</code> <code>str | None</code> <p>A timestamp from which to start listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>end_date</code> <code>str | None</code> <p>A timestamp at which to stop listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[list[BulkCharge]] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/bulk_charges.py</code> <pre><code>async def get_batches(\n    self,\n    page: int = 1,\n    pagination: int = 50,\n    start_date: str | None = None,\n    end_date: str | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[list[BulkCharge]] | Response[PaystackDataModel]:\n    \"\"\"This gets all bulk charge batches created by the integration.\n\n    Args:\n        page: Specify exactly what transfer you want to page. If not specified, we use a default value of 1.\n        pagination: Specify how many records you want to retrieve per page.\n            If not specified we use a default value of 50.\n        start_date: A timestamp from which to start listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        end_date: A timestamp at which to stop listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/bulkcharge?perPage={pagination}\")\n    query_params = [\n        (\"page\", page),\n        (\"from\", start_date),\n        (\"to\", end_date),\n    ]\n    url = append_query_params(query_params, url)\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or BulkCharge,\n    )\n</code></pre>"},{"location":"reference/bulk_charges/#pypaystack2.sub_clients.async_clients.bulk_charges.AsyncBulkChargeClient.get_charges_in_batch","title":"<code>get_charges_in_batch(id_or_code, status, pagination=50, page=1, start_date=None, end_date=None, alternate_model_class=None)</code>  <code>async</code>","text":"<p>This method retrieves the charges associated with a specified batch code. Pagination parameters are available. You can also filter by status. Charge statuses can be <code>Status.PENDING</code>, <code>Status.SUCCESS</code> or <code>Status.FAILED</code>.</p> <p>Parameters:</p> Name Type Description Default <code>id_or_code</code> <code>str | int</code> <p>An ID or code for the batch whose charges you want to retrieve.</p> required <code>status</code> <code>Status</code> <p>Any of the values from the Status enum.</p> required <code>pagination</code> <code>int</code> <p>Specify how many records you want to retrieve per page. If not specified we use a default value of 50.</p> <code>50</code> <code>page</code> <code>int</code> <p>Specify exactly what transfer you want to page. If not specified we use a default value of 1.</p> <code>1</code> <code>start_date</code> <code>str | None</code> <p>A timestamp from which to start listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>end_date</code> <code>str | None</code> <p>A timestamp at which to stop listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[list[BulkChargeUnitCharge]] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/bulk_charges.py</code> <pre><code>async def get_charges_in_batch(\n    self,\n    id_or_code: str | int,\n    status: Status,\n    pagination: int = 50,\n    page: int = 1,\n    start_date: str | None = None,\n    end_date: str | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[list[BulkChargeUnitCharge]] | Response[PaystackDataModel]:\n    \"\"\"\n    This method retrieves the charges associated with a specified\n    batch code. Pagination parameters are available. You can also\n    filter by status. Charge statuses can be `Status.PENDING`,\n    `Status.SUCCESS` or `Status.FAILED`.\n\n    Args:\n        id_or_code: An ID or code for the batch whose charges you want to retrieve.\n        status: Any of the values from the Status enum.\n        pagination: Specify how many records you want to retrieve per page.\n            If not specified we use a default value of 50.\n        page: Specify exactly what transfer you want to page. If not specified we use a default value of 1.\n        start_date: A timestamp from which to start listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        end_date: A timestamp at which to stop listing batches e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/bulkcharge/{id_or_code}/charges?perPage={pagination}\")\n    query_params = [\n        (\"status\", status),\n        (\"page\", page),\n        (\"from\", start_date),\n        (\"to\", end_date),\n    ]\n    url = append_query_params(query_params, url)\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or BulkChargeUnitCharge,\n    )\n</code></pre>"},{"location":"reference/bulk_charges/#pypaystack2.sub_clients.async_clients.bulk_charges.AsyncBulkChargeClient.initiate","title":"<code>initiate(body, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Send a list of dictionaries with authorization <code>codes</code> and <code>amount</code> (in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR ) so paystack can process transactions as a batch.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>list[BulkChargeInstruction]</code> <p>A list of BulkChargeInstruction.</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[BulkCharge] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/bulk_charges.py</code> <pre><code>async def initiate(\n    self,\n    body: list[BulkChargeInstruction],\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[BulkCharge] | Response[PaystackDataModel]:\n    \"\"\"\n    Send a list of dictionaries with authorization ``codes`` and ``amount``\n    (in kobo if currency is NGN, pesewas, if currency is GHS, and cents,\n    if currency is ZAR ) so paystack can process transactions as a batch.\n\n    Args:\n        body: A list of BulkChargeInstruction.\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(\"/bulkcharge\")\n    payload = [item.model_dump() for item in body]\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or BulkCharge,\n    )\n</code></pre>"},{"location":"reference/bulk_charges/#pypaystack2.sub_clients.async_clients.bulk_charges.AsyncBulkChargeClient.pause_batch","title":"<code>pause_batch(batch_code, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Use this method to pause processing a batch.</p> <p>Parameters:</p> Name Type Description Default <code>batch_code</code> <code>str</code> <p>The batch code for the bulk charge you want to pause.</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[None] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/bulk_charges.py</code> <pre><code>async def pause_batch(\n    self,\n    batch_code: str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[None] | Response[PaystackDataModel]:\n    \"\"\"Use this method to pause processing a batch.\n\n    Args:\n        batch_code: The batch code for the bulk charge you want to pause.\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/bulkcharge/pause/{batch_code}\")\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class,\n    )\n</code></pre>"},{"location":"reference/bulk_charges/#pypaystack2.sub_clients.async_clients.bulk_charges.AsyncBulkChargeClient.resume_batch","title":"<code>resume_batch(batch_code, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Use this method to resume processing a batch</p> <p>Parameters:</p> Name Type Description Default <code>batch_code</code> <code>str</code> <p>The batch code for the bulk charge you want to resume.</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[None] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/bulk_charges.py</code> <pre><code>async def resume_batch(\n    self,\n    batch_code: str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[None] | Response[PaystackDataModel]:\n    \"\"\"Use this method to resume processing a batch\n\n    Args:\n        batch_code: The batch code for the bulk charge you want to resume.\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/bulkcharge/resume/{batch_code}\")\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class,\n    )\n</code></pre>"},{"location":"reference/charge/","title":"Charge","text":""},{"location":"reference/charge/#pypaystack2.sub_clients.sync_clients.charge.ChargeClient","title":"<code>ChargeClient</code>","text":"<p>               Bases: <code>BaseAPIClient</code></p> <p>Provides a wrapper for paystack Charge API</p> <p>The Charge API allows you to configure a payment channel of your choice when initiating a payment. https://paystack.com/docs/api/charge/</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/charge.py</code> <pre><code>class ChargeClient(BaseAPIClient):\n    \"\"\"Provides a wrapper for paystack Charge API\n\n    The Charge API allows you to configure a payment channel of your choice when initiating a payment.\n    https://paystack.com/docs/api/charge/\n\n    \"\"\"\n\n    def charge(\n        self,\n        email: str,\n        amount: int,\n        bank: dict[str, Any] | None = None,\n        bank_transfer: dict[str, Any] | None = None,\n        auth_code: str | None = None,\n        pin: str | None = None,\n        metadata: dict[str, Any] | None = None,\n        reference: str | None = None,\n        ussd: dict[str, Any] | None = None,\n        mobile_money: dict[str, Any] | None = None,\n        device_id: str | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[ChargeStep] | Response[PaystackDataModel]:\n        \"\"\"Initiate a payment by integrating the payment channel of your choice.\n\n        Args:\n            email: Customer's email address\n            amount: Amount should be in kobo if currency is NGN, pesewas, if currency is GHS,\n                and cents, if currency is ZAR\n            bank: Bank account to charge (don't send if charging an authorization code)\n            bank_transfer: Takes the settings for the Pay with Transfer (PwT) channel. Pass in the\n                account_expires_at param to set the expiry time.\n            auth_code: An authorization code to charge (don't send if charging a bank account)\n            pin: 4-digit PIN (send with a non-reusable authorization code)\n            metadata: A dictionary of data.\n            reference: Unique transaction reference. Only -, .\\\\`, = and alphanumeric characters allowed.\n            ussd: USSD type to charge (don't send if charging an authorization code, bank or card)\n            mobile_money: Mobile details (don't send if charging an authorization code, bank or card)\n            device_id: This is the unique identifier of the device a user uses in making payment. Only -, .\\\\`,\n                = and alphanumeric characters allowed.\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        payload = {\"email\": email, \"amount\": amount}\n        optional_params = [\n            (\"bank\", bank),\n            (\"bank_transfer\", bank_transfer),\n            (\"authorization_code\", auth_code),\n            (\"pin\", pin),\n            (\"metadata\", metadata),\n            (\"reference\", reference),\n            (\"ussd\", ussd),\n            (\"mobile_money\", mobile_money),\n            (\"device_id\", device_id),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        url = self._full_url(\"/charge\")\n        return self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or ChargeStep,\n        )\n\n    def submit_pin(\n        self,\n        pin: str,\n        reference: str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[ChargeStep] | Response[PaystackDataModel]:\n        \"\"\"Submit PIN to continue a charge\n\n        Args:\n            pin: PIN submitted by user\n            reference: Reference for transaction that requested pin\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        payload = {\"pin\": pin, \"reference\": reference}\n        url = self._full_url(\"/charge/submit_pin\")\n        return self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or ChargeStep,\n        )\n\n    def submit_otp(\n        self,\n        otp: str,\n        reference: str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[ChargeStep] | Response[PaystackDataModel]:\n        \"\"\"Submit OTP to complete a charge\n\n        Args:\n            otp: OTP submitted by user\n            reference: Reference for ongoing transaction\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        payload = {\"otp\": otp, \"reference\": reference}\n        url = self._full_url(\"/charge/submit_otp\")\n        return self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or ChargeStep,\n        )\n\n    def submit_phone(\n        self,\n        phone: str,\n        reference: str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[ChargeStep] | Response[PaystackDataModel]:\n        \"\"\"Submit Phone when requested\n\n        Args:\n            phone: Phone submitted by user\n            reference: Reference for ongoing transaction\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        payload = {\"phone\": phone, \"reference\": reference}\n        url = self._full_url(\"/charge/submit_phone\")\n        return self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or ChargeStep,\n        )\n\n    def submit_birthday(\n        self,\n        birthday: str,\n        reference: str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[ChargeStep] | Response[PaystackDataModel]:\n        \"\"\"Submit Birthday when requested\n\n        Args:\n            birthday: Birthday submitted by user. ISO Format e.g. 2016-09-21\n            reference: Reference for ongoing transaction\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        payload = {\"birthday\": birthday, \"reference\": reference}\n        url = self._full_url(\"/charge/submit_birthday\")\n        return self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or ChargeStep,\n        )\n\n    def set_address(\n        self,\n        address: str,\n        reference: str,\n        city: str,\n        state: str,\n        zipcode: str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[ChargeStep] | Response[PaystackDataModel]:\n        \"\"\"Submit address to continue a charge\n\n        Args:\n            address: Address submitted by user\n            reference: Reference for ongoing transaction\n            city: City submitted by user\n            state: State submitted by user\n            zipcode: sZipcode submitted by user\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        payload = {\n            \"address\": address,\n            \"reference\": reference,\n            \"city\": city,\n            \"state\": state,\n            \"zip_code\": zipcode,\n        }\n        url = self._full_url(\"/charge/submit_address\")\n        return self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or ChargeStep,\n        )\n\n    def check_pending_charge(\n        self,\n        reference: str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[Transaction] | Response[PaystackDataModel]:\n        \"\"\"\n        When you get \"pending\" as a charge status or if there was an\n        exception when calling any of the /charge endpoints, wait 10\n        seconds or more, then make a check to see if its status has changed.\n        Don't call too early as you may get a lot more pending than you should.\n\n        Args:\n            reference: The reference to check\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/charge/{reference}\")\n        return self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or Transaction,\n        )\n</code></pre>"},{"location":"reference/charge/#pypaystack2.sub_clients.sync_clients.charge.ChargeClient.charge","title":"<code>charge(email, amount, bank=None, bank_transfer=None, auth_code=None, pin=None, metadata=None, reference=None, ussd=None, mobile_money=None, device_id=None, alternate_model_class=None)</code>","text":"<p>Initiate a payment by integrating the payment channel of your choice.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Customer's email address</p> required <code>amount</code> <code>int</code> <p>Amount should be in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR</p> required <code>bank</code> <code>dict[str, Any] | None</code> <p>Bank account to charge (don't send if charging an authorization code)</p> <code>None</code> <code>bank_transfer</code> <code>dict[str, Any] | None</code> <p>Takes the settings for the Pay with Transfer (PwT) channel. Pass in the account_expires_at param to set the expiry time.</p> <code>None</code> <code>auth_code</code> <code>str | None</code> <p>An authorization code to charge (don't send if charging a bank account)</p> <code>None</code> <code>pin</code> <code>str | None</code> <p>4-digit PIN (send with a non-reusable authorization code)</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>A dictionary of data.</p> <code>None</code> <code>reference</code> <code>str | None</code> <p>Unique transaction reference. Only -, .`, = and alphanumeric characters allowed.</p> <code>None</code> <code>ussd</code> <code>dict[str, Any] | None</code> <p>USSD type to charge (don't send if charging an authorization code, bank or card)</p> <code>None</code> <code>mobile_money</code> <code>dict[str, Any] | None</code> <p>Mobile details (don't send if charging an authorization code, bank or card)</p> <code>None</code> <code>device_id</code> <code>str | None</code> <p>This is the unique identifier of the device a user uses in making payment. Only -, .`, = and alphanumeric characters allowed.</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[ChargeStep] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/charge.py</code> <pre><code>def charge(\n    self,\n    email: str,\n    amount: int,\n    bank: dict[str, Any] | None = None,\n    bank_transfer: dict[str, Any] | None = None,\n    auth_code: str | None = None,\n    pin: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    reference: str | None = None,\n    ussd: dict[str, Any] | None = None,\n    mobile_money: dict[str, Any] | None = None,\n    device_id: str | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[ChargeStep] | Response[PaystackDataModel]:\n    \"\"\"Initiate a payment by integrating the payment channel of your choice.\n\n    Args:\n        email: Customer's email address\n        amount: Amount should be in kobo if currency is NGN, pesewas, if currency is GHS,\n            and cents, if currency is ZAR\n        bank: Bank account to charge (don't send if charging an authorization code)\n        bank_transfer: Takes the settings for the Pay with Transfer (PwT) channel. Pass in the\n            account_expires_at param to set the expiry time.\n        auth_code: An authorization code to charge (don't send if charging a bank account)\n        pin: 4-digit PIN (send with a non-reusable authorization code)\n        metadata: A dictionary of data.\n        reference: Unique transaction reference. Only -, .\\\\`, = and alphanumeric characters allowed.\n        ussd: USSD type to charge (don't send if charging an authorization code, bank or card)\n        mobile_money: Mobile details (don't send if charging an authorization code, bank or card)\n        device_id: This is the unique identifier of the device a user uses in making payment. Only -, .\\\\`,\n            = and alphanumeric characters allowed.\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    payload = {\"email\": email, \"amount\": amount}\n    optional_params = [\n        (\"bank\", bank),\n        (\"bank_transfer\", bank_transfer),\n        (\"authorization_code\", auth_code),\n        (\"pin\", pin),\n        (\"metadata\", metadata),\n        (\"reference\", reference),\n        (\"ussd\", ussd),\n        (\"mobile_money\", mobile_money),\n        (\"device_id\", device_id),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    url = self._full_url(\"/charge\")\n    return self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or ChargeStep,\n    )\n</code></pre>"},{"location":"reference/charge/#pypaystack2.sub_clients.sync_clients.charge.ChargeClient.check_pending_charge","title":"<code>check_pending_charge(reference, alternate_model_class=None)</code>","text":"<p>When you get \"pending\" as a charge status or if there was an exception when calling any of the /charge endpoints, wait 10 seconds or more, then make a check to see if its status has changed. Don't call too early as you may get a lot more pending than you should.</p> <p>Parameters:</p> Name Type Description Default <code>reference</code> <code>str</code> <p>The reference to check</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[Transaction] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/charge.py</code> <pre><code>def check_pending_charge(\n    self,\n    reference: str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[Transaction] | Response[PaystackDataModel]:\n    \"\"\"\n    When you get \"pending\" as a charge status or if there was an\n    exception when calling any of the /charge endpoints, wait 10\n    seconds or more, then make a check to see if its status has changed.\n    Don't call too early as you may get a lot more pending than you should.\n\n    Args:\n        reference: The reference to check\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/charge/{reference}\")\n    return self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or Transaction,\n    )\n</code></pre>"},{"location":"reference/charge/#pypaystack2.sub_clients.sync_clients.charge.ChargeClient.set_address","title":"<code>set_address(address, reference, city, state, zipcode, alternate_model_class=None)</code>","text":"<p>Submit address to continue a charge</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>str</code> <p>Address submitted by user</p> required <code>reference</code> <code>str</code> <p>Reference for ongoing transaction</p> required <code>city</code> <code>str</code> <p>City submitted by user</p> required <code>state</code> <code>str</code> <p>State submitted by user</p> required <code>zipcode</code> <code>str</code> <p>sZipcode submitted by user</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[ChargeStep] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/charge.py</code> <pre><code>def set_address(\n    self,\n    address: str,\n    reference: str,\n    city: str,\n    state: str,\n    zipcode: str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[ChargeStep] | Response[PaystackDataModel]:\n    \"\"\"Submit address to continue a charge\n\n    Args:\n        address: Address submitted by user\n        reference: Reference for ongoing transaction\n        city: City submitted by user\n        state: State submitted by user\n        zipcode: sZipcode submitted by user\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    payload = {\n        \"address\": address,\n        \"reference\": reference,\n        \"city\": city,\n        \"state\": state,\n        \"zip_code\": zipcode,\n    }\n    url = self._full_url(\"/charge/submit_address\")\n    return self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or ChargeStep,\n    )\n</code></pre>"},{"location":"reference/charge/#pypaystack2.sub_clients.sync_clients.charge.ChargeClient.submit_birthday","title":"<code>submit_birthday(birthday, reference, alternate_model_class=None)</code>","text":"<p>Submit Birthday when requested</p> <p>Parameters:</p> Name Type Description Default <code>birthday</code> <code>str</code> <p>Birthday submitted by user. ISO Format e.g. 2016-09-21</p> required <code>reference</code> <code>str</code> <p>Reference for ongoing transaction</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[ChargeStep] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/charge.py</code> <pre><code>def submit_birthday(\n    self,\n    birthday: str,\n    reference: str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[ChargeStep] | Response[PaystackDataModel]:\n    \"\"\"Submit Birthday when requested\n\n    Args:\n        birthday: Birthday submitted by user. ISO Format e.g. 2016-09-21\n        reference: Reference for ongoing transaction\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    payload = {\"birthday\": birthday, \"reference\": reference}\n    url = self._full_url(\"/charge/submit_birthday\")\n    return self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or ChargeStep,\n    )\n</code></pre>"},{"location":"reference/charge/#pypaystack2.sub_clients.sync_clients.charge.ChargeClient.submit_otp","title":"<code>submit_otp(otp, reference, alternate_model_class=None)</code>","text":"<p>Submit OTP to complete a charge</p> <p>Parameters:</p> Name Type Description Default <code>otp</code> <code>str</code> <p>OTP submitted by user</p> required <code>reference</code> <code>str</code> <p>Reference for ongoing transaction</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[ChargeStep] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/charge.py</code> <pre><code>def submit_otp(\n    self,\n    otp: str,\n    reference: str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[ChargeStep] | Response[PaystackDataModel]:\n    \"\"\"Submit OTP to complete a charge\n\n    Args:\n        otp: OTP submitted by user\n        reference: Reference for ongoing transaction\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    payload = {\"otp\": otp, \"reference\": reference}\n    url = self._full_url(\"/charge/submit_otp\")\n    return self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or ChargeStep,\n    )\n</code></pre>"},{"location":"reference/charge/#pypaystack2.sub_clients.sync_clients.charge.ChargeClient.submit_phone","title":"<code>submit_phone(phone, reference, alternate_model_class=None)</code>","text":"<p>Submit Phone when requested</p> <p>Parameters:</p> Name Type Description Default <code>phone</code> <code>str</code> <p>Phone submitted by user</p> required <code>reference</code> <code>str</code> <p>Reference for ongoing transaction</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[ChargeStep] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/charge.py</code> <pre><code>def submit_phone(\n    self,\n    phone: str,\n    reference: str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[ChargeStep] | Response[PaystackDataModel]:\n    \"\"\"Submit Phone when requested\n\n    Args:\n        phone: Phone submitted by user\n        reference: Reference for ongoing transaction\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    payload = {\"phone\": phone, \"reference\": reference}\n    url = self._full_url(\"/charge/submit_phone\")\n    return self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or ChargeStep,\n    )\n</code></pre>"},{"location":"reference/charge/#pypaystack2.sub_clients.sync_clients.charge.ChargeClient.submit_pin","title":"<code>submit_pin(pin, reference, alternate_model_class=None)</code>","text":"<p>Submit PIN to continue a charge</p> <p>Parameters:</p> Name Type Description Default <code>pin</code> <code>str</code> <p>PIN submitted by user</p> required <code>reference</code> <code>str</code> <p>Reference for transaction that requested pin</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[ChargeStep] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/charge.py</code> <pre><code>def submit_pin(\n    self,\n    pin: str,\n    reference: str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[ChargeStep] | Response[PaystackDataModel]:\n    \"\"\"Submit PIN to continue a charge\n\n    Args:\n        pin: PIN submitted by user\n        reference: Reference for transaction that requested pin\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    payload = {\"pin\": pin, \"reference\": reference}\n    url = self._full_url(\"/charge/submit_pin\")\n    return self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or ChargeStep,\n    )\n</code></pre>"},{"location":"reference/charge/#pypaystack2.sub_clients.async_clients.charge.AsyncChargeClient","title":"<code>AsyncChargeClient</code>","text":"<p>               Bases: <code>BaseAsyncAPIClient</code></p> <p>Provides a wrapper for paystack Charge API</p> <p>The Charge API allows you to configure a payment channel of your choice when initiating a payment. https://paystack.com/docs/api/charge/</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/charge.py</code> <pre><code>class AsyncChargeClient(BaseAsyncAPIClient):\n    \"\"\"Provides a wrapper for paystack Charge API\n\n    The Charge API allows you to configure a payment channel of your choice when initiating a payment.\n    https://paystack.com/docs/api/charge/\n\n    \"\"\"\n\n    async def charge(\n        self,\n        email: str,\n        amount: int,\n        bank: dict[str, Any] | None = None,\n        bank_transfer: dict[str, Any] | None = None,\n        auth_code: str | None = None,\n        pin: str | None = None,\n        metadata: dict[str, Any] | None = None,\n        reference: str | None = None,\n        ussd: dict[str, Any] | None = None,\n        mobile_money: dict[str, Any] | None = None,\n        device_id: str | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[ChargeStep] | Response[PaystackDataModel]:\n        \"\"\"Initiate a payment by integrating the payment channel of your choice.\n\n        Args:\n            email: Customer's email address\n            amount: Amount should be in kobo if currency is NGN, pesewas, if currency is GHS,\n                and cents, if currency is ZAR\n            bank: Bank account to charge (don't send if charging an authorization code)\n            bank_transfer: Takes the settings for the Pay with Transfer (PwT) channel. Pass in the\n                account_expires_at param to set the expiry time.\n            auth_code: An authorization code to charge (don't send if charging a bank account)\n            pin: 4-digit PIN (send with a non-reusable authorization code)\n            metadata: A dictionary of data.\n            reference: Unique transaction reference. Only -, .\\\\`, = and alphanumeric characters allowed.\n            ussd: USSD type to charge (don't send if charging an authorization code, bank or card)\n            mobile_money: Mobile details (don't send if charging an authorization code, bank or card)\n            device_id: This is the unique identifier of the device a user uses in making payment. Only -, .\\\\`,\n                = and alphanumeric characters allowed.\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        payload = {\"email\": email, \"amount\": amount}\n        optional_params = [\n            (\"bank\", bank),\n            (\"bank_transfer\", bank_transfer),\n            (\"authorization_code\", auth_code),\n            (\"pin\", pin),\n            (\"metadata\", metadata),\n            (\"reference\", reference),\n            (\"ussd\", ussd),\n            (\"mobile_money\", mobile_money),\n            (\"device_id\", device_id),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        url = self._full_url(\"/charge\")\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or ChargeStep,\n        )\n\n    async def submit_pin(\n        self,\n        pin: str,\n        reference: str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[ChargeStep] | Response[PaystackDataModel]:\n        \"\"\"Submit PIN to continue a charge\n\n        Args:\n            pin: PIN submitted by user\n            reference: Reference for transaction that requested pin\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        payload = {\"pin\": pin, \"reference\": reference}\n        url = self._full_url(\"/charge/submit_pin\")\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or ChargeStep,\n        )\n\n    async def submit_otp(\n        self,\n        otp: str,\n        reference: str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[ChargeStep] | Response[PaystackDataModel]:\n        \"\"\"Submit OTP to complete a charge\n\n        Args:\n            otp: OTP submitted by user\n            reference: Reference for ongoing transaction\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        payload = {\"otp\": otp, \"reference\": reference}\n        url = self._full_url(\"/charge/submit_otp\")\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or ChargeStep,\n        )\n\n    async def submit_phone(\n        self,\n        phone: str,\n        reference: str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[ChargeStep] | Response[PaystackDataModel]:\n        \"\"\"Submit Phone when requested\n\n        Args:\n            phone: Phone submitted by user\n            reference: Reference for ongoing transaction\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        payload = {\"phone\": phone, \"reference\": reference}\n        url = self._full_url(\"/charge/submit_phone\")\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or ChargeStep,\n        )\n\n    async def submit_birthday(\n        self,\n        birthday: str,\n        reference: str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[ChargeStep] | Response[PaystackDataModel]:\n        \"\"\"Submit Birthday when requested\n\n        Args:\n            birthday: Birthday submitted by user. ISO Format e.g. 2016-09-21\n            reference: Reference for ongoing transaction\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        payload = {\"birthday\": birthday, \"reference\": reference}\n        url = self._full_url(\"/charge/submit_birthday\")\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or ChargeStep,\n        )\n\n    async def set_address(\n        self,\n        address: str,\n        reference: str,\n        city: str,\n        state: str,\n        zipcode: str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[ChargeStep] | Response[PaystackDataModel]:\n        \"\"\"Submit address to continue a charge\n\n        Args:\n            address: Address submitted by user\n            reference: Reference for ongoing transaction\n            city: City submitted by user\n            state: State submitted by user\n            zipcode: Zipcode submitted by user\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        payload = {\n            \"address\": address,\n            \"reference\": reference,\n            \"city\": city,\n            \"state\": state,\n            \"zip_code\": zipcode,\n        }\n        url = self._full_url(\"/charge/submit_address\")\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or Transaction,\n        )\n\n    async def check_pending_charge(\n        self,\n        reference: str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[Transaction] | Response[PaystackDataModel]:\n        \"\"\"\n        When you get \"pending\" as a charge status or if there was an\n        exception when calling any of the /charge endpoints, wait 10\n        seconds or more, then make a check to see if its status has changed.\n        Don't call too early as you may get a lot more pending than you should.\n\n        Args:\n            reference: The reference to check\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/charge/{reference}\")\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or Transaction,\n        )\n</code></pre>"},{"location":"reference/charge/#pypaystack2.sub_clients.async_clients.charge.AsyncChargeClient.charge","title":"<code>charge(email, amount, bank=None, bank_transfer=None, auth_code=None, pin=None, metadata=None, reference=None, ussd=None, mobile_money=None, device_id=None, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Initiate a payment by integrating the payment channel of your choice.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Customer's email address</p> required <code>amount</code> <code>int</code> <p>Amount should be in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR</p> required <code>bank</code> <code>dict[str, Any] | None</code> <p>Bank account to charge (don't send if charging an authorization code)</p> <code>None</code> <code>bank_transfer</code> <code>dict[str, Any] | None</code> <p>Takes the settings for the Pay with Transfer (PwT) channel. Pass in the account_expires_at param to set the expiry time.</p> <code>None</code> <code>auth_code</code> <code>str | None</code> <p>An authorization code to charge (don't send if charging a bank account)</p> <code>None</code> <code>pin</code> <code>str | None</code> <p>4-digit PIN (send with a non-reusable authorization code)</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>A dictionary of data.</p> <code>None</code> <code>reference</code> <code>str | None</code> <p>Unique transaction reference. Only -, .`, = and alphanumeric characters allowed.</p> <code>None</code> <code>ussd</code> <code>dict[str, Any] | None</code> <p>USSD type to charge (don't send if charging an authorization code, bank or card)</p> <code>None</code> <code>mobile_money</code> <code>dict[str, Any] | None</code> <p>Mobile details (don't send if charging an authorization code, bank or card)</p> <code>None</code> <code>device_id</code> <code>str | None</code> <p>This is the unique identifier of the device a user uses in making payment. Only -, .`, = and alphanumeric characters allowed.</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[ChargeStep] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/charge.py</code> <pre><code>async def charge(\n    self,\n    email: str,\n    amount: int,\n    bank: dict[str, Any] | None = None,\n    bank_transfer: dict[str, Any] | None = None,\n    auth_code: str | None = None,\n    pin: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    reference: str | None = None,\n    ussd: dict[str, Any] | None = None,\n    mobile_money: dict[str, Any] | None = None,\n    device_id: str | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[ChargeStep] | Response[PaystackDataModel]:\n    \"\"\"Initiate a payment by integrating the payment channel of your choice.\n\n    Args:\n        email: Customer's email address\n        amount: Amount should be in kobo if currency is NGN, pesewas, if currency is GHS,\n            and cents, if currency is ZAR\n        bank: Bank account to charge (don't send if charging an authorization code)\n        bank_transfer: Takes the settings for the Pay with Transfer (PwT) channel. Pass in the\n            account_expires_at param to set the expiry time.\n        auth_code: An authorization code to charge (don't send if charging a bank account)\n        pin: 4-digit PIN (send with a non-reusable authorization code)\n        metadata: A dictionary of data.\n        reference: Unique transaction reference. Only -, .\\\\`, = and alphanumeric characters allowed.\n        ussd: USSD type to charge (don't send if charging an authorization code, bank or card)\n        mobile_money: Mobile details (don't send if charging an authorization code, bank or card)\n        device_id: This is the unique identifier of the device a user uses in making payment. Only -, .\\\\`,\n            = and alphanumeric characters allowed.\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    payload = {\"email\": email, \"amount\": amount}\n    optional_params = [\n        (\"bank\", bank),\n        (\"bank_transfer\", bank_transfer),\n        (\"authorization_code\", auth_code),\n        (\"pin\", pin),\n        (\"metadata\", metadata),\n        (\"reference\", reference),\n        (\"ussd\", ussd),\n        (\"mobile_money\", mobile_money),\n        (\"device_id\", device_id),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    url = self._full_url(\"/charge\")\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or ChargeStep,\n    )\n</code></pre>"},{"location":"reference/charge/#pypaystack2.sub_clients.async_clients.charge.AsyncChargeClient.check_pending_charge","title":"<code>check_pending_charge(reference, alternate_model_class=None)</code>  <code>async</code>","text":"<p>When you get \"pending\" as a charge status or if there was an exception when calling any of the /charge endpoints, wait 10 seconds or more, then make a check to see if its status has changed. Don't call too early as you may get a lot more pending than you should.</p> <p>Parameters:</p> Name Type Description Default <code>reference</code> <code>str</code> <p>The reference to check</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[Transaction] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/charge.py</code> <pre><code>async def check_pending_charge(\n    self,\n    reference: str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[Transaction] | Response[PaystackDataModel]:\n    \"\"\"\n    When you get \"pending\" as a charge status or if there was an\n    exception when calling any of the /charge endpoints, wait 10\n    seconds or more, then make a check to see if its status has changed.\n    Don't call too early as you may get a lot more pending than you should.\n\n    Args:\n        reference: The reference to check\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/charge/{reference}\")\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or Transaction,\n    )\n</code></pre>"},{"location":"reference/charge/#pypaystack2.sub_clients.async_clients.charge.AsyncChargeClient.set_address","title":"<code>set_address(address, reference, city, state, zipcode, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Submit address to continue a charge</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>str</code> <p>Address submitted by user</p> required <code>reference</code> <code>str</code> <p>Reference for ongoing transaction</p> required <code>city</code> <code>str</code> <p>City submitted by user</p> required <code>state</code> <code>str</code> <p>State submitted by user</p> required <code>zipcode</code> <code>str</code> <p>Zipcode submitted by user</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[ChargeStep] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/charge.py</code> <pre><code>async def set_address(\n    self,\n    address: str,\n    reference: str,\n    city: str,\n    state: str,\n    zipcode: str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[ChargeStep] | Response[PaystackDataModel]:\n    \"\"\"Submit address to continue a charge\n\n    Args:\n        address: Address submitted by user\n        reference: Reference for ongoing transaction\n        city: City submitted by user\n        state: State submitted by user\n        zipcode: Zipcode submitted by user\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    payload = {\n        \"address\": address,\n        \"reference\": reference,\n        \"city\": city,\n        \"state\": state,\n        \"zip_code\": zipcode,\n    }\n    url = self._full_url(\"/charge/submit_address\")\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or Transaction,\n    )\n</code></pre>"},{"location":"reference/charge/#pypaystack2.sub_clients.async_clients.charge.AsyncChargeClient.submit_birthday","title":"<code>submit_birthday(birthday, reference, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Submit Birthday when requested</p> <p>Parameters:</p> Name Type Description Default <code>birthday</code> <code>str</code> <p>Birthday submitted by user. ISO Format e.g. 2016-09-21</p> required <code>reference</code> <code>str</code> <p>Reference for ongoing transaction</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[ChargeStep] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/charge.py</code> <pre><code>async def submit_birthday(\n    self,\n    birthday: str,\n    reference: str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[ChargeStep] | Response[PaystackDataModel]:\n    \"\"\"Submit Birthday when requested\n\n    Args:\n        birthday: Birthday submitted by user. ISO Format e.g. 2016-09-21\n        reference: Reference for ongoing transaction\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    payload = {\"birthday\": birthday, \"reference\": reference}\n    url = self._full_url(\"/charge/submit_birthday\")\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or ChargeStep,\n    )\n</code></pre>"},{"location":"reference/charge/#pypaystack2.sub_clients.async_clients.charge.AsyncChargeClient.submit_otp","title":"<code>submit_otp(otp, reference, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Submit OTP to complete a charge</p> <p>Parameters:</p> Name Type Description Default <code>otp</code> <code>str</code> <p>OTP submitted by user</p> required <code>reference</code> <code>str</code> <p>Reference for ongoing transaction</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[ChargeStep] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/charge.py</code> <pre><code>async def submit_otp(\n    self,\n    otp: str,\n    reference: str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[ChargeStep] | Response[PaystackDataModel]:\n    \"\"\"Submit OTP to complete a charge\n\n    Args:\n        otp: OTP submitted by user\n        reference: Reference for ongoing transaction\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    payload = {\"otp\": otp, \"reference\": reference}\n    url = self._full_url(\"/charge/submit_otp\")\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or ChargeStep,\n    )\n</code></pre>"},{"location":"reference/charge/#pypaystack2.sub_clients.async_clients.charge.AsyncChargeClient.submit_phone","title":"<code>submit_phone(phone, reference, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Submit Phone when requested</p> <p>Parameters:</p> Name Type Description Default <code>phone</code> <code>str</code> <p>Phone submitted by user</p> required <code>reference</code> <code>str</code> <p>Reference for ongoing transaction</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[ChargeStep] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/charge.py</code> <pre><code>async def submit_phone(\n    self,\n    phone: str,\n    reference: str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[ChargeStep] | Response[PaystackDataModel]:\n    \"\"\"Submit Phone when requested\n\n    Args:\n        phone: Phone submitted by user\n        reference: Reference for ongoing transaction\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    payload = {\"phone\": phone, \"reference\": reference}\n    url = self._full_url(\"/charge/submit_phone\")\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or ChargeStep,\n    )\n</code></pre>"},{"location":"reference/charge/#pypaystack2.sub_clients.async_clients.charge.AsyncChargeClient.submit_pin","title":"<code>submit_pin(pin, reference, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Submit PIN to continue a charge</p> <p>Parameters:</p> Name Type Description Default <code>pin</code> <code>str</code> <p>PIN submitted by user</p> required <code>reference</code> <code>str</code> <p>Reference for transaction that requested pin</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[ChargeStep] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/charge.py</code> <pre><code>async def submit_pin(\n    self,\n    pin: str,\n    reference: str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[ChargeStep] | Response[PaystackDataModel]:\n    \"\"\"Submit PIN to continue a charge\n\n    Args:\n        pin: PIN submitted by user\n        reference: Reference for transaction that requested pin\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    payload = {\"pin\": pin, \"reference\": reference}\n    url = self._full_url(\"/charge/submit_pin\")\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or ChargeStep,\n    )\n</code></pre>"},{"location":"reference/customer/","title":"Customer","text":""},{"location":"reference/customer/#pypaystack2.sub_clients.sync_clients.customers.CustomerClient","title":"<code>CustomerClient</code>","text":"<p>               Bases: <code>BaseAPIClient</code></p> <p>Provides a wrapper for paystack Customer API</p> <p>The Customers API allows you to create and manage customers in your integration. https://paystack.com/docs/api/customer/</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/customers.py</code> <pre><code>class CustomerClient(BaseAPIClient):\n    \"\"\"Provides a wrapper for paystack Customer API\n\n    The Customers API allows you to create and manage customers in your integration.\n    https://paystack.com/docs/api/customer/\n    \"\"\"\n\n    def create(\n        self,\n        email: str,\n        first_name: str | None = None,\n        last_name: str | None = None,\n        phone: str | None = None,\n        metadata: dict[str, Any] | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[Customer] | Response[PaystackDataModel]:\n        \"\"\"Create a customer on your integration.\n\n        Note:\n            The `first_name`, `last_name` and `phone` are optional parameters. However,\n            when creating a customer that would be assigned a Dedicated Virtual\n            Account and your business category falls under Betting, Financial\n            services, and General Service, then these parameters become compulsory.\n\n        Args:\n            email: Customer's email address\n            first_name: Customer's first name\n            last_name: Customer's last name\n            phone: Customer's phone number\n            metadata: A dictionary that you can attach to the customer. It can be used\n                to store additional information in a structured format.\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(\"/customer/\")\n        payload = {\n            \"email\": email,\n        }\n        optional_params = [\n            (\"first_name\", first_name),\n            (\"last_name\", last_name),\n            (\"phone\", phone),\n            (\"metadata\", metadata),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or Customer,\n        )\n\n    def get_customers(\n        self,\n        start_date: str | None = None,\n        end_date: str | None = None,\n        page: int = 1,\n        pagination: int = 50,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[list[Customer]] | Response[PaystackDataModel]:\n        \"\"\"Fetches customers available on your integration.\n\n        Args:\n            start_date: A timestamp from which to start listing customers e.g., 2016-09-24T00:00:05.000Z, 2016-09-21\n            end_date: A timestamp at which to stop listing customers e.g., 2016-09-24T00:00:05.000Z, 2016-09-21\n            page: Specify exactly what page you want to retrieve. If not specified, we use a default value of 1.\n            pagination: Specifies how many records you want to retrieve per page.\n                If not specified, we use a default value of 50.\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        query_params = [\n            (\"page\", page),\n            (\"from\", start_date),\n            (\"to\", end_date),\n        ]\n        url = self._full_url(f\"/customer/?perPage={pagination}\")\n        url = append_query_params(query_params, url)\n        return self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or Customer,\n        )\n\n    def get_customer(\n        self,\n        email_or_code: str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[Customer] | Response[PaystackDataModel]:\n        \"\"\"Get details of a customer on your integration.\n\n        Args:\n            email_or_code: An email or customer code for the customer you want to fetch\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/customer/{email_or_code}/\")\n        return self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or Customer,\n        )\n\n    def update(\n        self,\n        code: str,\n        first_name: str | None = None,\n        last_name: str | None = None,\n        phone: str | None = None,\n        metadata: dict[str, Any] | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[Customer] | Response[PaystackDataModel]:\n        \"\"\"Update a customer's details on your integration\n\n        Args:\n            code: Customer's code\n            first_name: Customer's first name\n            last_name: Customer's last name\n            phone: Customer's phone number\n            metadata: A dictionary that you can attach to the customer. It can be used to store additional\n                information in a structured format.\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/customer/{code}/\")\n        payload: dict[str, Any] = {}\n        optional_params = [\n            (\"first_name\", first_name),\n            (\"last_name\", last_name),\n            (\"phone\", phone),\n            (\"metadata\", metadata),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return self._handle_request(  # type: ignore\n            HTTPMethod.PUT,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or Customer,\n        )\n\n    def validate(\n        self,\n        email_or_code: str,\n        first_name: str,\n        last_name: str,\n        identification_type: Identification,\n        country: Country,\n        bvn: str,\n        identification_number: str | None = None,\n        bank_code: str | None = None,\n        account_number: str | None = None,\n        middle_name: str | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[None] | Response[PaystackDataModel]:\n        \"\"\"Validate a customer's identity\n\n        Args:\n            email_or_code: Customer's email or code\n            first_name: Customer's first name\n            last_name: Customer's last name\n            identification_type: Enum of Identification e.g `Identification.BVN`\n            identification_number: An identification number based on the `identification_type`\n            country: Customer's Country e.g `Country.NIGERIA`\n            bvn: Customer's Bank Verification Number\n            bank_code: You can get the list of Bank Codes by calling the\n                Miscellaneous API `get_banks` method. (required if type is bank_account)\n            account_number: Customer's bank account number. (required if type is bank_account)\n            middle_name: Customer's middle name\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        if identification_type == Identification.BANK_ACCOUNT:\n            if bank_code is None:\n                raise ValueError(\n                    \"`bank_code` is required if identification type is `Identification.BANK_ACCOUNT`\"\n                )\n            if account_number is None:\n                raise ValueError(\n                    \"`account_number` is required if identification type is `Identification.BANK_ACCOUNT`\"\n                )\n\n        url = self._full_url(f\"/customer/{email_or_code}/identification\")\n        payload = {\n            \"first_name\": first_name,\n            \"last_name\": last_name,\n            \"type\": identification_type,\n            \"country\": country,\n            \"bvn\": bvn,\n        }\n        optional_params = [\n            (\"bank_code\", bank_code),\n            (\"account_number\", account_number),\n            (\"middle_name\", middle_name),\n            (\"value\", identification_number),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class,\n        )\n\n    def flag(\n        self,\n        customer: str,\n        risk_action: RiskAction | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[Customer] | Response[PaystackDataModel]:\n        \"\"\"Whitelist or blacklist a customer on your integration\n\n        Args:\n            customer: Customer's code, or email address\n            risk_action: One of the possible risk actions from the RiskAction enum e.g `RiskAction.DEFAULT`\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(\"/customer/set_risk_action\")\n        payload = {\n            \"customer\": customer,\n        }\n        optional_params = [\n            (\"risk_action\", risk_action),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or Customer,\n        )\n\n    def deactivate(\n        self,\n        auth_code: str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[None] | Response[PaystackDataModel]:\n        \"\"\"Deactivate an authorization when the card needs to be forgotten\n\n        Args:\n            auth_code: Authorization code to be deactivated\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(\"/customer/deactivate_authorization\")\n        payload = {\n            \"authorization_code\": auth_code,\n        }\n        return self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class,\n        )\n</code></pre>"},{"location":"reference/customer/#pypaystack2.sub_clients.sync_clients.customers.CustomerClient.create","title":"<code>create(email, first_name=None, last_name=None, phone=None, metadata=None, alternate_model_class=None)</code>","text":"<p>Create a customer on your integration.</p> Note <p>The <code>first_name</code>, <code>last_name</code> and <code>phone</code> are optional parameters. However, when creating a customer that would be assigned a Dedicated Virtual Account and your business category falls under Betting, Financial services, and General Service, then these parameters become compulsory.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Customer's email address</p> required <code>first_name</code> <code>str | None</code> <p>Customer's first name</p> <code>None</code> <code>last_name</code> <code>str | None</code> <p>Customer's last name</p> <code>None</code> <code>phone</code> <code>str | None</code> <p>Customer's phone number</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>A dictionary that you can attach to the customer. It can be used to store additional information in a structured format.</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[Customer] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/customers.py</code> <pre><code>def create(\n    self,\n    email: str,\n    first_name: str | None = None,\n    last_name: str | None = None,\n    phone: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[Customer] | Response[PaystackDataModel]:\n    \"\"\"Create a customer on your integration.\n\n    Note:\n        The `first_name`, `last_name` and `phone` are optional parameters. However,\n        when creating a customer that would be assigned a Dedicated Virtual\n        Account and your business category falls under Betting, Financial\n        services, and General Service, then these parameters become compulsory.\n\n    Args:\n        email: Customer's email address\n        first_name: Customer's first name\n        last_name: Customer's last name\n        phone: Customer's phone number\n        metadata: A dictionary that you can attach to the customer. It can be used\n            to store additional information in a structured format.\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(\"/customer/\")\n    payload = {\n        \"email\": email,\n    }\n    optional_params = [\n        (\"first_name\", first_name),\n        (\"last_name\", last_name),\n        (\"phone\", phone),\n        (\"metadata\", metadata),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or Customer,\n    )\n</code></pre>"},{"location":"reference/customer/#pypaystack2.sub_clients.sync_clients.customers.CustomerClient.deactivate","title":"<code>deactivate(auth_code, alternate_model_class=None)</code>","text":"<p>Deactivate an authorization when the card needs to be forgotten</p> <p>Parameters:</p> Name Type Description Default <code>auth_code</code> <code>str</code> <p>Authorization code to be deactivated</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[None] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/customers.py</code> <pre><code>def deactivate(\n    self,\n    auth_code: str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[None] | Response[PaystackDataModel]:\n    \"\"\"Deactivate an authorization when the card needs to be forgotten\n\n    Args:\n        auth_code: Authorization code to be deactivated\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(\"/customer/deactivate_authorization\")\n    payload = {\n        \"authorization_code\": auth_code,\n    }\n    return self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class,\n    )\n</code></pre>"},{"location":"reference/customer/#pypaystack2.sub_clients.sync_clients.customers.CustomerClient.flag","title":"<code>flag(customer, risk_action=None, alternate_model_class=None)</code>","text":"<p>Whitelist or blacklist a customer on your integration</p> <p>Parameters:</p> Name Type Description Default <code>customer</code> <code>str</code> <p>Customer's code, or email address</p> required <code>risk_action</code> <code>RiskAction | None</code> <p>One of the possible risk actions from the RiskAction enum e.g <code>RiskAction.DEFAULT</code></p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[Customer] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/customers.py</code> <pre><code>def flag(\n    self,\n    customer: str,\n    risk_action: RiskAction | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[Customer] | Response[PaystackDataModel]:\n    \"\"\"Whitelist or blacklist a customer on your integration\n\n    Args:\n        customer: Customer's code, or email address\n        risk_action: One of the possible risk actions from the RiskAction enum e.g `RiskAction.DEFAULT`\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(\"/customer/set_risk_action\")\n    payload = {\n        \"customer\": customer,\n    }\n    optional_params = [\n        (\"risk_action\", risk_action),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or Customer,\n    )\n</code></pre>"},{"location":"reference/customer/#pypaystack2.sub_clients.sync_clients.customers.CustomerClient.get_customer","title":"<code>get_customer(email_or_code, alternate_model_class=None)</code>","text":"<p>Get details of a customer on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>email_or_code</code> <code>str</code> <p>An email or customer code for the customer you want to fetch</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[Customer] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/customers.py</code> <pre><code>def get_customer(\n    self,\n    email_or_code: str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[Customer] | Response[PaystackDataModel]:\n    \"\"\"Get details of a customer on your integration.\n\n    Args:\n        email_or_code: An email or customer code for the customer you want to fetch\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/customer/{email_or_code}/\")\n    return self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or Customer,\n    )\n</code></pre>"},{"location":"reference/customer/#pypaystack2.sub_clients.sync_clients.customers.CustomerClient.get_customers","title":"<code>get_customers(start_date=None, end_date=None, page=1, pagination=50, alternate_model_class=None)</code>","text":"<p>Fetches customers available on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>start_date</code> <code>str | None</code> <p>A timestamp from which to start listing customers e.g., 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>end_date</code> <code>str | None</code> <p>A timestamp at which to stop listing customers e.g., 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>page</code> <code>int</code> <p>Specify exactly what page you want to retrieve. If not specified, we use a default value of 1.</p> <code>1</code> <code>pagination</code> <code>int</code> <p>Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50.</p> <code>50</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[list[Customer]] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/customers.py</code> <pre><code>def get_customers(\n    self,\n    start_date: str | None = None,\n    end_date: str | None = None,\n    page: int = 1,\n    pagination: int = 50,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[list[Customer]] | Response[PaystackDataModel]:\n    \"\"\"Fetches customers available on your integration.\n\n    Args:\n        start_date: A timestamp from which to start listing customers e.g., 2016-09-24T00:00:05.000Z, 2016-09-21\n        end_date: A timestamp at which to stop listing customers e.g., 2016-09-24T00:00:05.000Z, 2016-09-21\n        page: Specify exactly what page you want to retrieve. If not specified, we use a default value of 1.\n        pagination: Specifies how many records you want to retrieve per page.\n            If not specified, we use a default value of 50.\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    query_params = [\n        (\"page\", page),\n        (\"from\", start_date),\n        (\"to\", end_date),\n    ]\n    url = self._full_url(f\"/customer/?perPage={pagination}\")\n    url = append_query_params(query_params, url)\n    return self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or Customer,\n    )\n</code></pre>"},{"location":"reference/customer/#pypaystack2.sub_clients.sync_clients.customers.CustomerClient.update","title":"<code>update(code, first_name=None, last_name=None, phone=None, metadata=None, alternate_model_class=None)</code>","text":"<p>Update a customer's details on your integration</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>Customer's code</p> required <code>first_name</code> <code>str | None</code> <p>Customer's first name</p> <code>None</code> <code>last_name</code> <code>str | None</code> <p>Customer's last name</p> <code>None</code> <code>phone</code> <code>str | None</code> <p>Customer's phone number</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>A dictionary that you can attach to the customer. It can be used to store additional information in a structured format.</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[Customer] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/customers.py</code> <pre><code>def update(\n    self,\n    code: str,\n    first_name: str | None = None,\n    last_name: str | None = None,\n    phone: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[Customer] | Response[PaystackDataModel]:\n    \"\"\"Update a customer's details on your integration\n\n    Args:\n        code: Customer's code\n        first_name: Customer's first name\n        last_name: Customer's last name\n        phone: Customer's phone number\n        metadata: A dictionary that you can attach to the customer. It can be used to store additional\n            information in a structured format.\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/customer/{code}/\")\n    payload: dict[str, Any] = {}\n    optional_params = [\n        (\"first_name\", first_name),\n        (\"last_name\", last_name),\n        (\"phone\", phone),\n        (\"metadata\", metadata),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return self._handle_request(  # type: ignore\n        HTTPMethod.PUT,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or Customer,\n    )\n</code></pre>"},{"location":"reference/customer/#pypaystack2.sub_clients.sync_clients.customers.CustomerClient.validate","title":"<code>validate(email_or_code, first_name, last_name, identification_type, country, bvn, identification_number=None, bank_code=None, account_number=None, middle_name=None, alternate_model_class=None)</code>","text":"<p>Validate a customer's identity</p> <p>Parameters:</p> Name Type Description Default <code>email_or_code</code> <code>str</code> <p>Customer's email or code</p> required <code>first_name</code> <code>str</code> <p>Customer's first name</p> required <code>last_name</code> <code>str</code> <p>Customer's last name</p> required <code>identification_type</code> <code>Identification</code> <p>Enum of Identification e.g <code>Identification.BVN</code></p> required <code>identification_number</code> <code>str | None</code> <p>An identification number based on the <code>identification_type</code></p> <code>None</code> <code>country</code> <code>Country</code> <p>Customer's Country e.g <code>Country.NIGERIA</code></p> required <code>bvn</code> <code>str</code> <p>Customer's Bank Verification Number</p> required <code>bank_code</code> <code>str | None</code> <p>You can get the list of Bank Codes by calling the Miscellaneous API <code>get_banks</code> method. (required if type is bank_account)</p> <code>None</code> <code>account_number</code> <code>str | None</code> <p>Customer's bank account number. (required if type is bank_account)</p> <code>None</code> <code>middle_name</code> <code>str | None</code> <p>Customer's middle name</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[None] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/customers.py</code> <pre><code>def validate(\n    self,\n    email_or_code: str,\n    first_name: str,\n    last_name: str,\n    identification_type: Identification,\n    country: Country,\n    bvn: str,\n    identification_number: str | None = None,\n    bank_code: str | None = None,\n    account_number: str | None = None,\n    middle_name: str | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[None] | Response[PaystackDataModel]:\n    \"\"\"Validate a customer's identity\n\n    Args:\n        email_or_code: Customer's email or code\n        first_name: Customer's first name\n        last_name: Customer's last name\n        identification_type: Enum of Identification e.g `Identification.BVN`\n        identification_number: An identification number based on the `identification_type`\n        country: Customer's Country e.g `Country.NIGERIA`\n        bvn: Customer's Bank Verification Number\n        bank_code: You can get the list of Bank Codes by calling the\n            Miscellaneous API `get_banks` method. (required if type is bank_account)\n        account_number: Customer's bank account number. (required if type is bank_account)\n        middle_name: Customer's middle name\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    if identification_type == Identification.BANK_ACCOUNT:\n        if bank_code is None:\n            raise ValueError(\n                \"`bank_code` is required if identification type is `Identification.BANK_ACCOUNT`\"\n            )\n        if account_number is None:\n            raise ValueError(\n                \"`account_number` is required if identification type is `Identification.BANK_ACCOUNT`\"\n            )\n\n    url = self._full_url(f\"/customer/{email_or_code}/identification\")\n    payload = {\n        \"first_name\": first_name,\n        \"last_name\": last_name,\n        \"type\": identification_type,\n        \"country\": country,\n        \"bvn\": bvn,\n    }\n    optional_params = [\n        (\"bank_code\", bank_code),\n        (\"account_number\", account_number),\n        (\"middle_name\", middle_name),\n        (\"value\", identification_number),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class,\n    )\n</code></pre>"},{"location":"reference/customer/#pypaystack2.sub_clients.async_clients.customers.AsyncCustomerClient","title":"<code>AsyncCustomerClient</code>","text":"<p>               Bases: <code>BaseAsyncAPIClient</code></p> <p>Provides a wrapper for paystack Customer API</p> <p>The Customers API allows you to create and manage customers in your integration. https://paystack.com/docs/api/customer/</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/customers.py</code> <pre><code>class AsyncCustomerClient(BaseAsyncAPIClient):\n    \"\"\"Provides a wrapper for paystack Customer API\n\n    The Customers API allows you to create and manage customers in your integration.\n    https://paystack.com/docs/api/customer/\n    \"\"\"\n\n    async def create(\n        self,\n        email: str,\n        first_name: str | None = None,\n        last_name: str | None = None,\n        phone: str | None = None,\n        metadata: dict[str, Any] | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[Customer] | Response[PaystackDataModel]:\n        \"\"\"Create a customer on your integration.\n\n        Note:\n            The `first_name`, `last_name` and `phone` are optional parameters. However,\n            when creating a customer that would be assigned a Dedicated Virtual\n            Account and your business category falls under Betting, Financial\n            services, and General Service, then these parameters become compulsory.\n\n        Args:\n            email: Customer's email address\n            first_name: Customer's first name\n            last_name: Customer's last name\n            phone: Customer's phone number\n            metadata: A dictionary that you can attach to the customer. It can be used\n                to store additional information in a structured format.\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(\"/customer/\")\n        payload = {\n            \"email\": email,\n        }\n        optional_params = [\n            (\"first_name\", first_name),\n            (\"last_name\", last_name),\n            (\"phone\", phone),\n            (\"metadata\", metadata),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or Customer,\n        )\n\n    async def get_customers(\n        self,\n        start_date: str | None = None,\n        end_date: str | None = None,\n        page: int = 1,\n        pagination: int = 50,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[list[Customer]] | Response[PaystackDataModel]:\n        \"\"\"Fetches customers available on your integration.\n\n        Args:\n            start_date: A timestamp from which to start listing customers e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            end_date: A timestamp at which to stop listing customers e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            page: Specify exactly what page you want to retrieve. If not specified, we use a default value of 1.\n            pagination: Specifies how many records you want to retrieve per page.\n                If not specified we use a default value of 50.\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        query_params = [\n            (\"page\", page),\n            (\"from\", start_date),\n            (\"to\", end_date),\n        ]\n        url = self._full_url(f\"/customer/?perPage={pagination}\")\n        url = append_query_params(query_params, url)\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or Customer,\n        )\n\n    async def get_customer(\n        self,\n        email_or_code: str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[Customer] | Response[PaystackDataModel]:\n        \"\"\"Get details of a customer on your integration.\n\n        Args:\n            email_or_code: An email or customer code for the customer you want to fetch\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/customer/{email_or_code}/\")\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or Customer,\n        )\n\n    async def update(\n        self,\n        code: str,\n        first_name: str | None = None,\n        last_name: str | None = None,\n        phone: str | None = None,\n        metadata: dict[str, Any] | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[Customer] | Response[PaystackDataModel]:\n        \"\"\"Update a customer's details on your integration\n\n        Args:\n            code: Customer's code\n            first_name: Customer's first name\n            last_name: Customer's last name\n            phone: Customer's phone number\n            metadata: A dictionary that you can attach to the customer. It can be used to store additional\n                information in a structured format.\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/customer/{code}/\")\n        payload: dict[str, Any] = {}\n\n        optional_params = [\n            (\"first_name\", first_name),\n            (\"last_name\", last_name),\n            (\"phone\", phone),\n            (\"metadata\", metadata),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.PUT,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or Customer,\n        )\n\n    async def validate(\n        self,\n        email_or_code: str,\n        first_name: str,\n        last_name: str,\n        identification_type: Identification,\n        country: Country,\n        bvn: str,\n        identification_number: str | None = None,\n        bank_code: str | None = None,\n        account_number: str | None = None,\n        middle_name: str | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[None] | Response[PaystackDataModel]:\n        \"\"\"Validate a customer's identity\n\n        Args:\n            email_or_code: Customer's email or code\n            first_name: Customer's first name\n            last_name: Customer's last name\n            identification_type: Enum of Identification e.g `Identification.BVN`\n            identification_number: An identification number based on the `identification_type`\n            country: Customer's Country e.g `Country.NIGERIA`\n            bvn: Customer's Bank Verification Number\n            bank_code: You can get the list of Bank Codes by calling the\n                Miscellaneous API `get_banks` method. (required if type is bank_account)\n            account_number: Customer's bank account number. (required if type is bank_account)\n            middle_name: Customer's middle name\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        if identification_type == Identification.BANK_ACCOUNT:\n            if bank_code is None:\n                raise ValueError(\n                    \"`bank_code` is required if identification type is `Identification.BANK_ACCOUNT`\"\n                )\n            if account_number is None:\n                raise ValueError(\n                    \"`account_number` is required if identification type is `Identification.BANK_ACCOUNT`\"\n                )\n\n        url = self._full_url(f\"/customer/{email_or_code}/identification\")\n        payload = {\n            \"first_name\": first_name,\n            \"last_name\": last_name,\n            \"type\": identification_type,\n            \"country\": country,\n            \"bvn\": bvn,\n        }\n        optional_params = [\n            (\"bank_code\", bank_code),\n            (\"account_number\", account_number),\n            (\"middle_name\", middle_name),\n            (\"value\", identification_number),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class,\n        )\n\n    async def flag(\n        self,\n        customer: str,\n        risk_action: RiskAction | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[Customer] | Response[PaystackDataModel]:\n        \"\"\"Whitelist or blacklist a customer on your integration\n\n        Args:\n            customer: Customer's code, or email address\n            risk_action: One of the possible risk actions from the RiskAction enum e.g `RiskAction.DEFAULT`\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(\"/customer/set_risk_action\")\n        payload = {\n            \"customer\": customer,\n        }\n        optional_params = [\n            (\"risk_action\", risk_action),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or Customer,\n        )\n\n    async def deactivate(\n        self,\n        auth_code: str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[None] | Response[PaystackDataModel]:\n        \"\"\"Deactivate an authorization when the card needs to be forgotten\n\n        Args:\n            auth_code: Authorization code to be deactivated\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(\"/customer/deactivate_authorization\")\n        payload = {\n            \"authorization_code\": auth_code,\n        }\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class,\n        )\n</code></pre>"},{"location":"reference/customer/#pypaystack2.sub_clients.async_clients.customers.AsyncCustomerClient.create","title":"<code>create(email, first_name=None, last_name=None, phone=None, metadata=None, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Create a customer on your integration.</p> Note <p>The <code>first_name</code>, <code>last_name</code> and <code>phone</code> are optional parameters. However, when creating a customer that would be assigned a Dedicated Virtual Account and your business category falls under Betting, Financial services, and General Service, then these parameters become compulsory.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Customer's email address</p> required <code>first_name</code> <code>str | None</code> <p>Customer's first name</p> <code>None</code> <code>last_name</code> <code>str | None</code> <p>Customer's last name</p> <code>None</code> <code>phone</code> <code>str | None</code> <p>Customer's phone number</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>A dictionary that you can attach to the customer. It can be used to store additional information in a structured format.</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[Customer] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/customers.py</code> <pre><code>async def create(\n    self,\n    email: str,\n    first_name: str | None = None,\n    last_name: str | None = None,\n    phone: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[Customer] | Response[PaystackDataModel]:\n    \"\"\"Create a customer on your integration.\n\n    Note:\n        The `first_name`, `last_name` and `phone` are optional parameters. However,\n        when creating a customer that would be assigned a Dedicated Virtual\n        Account and your business category falls under Betting, Financial\n        services, and General Service, then these parameters become compulsory.\n\n    Args:\n        email: Customer's email address\n        first_name: Customer's first name\n        last_name: Customer's last name\n        phone: Customer's phone number\n        metadata: A dictionary that you can attach to the customer. It can be used\n            to store additional information in a structured format.\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(\"/customer/\")\n    payload = {\n        \"email\": email,\n    }\n    optional_params = [\n        (\"first_name\", first_name),\n        (\"last_name\", last_name),\n        (\"phone\", phone),\n        (\"metadata\", metadata),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or Customer,\n    )\n</code></pre>"},{"location":"reference/customer/#pypaystack2.sub_clients.async_clients.customers.AsyncCustomerClient.deactivate","title":"<code>deactivate(auth_code, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Deactivate an authorization when the card needs to be forgotten</p> <p>Parameters:</p> Name Type Description Default <code>auth_code</code> <code>str</code> <p>Authorization code to be deactivated</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[None] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/customers.py</code> <pre><code>async def deactivate(\n    self,\n    auth_code: str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[None] | Response[PaystackDataModel]:\n    \"\"\"Deactivate an authorization when the card needs to be forgotten\n\n    Args:\n        auth_code: Authorization code to be deactivated\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(\"/customer/deactivate_authorization\")\n    payload = {\n        \"authorization_code\": auth_code,\n    }\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class,\n    )\n</code></pre>"},{"location":"reference/customer/#pypaystack2.sub_clients.async_clients.customers.AsyncCustomerClient.flag","title":"<code>flag(customer, risk_action=None, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Whitelist or blacklist a customer on your integration</p> <p>Parameters:</p> Name Type Description Default <code>customer</code> <code>str</code> <p>Customer's code, or email address</p> required <code>risk_action</code> <code>RiskAction | None</code> <p>One of the possible risk actions from the RiskAction enum e.g <code>RiskAction.DEFAULT</code></p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[Customer] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/customers.py</code> <pre><code>async def flag(\n    self,\n    customer: str,\n    risk_action: RiskAction | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[Customer] | Response[PaystackDataModel]:\n    \"\"\"Whitelist or blacklist a customer on your integration\n\n    Args:\n        customer: Customer's code, or email address\n        risk_action: One of the possible risk actions from the RiskAction enum e.g `RiskAction.DEFAULT`\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(\"/customer/set_risk_action\")\n    payload = {\n        \"customer\": customer,\n    }\n    optional_params = [\n        (\"risk_action\", risk_action),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or Customer,\n    )\n</code></pre>"},{"location":"reference/customer/#pypaystack2.sub_clients.async_clients.customers.AsyncCustomerClient.get_customer","title":"<code>get_customer(email_or_code, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Get details of a customer on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>email_or_code</code> <code>str</code> <p>An email or customer code for the customer you want to fetch</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[Customer] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/customers.py</code> <pre><code>async def get_customer(\n    self,\n    email_or_code: str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[Customer] | Response[PaystackDataModel]:\n    \"\"\"Get details of a customer on your integration.\n\n    Args:\n        email_or_code: An email or customer code for the customer you want to fetch\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/customer/{email_or_code}/\")\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or Customer,\n    )\n</code></pre>"},{"location":"reference/customer/#pypaystack2.sub_clients.async_clients.customers.AsyncCustomerClient.get_customers","title":"<code>get_customers(start_date=None, end_date=None, page=1, pagination=50, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Fetches customers available on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>start_date</code> <code>str | None</code> <p>A timestamp from which to start listing customers e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>end_date</code> <code>str | None</code> <p>A timestamp at which to stop listing customers e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>page</code> <code>int</code> <p>Specify exactly what page you want to retrieve. If not specified, we use a default value of 1.</p> <code>1</code> <code>pagination</code> <code>int</code> <p>Specifies how many records you want to retrieve per page. If not specified we use a default value of 50.</p> <code>50</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[list[Customer]] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/customers.py</code> <pre><code>async def get_customers(\n    self,\n    start_date: str | None = None,\n    end_date: str | None = None,\n    page: int = 1,\n    pagination: int = 50,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[list[Customer]] | Response[PaystackDataModel]:\n    \"\"\"Fetches customers available on your integration.\n\n    Args:\n        start_date: A timestamp from which to start listing customers e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        end_date: A timestamp at which to stop listing customers e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        page: Specify exactly what page you want to retrieve. If not specified, we use a default value of 1.\n        pagination: Specifies how many records you want to retrieve per page.\n            If not specified we use a default value of 50.\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    query_params = [\n        (\"page\", page),\n        (\"from\", start_date),\n        (\"to\", end_date),\n    ]\n    url = self._full_url(f\"/customer/?perPage={pagination}\")\n    url = append_query_params(query_params, url)\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or Customer,\n    )\n</code></pre>"},{"location":"reference/customer/#pypaystack2.sub_clients.async_clients.customers.AsyncCustomerClient.update","title":"<code>update(code, first_name=None, last_name=None, phone=None, metadata=None, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Update a customer's details on your integration</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>Customer's code</p> required <code>first_name</code> <code>str | None</code> <p>Customer's first name</p> <code>None</code> <code>last_name</code> <code>str | None</code> <p>Customer's last name</p> <code>None</code> <code>phone</code> <code>str | None</code> <p>Customer's phone number</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>A dictionary that you can attach to the customer. It can be used to store additional information in a structured format.</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[Customer] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/customers.py</code> <pre><code>async def update(\n    self,\n    code: str,\n    first_name: str | None = None,\n    last_name: str | None = None,\n    phone: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[Customer] | Response[PaystackDataModel]:\n    \"\"\"Update a customer's details on your integration\n\n    Args:\n        code: Customer's code\n        first_name: Customer's first name\n        last_name: Customer's last name\n        phone: Customer's phone number\n        metadata: A dictionary that you can attach to the customer. It can be used to store additional\n            information in a structured format.\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/customer/{code}/\")\n    payload: dict[str, Any] = {}\n\n    optional_params = [\n        (\"first_name\", first_name),\n        (\"last_name\", last_name),\n        (\"phone\", phone),\n        (\"metadata\", metadata),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.PUT,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or Customer,\n    )\n</code></pre>"},{"location":"reference/customer/#pypaystack2.sub_clients.async_clients.customers.AsyncCustomerClient.validate","title":"<code>validate(email_or_code, first_name, last_name, identification_type, country, bvn, identification_number=None, bank_code=None, account_number=None, middle_name=None, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Validate a customer's identity</p> <p>Parameters:</p> Name Type Description Default <code>email_or_code</code> <code>str</code> <p>Customer's email or code</p> required <code>first_name</code> <code>str</code> <p>Customer's first name</p> required <code>last_name</code> <code>str</code> <p>Customer's last name</p> required <code>identification_type</code> <code>Identification</code> <p>Enum of Identification e.g <code>Identification.BVN</code></p> required <code>identification_number</code> <code>str | None</code> <p>An identification number based on the <code>identification_type</code></p> <code>None</code> <code>country</code> <code>Country</code> <p>Customer's Country e.g <code>Country.NIGERIA</code></p> required <code>bvn</code> <code>str</code> <p>Customer's Bank Verification Number</p> required <code>bank_code</code> <code>str | None</code> <p>You can get the list of Bank Codes by calling the Miscellaneous API <code>get_banks</code> method. (required if type is bank_account)</p> <code>None</code> <code>account_number</code> <code>str | None</code> <p>Customer's bank account number. (required if type is bank_account)</p> <code>None</code> <code>middle_name</code> <code>str | None</code> <p>Customer's middle name</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[None] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/customers.py</code> <pre><code>async def validate(\n    self,\n    email_or_code: str,\n    first_name: str,\n    last_name: str,\n    identification_type: Identification,\n    country: Country,\n    bvn: str,\n    identification_number: str | None = None,\n    bank_code: str | None = None,\n    account_number: str | None = None,\n    middle_name: str | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[None] | Response[PaystackDataModel]:\n    \"\"\"Validate a customer's identity\n\n    Args:\n        email_or_code: Customer's email or code\n        first_name: Customer's first name\n        last_name: Customer's last name\n        identification_type: Enum of Identification e.g `Identification.BVN`\n        identification_number: An identification number based on the `identification_type`\n        country: Customer's Country e.g `Country.NIGERIA`\n        bvn: Customer's Bank Verification Number\n        bank_code: You can get the list of Bank Codes by calling the\n            Miscellaneous API `get_banks` method. (required if type is bank_account)\n        account_number: Customer's bank account number. (required if type is bank_account)\n        middle_name: Customer's middle name\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    if identification_type == Identification.BANK_ACCOUNT:\n        if bank_code is None:\n            raise ValueError(\n                \"`bank_code` is required if identification type is `Identification.BANK_ACCOUNT`\"\n            )\n        if account_number is None:\n            raise ValueError(\n                \"`account_number` is required if identification type is `Identification.BANK_ACCOUNT`\"\n            )\n\n    url = self._full_url(f\"/customer/{email_or_code}/identification\")\n    payload = {\n        \"first_name\": first_name,\n        \"last_name\": last_name,\n        \"type\": identification_type,\n        \"country\": country,\n        \"bvn\": bvn,\n    }\n    optional_params = [\n        (\"bank_code\", bank_code),\n        (\"account_number\", account_number),\n        (\"middle_name\", middle_name),\n        (\"value\", identification_number),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class,\n    )\n</code></pre>"},{"location":"reference/dedicated_accounts/","title":"Dedicated accounts","text":""},{"location":"reference/dedicated_accounts/#pypaystack2.sub_clients.sync_clients.dedicated_accounts.DedicatedAccountClient","title":"<code>DedicatedAccountClient</code>","text":"<p>               Bases: <code>BaseAPIClient</code></p> <p>Provides a wrapper for paystack Dedicated Virtual Account API</p> <p>The Dedicated Virtual Account API enables Nigerian merchants to manage unique payment accounts of their customers. https://paystack.com/docs/api/dedicated-virtual-account/</p> Note <p>This feature is only available to businesses in Nigeria.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/dedicated_accounts.py</code> <pre><code>class DedicatedAccountClient(BaseAPIClient):\n    \"\"\"Provides a wrapper for paystack Dedicated Virtual Account API\n\n    The Dedicated Virtual Account API enables Nigerian merchants to manage\n    unique payment accounts of their customers.\n    https://paystack.com/docs/api/dedicated-virtual-account/\n\n\n    Note:\n        This feature is only available to businesses in Nigeria.\n    \"\"\"\n\n    def create(\n        self,\n        customer: str,\n        preferred_bank: str | None = None,\n        subaccount: str | None = None,\n        split_code: str | None = None,\n        first_name: str | None = None,\n        last_name: str | None = None,\n        phone: str | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[DedicatedAccount] | Response[PaystackDataModel]:\n        \"\"\"Create a dedicated virtual account for an existing customer\n\n        Note:\n            * This feature is only available to businesses in Nigeria.\n            * Paystack currently supports Wema Bank and Titan Paystack.\n\n        Args:\n            customer: Customer ID or code\n            preferred_bank: The bank slug for a preferred bank. To get a list of available banks, use the\n                Miscellaneous API ``.get_providers`` method.\n            subaccount: Subaccount code of the account you want to split the transaction with\n            split_code: Split code consisting of the lists of accounts you want to split the transaction with\n            first_name: Customer's first name\n            last_name: Customer's last name\n            phone: Customer's phone number\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(\"/dedicated_account\")\n        payload = {\n            \"customer\": customer,\n        }\n        optional_params = [\n            (\"preferred_bank\", preferred_bank),\n            (\"subaccount\", subaccount),\n            (\"split_code\", split_code),\n            (\"first_name\", first_name),\n            (\"last_name\", last_name),\n            (\"phone\", phone),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return self._handle_request(\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or DedicatedAccount,\n        )\n\n    def assign(\n        self,\n        email: str,\n        first_name: str,\n        last_name: str,\n        phone: str,\n        preferred_bank: str,\n        country: Country = Country.NIGERIA,\n        account_number: str | None = None,\n        bvn: str | None = None,\n        bank_code: str | None = None,\n        subaccount: str | None = None,\n        split_code: str | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[None] | Response[PaystackDataModel]:\n        \"\"\"Create a customer, validate the customer, and assign a DVA to the customer.\n\n        Note:\n            * This feature is only available to businesses in Nigeria.\n            * Paystack currently supports Wema Bank and Titan Paystack.\n\n        Args:\n            email: Customer email address\n            first_name: Customer's first name\n            last_name: Customer's last name\n            phone: Customer's phone number\n            preferred_bank: The bank slug for preferred bank. To get a list of available banks, use the\n                Paystack.miscellaneous.get_banks, AsyncPaystack.miscellaneous.get_banks, Miscellaneous.get_banks\n                or AsyncMiscellaneous.get_banks, with `pay_with_bank_transfer=true`\n            country: Currently accepts `Country.NIGERIA` only\n            account_number: Customer's account number\n            bvn: Customer's Bank Verification Number\n            bank_code: Customer's bank code\n            subaccount: Subaccount code of the account you want to split the transaction with\n            split_code: Split code consisting of the lists of accounts you want to split the transaction with\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(\"/dedicated_account/assign\")\n        payload = {\n            \"email\": email,\n            \"first_name\": first_name,\n            \"last_name\": last_name,\n            \"phone\": phone,\n            \"preferred_bank\": preferred_bank,\n            \"country\": country,\n        }\n        optional_params = [\n            (\"account_number\", account_number),\n            (\"bvn\", bvn),\n            (\"bank_code\", bank_code),\n            (\"subaccount\", subaccount),\n            (\"split_code\", split_code),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class,\n        )\n\n    def get_dedicated_accounts(\n        self,\n        active: bool = True,\n        currency: Currency = Currency.NGN,\n        provider_slug: str | None = None,\n        bank_id: str | int | None = None,\n        customer: str | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[list[DedicatedAccount]] | Response[PaystackDataModel]:\n        \"\"\"Fetches dedicated virtual accounts available on your integration.\n\n        Note:\n            * This feature is only available to businesses in Nigeria.\n            * Paystack currently supports Wema Bank and Titan Paystack.\n\n        Args:\n            active: Status of the dedicated virtual account\n            currency: The currency of the dedicated virtual account. Only ``Currency.NGN`` is currently allowed\n            provider_slug: The bank's slug in lowercase, without spaces e.g. wema-bank. call the `.get_providers`\n                method of this class to see available providers.\n            bank_id: The bank's ID e.g., 035\n            customer: The customer's ID\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        query_params = [\n            (\"currency\", currency),\n            (\"provider_slug\", provider_slug),\n            (\"bank_id\", bank_id),\n            (\"customer\", customer),\n        ]\n        url = self._full_url(f\"/dedicated_account?active={active}\")\n        url = append_query_params(query_params, url)\n        return self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or DedicatedAccount,\n        )\n\n    def get_dedicated_account(\n        self,\n        dedicated_account_id: int | str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[DedicatedAccount] | Response[PaystackDataModel]:\n        \"\"\"Get details of a dedicated virtual account on your integration.\n\n        Note:\n            * This feature is only available to businesses in Nigeria.\n            * Paystack currently supports Wema Bank and Titan Paystack.\n\n        Args:\n            dedicated_account_id: ID of dedicated virtual account\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/dedicated_account/{dedicated_account_id}\")\n        return self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or DedicatedAccount,\n        )\n\n    def requery(\n        self,\n        account_number: str,\n        provider_slug: str,\n        date: str | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[None] | Response[PaystackDataModel]:\n        \"\"\"Get details of a dedicated virtual account on your integration.\n\n        Note:\n            * This feature is only available to businesses in Nigeria.\n            * Paystack currently supports Wema Bank and Titan Paystack.\n\n        Args:\n            account_number: Virtual account number to requery\n            provider_slug: The bank's slug in lowercase, without spaces e.g. wema-bank\n            date: The day the transfer was made in YYYY-MM-DD ISO format\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/dedicated_account?account_number={account_number}\")\n        query_params = [\n            (\"provider_slug\", provider_slug),\n            (\"date\", date),\n        ]\n        url = append_query_params(query_params, url)\n        return self._handle_request(  # type: ignore\n            HTTPMethod.GET, url, response_data_model_class=alternate_model_class\n        )\n\n    def deactivate(\n        self,\n        dedicated_account_id: int | str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[DedicatedAccount] | Response[PaystackDataModel]:\n        \"\"\"Deactivate a dedicated virtual account on your integration.\n\n        Note:\n            * This feature is only available to businesses in Nigeria.\n            * Paystack currently supports Access Bank and Wema Bank.\n\n        Args:\n            dedicated_account_id: ID of dedicated virtual account\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/dedicated_account/{dedicated_account_id}\")\n        return self._handle_request(  # type: ignore\n            HTTPMethod.DELETE, url, response_data_model_class=alternate_model_class\n        )\n\n    def split(\n        self,\n        customer: int | str,\n        subaccount: str | None = None,\n        split_code: str | None = None,\n        preferred_bank: str | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[DedicatedAccount] | Response[PaystackDataModel]:\n        \"\"\"Split a dedicated virtual account transaction with one or more accounts\n\n        Note:\n            * This feature is only available to businesses in Nigeria.\n            * Paystack currently supports Access Bank and Wema Bank.\n\n        Args:\n            customer: Customer ID or code\n            subaccount: Subaccount code of the account you want to split the transaction with\n            split_code: Split code consisting of the lists of accounts you want to split the transaction with\n            preferred_bank: The bank slug for a preferred bank. To get a list of available banks,\n                use the Miscellaneous API ``.get_providers`` method\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(\"/dedicated_account/split\")\n        payload = {\"customer\": customer}\n\n        optional_params = [\n            (\"subaccount\", subaccount),\n            (\"split_code\", split_code),\n            (\"preferred_bank\", preferred_bank),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or DedicatedAccount,\n        )\n\n    def remove_split(\n        self,\n        account_number: str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[DedicatedAccount] | Response[PaystackDataModel]:\n        \"\"\"Removes a split.\n\n        If you've previously set up split payment for transactions on a dedicated virtual\n        account, you can remove it with this method.\n\n        Note:\n            * This feature is only available to businesses in Nigeria.\n            * Paystack currently supports Access Bank and Wema Bank.\n\n        Args:\n            account_number: Dedicated virtual account number\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(\"/dedicated_account/split\")\n        payload = {\n            \"account_number\": account_number,\n        }\n        return self._handle_request(  # type: ignore\n            HTTPMethod.DELETE,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or DedicatedAccount,\n        )\n\n    def get_providers(\n        self,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[list[DedicatedAccountProvider]] | Response[PaystackDataModel]:\n        \"\"\"Get available bank providers for a dedicated virtual account\n\n        Note:\n            * This feature is only available to businesses in Nigeria.\n            * Paystack currently supports Access Bank and Wema Bank.\n\n        Args:\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(\"/dedicated_account/available_providers\")\n        return self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or DedicatedAccountProvider,\n        )\n</code></pre>"},{"location":"reference/dedicated_accounts/#pypaystack2.sub_clients.sync_clients.dedicated_accounts.DedicatedAccountClient.assign","title":"<code>assign(email, first_name, last_name, phone, preferred_bank, country=Country.NIGERIA, account_number=None, bvn=None, bank_code=None, subaccount=None, split_code=None, alternate_model_class=None)</code>","text":"<p>Create a customer, validate the customer, and assign a DVA to the customer.</p> Note <ul> <li>This feature is only available to businesses in Nigeria.</li> <li>Paystack currently supports Wema Bank and Titan Paystack.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Customer email address</p> required <code>first_name</code> <code>str</code> <p>Customer's first name</p> required <code>last_name</code> <code>str</code> <p>Customer's last name</p> required <code>phone</code> <code>str</code> <p>Customer's phone number</p> required <code>preferred_bank</code> <code>str</code> <p>The bank slug for preferred bank. To get a list of available banks, use the Paystack.miscellaneous.get_banks, AsyncPaystack.miscellaneous.get_banks, Miscellaneous.get_banks or AsyncMiscellaneous.get_banks, with <code>pay_with_bank_transfer=true</code></p> required <code>country</code> <code>Country</code> <p>Currently accepts <code>Country.NIGERIA</code> only</p> <code>NIGERIA</code> <code>account_number</code> <code>str | None</code> <p>Customer's account number</p> <code>None</code> <code>bvn</code> <code>str | None</code> <p>Customer's Bank Verification Number</p> <code>None</code> <code>bank_code</code> <code>str | None</code> <p>Customer's bank code</p> <code>None</code> <code>subaccount</code> <code>str | None</code> <p>Subaccount code of the account you want to split the transaction with</p> <code>None</code> <code>split_code</code> <code>str | None</code> <p>Split code consisting of the lists of accounts you want to split the transaction with</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[None] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/dedicated_accounts.py</code> <pre><code>def assign(\n    self,\n    email: str,\n    first_name: str,\n    last_name: str,\n    phone: str,\n    preferred_bank: str,\n    country: Country = Country.NIGERIA,\n    account_number: str | None = None,\n    bvn: str | None = None,\n    bank_code: str | None = None,\n    subaccount: str | None = None,\n    split_code: str | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[None] | Response[PaystackDataModel]:\n    \"\"\"Create a customer, validate the customer, and assign a DVA to the customer.\n\n    Note:\n        * This feature is only available to businesses in Nigeria.\n        * Paystack currently supports Wema Bank and Titan Paystack.\n\n    Args:\n        email: Customer email address\n        first_name: Customer's first name\n        last_name: Customer's last name\n        phone: Customer's phone number\n        preferred_bank: The bank slug for preferred bank. To get a list of available banks, use the\n            Paystack.miscellaneous.get_banks, AsyncPaystack.miscellaneous.get_banks, Miscellaneous.get_banks\n            or AsyncMiscellaneous.get_banks, with `pay_with_bank_transfer=true`\n        country: Currently accepts `Country.NIGERIA` only\n        account_number: Customer's account number\n        bvn: Customer's Bank Verification Number\n        bank_code: Customer's bank code\n        subaccount: Subaccount code of the account you want to split the transaction with\n        split_code: Split code consisting of the lists of accounts you want to split the transaction with\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(\"/dedicated_account/assign\")\n    payload = {\n        \"email\": email,\n        \"first_name\": first_name,\n        \"last_name\": last_name,\n        \"phone\": phone,\n        \"preferred_bank\": preferred_bank,\n        \"country\": country,\n    }\n    optional_params = [\n        (\"account_number\", account_number),\n        (\"bvn\", bvn),\n        (\"bank_code\", bank_code),\n        (\"subaccount\", subaccount),\n        (\"split_code\", split_code),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class,\n    )\n</code></pre>"},{"location":"reference/dedicated_accounts/#pypaystack2.sub_clients.sync_clients.dedicated_accounts.DedicatedAccountClient.create","title":"<code>create(customer, preferred_bank=None, subaccount=None, split_code=None, first_name=None, last_name=None, phone=None, alternate_model_class=None)</code>","text":"<p>Create a dedicated virtual account for an existing customer</p> Note <ul> <li>This feature is only available to businesses in Nigeria.</li> <li>Paystack currently supports Wema Bank and Titan Paystack.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>customer</code> <code>str</code> <p>Customer ID or code</p> required <code>preferred_bank</code> <code>str | None</code> <p>The bank slug for a preferred bank. To get a list of available banks, use the Miscellaneous API <code>.get_providers</code> method.</p> <code>None</code> <code>subaccount</code> <code>str | None</code> <p>Subaccount code of the account you want to split the transaction with</p> <code>None</code> <code>split_code</code> <code>str | None</code> <p>Split code consisting of the lists of accounts you want to split the transaction with</p> <code>None</code> <code>first_name</code> <code>str | None</code> <p>Customer's first name</p> <code>None</code> <code>last_name</code> <code>str | None</code> <p>Customer's last name</p> <code>None</code> <code>phone</code> <code>str | None</code> <p>Customer's phone number</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[DedicatedAccount] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/dedicated_accounts.py</code> <pre><code>def create(\n    self,\n    customer: str,\n    preferred_bank: str | None = None,\n    subaccount: str | None = None,\n    split_code: str | None = None,\n    first_name: str | None = None,\n    last_name: str | None = None,\n    phone: str | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[DedicatedAccount] | Response[PaystackDataModel]:\n    \"\"\"Create a dedicated virtual account for an existing customer\n\n    Note:\n        * This feature is only available to businesses in Nigeria.\n        * Paystack currently supports Wema Bank and Titan Paystack.\n\n    Args:\n        customer: Customer ID or code\n        preferred_bank: The bank slug for a preferred bank. To get a list of available banks, use the\n            Miscellaneous API ``.get_providers`` method.\n        subaccount: Subaccount code of the account you want to split the transaction with\n        split_code: Split code consisting of the lists of accounts you want to split the transaction with\n        first_name: Customer's first name\n        last_name: Customer's last name\n        phone: Customer's phone number\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(\"/dedicated_account\")\n    payload = {\n        \"customer\": customer,\n    }\n    optional_params = [\n        (\"preferred_bank\", preferred_bank),\n        (\"subaccount\", subaccount),\n        (\"split_code\", split_code),\n        (\"first_name\", first_name),\n        (\"last_name\", last_name),\n        (\"phone\", phone),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return self._handle_request(\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or DedicatedAccount,\n    )\n</code></pre>"},{"location":"reference/dedicated_accounts/#pypaystack2.sub_clients.sync_clients.dedicated_accounts.DedicatedAccountClient.deactivate","title":"<code>deactivate(dedicated_account_id, alternate_model_class=None)</code>","text":"<p>Deactivate a dedicated virtual account on your integration.</p> Note <ul> <li>This feature is only available to businesses in Nigeria.</li> <li>Paystack currently supports Access Bank and Wema Bank.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>dedicated_account_id</code> <code>int | str</code> <p>ID of dedicated virtual account</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[DedicatedAccount] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/dedicated_accounts.py</code> <pre><code>def deactivate(\n    self,\n    dedicated_account_id: int | str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[DedicatedAccount] | Response[PaystackDataModel]:\n    \"\"\"Deactivate a dedicated virtual account on your integration.\n\n    Note:\n        * This feature is only available to businesses in Nigeria.\n        * Paystack currently supports Access Bank and Wema Bank.\n\n    Args:\n        dedicated_account_id: ID of dedicated virtual account\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/dedicated_account/{dedicated_account_id}\")\n    return self._handle_request(  # type: ignore\n        HTTPMethod.DELETE, url, response_data_model_class=alternate_model_class\n    )\n</code></pre>"},{"location":"reference/dedicated_accounts/#pypaystack2.sub_clients.sync_clients.dedicated_accounts.DedicatedAccountClient.get_dedicated_account","title":"<code>get_dedicated_account(dedicated_account_id, alternate_model_class=None)</code>","text":"<p>Get details of a dedicated virtual account on your integration.</p> Note <ul> <li>This feature is only available to businesses in Nigeria.</li> <li>Paystack currently supports Wema Bank and Titan Paystack.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>dedicated_account_id</code> <code>int | str</code> <p>ID of dedicated virtual account</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[DedicatedAccount] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/dedicated_accounts.py</code> <pre><code>def get_dedicated_account(\n    self,\n    dedicated_account_id: int | str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[DedicatedAccount] | Response[PaystackDataModel]:\n    \"\"\"Get details of a dedicated virtual account on your integration.\n\n    Note:\n        * This feature is only available to businesses in Nigeria.\n        * Paystack currently supports Wema Bank and Titan Paystack.\n\n    Args:\n        dedicated_account_id: ID of dedicated virtual account\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/dedicated_account/{dedicated_account_id}\")\n    return self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or DedicatedAccount,\n    )\n</code></pre>"},{"location":"reference/dedicated_accounts/#pypaystack2.sub_clients.sync_clients.dedicated_accounts.DedicatedAccountClient.get_dedicated_accounts","title":"<code>get_dedicated_accounts(active=True, currency=Currency.NGN, provider_slug=None, bank_id=None, customer=None, alternate_model_class=None)</code>","text":"<p>Fetches dedicated virtual accounts available on your integration.</p> Note <ul> <li>This feature is only available to businesses in Nigeria.</li> <li>Paystack currently supports Wema Bank and Titan Paystack.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>active</code> <code>bool</code> <p>Status of the dedicated virtual account</p> <code>True</code> <code>currency</code> <code>Currency</code> <p>The currency of the dedicated virtual account. Only <code>Currency.NGN</code> is currently allowed</p> <code>NGN</code> <code>provider_slug</code> <code>str | None</code> <p>The bank's slug in lowercase, without spaces e.g. wema-bank. call the <code>.get_providers</code> method of this class to see available providers.</p> <code>None</code> <code>bank_id</code> <code>str | int | None</code> <p>The bank's ID e.g., 035</p> <code>None</code> <code>customer</code> <code>str | None</code> <p>The customer's ID</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[list[DedicatedAccount]] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/dedicated_accounts.py</code> <pre><code>def get_dedicated_accounts(\n    self,\n    active: bool = True,\n    currency: Currency = Currency.NGN,\n    provider_slug: str | None = None,\n    bank_id: str | int | None = None,\n    customer: str | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[list[DedicatedAccount]] | Response[PaystackDataModel]:\n    \"\"\"Fetches dedicated virtual accounts available on your integration.\n\n    Note:\n        * This feature is only available to businesses in Nigeria.\n        * Paystack currently supports Wema Bank and Titan Paystack.\n\n    Args:\n        active: Status of the dedicated virtual account\n        currency: The currency of the dedicated virtual account. Only ``Currency.NGN`` is currently allowed\n        provider_slug: The bank's slug in lowercase, without spaces e.g. wema-bank. call the `.get_providers`\n            method of this class to see available providers.\n        bank_id: The bank's ID e.g., 035\n        customer: The customer's ID\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    query_params = [\n        (\"currency\", currency),\n        (\"provider_slug\", provider_slug),\n        (\"bank_id\", bank_id),\n        (\"customer\", customer),\n    ]\n    url = self._full_url(f\"/dedicated_account?active={active}\")\n    url = append_query_params(query_params, url)\n    return self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or DedicatedAccount,\n    )\n</code></pre>"},{"location":"reference/dedicated_accounts/#pypaystack2.sub_clients.sync_clients.dedicated_accounts.DedicatedAccountClient.get_providers","title":"<code>get_providers(alternate_model_class=None)</code>","text":"<p>Get available bank providers for a dedicated virtual account</p> Note <ul> <li>This feature is only available to businesses in Nigeria.</li> <li>Paystack currently supports Access Bank and Wema Bank.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[list[DedicatedAccountProvider]] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/dedicated_accounts.py</code> <pre><code>def get_providers(\n    self,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[list[DedicatedAccountProvider]] | Response[PaystackDataModel]:\n    \"\"\"Get available bank providers for a dedicated virtual account\n\n    Note:\n        * This feature is only available to businesses in Nigeria.\n        * Paystack currently supports Access Bank and Wema Bank.\n\n    Args:\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(\"/dedicated_account/available_providers\")\n    return self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or DedicatedAccountProvider,\n    )\n</code></pre>"},{"location":"reference/dedicated_accounts/#pypaystack2.sub_clients.sync_clients.dedicated_accounts.DedicatedAccountClient.remove_split","title":"<code>remove_split(account_number, alternate_model_class=None)</code>","text":"<p>Removes a split.</p> <p>If you've previously set up split payment for transactions on a dedicated virtual account, you can remove it with this method.</p> Note <ul> <li>This feature is only available to businesses in Nigeria.</li> <li>Paystack currently supports Access Bank and Wema Bank.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>account_number</code> <code>str</code> <p>Dedicated virtual account number</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[DedicatedAccount] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/dedicated_accounts.py</code> <pre><code>def remove_split(\n    self,\n    account_number: str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[DedicatedAccount] | Response[PaystackDataModel]:\n    \"\"\"Removes a split.\n\n    If you've previously set up split payment for transactions on a dedicated virtual\n    account, you can remove it with this method.\n\n    Note:\n        * This feature is only available to businesses in Nigeria.\n        * Paystack currently supports Access Bank and Wema Bank.\n\n    Args:\n        account_number: Dedicated virtual account number\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(\"/dedicated_account/split\")\n    payload = {\n        \"account_number\": account_number,\n    }\n    return self._handle_request(  # type: ignore\n        HTTPMethod.DELETE,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or DedicatedAccount,\n    )\n</code></pre>"},{"location":"reference/dedicated_accounts/#pypaystack2.sub_clients.sync_clients.dedicated_accounts.DedicatedAccountClient.requery","title":"<code>requery(account_number, provider_slug, date=None, alternate_model_class=None)</code>","text":"<p>Get details of a dedicated virtual account on your integration.</p> Note <ul> <li>This feature is only available to businesses in Nigeria.</li> <li>Paystack currently supports Wema Bank and Titan Paystack.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>account_number</code> <code>str</code> <p>Virtual account number to requery</p> required <code>provider_slug</code> <code>str</code> <p>The bank's slug in lowercase, without spaces e.g. wema-bank</p> required <code>date</code> <code>str | None</code> <p>The day the transfer was made in YYYY-MM-DD ISO format</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[None] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/dedicated_accounts.py</code> <pre><code>def requery(\n    self,\n    account_number: str,\n    provider_slug: str,\n    date: str | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[None] | Response[PaystackDataModel]:\n    \"\"\"Get details of a dedicated virtual account on your integration.\n\n    Note:\n        * This feature is only available to businesses in Nigeria.\n        * Paystack currently supports Wema Bank and Titan Paystack.\n\n    Args:\n        account_number: Virtual account number to requery\n        provider_slug: The bank's slug in lowercase, without spaces e.g. wema-bank\n        date: The day the transfer was made in YYYY-MM-DD ISO format\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/dedicated_account?account_number={account_number}\")\n    query_params = [\n        (\"provider_slug\", provider_slug),\n        (\"date\", date),\n    ]\n    url = append_query_params(query_params, url)\n    return self._handle_request(  # type: ignore\n        HTTPMethod.GET, url, response_data_model_class=alternate_model_class\n    )\n</code></pre>"},{"location":"reference/dedicated_accounts/#pypaystack2.sub_clients.sync_clients.dedicated_accounts.DedicatedAccountClient.split","title":"<code>split(customer, subaccount=None, split_code=None, preferred_bank=None, alternate_model_class=None)</code>","text":"<p>Split a dedicated virtual account transaction with one or more accounts</p> Note <ul> <li>This feature is only available to businesses in Nigeria.</li> <li>Paystack currently supports Access Bank and Wema Bank.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>customer</code> <code>int | str</code> <p>Customer ID or code</p> required <code>subaccount</code> <code>str | None</code> <p>Subaccount code of the account you want to split the transaction with</p> <code>None</code> <code>split_code</code> <code>str | None</code> <p>Split code consisting of the lists of accounts you want to split the transaction with</p> <code>None</code> <code>preferred_bank</code> <code>str | None</code> <p>The bank slug for a preferred bank. To get a list of available banks, use the Miscellaneous API <code>.get_providers</code> method</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[DedicatedAccount] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/dedicated_accounts.py</code> <pre><code>def split(\n    self,\n    customer: int | str,\n    subaccount: str | None = None,\n    split_code: str | None = None,\n    preferred_bank: str | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[DedicatedAccount] | Response[PaystackDataModel]:\n    \"\"\"Split a dedicated virtual account transaction with one or more accounts\n\n    Note:\n        * This feature is only available to businesses in Nigeria.\n        * Paystack currently supports Access Bank and Wema Bank.\n\n    Args:\n        customer: Customer ID or code\n        subaccount: Subaccount code of the account you want to split the transaction with\n        split_code: Split code consisting of the lists of accounts you want to split the transaction with\n        preferred_bank: The bank slug for a preferred bank. To get a list of available banks,\n            use the Miscellaneous API ``.get_providers`` method\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(\"/dedicated_account/split\")\n    payload = {\"customer\": customer}\n\n    optional_params = [\n        (\"subaccount\", subaccount),\n        (\"split_code\", split_code),\n        (\"preferred_bank\", preferred_bank),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or DedicatedAccount,\n    )\n</code></pre>"},{"location":"reference/dedicated_accounts/#pypaystack2.sub_clients.async_clients.dedicated_accounts.AsyncDedicatedAccountClient","title":"<code>AsyncDedicatedAccountClient</code>","text":"<p>               Bases: <code>BaseAsyncAPIClient</code></p> <p>Provides a wrapper for paystack Dedicated Virtual Account API</p> <p>The Dedicated Virtual Account API enables Nigerian merchants to manage unique payment accounts of their customers. https://paystack.com/docs/api/dedicated-virtual-account/</p> Note <p>This feature is only available to businesses in Nigeria.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/dedicated_accounts.py</code> <pre><code>class AsyncDedicatedAccountClient(BaseAsyncAPIClient):\n    \"\"\"Provides a wrapper for paystack Dedicated Virtual Account API\n\n    The Dedicated Virtual Account API enables Nigerian merchants to manage\n    unique payment accounts of their customers.\n    https://paystack.com/docs/api/dedicated-virtual-account/\n\n\n    Note:\n        This feature is only available to businesses in Nigeria.\n    \"\"\"\n\n    async def create(\n        self,\n        customer: str,\n        preferred_bank: str | None = None,\n        subaccount: str | None = None,\n        split_code: str | None = None,\n        first_name: str | None = None,\n        last_name: str | None = None,\n        phone: str | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[DedicatedAccount] | Response[PaystackDataModel]:\n        \"\"\"Create a dedicated virtual account for an existing customer\n\n        Note:\n            * This feature is only available to businesses in Nigeria.\n            * Paystack currently supports Wema Bank and Titan Paystack.\n\n        Args:\n            customer: Customer ID or code\n            preferred_bank: The bank slug for a preferred bank. To get a list of available banks, use the\n                Miscellaneous API ``.get_providers`` method.\n            subaccount: Subaccount code of the account you want to split the transaction with\n            split_code: Split code consisting of the lists of accounts you want to split the transaction with\n            first_name: Customer's first name\n            last_name: Customer's last name\n            phone: Customer's phone number\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(\"/dedicated_account\")\n        payload = {\n            \"customer\": customer,\n        }\n        optional_params = [\n            (\"preferred_bank\", preferred_bank),\n            (\"subaccount\", subaccount),\n            (\"split_code\", split_code),\n            (\"first_name\", first_name),\n            (\"last_name\", last_name),\n            (\"phone\", phone),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or DedicatedAccount,\n        )\n\n    async def assign(\n        self,\n        email: str,\n        first_name: str,\n        last_name: str,\n        phone: str,\n        preferred_bank: str,\n        country: Country = Country.NIGERIA,\n        account_number: str | None = None,\n        bvn: str | None = None,\n        bank_code: str | None = None,\n        subaccount: str | None = None,\n        split_code: str | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[None] | Response[PaystackDataModel]:\n        \"\"\"Create a customer, validate the customer, and assign a DVA to the customer.\n\n        Note:\n            * This feature is only available to businesses in Nigeria.\n            * Paystack currently supports Wema Bank and Titan Paystack.\n\n        Args:\n            email: Customer email address\n            first_name: Customer's first name\n            last_name: Customer's last name\n            phone: Customer's phone number\n            preferred_bank: The bank slug for preferred bank. To get a list of available banks, use the\n                Paystack.miscellaneous.get_banks, AsyncPaystack.miscellaneous.get_banks, Miscellaneous.get_banks\n                or AsyncMiscellaneous.get_banks, with `pay_with_bank_transfer=true`\n            country: Currently accepts `Country.NIGERIA` only\n            account_number: Customer's account number\n            bvn: Customer's Bank Verification Number\n            bank_code: Customer's bank code\n            subaccount: Subaccount code of the account you want to split the transaction with\n            split_code: Split code consisting of the lists of accounts you want to split the transaction with\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(\"/dedicated_account/assign\")\n        payload = {\n            \"email\": email,\n            \"first_name\": first_name,\n            \"last_name\": last_name,\n            \"phone\": phone,\n            \"preferred_bank\": preferred_bank,\n            \"country\": country,\n        }\n        optional_params = [\n            (\"account_number\", account_number),\n            (\"bvn\", bvn),\n            (\"bank_code\", bank_code),\n            (\"subaccount\", subaccount),\n            (\"split_code\", split_code),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class,\n        )\n\n    async def get_dedicated_accounts(\n        self,\n        active: bool = True,\n        currency: Currency = Currency.NGN,\n        provider_slug: str | None = None,\n        bank_id: str | int | None = None,\n        customer: str | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[list[DedicatedAccount]] | Response[PaystackDataModel]:\n        \"\"\"Fetches dedicated virtual accounts available on your integration.\n\n        Note:\n            * This feature is only available to businesses in Nigeria.\n            * Paystack currently supports Wema Bank and Titan Paystack.\n\n        Args:\n            active: Status of the dedicated virtual account\n            currency: The currency of the dedicated virtual account. Only ``Currency.NGN`` is currently allowed\n            provider_slug: The bank's slug in lowercase, without spaces e.g. wema-bank. call the `.get_providers`\n                method of this class to see available providers.\n            bank_id: The bank's ID e.g., 035\n            customer: The customer's ID\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        query_params = [\n            (\"currency\", currency),\n            (\"provider_slug\", provider_slug),\n            (\"bank_id\", bank_id),\n            (\"customer\", customer),\n        ]\n        url = self._full_url(f\"/dedicated_account?active={active}\")\n        url = append_query_params(query_params, url)\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or DedicatedAccount,\n        )\n\n    async def get_dedicated_account(\n        self,\n        dedicated_account_id: int | str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[DedicatedAccount] | Response[PaystackDataModel]:\n        \"\"\"Get details of a dedicated virtual account on your integration.\n\n        Note:\n            * This feature is only available to businesses in Nigeria.\n            * Paystack currently supports Wema Bank and Titan Paystack.\n\n        Args:\n            dedicated_account_id: ID of dedicated virtual account\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/dedicated_account/{dedicated_account_id}\")\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or DedicatedAccount,\n        )\n\n    async def requery(\n        self,\n        account_number: str,\n        provider_slug: str,\n        date: str | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[None] | Response[PaystackDataModel]:\n        \"\"\"Get details of a dedicated virtual account on your integration.\n\n        Note:\n            * This feature is only available to businesses in Nigeria.\n            * Paystack currently supports Wema Bank and Titan Paystack.\n\n        Args:\n            account_number: Virtual account number to requery\n            provider_slug: The bank's slug in lowercase, without spaces e.g. wema-bank\n            date: The day the transfer was made in YYYY-MM-DD ISO format\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/dedicated_account?account_number={account_number}\")\n        query_params = [\n            (\"provider_slug\", provider_slug),\n            (\"date\", date),\n        ]\n        url = append_query_params(query_params, url)\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.GET, url, response_data_model_class=alternate_model_class\n        )\n\n    async def deactivate(\n        self,\n        dedicated_account_id: int | str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[DedicatedAccount] | Response[PaystackDataModel]:\n        \"\"\"Deactivate a dedicated virtual account on your integration.\n\n        Note:\n            * This feature is only available to businesses in Nigeria.\n            * Paystack currently supports Access Bank and Wema Bank.\n\n        Args:\n            dedicated_account_id: ID of dedicated virtual account\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/dedicated_account/{dedicated_account_id}\")\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.DELETE, url, response_data_model_class=alternate_model_class\n        )\n\n    async def split(\n        self,\n        customer: int | str,\n        subaccount: str | None = None,\n        split_code: str | None = None,\n        preferred_bank: str | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[DedicatedAccount] | Response[PaystackDataModel]:\n        \"\"\"Split a dedicated virtual account transaction with one or more accounts\n\n        Note:\n            * This feature is only available to businesses in Nigeria.\n            * Paystack currently supports Access Bank and Wema Bank.\n\n        Args:\n            customer: Customer ID or code\n            subaccount: Subaccount code of the account you want to split the transaction with\n            split_code: Split code consisting of the lists of accounts you want to split the transaction with\n            preferred_bank: The bank slug for a preferred bank. To get a list of available banks,\n                use the Miscellaneous API ``.get_providers`` method\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(\"/dedicated_account/split\")\n        payload = {\"customer\": customer}\n\n        optional_params = [\n            (\"subaccount\", subaccount),\n            (\"split_code\", split_code),\n            (\"preferred_bank\", preferred_bank),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or DedicatedAccount,\n        )\n\n    async def remove_split(\n        self,\n        account_number: str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[DedicatedAccount] | Response[PaystackDataModel]:\n        \"\"\"Removes a split.\n\n        If you've previously set up split payment for transactions on a dedicated virtual\n        account, you can remove it with this method.\n\n        Note:\n            * This feature is only available to businesses in Nigeria.\n            * Paystack currently supports Access Bank and Wema Bank.\n\n        Args:\n            account_number: Dedicated virtual account number\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(\"/dedicated_account/split\")\n        payload = {\n            \"account_number\": account_number,\n        }\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.DELETE,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or DedicatedAccount,\n        )\n\n    async def get_providers(\n        self,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[list[DedicatedAccountProvider]] | Response[PaystackDataModel]:\n        \"\"\"Get available bank providers for a dedicated virtual account\n\n        Note:\n            * This feature is only available to businesses in Nigeria.\n            * Paystack currently supports Access Bank and Wema Bank.\n\n        Args:\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(\"/dedicated_account/available_providers\")\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or DedicatedAccountProvider,\n        )\n</code></pre>"},{"location":"reference/dedicated_accounts/#pypaystack2.sub_clients.async_clients.dedicated_accounts.AsyncDedicatedAccountClient.assign","title":"<code>assign(email, first_name, last_name, phone, preferred_bank, country=Country.NIGERIA, account_number=None, bvn=None, bank_code=None, subaccount=None, split_code=None, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Create a customer, validate the customer, and assign a DVA to the customer.</p> Note <ul> <li>This feature is only available to businesses in Nigeria.</li> <li>Paystack currently supports Wema Bank and Titan Paystack.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Customer email address</p> required <code>first_name</code> <code>str</code> <p>Customer's first name</p> required <code>last_name</code> <code>str</code> <p>Customer's last name</p> required <code>phone</code> <code>str</code> <p>Customer's phone number</p> required <code>preferred_bank</code> <code>str</code> <p>The bank slug for preferred bank. To get a list of available banks, use the Paystack.miscellaneous.get_banks, AsyncPaystack.miscellaneous.get_banks, Miscellaneous.get_banks or AsyncMiscellaneous.get_banks, with <code>pay_with_bank_transfer=true</code></p> required <code>country</code> <code>Country</code> <p>Currently accepts <code>Country.NIGERIA</code> only</p> <code>NIGERIA</code> <code>account_number</code> <code>str | None</code> <p>Customer's account number</p> <code>None</code> <code>bvn</code> <code>str | None</code> <p>Customer's Bank Verification Number</p> <code>None</code> <code>bank_code</code> <code>str | None</code> <p>Customer's bank code</p> <code>None</code> <code>subaccount</code> <code>str | None</code> <p>Subaccount code of the account you want to split the transaction with</p> <code>None</code> <code>split_code</code> <code>str | None</code> <p>Split code consisting of the lists of accounts you want to split the transaction with</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[None] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/dedicated_accounts.py</code> <pre><code>async def assign(\n    self,\n    email: str,\n    first_name: str,\n    last_name: str,\n    phone: str,\n    preferred_bank: str,\n    country: Country = Country.NIGERIA,\n    account_number: str | None = None,\n    bvn: str | None = None,\n    bank_code: str | None = None,\n    subaccount: str | None = None,\n    split_code: str | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[None] | Response[PaystackDataModel]:\n    \"\"\"Create a customer, validate the customer, and assign a DVA to the customer.\n\n    Note:\n        * This feature is only available to businesses in Nigeria.\n        * Paystack currently supports Wema Bank and Titan Paystack.\n\n    Args:\n        email: Customer email address\n        first_name: Customer's first name\n        last_name: Customer's last name\n        phone: Customer's phone number\n        preferred_bank: The bank slug for preferred bank. To get a list of available banks, use the\n            Paystack.miscellaneous.get_banks, AsyncPaystack.miscellaneous.get_banks, Miscellaneous.get_banks\n            or AsyncMiscellaneous.get_banks, with `pay_with_bank_transfer=true`\n        country: Currently accepts `Country.NIGERIA` only\n        account_number: Customer's account number\n        bvn: Customer's Bank Verification Number\n        bank_code: Customer's bank code\n        subaccount: Subaccount code of the account you want to split the transaction with\n        split_code: Split code consisting of the lists of accounts you want to split the transaction with\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(\"/dedicated_account/assign\")\n    payload = {\n        \"email\": email,\n        \"first_name\": first_name,\n        \"last_name\": last_name,\n        \"phone\": phone,\n        \"preferred_bank\": preferred_bank,\n        \"country\": country,\n    }\n    optional_params = [\n        (\"account_number\", account_number),\n        (\"bvn\", bvn),\n        (\"bank_code\", bank_code),\n        (\"subaccount\", subaccount),\n        (\"split_code\", split_code),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class,\n    )\n</code></pre>"},{"location":"reference/dedicated_accounts/#pypaystack2.sub_clients.async_clients.dedicated_accounts.AsyncDedicatedAccountClient.create","title":"<code>create(customer, preferred_bank=None, subaccount=None, split_code=None, first_name=None, last_name=None, phone=None, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Create a dedicated virtual account for an existing customer</p> Note <ul> <li>This feature is only available to businesses in Nigeria.</li> <li>Paystack currently supports Wema Bank and Titan Paystack.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>customer</code> <code>str</code> <p>Customer ID or code</p> required <code>preferred_bank</code> <code>str | None</code> <p>The bank slug for a preferred bank. To get a list of available banks, use the Miscellaneous API <code>.get_providers</code> method.</p> <code>None</code> <code>subaccount</code> <code>str | None</code> <p>Subaccount code of the account you want to split the transaction with</p> <code>None</code> <code>split_code</code> <code>str | None</code> <p>Split code consisting of the lists of accounts you want to split the transaction with</p> <code>None</code> <code>first_name</code> <code>str | None</code> <p>Customer's first name</p> <code>None</code> <code>last_name</code> <code>str | None</code> <p>Customer's last name</p> <code>None</code> <code>phone</code> <code>str | None</code> <p>Customer's phone number</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[DedicatedAccount] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/dedicated_accounts.py</code> <pre><code>async def create(\n    self,\n    customer: str,\n    preferred_bank: str | None = None,\n    subaccount: str | None = None,\n    split_code: str | None = None,\n    first_name: str | None = None,\n    last_name: str | None = None,\n    phone: str | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[DedicatedAccount] | Response[PaystackDataModel]:\n    \"\"\"Create a dedicated virtual account for an existing customer\n\n    Note:\n        * This feature is only available to businesses in Nigeria.\n        * Paystack currently supports Wema Bank and Titan Paystack.\n\n    Args:\n        customer: Customer ID or code\n        preferred_bank: The bank slug for a preferred bank. To get a list of available banks, use the\n            Miscellaneous API ``.get_providers`` method.\n        subaccount: Subaccount code of the account you want to split the transaction with\n        split_code: Split code consisting of the lists of accounts you want to split the transaction with\n        first_name: Customer's first name\n        last_name: Customer's last name\n        phone: Customer's phone number\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(\"/dedicated_account\")\n    payload = {\n        \"customer\": customer,\n    }\n    optional_params = [\n        (\"preferred_bank\", preferred_bank),\n        (\"subaccount\", subaccount),\n        (\"split_code\", split_code),\n        (\"first_name\", first_name),\n        (\"last_name\", last_name),\n        (\"phone\", phone),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or DedicatedAccount,\n    )\n</code></pre>"},{"location":"reference/dedicated_accounts/#pypaystack2.sub_clients.async_clients.dedicated_accounts.AsyncDedicatedAccountClient.deactivate","title":"<code>deactivate(dedicated_account_id, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Deactivate a dedicated virtual account on your integration.</p> Note <ul> <li>This feature is only available to businesses in Nigeria.</li> <li>Paystack currently supports Access Bank and Wema Bank.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>dedicated_account_id</code> <code>int | str</code> <p>ID of dedicated virtual account</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[DedicatedAccount] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/dedicated_accounts.py</code> <pre><code>async def deactivate(\n    self,\n    dedicated_account_id: int | str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[DedicatedAccount] | Response[PaystackDataModel]:\n    \"\"\"Deactivate a dedicated virtual account on your integration.\n\n    Note:\n        * This feature is only available to businesses in Nigeria.\n        * Paystack currently supports Access Bank and Wema Bank.\n\n    Args:\n        dedicated_account_id: ID of dedicated virtual account\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/dedicated_account/{dedicated_account_id}\")\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.DELETE, url, response_data_model_class=alternate_model_class\n    )\n</code></pre>"},{"location":"reference/dedicated_accounts/#pypaystack2.sub_clients.async_clients.dedicated_accounts.AsyncDedicatedAccountClient.get_dedicated_account","title":"<code>get_dedicated_account(dedicated_account_id, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Get details of a dedicated virtual account on your integration.</p> Note <ul> <li>This feature is only available to businesses in Nigeria.</li> <li>Paystack currently supports Wema Bank and Titan Paystack.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>dedicated_account_id</code> <code>int | str</code> <p>ID of dedicated virtual account</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[DedicatedAccount] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/dedicated_accounts.py</code> <pre><code>async def get_dedicated_account(\n    self,\n    dedicated_account_id: int | str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[DedicatedAccount] | Response[PaystackDataModel]:\n    \"\"\"Get details of a dedicated virtual account on your integration.\n\n    Note:\n        * This feature is only available to businesses in Nigeria.\n        * Paystack currently supports Wema Bank and Titan Paystack.\n\n    Args:\n        dedicated_account_id: ID of dedicated virtual account\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/dedicated_account/{dedicated_account_id}\")\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or DedicatedAccount,\n    )\n</code></pre>"},{"location":"reference/dedicated_accounts/#pypaystack2.sub_clients.async_clients.dedicated_accounts.AsyncDedicatedAccountClient.get_dedicated_accounts","title":"<code>get_dedicated_accounts(active=True, currency=Currency.NGN, provider_slug=None, bank_id=None, customer=None, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Fetches dedicated virtual accounts available on your integration.</p> Note <ul> <li>This feature is only available to businesses in Nigeria.</li> <li>Paystack currently supports Wema Bank and Titan Paystack.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>active</code> <code>bool</code> <p>Status of the dedicated virtual account</p> <code>True</code> <code>currency</code> <code>Currency</code> <p>The currency of the dedicated virtual account. Only <code>Currency.NGN</code> is currently allowed</p> <code>NGN</code> <code>provider_slug</code> <code>str | None</code> <p>The bank's slug in lowercase, without spaces e.g. wema-bank. call the <code>.get_providers</code> method of this class to see available providers.</p> <code>None</code> <code>bank_id</code> <code>str | int | None</code> <p>The bank's ID e.g., 035</p> <code>None</code> <code>customer</code> <code>str | None</code> <p>The customer's ID</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[list[DedicatedAccount]] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/dedicated_accounts.py</code> <pre><code>async def get_dedicated_accounts(\n    self,\n    active: bool = True,\n    currency: Currency = Currency.NGN,\n    provider_slug: str | None = None,\n    bank_id: str | int | None = None,\n    customer: str | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[list[DedicatedAccount]] | Response[PaystackDataModel]:\n    \"\"\"Fetches dedicated virtual accounts available on your integration.\n\n    Note:\n        * This feature is only available to businesses in Nigeria.\n        * Paystack currently supports Wema Bank and Titan Paystack.\n\n    Args:\n        active: Status of the dedicated virtual account\n        currency: The currency of the dedicated virtual account. Only ``Currency.NGN`` is currently allowed\n        provider_slug: The bank's slug in lowercase, without spaces e.g. wema-bank. call the `.get_providers`\n            method of this class to see available providers.\n        bank_id: The bank's ID e.g., 035\n        customer: The customer's ID\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    query_params = [\n        (\"currency\", currency),\n        (\"provider_slug\", provider_slug),\n        (\"bank_id\", bank_id),\n        (\"customer\", customer),\n    ]\n    url = self._full_url(f\"/dedicated_account?active={active}\")\n    url = append_query_params(query_params, url)\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or DedicatedAccount,\n    )\n</code></pre>"},{"location":"reference/dedicated_accounts/#pypaystack2.sub_clients.async_clients.dedicated_accounts.AsyncDedicatedAccountClient.get_providers","title":"<code>get_providers(alternate_model_class=None)</code>  <code>async</code>","text":"<p>Get available bank providers for a dedicated virtual account</p> Note <ul> <li>This feature is only available to businesses in Nigeria.</li> <li>Paystack currently supports Access Bank and Wema Bank.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[list[DedicatedAccountProvider]] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/dedicated_accounts.py</code> <pre><code>async def get_providers(\n    self,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[list[DedicatedAccountProvider]] | Response[PaystackDataModel]:\n    \"\"\"Get available bank providers for a dedicated virtual account\n\n    Note:\n        * This feature is only available to businesses in Nigeria.\n        * Paystack currently supports Access Bank and Wema Bank.\n\n    Args:\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(\"/dedicated_account/available_providers\")\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or DedicatedAccountProvider,\n    )\n</code></pre>"},{"location":"reference/dedicated_accounts/#pypaystack2.sub_clients.async_clients.dedicated_accounts.AsyncDedicatedAccountClient.remove_split","title":"<code>remove_split(account_number, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Removes a split.</p> <p>If you've previously set up split payment for transactions on a dedicated virtual account, you can remove it with this method.</p> Note <ul> <li>This feature is only available to businesses in Nigeria.</li> <li>Paystack currently supports Access Bank and Wema Bank.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>account_number</code> <code>str</code> <p>Dedicated virtual account number</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[DedicatedAccount] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/dedicated_accounts.py</code> <pre><code>async def remove_split(\n    self,\n    account_number: str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[DedicatedAccount] | Response[PaystackDataModel]:\n    \"\"\"Removes a split.\n\n    If you've previously set up split payment for transactions on a dedicated virtual\n    account, you can remove it with this method.\n\n    Note:\n        * This feature is only available to businesses in Nigeria.\n        * Paystack currently supports Access Bank and Wema Bank.\n\n    Args:\n        account_number: Dedicated virtual account number\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(\"/dedicated_account/split\")\n    payload = {\n        \"account_number\": account_number,\n    }\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.DELETE,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or DedicatedAccount,\n    )\n</code></pre>"},{"location":"reference/dedicated_accounts/#pypaystack2.sub_clients.async_clients.dedicated_accounts.AsyncDedicatedAccountClient.requery","title":"<code>requery(account_number, provider_slug, date=None, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Get details of a dedicated virtual account on your integration.</p> Note <ul> <li>This feature is only available to businesses in Nigeria.</li> <li>Paystack currently supports Wema Bank and Titan Paystack.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>account_number</code> <code>str</code> <p>Virtual account number to requery</p> required <code>provider_slug</code> <code>str</code> <p>The bank's slug in lowercase, without spaces e.g. wema-bank</p> required <code>date</code> <code>str | None</code> <p>The day the transfer was made in YYYY-MM-DD ISO format</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[None] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/dedicated_accounts.py</code> <pre><code>async def requery(\n    self,\n    account_number: str,\n    provider_slug: str,\n    date: str | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[None] | Response[PaystackDataModel]:\n    \"\"\"Get details of a dedicated virtual account on your integration.\n\n    Note:\n        * This feature is only available to businesses in Nigeria.\n        * Paystack currently supports Wema Bank and Titan Paystack.\n\n    Args:\n        account_number: Virtual account number to requery\n        provider_slug: The bank's slug in lowercase, without spaces e.g. wema-bank\n        date: The day the transfer was made in YYYY-MM-DD ISO format\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/dedicated_account?account_number={account_number}\")\n    query_params = [\n        (\"provider_slug\", provider_slug),\n        (\"date\", date),\n    ]\n    url = append_query_params(query_params, url)\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.GET, url, response_data_model_class=alternate_model_class\n    )\n</code></pre>"},{"location":"reference/dedicated_accounts/#pypaystack2.sub_clients.async_clients.dedicated_accounts.AsyncDedicatedAccountClient.split","title":"<code>split(customer, subaccount=None, split_code=None, preferred_bank=None, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Split a dedicated virtual account transaction with one or more accounts</p> Note <ul> <li>This feature is only available to businesses in Nigeria.</li> <li>Paystack currently supports Access Bank and Wema Bank.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>customer</code> <code>int | str</code> <p>Customer ID or code</p> required <code>subaccount</code> <code>str | None</code> <p>Subaccount code of the account you want to split the transaction with</p> <code>None</code> <code>split_code</code> <code>str | None</code> <p>Split code consisting of the lists of accounts you want to split the transaction with</p> <code>None</code> <code>preferred_bank</code> <code>str | None</code> <p>The bank slug for a preferred bank. To get a list of available banks, use the Miscellaneous API <code>.get_providers</code> method</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[DedicatedAccount] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/dedicated_accounts.py</code> <pre><code>async def split(\n    self,\n    customer: int | str,\n    subaccount: str | None = None,\n    split_code: str | None = None,\n    preferred_bank: str | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[DedicatedAccount] | Response[PaystackDataModel]:\n    \"\"\"Split a dedicated virtual account transaction with one or more accounts\n\n    Note:\n        * This feature is only available to businesses in Nigeria.\n        * Paystack currently supports Access Bank and Wema Bank.\n\n    Args:\n        customer: Customer ID or code\n        subaccount: Subaccount code of the account you want to split the transaction with\n        split_code: Split code consisting of the lists of accounts you want to split the transaction with\n        preferred_bank: The bank slug for a preferred bank. To get a list of available banks,\n            use the Miscellaneous API ``.get_providers`` method\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(\"/dedicated_account/split\")\n    payload = {\"customer\": customer}\n\n    optional_params = [\n        (\"subaccount\", subaccount),\n        (\"split_code\", split_code),\n        (\"preferred_bank\", preferred_bank),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or DedicatedAccount,\n    )\n</code></pre>"},{"location":"reference/disputes/","title":"Disputes","text":""},{"location":"reference/disputes/#pypaystack2.sub_clients.sync_clients.disputes.DisputeClient","title":"<code>DisputeClient</code>","text":"<p>               Bases: <code>BaseAPIClient</code></p> <p>Provides a wrapper for paystack Disputes API</p> <p>The Disputes API allows you to manage transaction disputes on your integration. https://paystack.com/docs/api/dispute/</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/disputes.py</code> <pre><code>class DisputeClient(BaseAPIClient):\n    \"\"\"Provides a wrapper for paystack Disputes API\n\n    The Disputes API allows you to manage transaction disputes on your integration.\n    https://paystack.com/docs/api/dispute/\n    \"\"\"\n\n    def get_disputes(\n        self,\n        start_date: str,\n        end_date: str,\n        pagination: int = 50,\n        page: int = 1,\n        transaction: str | None = None,\n        status: DisputeStatus | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[list[Dispute]] | Response[PaystackDataModel]:\n        \"\"\"Fetches disputes filed against you\n\n        Args:\n            start_date: A timestamp from which to start listing dispute e.g. 2016-09-21\n            end_date: A timestamp at which to stop listing dispute e.g. 2016-09-21\n            pagination : Specifies how many records you want to retrieve per page.\n                If not specified we use a default value of 50.\n            page: Specifies exactly what dispute you want to page.\n                If not specified we use a default value of 1.\n            transaction: Transaction ID\n            status: Any of DisputeStatus enum values.\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/dispute?perPage={pagination}\")\n        query_params = [\n            (\"page\", page),\n            (\"from\", start_date),\n            (\"to\", end_date),\n            (\"transaction\", transaction),\n            (\"status\", status),\n        ]\n        url = append_query_params(query_params, url)\n        return self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or Dispute,\n        )\n\n    def get_dispute(\n        self,\n        id_: int | str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[Dispute] | Response[PaystackDataModel]:\n        \"\"\"Get more details about a dispute.\n\n        Args:\n            id_: The dispute ID you want to fetch\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/dispute/{id_}\")\n        return self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or Dispute,\n        )\n\n    def get_transaction_disputes(\n        self,\n        id_: int | str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[list[Dispute]] | Response[PaystackDataModel]:\n        \"\"\"This method retrieves disputes for a particular transaction\n\n        Args:\n            id_: The transaction ID you want to fetch\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/dispute/transaction/{id_}\")\n        return self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or Dispute,\n        )\n\n    def update_dispute(\n        self,\n        id_: int | str,\n        refund_amount: int,\n        uploaded_filename: str | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[Dispute] | Response[PaystackDataModel]:\n        \"\"\"Update details of a dispute on your integration\n\n        Args:\n            id_: Dispute ID\n            refund_amount: the amount to refund, in kobo if currency is NGN, pesewas,\n                if currency is GHS, and cents, if currency is ZAR\n            uploaded_filename: filename of attachment returned via response from upload url(GET /dispute/:id/upload_url)\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        payload = {\"refund_amount\": refund_amount}\n        payload = add_to_payload([(\"uploaded_filename\", uploaded_filename)], payload)\n        url = self._full_url(f\"/dispute/{id_}\")\n        return self._handle_request(  # type: ignore\n            HTTPMethod.PUT,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or Dispute,\n        )\n\n    def add_evidence(\n        self,\n        id_: int | str,\n        customer_email: str,\n        customer_name: str,\n        customer_phone: str,\n        service_details: str,\n        delivery_address: str | None = None,\n        delivery_date: str | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[DisputeEvidence] | Response[PaystackDataModel]:\n        \"\"\"Provide evidence for a dispute\n\n        Args:\n            id_: Dispute ID\n            customer_email: Customer email\n            customer_name: Customer name\n            customer_phone: Customer phone\n            service_details: Details of service involved\n            delivery_address: Delivery Address\n            delivery_date: ISO 8601 representation of delivery date (YYYY-MM-DD)\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        payload = {\n            \"customer_email\": customer_email,\n            \"customer_name\": customer_name,\n            \"customer_phone\": customer_phone,\n            \"service_details\": service_details,\n        }\n        optional_params = [\n            (\"delivery_address\", delivery_address),\n            (\"delivery_date\", delivery_date),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        url = self._full_url(f\"dispute/{id_}/evidence\")\n        return self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or DisputeEvidence,\n        )\n\n    def get_upload_url(\n        self,\n        id_: int | str,\n        upload_filename: str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[DisputeUploadInfo] | Response[PaystackDataModel]:\n        \"\"\"Get URL to upload a dispute evidence.\n\n        Args:\n            id_: Dispute ID\n            upload_filename: The file name, with its extension, that you want to upload. e.g. filename.pdf\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._full_url(\n            f\"/dispute/{id_}/upload_url?upload_filename={upload_filename}\"\n        )\n        return self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or DisputeUploadInfo,\n        )\n\n    def resolve_dispute(\n        self,\n        id_: int | str,\n        resolution: Resolution,\n        message: str,\n        refund_amount: int,\n        uploaded_filename: str,\n        evidence: int | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[Dispute] | Response[PaystackDataModel]:\n        \"\"\"Resolve a dispute on your integration\n\n        Args:\n            id_: Dispute ID\n            resolution: Any of the Resolution enum value.\n            message: Reason for resolving\n            refund_amount: the amount to refund, in kobo if currency is NGN,\n                pesewas, if currency is GHS, and cents, if currency is ZAR\n            uploaded_filename: filename of attachment returned via response from\n                upload url(GET /dispute/:id/upload_url)\n            evidence: Evidence ID for fraud claims\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        payload = {\n            \"resolution\": resolution,\n            \"message\": message,\n            \"refund_amount\": refund_amount,\n            \"uploaded_filename\": uploaded_filename,\n        }\n        payload = add_to_payload([(\"evidence\", evidence)], payload)\n        url = self._full_url(f\"/dispute/{id_}/resolve\")\n        return self._handle_request(  # type: ignore\n            HTTPMethod.PUT,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or Dispute,\n        )\n\n    def export_disputes(\n        self,\n        start_date: str,\n        end_date: str,\n        pagination: int = 50,\n        page: int = 1,\n        transaction: str | None = None,\n        status: DisputeStatus | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[DisputeExportInfo] | Response[PaystackDataModel]:\n        \"\"\"Export disputes available on your integration.\n\n        Args:\n            start_date: A timestamp from which to start listing dispute e.g. 2016-09-21\n            end_date: A timestamp at which to stop listing dispute e.g. 2016-09-21\n            pagination: Specifies how many records you want to retrieve per page.\n                If not specified we use a default value of 50.\n            page: Specifies exactly what dispute you want to page. If not specified we use a default value of 1.\n            transaction: Transaction ID\n            status: Any value from the DisputeStatus enum\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/dispute/export?perPage={pagination}\")\n        query_params = [\n            (\"page\", page),\n            (\"from\", start_date),\n            (\"to\", end_date),\n            (\"transaction\", transaction),\n            (\"status\", status),\n        ]\n        url = append_query_params(query_params, url)\n        return self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or DisputeExportInfo,\n        )\n</code></pre>"},{"location":"reference/disputes/#pypaystack2.sub_clients.sync_clients.disputes.DisputeClient.add_evidence","title":"<code>add_evidence(id_, customer_email, customer_name, customer_phone, service_details, delivery_address=None, delivery_date=None, alternate_model_class=None)</code>","text":"<p>Provide evidence for a dispute</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>int | str</code> <p>Dispute ID</p> required <code>customer_email</code> <code>str</code> <p>Customer email</p> required <code>customer_name</code> <code>str</code> <p>Customer name</p> required <code>customer_phone</code> <code>str</code> <p>Customer phone</p> required <code>service_details</code> <code>str</code> <p>Details of service involved</p> required <code>delivery_address</code> <code>str | None</code> <p>Delivery Address</p> <code>None</code> <code>delivery_date</code> <code>str | None</code> <p>ISO 8601 representation of delivery date (YYYY-MM-DD)</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[DisputeEvidence] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/disputes.py</code> <pre><code>def add_evidence(\n    self,\n    id_: int | str,\n    customer_email: str,\n    customer_name: str,\n    customer_phone: str,\n    service_details: str,\n    delivery_address: str | None = None,\n    delivery_date: str | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[DisputeEvidence] | Response[PaystackDataModel]:\n    \"\"\"Provide evidence for a dispute\n\n    Args:\n        id_: Dispute ID\n        customer_email: Customer email\n        customer_name: Customer name\n        customer_phone: Customer phone\n        service_details: Details of service involved\n        delivery_address: Delivery Address\n        delivery_date: ISO 8601 representation of delivery date (YYYY-MM-DD)\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    payload = {\n        \"customer_email\": customer_email,\n        \"customer_name\": customer_name,\n        \"customer_phone\": customer_phone,\n        \"service_details\": service_details,\n    }\n    optional_params = [\n        (\"delivery_address\", delivery_address),\n        (\"delivery_date\", delivery_date),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    url = self._full_url(f\"dispute/{id_}/evidence\")\n    return self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or DisputeEvidence,\n    )\n</code></pre>"},{"location":"reference/disputes/#pypaystack2.sub_clients.sync_clients.disputes.DisputeClient.export_disputes","title":"<code>export_disputes(start_date, end_date, pagination=50, page=1, transaction=None, status=None, alternate_model_class=None)</code>","text":"<p>Export disputes available on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>start_date</code> <code>str</code> <p>A timestamp from which to start listing dispute e.g. 2016-09-21</p> required <code>end_date</code> <code>str</code> <p>A timestamp at which to stop listing dispute e.g. 2016-09-21</p> required <code>pagination</code> <code>int</code> <p>Specifies how many records you want to retrieve per page. If not specified we use a default value of 50.</p> <code>50</code> <code>page</code> <code>int</code> <p>Specifies exactly what dispute you want to page. If not specified we use a default value of 1.</p> <code>1</code> <code>transaction</code> <code>str | None</code> <p>Transaction ID</p> <code>None</code> <code>status</code> <code>DisputeStatus | None</code> <p>Any value from the DisputeStatus enum</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[DisputeExportInfo] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/disputes.py</code> <pre><code>def export_disputes(\n    self,\n    start_date: str,\n    end_date: str,\n    pagination: int = 50,\n    page: int = 1,\n    transaction: str | None = None,\n    status: DisputeStatus | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[DisputeExportInfo] | Response[PaystackDataModel]:\n    \"\"\"Export disputes available on your integration.\n\n    Args:\n        start_date: A timestamp from which to start listing dispute e.g. 2016-09-21\n        end_date: A timestamp at which to stop listing dispute e.g. 2016-09-21\n        pagination: Specifies how many records you want to retrieve per page.\n            If not specified we use a default value of 50.\n        page: Specifies exactly what dispute you want to page. If not specified we use a default value of 1.\n        transaction: Transaction ID\n        status: Any value from the DisputeStatus enum\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/dispute/export?perPage={pagination}\")\n    query_params = [\n        (\"page\", page),\n        (\"from\", start_date),\n        (\"to\", end_date),\n        (\"transaction\", transaction),\n        (\"status\", status),\n    ]\n    url = append_query_params(query_params, url)\n    return self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or DisputeExportInfo,\n    )\n</code></pre>"},{"location":"reference/disputes/#pypaystack2.sub_clients.sync_clients.disputes.DisputeClient.get_dispute","title":"<code>get_dispute(id_, alternate_model_class=None)</code>","text":"<p>Get more details about a dispute.</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>int | str</code> <p>The dispute ID you want to fetch</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[Dispute] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/disputes.py</code> <pre><code>def get_dispute(\n    self,\n    id_: int | str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[Dispute] | Response[PaystackDataModel]:\n    \"\"\"Get more details about a dispute.\n\n    Args:\n        id_: The dispute ID you want to fetch\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/dispute/{id_}\")\n    return self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or Dispute,\n    )\n</code></pre>"},{"location":"reference/disputes/#pypaystack2.sub_clients.sync_clients.disputes.DisputeClient.get_disputes","title":"<code>get_disputes(start_date, end_date, pagination=50, page=1, transaction=None, status=None, alternate_model_class=None)</code>","text":"<p>Fetches disputes filed against you</p> <p>Parameters:</p> Name Type Description Default <code>start_date</code> <code>str</code> <p>A timestamp from which to start listing dispute e.g. 2016-09-21</p> required <code>end_date</code> <code>str</code> <p>A timestamp at which to stop listing dispute e.g. 2016-09-21</p> required <code>pagination </code> <p>Specifies how many records you want to retrieve per page. If not specified we use a default value of 50.</p> required <code>page</code> <code>int</code> <p>Specifies exactly what dispute you want to page. If not specified we use a default value of 1.</p> <code>1</code> <code>transaction</code> <code>str | None</code> <p>Transaction ID</p> <code>None</code> <code>status</code> <code>DisputeStatus | None</code> <p>Any of DisputeStatus enum values.</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[list[Dispute]] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/disputes.py</code> <pre><code>def get_disputes(\n    self,\n    start_date: str,\n    end_date: str,\n    pagination: int = 50,\n    page: int = 1,\n    transaction: str | None = None,\n    status: DisputeStatus | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[list[Dispute]] | Response[PaystackDataModel]:\n    \"\"\"Fetches disputes filed against you\n\n    Args:\n        start_date: A timestamp from which to start listing dispute e.g. 2016-09-21\n        end_date: A timestamp at which to stop listing dispute e.g. 2016-09-21\n        pagination : Specifies how many records you want to retrieve per page.\n            If not specified we use a default value of 50.\n        page: Specifies exactly what dispute you want to page.\n            If not specified we use a default value of 1.\n        transaction: Transaction ID\n        status: Any of DisputeStatus enum values.\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/dispute?perPage={pagination}\")\n    query_params = [\n        (\"page\", page),\n        (\"from\", start_date),\n        (\"to\", end_date),\n        (\"transaction\", transaction),\n        (\"status\", status),\n    ]\n    url = append_query_params(query_params, url)\n    return self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or Dispute,\n    )\n</code></pre>"},{"location":"reference/disputes/#pypaystack2.sub_clients.sync_clients.disputes.DisputeClient.get_transaction_disputes","title":"<code>get_transaction_disputes(id_, alternate_model_class=None)</code>","text":"<p>This method retrieves disputes for a particular transaction</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>int | str</code> <p>The transaction ID you want to fetch</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[list[Dispute]] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/disputes.py</code> <pre><code>def get_transaction_disputes(\n    self,\n    id_: int | str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[list[Dispute]] | Response[PaystackDataModel]:\n    \"\"\"This method retrieves disputes for a particular transaction\n\n    Args:\n        id_: The transaction ID you want to fetch\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/dispute/transaction/{id_}\")\n    return self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or Dispute,\n    )\n</code></pre>"},{"location":"reference/disputes/#pypaystack2.sub_clients.sync_clients.disputes.DisputeClient.get_upload_url","title":"<code>get_upload_url(id_, upload_filename, alternate_model_class=None)</code>","text":"<p>Get URL to upload a dispute evidence.</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>int | str</code> <p>Dispute ID</p> required <code>upload_filename</code> <code>str</code> <p>The file name, with its extension, that you want to upload. e.g. filename.pdf</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[DisputeUploadInfo] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/disputes.py</code> <pre><code>def get_upload_url(\n    self,\n    id_: int | str,\n    upload_filename: str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[DisputeUploadInfo] | Response[PaystackDataModel]:\n    \"\"\"Get URL to upload a dispute evidence.\n\n    Args:\n        id_: Dispute ID\n        upload_filename: The file name, with its extension, that you want to upload. e.g. filename.pdf\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._full_url(\n        f\"/dispute/{id_}/upload_url?upload_filename={upload_filename}\"\n    )\n    return self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or DisputeUploadInfo,\n    )\n</code></pre>"},{"location":"reference/disputes/#pypaystack2.sub_clients.sync_clients.disputes.DisputeClient.resolve_dispute","title":"<code>resolve_dispute(id_, resolution, message, refund_amount, uploaded_filename, evidence=None, alternate_model_class=None)</code>","text":"<p>Resolve a dispute on your integration</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>int | str</code> <p>Dispute ID</p> required <code>resolution</code> <code>Resolution</code> <p>Any of the Resolution enum value.</p> required <code>message</code> <code>str</code> <p>Reason for resolving</p> required <code>refund_amount</code> <code>int</code> <p>the amount to refund, in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR</p> required <code>uploaded_filename</code> <code>str</code> <p>filename of attachment returned via response from upload url(GET /dispute/:id/upload_url)</p> required <code>evidence</code> <code>int | None</code> <p>Evidence ID for fraud claims</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[Dispute] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/disputes.py</code> <pre><code>def resolve_dispute(\n    self,\n    id_: int | str,\n    resolution: Resolution,\n    message: str,\n    refund_amount: int,\n    uploaded_filename: str,\n    evidence: int | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[Dispute] | Response[PaystackDataModel]:\n    \"\"\"Resolve a dispute on your integration\n\n    Args:\n        id_: Dispute ID\n        resolution: Any of the Resolution enum value.\n        message: Reason for resolving\n        refund_amount: the amount to refund, in kobo if currency is NGN,\n            pesewas, if currency is GHS, and cents, if currency is ZAR\n        uploaded_filename: filename of attachment returned via response from\n            upload url(GET /dispute/:id/upload_url)\n        evidence: Evidence ID for fraud claims\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    payload = {\n        \"resolution\": resolution,\n        \"message\": message,\n        \"refund_amount\": refund_amount,\n        \"uploaded_filename\": uploaded_filename,\n    }\n    payload = add_to_payload([(\"evidence\", evidence)], payload)\n    url = self._full_url(f\"/dispute/{id_}/resolve\")\n    return self._handle_request(  # type: ignore\n        HTTPMethod.PUT,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or Dispute,\n    )\n</code></pre>"},{"location":"reference/disputes/#pypaystack2.sub_clients.sync_clients.disputes.DisputeClient.update_dispute","title":"<code>update_dispute(id_, refund_amount, uploaded_filename=None, alternate_model_class=None)</code>","text":"<p>Update details of a dispute on your integration</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>int | str</code> <p>Dispute ID</p> required <code>refund_amount</code> <code>int</code> <p>the amount to refund, in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR</p> required <code>uploaded_filename</code> <code>str | None</code> <p>filename of attachment returned via response from upload url(GET /dispute/:id/upload_url)</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[Dispute] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/disputes.py</code> <pre><code>def update_dispute(\n    self,\n    id_: int | str,\n    refund_amount: int,\n    uploaded_filename: str | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[Dispute] | Response[PaystackDataModel]:\n    \"\"\"Update details of a dispute on your integration\n\n    Args:\n        id_: Dispute ID\n        refund_amount: the amount to refund, in kobo if currency is NGN, pesewas,\n            if currency is GHS, and cents, if currency is ZAR\n        uploaded_filename: filename of attachment returned via response from upload url(GET /dispute/:id/upload_url)\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    payload = {\"refund_amount\": refund_amount}\n    payload = add_to_payload([(\"uploaded_filename\", uploaded_filename)], payload)\n    url = self._full_url(f\"/dispute/{id_}\")\n    return self._handle_request(  # type: ignore\n        HTTPMethod.PUT,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or Dispute,\n    )\n</code></pre>"},{"location":"reference/disputes/#pypaystack2.sub_clients.async_clients.disputes.AsyncDisputeClient","title":"<code>AsyncDisputeClient</code>","text":"<p>               Bases: <code>BaseAsyncAPIClient</code></p> <p>Provides a wrapper for paystack Disputes API</p> <p>The Disputes API allows you manage transaction disputes on your integration. https://paystack.com/docs/api/dispute/</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/disputes.py</code> <pre><code>class AsyncDisputeClient(BaseAsyncAPIClient):\n    \"\"\"Provides a wrapper for paystack Disputes API\n\n    The Disputes API allows you manage transaction disputes on your integration.\n    https://paystack.com/docs/api/dispute/\n    \"\"\"\n\n    async def get_disputes(\n        self,\n        start_date: str,\n        end_date: str,\n        pagination: int = 50,\n        page: int = 1,\n        transaction: str | None = None,\n        status: DisputeStatus | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[list[Dispute]] | Response[PaystackDataModel]:\n        \"\"\"Fetches disputes filed against you\n\n        Args:\n            start_date: A timestamp from which to start listing dispute e.g. 2016-09-21\n            end_date: A timestamp at which to stop listing dispute e.g. 2016-09-21\n            pagination : Specifies how many records you want to retrieve per page.\n                If not specified we use a default value of 50.\n            page: Specifies exactly what dispute you want to page.\n                If not specified we use a default value of 1.\n            transaction: Transaction ID\n            status: Any of DisputeStatus enum values.\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/dispute?perPage={pagination}\")\n        query_params = [\n            (\"page\", page),\n            (\"from\", start_date),\n            (\"to\", end_date),\n            (\"transaction\", transaction),\n            (\"status\", status),\n        ]\n        url = append_query_params(query_params, url)\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or Dispute,\n        )\n\n    async def get_dispute(\n        self,\n        id_: int | str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[Dispute] | Response[PaystackDataModel]:\n        \"\"\"Get more details about a dispute.\n\n        Args:\n            id_: The dispute ID you want to fetch\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/dispute/{id_}\")\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or Dispute,\n        )\n\n    async def get_transaction_disputes(\n        self,\n        id_: int | str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[list[Dispute]] | Response[PaystackDataModel]:\n        \"\"\"This method retrieves disputes for a particular transaction\n\n        Args:\n            id_: The transaction ID you want to fetch\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/dispute/transaction/{id_}\")\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or Dispute,\n        )\n\n    async def update_dispute(\n        self,\n        id_: int | str,\n        refund_amount: int,\n        uploaded_filename: str | None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[Dispute] | Response[PaystackDataModel]:\n        \"\"\"Update details of a dispute on your integration\n\n        Args:\n            id_: Dispute ID\n            refund_amount: the amount to refund, in kobo if currency is NGN, pesewas,\n                if currency is GHS, and cents, if currency is ZAR\n            uploaded_filename: filename of attachment returned via response from upload url(GET /dispute/:id/upload_url)\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        payload = {\"refund_amount\": refund_amount}\n        payload = add_to_payload([(\"uploaded_filename\", uploaded_filename)], payload)\n        url = self._full_url(f\"/dispute/{id_}\")\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.PUT,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or Dispute,\n        )\n\n    async def add_evidence(\n        self,\n        id_: int | str,\n        customer_email: str,\n        customer_name: str,\n        customer_phone: str,\n        service_details: str,\n        delivery_address: str | None = None,\n        delivery_date: str | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[DisputeEvidence] | Response[PaystackDataModel]:\n        \"\"\"Provide evidence for a dispute\n\n        Args:\n            id_: Dispute ID\n            customer_email: Customer email\n            customer_name: Customer name\n            customer_phone: Customer phone\n            service_details: Details of service involved\n            delivery_address: Delivery Address\n            delivery_date: ISO 8601 representation of delivery date (YYYY-MM-DD)\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        payload = {\n            \"customer_email\": customer_email,\n            \"customer_name\": customer_name,\n            \"customer_phone\": customer_phone,\n            \"service_details\": service_details,\n        }\n        optional_params = [\n            (\"delivery_address\", delivery_address),\n            (\"delivery_date\", delivery_date),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        url = self._full_url(f\"dispute/{id_}/evidence\")\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or DisputeEvidence,\n        )\n\n    async def get_upload_url(\n        self,\n        id_: int | str,\n        upload_filename: str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[DisputeUploadInfo] | Response[PaystackDataModel]:\n        \"\"\"Get URL to upload a dispute evidence.\n\n        Args:\n            id_: Dispute ID\n            upload_filename: The file name, with its extension, that you want to upload. e.g. filename.pdf\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._full_url(\n            f\"/dispute/{id_}/upload_url?upload_filename={upload_filename}\"\n        )\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or DisputeUploadInfo,\n        )\n\n    async def resolve_dispute(\n        self,\n        id_: int | str,\n        resolution: Resolution,\n        message: str,\n        refund_amount: int,\n        uploaded_filename: str,\n        evidence: int | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[Dispute] | Response[PaystackDataModel]:\n        \"\"\"Resolve a dispute on your integration\n\n        Args:\n            id_: Dispute ID\n            resolution: Any of the Resolution enum value.\n            message: Reason for resolving\n            refund_amount: the amount to refund, in kobo if currency is NGN,\n                pesewas, if currency is GHS, and cents, if currency is ZAR\n            uploaded_filename: filename of attachment returned via response from\n                upload url(GET /dispute/:id/upload_url)\n            evidence: Evidence ID for fraud claims\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        payload = {\n            \"resolution\": resolution,\n            \"message\": message,\n            \"refund_amount\": refund_amount,\n            \"uploaded_filename\": uploaded_filename,\n        }\n        payload = add_to_payload([(\"evidence\", evidence)], payload)\n        url = self._full_url(f\"/dispute/{id_}/resolve\")\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.PUT,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or Dispute,\n        )\n\n    async def export_disputes(\n        self,\n        start_date: str,\n        end_date: str,\n        pagination: int = 50,\n        page: int = 1,\n        transaction: str | None = None,\n        status: DisputeStatus | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[DisputeExportInfo] | Response[PaystackDataModel]:\n        \"\"\"Export disputes available on your integration.\n\n        Args:\n            start_date: A timestamp from which to start listing dispute e.g. 2016-09-21\n            end_date: A timestamp at which to stop listing dispute e.g. 2016-09-21\n            pagination: Specifies how many records you want to retrieve per page.\n                If not specified we use a default value of 50.\n            page: Specifies exactly what dispute you want to page. If not specified we use a default value of 1.\n            transaction: Transaction ID\n            status: Any value from the DisputeStatus enum\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/dispute/export?perPage={pagination}\")\n        query_params = [\n            (\"page\", page),\n            (\"from\", start_date),\n            (\"to\", end_date),\n            (\"transaction\", transaction),\n            (\"status\", status),\n        ]\n        url = append_query_params(query_params, url)\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or DisputeExportInfo,\n        )\n</code></pre>"},{"location":"reference/disputes/#pypaystack2.sub_clients.async_clients.disputes.AsyncDisputeClient.add_evidence","title":"<code>add_evidence(id_, customer_email, customer_name, customer_phone, service_details, delivery_address=None, delivery_date=None, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Provide evidence for a dispute</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>int | str</code> <p>Dispute ID</p> required <code>customer_email</code> <code>str</code> <p>Customer email</p> required <code>customer_name</code> <code>str</code> <p>Customer name</p> required <code>customer_phone</code> <code>str</code> <p>Customer phone</p> required <code>service_details</code> <code>str</code> <p>Details of service involved</p> required <code>delivery_address</code> <code>str | None</code> <p>Delivery Address</p> <code>None</code> <code>delivery_date</code> <code>str | None</code> <p>ISO 8601 representation of delivery date (YYYY-MM-DD)</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[DisputeEvidence] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/disputes.py</code> <pre><code>async def add_evidence(\n    self,\n    id_: int | str,\n    customer_email: str,\n    customer_name: str,\n    customer_phone: str,\n    service_details: str,\n    delivery_address: str | None = None,\n    delivery_date: str | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[DisputeEvidence] | Response[PaystackDataModel]:\n    \"\"\"Provide evidence for a dispute\n\n    Args:\n        id_: Dispute ID\n        customer_email: Customer email\n        customer_name: Customer name\n        customer_phone: Customer phone\n        service_details: Details of service involved\n        delivery_address: Delivery Address\n        delivery_date: ISO 8601 representation of delivery date (YYYY-MM-DD)\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    payload = {\n        \"customer_email\": customer_email,\n        \"customer_name\": customer_name,\n        \"customer_phone\": customer_phone,\n        \"service_details\": service_details,\n    }\n    optional_params = [\n        (\"delivery_address\", delivery_address),\n        (\"delivery_date\", delivery_date),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    url = self._full_url(f\"dispute/{id_}/evidence\")\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or DisputeEvidence,\n    )\n</code></pre>"},{"location":"reference/disputes/#pypaystack2.sub_clients.async_clients.disputes.AsyncDisputeClient.export_disputes","title":"<code>export_disputes(start_date, end_date, pagination=50, page=1, transaction=None, status=None, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Export disputes available on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>start_date</code> <code>str</code> <p>A timestamp from which to start listing dispute e.g. 2016-09-21</p> required <code>end_date</code> <code>str</code> <p>A timestamp at which to stop listing dispute e.g. 2016-09-21</p> required <code>pagination</code> <code>int</code> <p>Specifies how many records you want to retrieve per page. If not specified we use a default value of 50.</p> <code>50</code> <code>page</code> <code>int</code> <p>Specifies exactly what dispute you want to page. If not specified we use a default value of 1.</p> <code>1</code> <code>transaction</code> <code>str | None</code> <p>Transaction ID</p> <code>None</code> <code>status</code> <code>DisputeStatus | None</code> <p>Any value from the DisputeStatus enum</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[DisputeExportInfo] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/disputes.py</code> <pre><code>async def export_disputes(\n    self,\n    start_date: str,\n    end_date: str,\n    pagination: int = 50,\n    page: int = 1,\n    transaction: str | None = None,\n    status: DisputeStatus | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[DisputeExportInfo] | Response[PaystackDataModel]:\n    \"\"\"Export disputes available on your integration.\n\n    Args:\n        start_date: A timestamp from which to start listing dispute e.g. 2016-09-21\n        end_date: A timestamp at which to stop listing dispute e.g. 2016-09-21\n        pagination: Specifies how many records you want to retrieve per page.\n            If not specified we use a default value of 50.\n        page: Specifies exactly what dispute you want to page. If not specified we use a default value of 1.\n        transaction: Transaction ID\n        status: Any value from the DisputeStatus enum\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/dispute/export?perPage={pagination}\")\n    query_params = [\n        (\"page\", page),\n        (\"from\", start_date),\n        (\"to\", end_date),\n        (\"transaction\", transaction),\n        (\"status\", status),\n    ]\n    url = append_query_params(query_params, url)\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or DisputeExportInfo,\n    )\n</code></pre>"},{"location":"reference/disputes/#pypaystack2.sub_clients.async_clients.disputes.AsyncDisputeClient.get_dispute","title":"<code>get_dispute(id_, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Get more details about a dispute.</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>int | str</code> <p>The dispute ID you want to fetch</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[Dispute] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/disputes.py</code> <pre><code>async def get_dispute(\n    self,\n    id_: int | str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[Dispute] | Response[PaystackDataModel]:\n    \"\"\"Get more details about a dispute.\n\n    Args:\n        id_: The dispute ID you want to fetch\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/dispute/{id_}\")\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or Dispute,\n    )\n</code></pre>"},{"location":"reference/disputes/#pypaystack2.sub_clients.async_clients.disputes.AsyncDisputeClient.get_disputes","title":"<code>get_disputes(start_date, end_date, pagination=50, page=1, transaction=None, status=None, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Fetches disputes filed against you</p> <p>Parameters:</p> Name Type Description Default <code>start_date</code> <code>str</code> <p>A timestamp from which to start listing dispute e.g. 2016-09-21</p> required <code>end_date</code> <code>str</code> <p>A timestamp at which to stop listing dispute e.g. 2016-09-21</p> required <code>pagination </code> <p>Specifies how many records you want to retrieve per page. If not specified we use a default value of 50.</p> required <code>page</code> <code>int</code> <p>Specifies exactly what dispute you want to page. If not specified we use a default value of 1.</p> <code>1</code> <code>transaction</code> <code>str | None</code> <p>Transaction ID</p> <code>None</code> <code>status</code> <code>DisputeStatus | None</code> <p>Any of DisputeStatus enum values.</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[list[Dispute]] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/disputes.py</code> <pre><code>async def get_disputes(\n    self,\n    start_date: str,\n    end_date: str,\n    pagination: int = 50,\n    page: int = 1,\n    transaction: str | None = None,\n    status: DisputeStatus | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[list[Dispute]] | Response[PaystackDataModel]:\n    \"\"\"Fetches disputes filed against you\n\n    Args:\n        start_date: A timestamp from which to start listing dispute e.g. 2016-09-21\n        end_date: A timestamp at which to stop listing dispute e.g. 2016-09-21\n        pagination : Specifies how many records you want to retrieve per page.\n            If not specified we use a default value of 50.\n        page: Specifies exactly what dispute you want to page.\n            If not specified we use a default value of 1.\n        transaction: Transaction ID\n        status: Any of DisputeStatus enum values.\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/dispute?perPage={pagination}\")\n    query_params = [\n        (\"page\", page),\n        (\"from\", start_date),\n        (\"to\", end_date),\n        (\"transaction\", transaction),\n        (\"status\", status),\n    ]\n    url = append_query_params(query_params, url)\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or Dispute,\n    )\n</code></pre>"},{"location":"reference/disputes/#pypaystack2.sub_clients.async_clients.disputes.AsyncDisputeClient.get_transaction_disputes","title":"<code>get_transaction_disputes(id_, alternate_model_class=None)</code>  <code>async</code>","text":"<p>This method retrieves disputes for a particular transaction</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>int | str</code> <p>The transaction ID you want to fetch</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[list[Dispute]] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/disputes.py</code> <pre><code>async def get_transaction_disputes(\n    self,\n    id_: int | str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[list[Dispute]] | Response[PaystackDataModel]:\n    \"\"\"This method retrieves disputes for a particular transaction\n\n    Args:\n        id_: The transaction ID you want to fetch\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/dispute/transaction/{id_}\")\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or Dispute,\n    )\n</code></pre>"},{"location":"reference/disputes/#pypaystack2.sub_clients.async_clients.disputes.AsyncDisputeClient.get_upload_url","title":"<code>get_upload_url(id_, upload_filename, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Get URL to upload a dispute evidence.</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>int | str</code> <p>Dispute ID</p> required <code>upload_filename</code> <code>str</code> <p>The file name, with its extension, that you want to upload. e.g. filename.pdf</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[DisputeUploadInfo] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/disputes.py</code> <pre><code>async def get_upload_url(\n    self,\n    id_: int | str,\n    upload_filename: str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[DisputeUploadInfo] | Response[PaystackDataModel]:\n    \"\"\"Get URL to upload a dispute evidence.\n\n    Args:\n        id_: Dispute ID\n        upload_filename: The file name, with its extension, that you want to upload. e.g. filename.pdf\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._full_url(\n        f\"/dispute/{id_}/upload_url?upload_filename={upload_filename}\"\n    )\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or DisputeUploadInfo,\n    )\n</code></pre>"},{"location":"reference/disputes/#pypaystack2.sub_clients.async_clients.disputes.AsyncDisputeClient.resolve_dispute","title":"<code>resolve_dispute(id_, resolution, message, refund_amount, uploaded_filename, evidence=None, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Resolve a dispute on your integration</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>int | str</code> <p>Dispute ID</p> required <code>resolution</code> <code>Resolution</code> <p>Any of the Resolution enum value.</p> required <code>message</code> <code>str</code> <p>Reason for resolving</p> required <code>refund_amount</code> <code>int</code> <p>the amount to refund, in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR</p> required <code>uploaded_filename</code> <code>str</code> <p>filename of attachment returned via response from upload url(GET /dispute/:id/upload_url)</p> required <code>evidence</code> <code>int | None</code> <p>Evidence ID for fraud claims</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[Dispute] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/disputes.py</code> <pre><code>async def resolve_dispute(\n    self,\n    id_: int | str,\n    resolution: Resolution,\n    message: str,\n    refund_amount: int,\n    uploaded_filename: str,\n    evidence: int | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[Dispute] | Response[PaystackDataModel]:\n    \"\"\"Resolve a dispute on your integration\n\n    Args:\n        id_: Dispute ID\n        resolution: Any of the Resolution enum value.\n        message: Reason for resolving\n        refund_amount: the amount to refund, in kobo if currency is NGN,\n            pesewas, if currency is GHS, and cents, if currency is ZAR\n        uploaded_filename: filename of attachment returned via response from\n            upload url(GET /dispute/:id/upload_url)\n        evidence: Evidence ID for fraud claims\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    payload = {\n        \"resolution\": resolution,\n        \"message\": message,\n        \"refund_amount\": refund_amount,\n        \"uploaded_filename\": uploaded_filename,\n    }\n    payload = add_to_payload([(\"evidence\", evidence)], payload)\n    url = self._full_url(f\"/dispute/{id_}/resolve\")\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.PUT,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or Dispute,\n    )\n</code></pre>"},{"location":"reference/disputes/#pypaystack2.sub_clients.async_clients.disputes.AsyncDisputeClient.update_dispute","title":"<code>update_dispute(id_, refund_amount, uploaded_filename, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Update details of a dispute on your integration</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>int | str</code> <p>Dispute ID</p> required <code>refund_amount</code> <code>int</code> <p>the amount to refund, in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR</p> required <code>uploaded_filename</code> <code>str | None</code> <p>filename of attachment returned via response from upload url(GET /dispute/:id/upload_url)</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[Dispute] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/disputes.py</code> <pre><code>async def update_dispute(\n    self,\n    id_: int | str,\n    refund_amount: int,\n    uploaded_filename: str | None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[Dispute] | Response[PaystackDataModel]:\n    \"\"\"Update details of a dispute on your integration\n\n    Args:\n        id_: Dispute ID\n        refund_amount: the amount to refund, in kobo if currency is NGN, pesewas,\n            if currency is GHS, and cents, if currency is ZAR\n        uploaded_filename: filename of attachment returned via response from upload url(GET /dispute/:id/upload_url)\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    payload = {\"refund_amount\": refund_amount}\n    payload = add_to_payload([(\"uploaded_filename\", uploaded_filename)], payload)\n    url = self._full_url(f\"/dispute/{id_}\")\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.PUT,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or Dispute,\n    )\n</code></pre>"},{"location":"reference/integration/","title":"Integration","text":""},{"location":"reference/integration/#pypaystack2.sub_clients.sync_clients.integration.IntegrationClient","title":"<code>IntegrationClient</code>","text":"<p>               Bases: <code>BaseAPIClient</code></p> <p>Provides a wrapper for paystack Integration API</p> <p>The Integration API allows you to manage some settings on your integration. https://paystack.com/docs/api/integration/</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/integration.py</code> <pre><code>class IntegrationClient(BaseAPIClient):\n    \"\"\"Provides a wrapper for paystack Integration API\n\n    The Integration API allows you to manage some settings on your integration.\n    https://paystack.com/docs/api/integration/\n    \"\"\"\n\n    def get_payment_session_timeout(\n        self,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[IntegrationTimeout] | Response[PaystackDataModel]:\n        \"\"\"Fetch the payment session timeout on your integration\n\n        Args:\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(\"/integration/payment_session_timeout\")\n        return self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or IntegrationTimeout,\n        )\n\n    def update_payment_session_timeout(\n        self,\n        timeout: int,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[IntegrationTimeout] | Response[PaystackDataModel]:\n        \"\"\"Update the payment session timeout on your integration\n\n        Args:\n            timeout: Time before stopping session (in seconds). Set to 0 to cancel session timeouts\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        payload = {\"timeout\": timeout}\n        url = self._full_url(\"/integration/payment_session_timeout\")\n        return self._handle_request(  # type: ignore\n            HTTPMethod.PUT,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or IntegrationTimeout,\n        )\n</code></pre>"},{"location":"reference/integration/#pypaystack2.sub_clients.sync_clients.integration.IntegrationClient.get_payment_session_timeout","title":"<code>get_payment_session_timeout(alternate_model_class=None)</code>","text":"<p>Fetch the payment session timeout on your integration</p> <p>Parameters:</p> Name Type Description Default <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[IntegrationTimeout] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/integration.py</code> <pre><code>def get_payment_session_timeout(\n    self,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[IntegrationTimeout] | Response[PaystackDataModel]:\n    \"\"\"Fetch the payment session timeout on your integration\n\n    Args:\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(\"/integration/payment_session_timeout\")\n    return self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or IntegrationTimeout,\n    )\n</code></pre>"},{"location":"reference/integration/#pypaystack2.sub_clients.sync_clients.integration.IntegrationClient.update_payment_session_timeout","title":"<code>update_payment_session_timeout(timeout, alternate_model_class=None)</code>","text":"<p>Update the payment session timeout on your integration</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>int</code> <p>Time before stopping session (in seconds). Set to 0 to cancel session timeouts</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[IntegrationTimeout] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/integration.py</code> <pre><code>def update_payment_session_timeout(\n    self,\n    timeout: int,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[IntegrationTimeout] | Response[PaystackDataModel]:\n    \"\"\"Update the payment session timeout on your integration\n\n    Args:\n        timeout: Time before stopping session (in seconds). Set to 0 to cancel session timeouts\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    payload = {\"timeout\": timeout}\n    url = self._full_url(\"/integration/payment_session_timeout\")\n    return self._handle_request(  # type: ignore\n        HTTPMethod.PUT,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or IntegrationTimeout,\n    )\n</code></pre>"},{"location":"reference/integration/#pypaystack2.sub_clients.async_clients.integration.AsyncIntegrationClient","title":"<code>AsyncIntegrationClient</code>","text":"<p>               Bases: <code>BaseAsyncAPIClient</code></p> <p>Provides a wrapper for paystack Integration API</p> <p>The Integration API allows you to manage some settings on your integration. https://paystack.com/docs/api/integration/</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/integration.py</code> <pre><code>class AsyncIntegrationClient(BaseAsyncAPIClient):\n    \"\"\"Provides a wrapper for paystack Integration API\n\n    The Integration API allows you to manage some settings on your integration.\n    https://paystack.com/docs/api/integration/\n    \"\"\"\n\n    async def get_payment_session_timeout(\n        self,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[IntegrationTimeout] | Response[PaystackDataModel]:\n        \"\"\"Fetch the payment session timeout on your integration\n\n        Args:\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(\"/integration/payment_session_timeout\")\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or IntegrationTimeout,\n        )\n\n    async def update_payment_session_timeout(\n        self,\n        timeout: int,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[IntegrationTimeout] | Response[PaystackDataModel]:\n        \"\"\"Update the payment session timeout on your integration\n\n        Args:\n            timeout: Time before stopping session (in seconds). Set to 0 to cancel session timeouts\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        payload = {\"timeout\": timeout}\n        url = self._full_url(\"/integration/payment_session_timeout\")\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.PUT,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or IntegrationTimeout,\n        )\n</code></pre>"},{"location":"reference/integration/#pypaystack2.sub_clients.async_clients.integration.AsyncIntegrationClient.get_payment_session_timeout","title":"<code>get_payment_session_timeout(alternate_model_class=None)</code>  <code>async</code>","text":"<p>Fetch the payment session timeout on your integration</p> <p>Parameters:</p> Name Type Description Default <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[IntegrationTimeout] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/integration.py</code> <pre><code>async def get_payment_session_timeout(\n    self,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[IntegrationTimeout] | Response[PaystackDataModel]:\n    \"\"\"Fetch the payment session timeout on your integration\n\n    Args:\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(\"/integration/payment_session_timeout\")\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or IntegrationTimeout,\n    )\n</code></pre>"},{"location":"reference/integration/#pypaystack2.sub_clients.async_clients.integration.AsyncIntegrationClient.update_payment_session_timeout","title":"<code>update_payment_session_timeout(timeout, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Update the payment session timeout on your integration</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>int</code> <p>Time before stopping session (in seconds). Set to 0 to cancel session timeouts</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[IntegrationTimeout] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/integration.py</code> <pre><code>async def update_payment_session_timeout(\n    self,\n    timeout: int,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[IntegrationTimeout] | Response[PaystackDataModel]:\n    \"\"\"Update the payment session timeout on your integration\n\n    Args:\n        timeout: Time before stopping session (in seconds). Set to 0 to cancel session timeouts\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    payload = {\"timeout\": timeout}\n    url = self._full_url(\"/integration/payment_session_timeout\")\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.PUT,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or IntegrationTimeout,\n    )\n</code></pre>"},{"location":"reference/miscellaneous/","title":"Miscellaneous","text":""},{"location":"reference/miscellaneous/#pypaystack2.sub_clients.sync_clients.miscellaneous.MiscellaneousClient","title":"<code>MiscellaneousClient</code>","text":"<p>               Bases: <code>BaseAPIClient</code></p> <p>Provides a wrapper for paystack Miscellaneous API</p> <p>The Miscellaneous API are supporting APIs that can be used to provide more details to other APIs. https://paystack.com/docs/api/miscellaneous/</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/miscellaneous.py</code> <pre><code>class MiscellaneousClient(BaseAPIClient):\n    \"\"\"Provides a wrapper for paystack Miscellaneous API\n\n    The Miscellaneous API are supporting APIs that can be used to provide more details to other APIs.\n    https://paystack.com/docs/api/miscellaneous/\n    \"\"\"\n\n    def get_banks(\n        self,\n        country: Country,\n        use_cursor: bool = False,\n        next_: str | None = None,\n        previous: str | None = None,\n        gateway: Gateway | None = None,\n        type_: BankType | None = None,\n        currency: Currency | None = None,\n        pay_with_bank_transfer: bool | None = None,\n        pay_with_bank: bool | None = None,\n        include_nip_sort_code: bool | None = None,\n        pagination: int = 50,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[list[Bank]] | Response[PaystackDataModel]:\n        \"\"\"Get a list of all supported banks and their properties\n\n        Args:\n            country: The country from which to obtain the list of supported banks. any value from the ``Country`` enum.\n            use_cursor: Flag to enable cursor pagination.\n            next_: A cursor that indicates your place in the list. It can be used to fetch the next page of the list\n            previous: A cursor that indicates your place in the list. It should be used\n                to fetch the previous page of the list after an intial next request\n            gateway: The gateway type of the bank. Any value from the ``Gateway`` enum.\n            type_: Type of financial channel. For Ghanaian channels, please use either\n                mobile_money for mobile money channels OR ghipps for bank channels\n            currency: Any value from the Currency enum.\n            pay_with_bank_transfer: A flag to filter for available banks a customer can make a transfer to\n                complete a payment\n            pay_with_bank: A flag to filter for banks a customer can pay directly from\n            pagination: The number of objects to return per page. Defaults to 50, and limited to 100 records per page.\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n            include_nip_sort_code: A flag that returns Nigerian banks with their nip institution code.\n                The returned value can be used in identifying institutions on NIP.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        country_full = Country.get_full(country)\n        url = self._full_url(f\"/bank?perPage={pagination}\")\n        query_params = [\n            (\"country\", country_full),\n            (\"use_cursor\", use_cursor),\n            (\"next\", next_),\n            (\"previous\", previous),\n            (\"gateway\", gateway),\n            (\"type\", type_),\n            (\"currency\", currency),\n            (\"pay_with_bank_transfer\", pay_with_bank_transfer),\n            (\"pay_with_bank\", pay_with_bank),\n            (\"include_nip_sort_code\", include_nip_sort_code),\n        ]\n        url = append_query_params(query_params, url)\n        return self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or Bank,\n        )\n\n    def get_countries(\n        self,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[list[PaystackSupportedCountry]] | Response[PaystackDataModel]:\n        \"\"\"Gets a list of Countries that Paystack currently supports\n\n        Args:\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(\"/country\")\n        return self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or PaystackSupportedCountry,\n        )\n\n    def get_states(\n        self,\n        country: Country | str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[list[State]] | Response[PaystackDataModel]:\n        \"\"\"Get a list of states for a country for address verification.\n\n        Args:\n            country: Any value from the country enum.\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/address_verification/states?country={country}\")\n        return self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or State,\n        )\n</code></pre>"},{"location":"reference/miscellaneous/#pypaystack2.sub_clients.sync_clients.miscellaneous.MiscellaneousClient.get_banks","title":"<code>get_banks(country, use_cursor=False, next_=None, previous=None, gateway=None, type_=None, currency=None, pay_with_bank_transfer=None, pay_with_bank=None, include_nip_sort_code=None, pagination=50, alternate_model_class=None)</code>","text":"<p>Get a list of all supported banks and their properties</p> <p>Parameters:</p> Name Type Description Default <code>country</code> <code>Country</code> <p>The country from which to obtain the list of supported banks. any value from the <code>Country</code> enum.</p> required <code>use_cursor</code> <code>bool</code> <p>Flag to enable cursor pagination.</p> <code>False</code> <code>next_</code> <code>str | None</code> <p>A cursor that indicates your place in the list. It can be used to fetch the next page of the list</p> <code>None</code> <code>previous</code> <code>str | None</code> <p>A cursor that indicates your place in the list. It should be used to fetch the previous page of the list after an intial next request</p> <code>None</code> <code>gateway</code> <code>Gateway | None</code> <p>The gateway type of the bank. Any value from the <code>Gateway</code> enum.</p> <code>None</code> <code>type_</code> <code>BankType | None</code> <p>Type of financial channel. For Ghanaian channels, please use either mobile_money for mobile money channels OR ghipps for bank channels</p> <code>None</code> <code>currency</code> <code>Currency | None</code> <p>Any value from the Currency enum.</p> <code>None</code> <code>pay_with_bank_transfer</code> <code>bool | None</code> <p>A flag to filter for available banks a customer can make a transfer to complete a payment</p> <code>None</code> <code>pay_with_bank</code> <code>bool | None</code> <p>A flag to filter for banks a customer can pay directly from</p> <code>None</code> <code>pagination</code> <code>int</code> <p>The number of objects to return per page. Defaults to 50, and limited to 100 records per page.</p> <code>50</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <code>include_nip_sort_code</code> <code>bool | None</code> <p>A flag that returns Nigerian banks with their nip institution code. The returned value can be used in identifying institutions on NIP.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[list[Bank]] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/miscellaneous.py</code> <pre><code>def get_banks(\n    self,\n    country: Country,\n    use_cursor: bool = False,\n    next_: str | None = None,\n    previous: str | None = None,\n    gateway: Gateway | None = None,\n    type_: BankType | None = None,\n    currency: Currency | None = None,\n    pay_with_bank_transfer: bool | None = None,\n    pay_with_bank: bool | None = None,\n    include_nip_sort_code: bool | None = None,\n    pagination: int = 50,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[list[Bank]] | Response[PaystackDataModel]:\n    \"\"\"Get a list of all supported banks and their properties\n\n    Args:\n        country: The country from which to obtain the list of supported banks. any value from the ``Country`` enum.\n        use_cursor: Flag to enable cursor pagination.\n        next_: A cursor that indicates your place in the list. It can be used to fetch the next page of the list\n        previous: A cursor that indicates your place in the list. It should be used\n            to fetch the previous page of the list after an intial next request\n        gateway: The gateway type of the bank. Any value from the ``Gateway`` enum.\n        type_: Type of financial channel. For Ghanaian channels, please use either\n            mobile_money for mobile money channels OR ghipps for bank channels\n        currency: Any value from the Currency enum.\n        pay_with_bank_transfer: A flag to filter for available banks a customer can make a transfer to\n            complete a payment\n        pay_with_bank: A flag to filter for banks a customer can pay directly from\n        pagination: The number of objects to return per page. Defaults to 50, and limited to 100 records per page.\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n        include_nip_sort_code: A flag that returns Nigerian banks with their nip institution code.\n            The returned value can be used in identifying institutions on NIP.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    country_full = Country.get_full(country)\n    url = self._full_url(f\"/bank?perPage={pagination}\")\n    query_params = [\n        (\"country\", country_full),\n        (\"use_cursor\", use_cursor),\n        (\"next\", next_),\n        (\"previous\", previous),\n        (\"gateway\", gateway),\n        (\"type\", type_),\n        (\"currency\", currency),\n        (\"pay_with_bank_transfer\", pay_with_bank_transfer),\n        (\"pay_with_bank\", pay_with_bank),\n        (\"include_nip_sort_code\", include_nip_sort_code),\n    ]\n    url = append_query_params(query_params, url)\n    return self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or Bank,\n    )\n</code></pre>"},{"location":"reference/miscellaneous/#pypaystack2.sub_clients.sync_clients.miscellaneous.MiscellaneousClient.get_countries","title":"<code>get_countries(alternate_model_class=None)</code>","text":"<p>Gets a list of Countries that Paystack currently supports</p> <p>Parameters:</p> Name Type Description Default <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[list[PaystackSupportedCountry]] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/miscellaneous.py</code> <pre><code>def get_countries(\n    self,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[list[PaystackSupportedCountry]] | Response[PaystackDataModel]:\n    \"\"\"Gets a list of Countries that Paystack currently supports\n\n    Args:\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(\"/country\")\n    return self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or PaystackSupportedCountry,\n    )\n</code></pre>"},{"location":"reference/miscellaneous/#pypaystack2.sub_clients.sync_clients.miscellaneous.MiscellaneousClient.get_states","title":"<code>get_states(country, alternate_model_class=None)</code>","text":"<p>Get a list of states for a country for address verification.</p> <p>Parameters:</p> Name Type Description Default <code>country</code> <code>Country | str</code> <p>Any value from the country enum.</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[list[State]] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/miscellaneous.py</code> <pre><code>def get_states(\n    self,\n    country: Country | str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[list[State]] | Response[PaystackDataModel]:\n    \"\"\"Get a list of states for a country for address verification.\n\n    Args:\n        country: Any value from the country enum.\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/address_verification/states?country={country}\")\n    return self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or State,\n    )\n</code></pre>"},{"location":"reference/miscellaneous/#pypaystack2.sub_clients.async_clients.miscellaneous.AsyncMiscellaneousClient","title":"<code>AsyncMiscellaneousClient</code>","text":"<p>               Bases: <code>BaseAsyncAPIClient</code></p> <p>Provides a wrapper for paystack Miscellaneous API</p> <p>The Miscellaneous API are supporting APIs that can be used to provide more details to other APIs. https://paystack.com/docs/api/miscellaneous/</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/miscellaneous.py</code> <pre><code>class AsyncMiscellaneousClient(BaseAsyncAPIClient):\n    \"\"\"Provides a wrapper for paystack Miscellaneous API\n\n    The Miscellaneous API are supporting APIs that can be used to provide more details to other APIs.\n    https://paystack.com/docs/api/miscellaneous/\n    \"\"\"\n\n    async def get_banks(\n        self,\n        country: Country,\n        use_cursor: bool = False,\n        next_: str | None = None,\n        previous: str | None = None,\n        gateway: Gateway | None = None,\n        type_: BankType | None = None,\n        currency: Currency | None = None,\n        pay_with_bank_transfer: bool | None = None,\n        pay_with_bank: bool | None = None,\n        include_nip_sort_code: bool | None = None,\n        pagination: int = 50,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[list[Bank]] | Response[PaystackDataModel]:\n        \"\"\"Get a list of all supported banks and their properties\n\n        Args:\n            country: The country from which to obtain the list of supported banks. any value from the ``Country`` enum.\n            use_cursor: Flag to enable cursor pagination.\n            next_: A cursor that indicates your place in the list. It can be used to fetch the next page of the list\n            previous: A cursor that indicates your place in the list. It should be used\n                to fetch the previous page of the list after an intial next request\n            gateway: The gateway type of the bank. Any value from the ``Gateway`` enum.\n            type_: Type of financial channel. For Ghanaian channels, please use either\n                mobile_money for mobile money channels OR ghipps for bank channels\n            currency: Any value from the Currency enum.\n            pay_with_bank_transfer: A flag to filter for available banks a customer can make a transfer to\n                complete a payment\n            pay_with_bank: A flag to filter for banks a customer can pay directly from\n            pagination: The number of objects to return per page. Defaults to 50, and limited to 100 records per page.\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n            include_nip_sort_code: A flag that returns Nigerian banks with their nip institution code.\n                The returned value can be used in identifying institutions on NIP.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        country_full = Country.get_full(country)\n        url = self._full_url(f\"/bank?perPage={pagination}\")\n        query_params = [\n            (\"country\", country_full),\n            (\"use_cursor\", use_cursor),\n            (\"next\", next_),\n            (\"previous\", previous),\n            (\"gateway\", gateway),\n            (\"type\", type_),\n            (\"currency\", currency),\n            (\"pay_with_bank_transfer\", pay_with_bank_transfer),\n            (\"pay_with_bank\", pay_with_bank),\n            (\"include_nip_sort_code\", include_nip_sort_code),\n        ]\n        url = append_query_params(query_params, url)\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or Bank,\n        )\n\n    async def get_countries(\n        self,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[list[PaystackSupportedCountry]] | Response[PaystackDataModel]:\n        \"\"\"Gets a list of Countries that Paystack currently supports\n\n        Args:\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(\"/country\")\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or PaystackSupportedCountry,\n        )\n\n    async def get_states(\n        self,\n        country: Country | str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[list[State]] | Response[PaystackDataModel]:\n        \"\"\"Get a list of states for a country for address verification.\n\n        Args:\n            country: Any value from the country enum.\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/address_verification/states?country={country}\")\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or State,\n        )\n</code></pre>"},{"location":"reference/miscellaneous/#pypaystack2.sub_clients.async_clients.miscellaneous.AsyncMiscellaneousClient.get_banks","title":"<code>get_banks(country, use_cursor=False, next_=None, previous=None, gateway=None, type_=None, currency=None, pay_with_bank_transfer=None, pay_with_bank=None, include_nip_sort_code=None, pagination=50, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Get a list of all supported banks and their properties</p> <p>Parameters:</p> Name Type Description Default <code>country</code> <code>Country</code> <p>The country from which to obtain the list of supported banks. any value from the <code>Country</code> enum.</p> required <code>use_cursor</code> <code>bool</code> <p>Flag to enable cursor pagination.</p> <code>False</code> <code>next_</code> <code>str | None</code> <p>A cursor that indicates your place in the list. It can be used to fetch the next page of the list</p> <code>None</code> <code>previous</code> <code>str | None</code> <p>A cursor that indicates your place in the list. It should be used to fetch the previous page of the list after an intial next request</p> <code>None</code> <code>gateway</code> <code>Gateway | None</code> <p>The gateway type of the bank. Any value from the <code>Gateway</code> enum.</p> <code>None</code> <code>type_</code> <code>BankType | None</code> <p>Type of financial channel. For Ghanaian channels, please use either mobile_money for mobile money channels OR ghipps for bank channels</p> <code>None</code> <code>currency</code> <code>Currency | None</code> <p>Any value from the Currency enum.</p> <code>None</code> <code>pay_with_bank_transfer</code> <code>bool | None</code> <p>A flag to filter for available banks a customer can make a transfer to complete a payment</p> <code>None</code> <code>pay_with_bank</code> <code>bool | None</code> <p>A flag to filter for banks a customer can pay directly from</p> <code>None</code> <code>pagination</code> <code>int</code> <p>The number of objects to return per page. Defaults to 50, and limited to 100 records per page.</p> <code>50</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <code>include_nip_sort_code</code> <code>bool | None</code> <p>A flag that returns Nigerian banks with their nip institution code. The returned value can be used in identifying institutions on NIP.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[list[Bank]] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/miscellaneous.py</code> <pre><code>async def get_banks(\n    self,\n    country: Country,\n    use_cursor: bool = False,\n    next_: str | None = None,\n    previous: str | None = None,\n    gateway: Gateway | None = None,\n    type_: BankType | None = None,\n    currency: Currency | None = None,\n    pay_with_bank_transfer: bool | None = None,\n    pay_with_bank: bool | None = None,\n    include_nip_sort_code: bool | None = None,\n    pagination: int = 50,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[list[Bank]] | Response[PaystackDataModel]:\n    \"\"\"Get a list of all supported banks and their properties\n\n    Args:\n        country: The country from which to obtain the list of supported banks. any value from the ``Country`` enum.\n        use_cursor: Flag to enable cursor pagination.\n        next_: A cursor that indicates your place in the list. It can be used to fetch the next page of the list\n        previous: A cursor that indicates your place in the list. It should be used\n            to fetch the previous page of the list after an intial next request\n        gateway: The gateway type of the bank. Any value from the ``Gateway`` enum.\n        type_: Type of financial channel. For Ghanaian channels, please use either\n            mobile_money for mobile money channels OR ghipps for bank channels\n        currency: Any value from the Currency enum.\n        pay_with_bank_transfer: A flag to filter for available banks a customer can make a transfer to\n            complete a payment\n        pay_with_bank: A flag to filter for banks a customer can pay directly from\n        pagination: The number of objects to return per page. Defaults to 50, and limited to 100 records per page.\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n        include_nip_sort_code: A flag that returns Nigerian banks with their nip institution code.\n            The returned value can be used in identifying institutions on NIP.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    country_full = Country.get_full(country)\n    url = self._full_url(f\"/bank?perPage={pagination}\")\n    query_params = [\n        (\"country\", country_full),\n        (\"use_cursor\", use_cursor),\n        (\"next\", next_),\n        (\"previous\", previous),\n        (\"gateway\", gateway),\n        (\"type\", type_),\n        (\"currency\", currency),\n        (\"pay_with_bank_transfer\", pay_with_bank_transfer),\n        (\"pay_with_bank\", pay_with_bank),\n        (\"include_nip_sort_code\", include_nip_sort_code),\n    ]\n    url = append_query_params(query_params, url)\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or Bank,\n    )\n</code></pre>"},{"location":"reference/miscellaneous/#pypaystack2.sub_clients.async_clients.miscellaneous.AsyncMiscellaneousClient.get_countries","title":"<code>get_countries(alternate_model_class=None)</code>  <code>async</code>","text":"<p>Gets a list of Countries that Paystack currently supports</p> <p>Parameters:</p> Name Type Description Default <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[list[PaystackSupportedCountry]] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/miscellaneous.py</code> <pre><code>async def get_countries(\n    self,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[list[PaystackSupportedCountry]] | Response[PaystackDataModel]:\n    \"\"\"Gets a list of Countries that Paystack currently supports\n\n    Args:\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(\"/country\")\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or PaystackSupportedCountry,\n    )\n</code></pre>"},{"location":"reference/miscellaneous/#pypaystack2.sub_clients.async_clients.miscellaneous.AsyncMiscellaneousClient.get_states","title":"<code>get_states(country, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Get a list of states for a country for address verification.</p> <p>Parameters:</p> Name Type Description Default <code>country</code> <code>Country | str</code> <p>Any value from the country enum.</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[list[State]] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/miscellaneous.py</code> <pre><code>async def get_states(\n    self,\n    country: Country | str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[list[State]] | Response[PaystackDataModel]:\n    \"\"\"Get a list of states for a country for address verification.\n\n    Args:\n        country: Any value from the country enum.\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/address_verification/states?country={country}\")\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or State,\n    )\n</code></pre>"},{"location":"reference/payment_pages/","title":"Payment pages","text":""},{"location":"reference/payment_pages/#pypaystack2.sub_clients.sync_clients.payment_pages.PaymentPageClient","title":"<code>PaymentPageClient</code>","text":"<p>               Bases: <code>BaseAPIClient</code></p> <p>Provides a wrapper for paystack Payment Pages API</p> <p>The Payment Pages API provides a quick and secure way to collect payment for products. https://paystack.com/docs/api/page/</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/payment_pages.py</code> <pre><code>class PaymentPageClient(BaseAPIClient):\n    \"\"\"Provides a wrapper for paystack Payment Pages API\n\n    The Payment Pages API provides a quick and secure way to collect payment for products.\n    https://paystack.com/docs/api/page/\n    \"\"\"\n\n    def create(\n        self,\n        name: str,\n        description: str | None = None,\n        amount: int | None = None,\n        split_code: str | None = None,\n        slug: str | None = None,\n        metadata: dict[str, Any] | None = None,\n        redirect_url: str | None = None,\n        custom_fields: list[Any] | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[PaymentPage] | Response[PaystackDataModel]:\n        \"\"\"Create a payment page on your integration\n\n        Args:\n            name: Name of page\n            description: A description for this page\n            amount: Amount should be in kobo if currency is ``Currency.NGN``, pesewas, if\n                currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR``\n            split_code: The split code of the transaction split. e.g. SPL_98WF13Eb3w\n            slug: URL slug you would like to be associated with this page.\n                Page will be accessible at ``https://paystack.com/pay/[slug]``\n            metadata: Extra data to configure the payment page including subaccount,\n                logo image, transaction charge\n            redirect_url: If you would like Paystack to redirect someplace upon\n                successful payment, specify the URL here.\n            custom_fields: If you would like to accept custom fields,\n                specify them here.\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(\"/page\")\n\n        payload = {\"name\": name}\n        optional_params = [\n            (\"description\", description),\n            (\"amount\", amount),\n            (\"split_code\", split_code),\n            (\"slug\", slug),\n            (\"metadata\", metadata),\n            (\"redirect_url\", redirect_url),\n            (\"custom_fields\", custom_fields),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or PaymentPage,\n        )\n\n    def get_pages(\n        self,\n        page: int = 1,\n        pagination: int = 50,\n        start_date: str | None = None,\n        end_date: str | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[list[PaymentPage]] | Response[PaystackDataModel]:\n        \"\"\"Fetch payment pages available on your integration.\n\n        Args:\n            page: Specifies exactly what page you want to retrieve.\n                If not specified, we use a default value of 1.\n            pagination: Specifies how many records you want to retrieve per page.\n                If not specified, we use a default value of 50.\n            start_date: A timestamp from which to start listing page e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            end_date: A timestamp at which to stop listing page e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(\"/page?perPage=\" + str(pagination))\n        query_params = [\n            (\"page\", page),\n            (\"start_date\", start_date),\n            (\"end_date\", end_date),\n        ]\n        url = append_query_params(query_params, url)\n        return self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or PaymentPage,\n        )\n\n    def get_page(\n        self,\n        id_or_slug: int | str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[PaymentPage] | Response[PaystackDataModel]:\n        \"\"\"Get details of a payment page on your integration.\n\n        Args:\n            id_or_slug: The page ``ID`` or ``slug`` you want to fetch\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/page/{id_or_slug}\")\n        return self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or PaymentPage,\n        )\n\n    def update(\n        self,\n        id_or_slug: int | str,\n        name: str,\n        description: str | None = None,\n        amount: int | None = None,\n        active: bool | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[PaymentPage] | Response[PaystackDataModel]:\n        \"\"\"Get details of a payment page on your integration.\n\n        Args:\n            id_or_slug: The page ``ID`` or ``slug`` you want to fetch\n            name: Name of page\n            description: A description for the page\n            amount: Default amount you want to accept using this page.\n                If none is set, customer is free to provide any amount\n                of their choice. The latter scenario is useful for\n                accepting donations\n            active: Set to ``False`` to deactivate page url\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/page/{id_or_slug}\")\n        payload = {\n            \"name\": name,\n        }\n        optional_params = [\n            (\"amount\", amount),\n            (\"active\", active),\n            (\"description\", description),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return self._handle_request(  # type: ignore\n            HTTPMethod.PUT,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or PaymentPage,\n        )\n\n    def check_slug_available(\n        self,\n        slug: str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[None] | Response[PaystackDataModel]:\n        \"\"\"Check the availability of a slug for a payment page.\n\n        Args:\n            slug: URL slug to be confirmed\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/page/check_slug_availability/{slug}\")\n        return self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class,\n        )\n\n    def add_products(\n        self,\n        id_: str,\n        products: list[int],\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[PaymentPage] | Response[PaystackDataModel]:\n        \"\"\"Add products to a payment page\n\n        Args:\n            id_: ID of the payment page\n            products: Ids of all the products\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/page/{id_}/product\")\n        payload = {\"products\": products}\n        return self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or PaymentPage,\n        )\n</code></pre>"},{"location":"reference/payment_pages/#pypaystack2.sub_clients.sync_clients.payment_pages.PaymentPageClient.add_products","title":"<code>add_products(id_, products, alternate_model_class=None)</code>","text":"<p>Add products to a payment page</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>ID of the payment page</p> required <code>products</code> <code>list[int]</code> <p>Ids of all the products</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[PaymentPage] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/payment_pages.py</code> <pre><code>def add_products(\n    self,\n    id_: str,\n    products: list[int],\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[PaymentPage] | Response[PaystackDataModel]:\n    \"\"\"Add products to a payment page\n\n    Args:\n        id_: ID of the payment page\n        products: Ids of all the products\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/page/{id_}/product\")\n    payload = {\"products\": products}\n    return self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or PaymentPage,\n    )\n</code></pre>"},{"location":"reference/payment_pages/#pypaystack2.sub_clients.sync_clients.payment_pages.PaymentPageClient.check_slug_available","title":"<code>check_slug_available(slug, alternate_model_class=None)</code>","text":"<p>Check the availability of a slug for a payment page.</p> <p>Parameters:</p> Name Type Description Default <code>slug</code> <code>str</code> <p>URL slug to be confirmed</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[None] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/payment_pages.py</code> <pre><code>def check_slug_available(\n    self,\n    slug: str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[None] | Response[PaystackDataModel]:\n    \"\"\"Check the availability of a slug for a payment page.\n\n    Args:\n        slug: URL slug to be confirmed\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/page/check_slug_availability/{slug}\")\n    return self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class,\n    )\n</code></pre>"},{"location":"reference/payment_pages/#pypaystack2.sub_clients.sync_clients.payment_pages.PaymentPageClient.create","title":"<code>create(name, description=None, amount=None, split_code=None, slug=None, metadata=None, redirect_url=None, custom_fields=None, alternate_model_class=None)</code>","text":"<p>Create a payment page on your integration</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of page</p> required <code>description</code> <code>str | None</code> <p>A description for this page</p> <code>None</code> <code>amount</code> <code>int | None</code> <p>Amount should be in kobo if currency is <code>Currency.NGN</code>, pesewas, if currency is <code>Currency.GHS</code>, and cents, if currency is <code>Currency.ZAR</code></p> <code>None</code> <code>split_code</code> <code>str | None</code> <p>The split code of the transaction split. e.g. SPL_98WF13Eb3w</p> <code>None</code> <code>slug</code> <code>str | None</code> <p>URL slug you would like to be associated with this page. Page will be accessible at <code>https://paystack.com/pay/[slug]</code></p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>Extra data to configure the payment page including subaccount, logo image, transaction charge</p> <code>None</code> <code>redirect_url</code> <code>str | None</code> <p>If you would like Paystack to redirect someplace upon successful payment, specify the URL here.</p> <code>None</code> <code>custom_fields</code> <code>list[Any] | None</code> <p>If you would like to accept custom fields, specify them here.</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[PaymentPage] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/payment_pages.py</code> <pre><code>def create(\n    self,\n    name: str,\n    description: str | None = None,\n    amount: int | None = None,\n    split_code: str | None = None,\n    slug: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    redirect_url: str | None = None,\n    custom_fields: list[Any] | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[PaymentPage] | Response[PaystackDataModel]:\n    \"\"\"Create a payment page on your integration\n\n    Args:\n        name: Name of page\n        description: A description for this page\n        amount: Amount should be in kobo if currency is ``Currency.NGN``, pesewas, if\n            currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR``\n        split_code: The split code of the transaction split. e.g. SPL_98WF13Eb3w\n        slug: URL slug you would like to be associated with this page.\n            Page will be accessible at ``https://paystack.com/pay/[slug]``\n        metadata: Extra data to configure the payment page including subaccount,\n            logo image, transaction charge\n        redirect_url: If you would like Paystack to redirect someplace upon\n            successful payment, specify the URL here.\n        custom_fields: If you would like to accept custom fields,\n            specify them here.\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(\"/page\")\n\n    payload = {\"name\": name}\n    optional_params = [\n        (\"description\", description),\n        (\"amount\", amount),\n        (\"split_code\", split_code),\n        (\"slug\", slug),\n        (\"metadata\", metadata),\n        (\"redirect_url\", redirect_url),\n        (\"custom_fields\", custom_fields),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or PaymentPage,\n    )\n</code></pre>"},{"location":"reference/payment_pages/#pypaystack2.sub_clients.sync_clients.payment_pages.PaymentPageClient.get_page","title":"<code>get_page(id_or_slug, alternate_model_class=None)</code>","text":"<p>Get details of a payment page on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>id_or_slug</code> <code>int | str</code> <p>The page <code>ID</code> or <code>slug</code> you want to fetch</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[PaymentPage] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/payment_pages.py</code> <pre><code>def get_page(\n    self,\n    id_or_slug: int | str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[PaymentPage] | Response[PaystackDataModel]:\n    \"\"\"Get details of a payment page on your integration.\n\n    Args:\n        id_or_slug: The page ``ID`` or ``slug`` you want to fetch\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/page/{id_or_slug}\")\n    return self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or PaymentPage,\n    )\n</code></pre>"},{"location":"reference/payment_pages/#pypaystack2.sub_clients.sync_clients.payment_pages.PaymentPageClient.get_pages","title":"<code>get_pages(page=1, pagination=50, start_date=None, end_date=None, alternate_model_class=None)</code>","text":"<p>Fetch payment pages available on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>int</code> <p>Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1.</p> <code>1</code> <code>pagination</code> <code>int</code> <p>Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50.</p> <code>50</code> <code>start_date</code> <code>str | None</code> <p>A timestamp from which to start listing page e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>end_date</code> <code>str | None</code> <p>A timestamp at which to stop listing page e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[list[PaymentPage]] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/payment_pages.py</code> <pre><code>def get_pages(\n    self,\n    page: int = 1,\n    pagination: int = 50,\n    start_date: str | None = None,\n    end_date: str | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[list[PaymentPage]] | Response[PaystackDataModel]:\n    \"\"\"Fetch payment pages available on your integration.\n\n    Args:\n        page: Specifies exactly what page you want to retrieve.\n            If not specified, we use a default value of 1.\n        pagination: Specifies how many records you want to retrieve per page.\n            If not specified, we use a default value of 50.\n        start_date: A timestamp from which to start listing page e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        end_date: A timestamp at which to stop listing page e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(\"/page?perPage=\" + str(pagination))\n    query_params = [\n        (\"page\", page),\n        (\"start_date\", start_date),\n        (\"end_date\", end_date),\n    ]\n    url = append_query_params(query_params, url)\n    return self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or PaymentPage,\n    )\n</code></pre>"},{"location":"reference/payment_pages/#pypaystack2.sub_clients.sync_clients.payment_pages.PaymentPageClient.update","title":"<code>update(id_or_slug, name, description=None, amount=None, active=None, alternate_model_class=None)</code>","text":"<p>Get details of a payment page on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>id_or_slug</code> <code>int | str</code> <p>The page <code>ID</code> or <code>slug</code> you want to fetch</p> required <code>name</code> <code>str</code> <p>Name of page</p> required <code>description</code> <code>str | None</code> <p>A description for the page</p> <code>None</code> <code>amount</code> <code>int | None</code> <p>Default amount you want to accept using this page. If none is set, customer is free to provide any amount of their choice. The latter scenario is useful for accepting donations</p> <code>None</code> <code>active</code> <code>bool | None</code> <p>Set to <code>False</code> to deactivate page url</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[PaymentPage] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/payment_pages.py</code> <pre><code>def update(\n    self,\n    id_or_slug: int | str,\n    name: str,\n    description: str | None = None,\n    amount: int | None = None,\n    active: bool | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[PaymentPage] | Response[PaystackDataModel]:\n    \"\"\"Get details of a payment page on your integration.\n\n    Args:\n        id_or_slug: The page ``ID`` or ``slug`` you want to fetch\n        name: Name of page\n        description: A description for the page\n        amount: Default amount you want to accept using this page.\n            If none is set, customer is free to provide any amount\n            of their choice. The latter scenario is useful for\n            accepting donations\n        active: Set to ``False`` to deactivate page url\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/page/{id_or_slug}\")\n    payload = {\n        \"name\": name,\n    }\n    optional_params = [\n        (\"amount\", amount),\n        (\"active\", active),\n        (\"description\", description),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return self._handle_request(  # type: ignore\n        HTTPMethod.PUT,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or PaymentPage,\n    )\n</code></pre>"},{"location":"reference/payment_pages/#pypaystack2.sub_clients.async_clients.payment_pages.AsyncPaymentPageClient","title":"<code>AsyncPaymentPageClient</code>","text":"<p>               Bases: <code>BaseAsyncAPIClient</code></p> <p>Provides a wrapper for paystack Payment Pages API</p> <p>The Payment Pages API provides a quick and secure way to collect payment for products. https://paystack.com/docs/api/page/</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/payment_pages.py</code> <pre><code>class AsyncPaymentPageClient(BaseAsyncAPIClient):\n    \"\"\"Provides a wrapper for paystack Payment Pages API\n\n    The Payment Pages API provides a quick and secure way to collect payment for products.\n    https://paystack.com/docs/api/page/\n    \"\"\"\n\n    async def create(\n        self,\n        name: str,\n        description: str | None = None,\n        amount: int | None = None,\n        split_code: str | None = None,\n        slug: str | None = None,\n        metadata: dict[str, Any] | None = None,\n        redirect_url: str | None = None,\n        custom_fields: list[Any] | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[PaymentPage] | Response[PaystackDataModel]:\n        \"\"\"Create a payment page on your integration\n\n        Args:\n            name: Name of page\n            description: A description for this page\n            amount: Amount should be in kobo if currency is ``Currency.NGN``, pesewas, if\n                currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR``\n            split_code: The split code of the transaction split. e.g. SPL_98WF13Eb3w\n            slug: URL slug you would like to be associated with this page.\n                Page will be accessible at ``https://paystack.com/pay/[slug]``\n            metadata: Extra data to configure the payment page including subaccount,\n                logo image, transaction charge\n            redirect_url: If you would like Paystack to redirect someplace upon\n                successful payment, specify the URL here.\n            custom_fields: If you would like to accept custom fields,\n                specify them here.\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(\"/page\")\n\n        payload = {\"name\": name}\n        optional_params = [\n            (\"description\", description),\n            (\"amount\", amount),\n            (\"split_code\", split_code),\n            (\"slug\", slug),\n            (\"metadata\", metadata),\n            (\"redirect_url\", redirect_url),\n            (\"custom_fields\", custom_fields),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or PaymentPage,\n        )\n\n    async def get_pages(\n        self,\n        page: int = 1,\n        pagination: int = 50,\n        start_date: str | None = None,\n        end_date: str | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[list[PaymentPage]] | Response[PaystackDataModel]:\n        \"\"\"Fetch payment pages available on your integration.\n\n        Args:\n            page: Specifies exactly what page you want to retrieve.\n                If not specified we use a default value of 1.\n            pagination: Specifies how many records you want to retrieve per page.\n                If not specified we use a default value of 50.\n            start_date: A timestamp from which to start listing page e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            end_date: A timestamp at which to stop listing page e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(\"/page?perPage=\" + str(pagination))\n        query_params = [\n            (\"page\", page),\n            (\"start_date\", start_date),\n            (\"end_date\", end_date),\n        ]\n        url = append_query_params(query_params, url)\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or PaymentPage,\n        )\n\n    async def get_page(\n        self,\n        id_or_slug: int | str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[PaymentPage] | Response[PaystackDataModel]:\n        \"\"\"Get details of a payment page on your integration.\n\n        Args:\n            id_or_slug: The page ``ID`` or ``slug`` you want to fetch\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/page/{id_or_slug}\")\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or PaymentPage,\n        )\n\n    async def update(\n        self,\n        id_or_slug: int | str,\n        name: str,\n        description: str | None = None,\n        amount: int | None = None,\n        active: bool | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[PaymentPage] | Response[PaystackDataModel]:\n        \"\"\"Get details of a payment page on your integration.\n\n        Args:\n            id_or_slug: The page ``ID`` or ``slug`` you want to fetch\n            name: Name of page\n            description: A description for the page\n            amount: Default amount you want to accept using this page.\n                If none is set, customer is free to provide any amount\n                of their choice. The latter scenario is useful for\n                accepting donations\n            active: Set to ``False`` to deactivate page url\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/page/{id_or_slug}\")\n        payload = {\n            \"name\": name,\n        }\n        optional_params = [\n            (\"amount\", amount),\n            (\"active\", active),\n            (\"description\", description),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.PUT,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or PaymentPage,\n        )\n\n    async def check_slug_available(\n        self,\n        slug: str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[None] | Response[PaystackDataModel]:\n        \"\"\"Check the availability of a slug for a payment page.\n\n        Args:\n            slug: URL slug to be confirmed\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/page/check_slug_availability/{slug}\")\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class,\n        )\n\n    async def add_products(\n        self,\n        id_: str,\n        products: list[int],\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[PaymentPage] | Response[PaystackDataModel]:\n        \"\"\"Add products to a payment page\n\n        Args:\n            id_: ID of the payment page\n            products: Ids of all the products\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/page/{id_}/product\")\n        payload = {\"products\": products}\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or PaymentPage,\n        )\n</code></pre>"},{"location":"reference/payment_pages/#pypaystack2.sub_clients.async_clients.payment_pages.AsyncPaymentPageClient.add_products","title":"<code>add_products(id_, products, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Add products to a payment page</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>ID of the payment page</p> required <code>products</code> <code>list[int]</code> <p>Ids of all the products</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[PaymentPage] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/payment_pages.py</code> <pre><code>async def add_products(\n    self,\n    id_: str,\n    products: list[int],\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[PaymentPage] | Response[PaystackDataModel]:\n    \"\"\"Add products to a payment page\n\n    Args:\n        id_: ID of the payment page\n        products: Ids of all the products\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/page/{id_}/product\")\n    payload = {\"products\": products}\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or PaymentPage,\n    )\n</code></pre>"},{"location":"reference/payment_pages/#pypaystack2.sub_clients.async_clients.payment_pages.AsyncPaymentPageClient.check_slug_available","title":"<code>check_slug_available(slug, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Check the availability of a slug for a payment page.</p> <p>Parameters:</p> Name Type Description Default <code>slug</code> <code>str</code> <p>URL slug to be confirmed</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[None] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/payment_pages.py</code> <pre><code>async def check_slug_available(\n    self,\n    slug: str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[None] | Response[PaystackDataModel]:\n    \"\"\"Check the availability of a slug for a payment page.\n\n    Args:\n        slug: URL slug to be confirmed\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/page/check_slug_availability/{slug}\")\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class,\n    )\n</code></pre>"},{"location":"reference/payment_pages/#pypaystack2.sub_clients.async_clients.payment_pages.AsyncPaymentPageClient.create","title":"<code>create(name, description=None, amount=None, split_code=None, slug=None, metadata=None, redirect_url=None, custom_fields=None, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Create a payment page on your integration</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of page</p> required <code>description</code> <code>str | None</code> <p>A description for this page</p> <code>None</code> <code>amount</code> <code>int | None</code> <p>Amount should be in kobo if currency is <code>Currency.NGN</code>, pesewas, if currency is <code>Currency.GHS</code>, and cents, if currency is <code>Currency.ZAR</code></p> <code>None</code> <code>split_code</code> <code>str | None</code> <p>The split code of the transaction split. e.g. SPL_98WF13Eb3w</p> <code>None</code> <code>slug</code> <code>str | None</code> <p>URL slug you would like to be associated with this page. Page will be accessible at <code>https://paystack.com/pay/[slug]</code></p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>Extra data to configure the payment page including subaccount, logo image, transaction charge</p> <code>None</code> <code>redirect_url</code> <code>str | None</code> <p>If you would like Paystack to redirect someplace upon successful payment, specify the URL here.</p> <code>None</code> <code>custom_fields</code> <code>list[Any] | None</code> <p>If you would like to accept custom fields, specify them here.</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[PaymentPage] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/payment_pages.py</code> <pre><code>async def create(\n    self,\n    name: str,\n    description: str | None = None,\n    amount: int | None = None,\n    split_code: str | None = None,\n    slug: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    redirect_url: str | None = None,\n    custom_fields: list[Any] | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[PaymentPage] | Response[PaystackDataModel]:\n    \"\"\"Create a payment page on your integration\n\n    Args:\n        name: Name of page\n        description: A description for this page\n        amount: Amount should be in kobo if currency is ``Currency.NGN``, pesewas, if\n            currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR``\n        split_code: The split code of the transaction split. e.g. SPL_98WF13Eb3w\n        slug: URL slug you would like to be associated with this page.\n            Page will be accessible at ``https://paystack.com/pay/[slug]``\n        metadata: Extra data to configure the payment page including subaccount,\n            logo image, transaction charge\n        redirect_url: If you would like Paystack to redirect someplace upon\n            successful payment, specify the URL here.\n        custom_fields: If you would like to accept custom fields,\n            specify them here.\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(\"/page\")\n\n    payload = {\"name\": name}\n    optional_params = [\n        (\"description\", description),\n        (\"amount\", amount),\n        (\"split_code\", split_code),\n        (\"slug\", slug),\n        (\"metadata\", metadata),\n        (\"redirect_url\", redirect_url),\n        (\"custom_fields\", custom_fields),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or PaymentPage,\n    )\n</code></pre>"},{"location":"reference/payment_pages/#pypaystack2.sub_clients.async_clients.payment_pages.AsyncPaymentPageClient.get_page","title":"<code>get_page(id_or_slug, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Get details of a payment page on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>id_or_slug</code> <code>int | str</code> <p>The page <code>ID</code> or <code>slug</code> you want to fetch</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[PaymentPage] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/payment_pages.py</code> <pre><code>async def get_page(\n    self,\n    id_or_slug: int | str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[PaymentPage] | Response[PaystackDataModel]:\n    \"\"\"Get details of a payment page on your integration.\n\n    Args:\n        id_or_slug: The page ``ID`` or ``slug`` you want to fetch\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/page/{id_or_slug}\")\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or PaymentPage,\n    )\n</code></pre>"},{"location":"reference/payment_pages/#pypaystack2.sub_clients.async_clients.payment_pages.AsyncPaymentPageClient.get_pages","title":"<code>get_pages(page=1, pagination=50, start_date=None, end_date=None, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Fetch payment pages available on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>int</code> <p>Specifies exactly what page you want to retrieve. If not specified we use a default value of 1.</p> <code>1</code> <code>pagination</code> <code>int</code> <p>Specifies how many records you want to retrieve per page. If not specified we use a default value of 50.</p> <code>50</code> <code>start_date</code> <code>str | None</code> <p>A timestamp from which to start listing page e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>end_date</code> <code>str | None</code> <p>A timestamp at which to stop listing page e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[list[PaymentPage]] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/payment_pages.py</code> <pre><code>async def get_pages(\n    self,\n    page: int = 1,\n    pagination: int = 50,\n    start_date: str | None = None,\n    end_date: str | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[list[PaymentPage]] | Response[PaystackDataModel]:\n    \"\"\"Fetch payment pages available on your integration.\n\n    Args:\n        page: Specifies exactly what page you want to retrieve.\n            If not specified we use a default value of 1.\n        pagination: Specifies how many records you want to retrieve per page.\n            If not specified we use a default value of 50.\n        start_date: A timestamp from which to start listing page e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        end_date: A timestamp at which to stop listing page e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(\"/page?perPage=\" + str(pagination))\n    query_params = [\n        (\"page\", page),\n        (\"start_date\", start_date),\n        (\"end_date\", end_date),\n    ]\n    url = append_query_params(query_params, url)\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or PaymentPage,\n    )\n</code></pre>"},{"location":"reference/payment_pages/#pypaystack2.sub_clients.async_clients.payment_pages.AsyncPaymentPageClient.update","title":"<code>update(id_or_slug, name, description=None, amount=None, active=None, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Get details of a payment page on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>id_or_slug</code> <code>int | str</code> <p>The page <code>ID</code> or <code>slug</code> you want to fetch</p> required <code>name</code> <code>str</code> <p>Name of page</p> required <code>description</code> <code>str | None</code> <p>A description for the page</p> <code>None</code> <code>amount</code> <code>int | None</code> <p>Default amount you want to accept using this page. If none is set, customer is free to provide any amount of their choice. The latter scenario is useful for accepting donations</p> <code>None</code> <code>active</code> <code>bool | None</code> <p>Set to <code>False</code> to deactivate page url</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[PaymentPage] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/payment_pages.py</code> <pre><code>async def update(\n    self,\n    id_or_slug: int | str,\n    name: str,\n    description: str | None = None,\n    amount: int | None = None,\n    active: bool | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[PaymentPage] | Response[PaystackDataModel]:\n    \"\"\"Get details of a payment page on your integration.\n\n    Args:\n        id_or_slug: The page ``ID`` or ``slug`` you want to fetch\n        name: Name of page\n        description: A description for the page\n        amount: Default amount you want to accept using this page.\n            If none is set, customer is free to provide any amount\n            of their choice. The latter scenario is useful for\n            accepting donations\n        active: Set to ``False`` to deactivate page url\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/page/{id_or_slug}\")\n    payload = {\n        \"name\": name,\n    }\n    optional_params = [\n        (\"amount\", amount),\n        (\"active\", active),\n        (\"description\", description),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.PUT,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or PaymentPage,\n    )\n</code></pre>"},{"location":"reference/payment_requests/","title":"Payment requests","text":""},{"location":"reference/payment_requests/#pypaystack2.sub_clients.sync_clients.payment_requests.PaymentRequestClient","title":"<code>PaymentRequestClient</code>","text":"<p>               Bases: <code>BaseAPIClient</code></p> <p>Provides a wrapper for paystack Payment Requests API</p> <p>The Payment Requests API allows you to manage requests for payment of goods and services. https://paystack.com/docs/api/payment-request/</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/payment_requests.py</code> <pre><code>class PaymentRequestClient(BaseAPIClient):\n    \"\"\"Provides a wrapper for paystack Payment Requests API\n\n    The Payment Requests API allows you to manage requests for payment of goods and services.\n    https://paystack.com/docs/api/payment-request/\n    \"\"\"\n\n    def create(\n        self,\n        customer: int | str,\n        amount: int,\n        due_date: str | None = None,\n        description: str | None = None,\n        line_items: list[LineItem] | None = None,\n        tax: list[Tax] | None = None,\n        currency: Currency | None = None,\n        send_notification: bool | None = None,\n        draft: bool | None = None,\n        has_invoice: bool | None = None,\n        invoice_number: int | None = None,\n        split_code: str | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[PaymentRequest] | Response[PaystackDataModel]:\n        \"\"\"Create a payment request for a transaction on your integration\n\n        Args:\n            customer: Customer id or code\n            amount: Payment request amount. It should be used when line items and tax values aren't specified.\n            due_date: ISO 8601 representation of request due date\n            description: A short description of the payment request\n            line_items: List of line items int the format [{\"name\":\"item 1\", \"amount\":2000, \"quantity\": 1}]\n            tax: List of taxes to be charged in the format [{\"name\":\"VAT\", \"amount\":2000}]\n            currency: Any value from Currency enum. default ``Currency.NGN``\n            send_notification: Indicates whether Paystack sends an email notification to customer. Defaults to ``True``\n            draft: Indicate if request should be saved as draft. Defaults to ``False`` and overrides send_notification\n            has_invoice: Set to ``True`` to create a draft invoice (adds an auto-incrementing invoice number\n                if none is provided) even if there are no line_items or tax passed\n            invoice_number: Numeric value of invoice. Invoice will start from 1 and auto increment from there.\n                This field is to help override whatever value Paystack decides. Auto increment for\n                subsequent invoices continue from this point.\n            split_code: The split code of the transaction split. e.g. SPL_98WF13Eb3w\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n        _line_items: list[dict[str, Any]] | None = None\n        _tax: list[dict[str, Any]] | None = None\n        if line_items:\n            _line_items = [item.model_dump() for item in line_items]\n        if tax:\n            _tax = [unit_tax.model_dump() for unit_tax in tax]\n\n        url = self._full_url(\"/paymentrequest\")\n\n        payload = {\"customer\": customer, \"amount\": amount}\n        optional_params = [\n            (\"due_date\", due_date),\n            (\"description\", description),\n            (\"line_items\", _line_items),\n            (\"tax\", _tax),\n            (\"currency\", currency),\n            (\"send_notification\", send_notification),\n            (\"draft\", draft),\n            (\"has_invoice\", has_invoice),\n            (\"invoice_number\", invoice_number),\n            (\"split_code\", split_code),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or PaymentRequest,\n        )\n\n    def get_payment_requests(\n        self,\n        customer: str | int | None = None,\n        status: Status | None = None,\n        currency: Currency | None = None,\n        include_archive: bool = False,\n        page: int = 1,\n        pagination: int = 50,\n        start_date: str | None = None,\n        end_date: str | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[list[PaymentRequest]] | Response[PaystackDataModel]:\n        \"\"\"Fetches the payment requests available on your integration.\n\n        Args:\n            customer: Filter by customer ID\n            status: Filter by payment request status. Any value from enum of ``Status``\n            currency: Filter by currency. Any value from enum of ``Currency``\n            include_archive: Show archived payment requests.\n            page: Specify exactly what payment request you want to page. If not specified, we use a default value of 1.\n            pagination: Specifies how many records you want to retrieve per page. If not specified,\n                we use a default value of 50.\n            start_date: A timestamp from which to start listing payment requests\n                e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            end_date: A timestamp at which to stop listing payment requests e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/paymentrequest?perPage={pagination}\")\n        query_params = [\n            (\"customer\", customer),\n            (\"status\", status),\n            (\"currency\", currency),\n            (\"include_archive\", include_archive),\n            (\"page\", page),\n            (\"start_date\", start_date),\n            (\"end_date\", end_date),\n        ]\n        url = append_query_params(query_params, url)\n        return self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or PaymentRequest,\n        )\n\n    def get_payment_request(\n        self,\n        id_or_code: int | str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[PaymentRequest] | Response[PaystackDataModel]:\n        \"\"\"Get details of a payment request on your integration\n\n        Args:\n            id_or_code: The payment request ID or code you want to fetch\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/paymentrequest/{id_or_code}\")\n        return self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or PaymentRequest,\n        )\n\n    def verify(\n        self,\n        id_or_code: int | str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[PaymentRequest] | Response[PaystackDataModel]:\n        \"\"\"Verify details of a payment request on your integration.\n\n        Args:\n            id_or_code: Payment Request id or code\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/paymentrequest/verify/{id_or_code}\")\n        return self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or PaymentRequest,\n        )\n\n    def send_notification(\n        self,\n        id_or_code: int | str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[None] | Response[PaystackDataModel]:\n        \"\"\"Send notification of a payment request to your customers\n\n        Args:\n            id_or_code: Payment Request id or code\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/paymentrequest/notify/{id_or_code}\")\n        return self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            response_data_model_class=alternate_model_class,\n        )\n\n    def get_total(\n        self,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[PaymentRequestStat] | Response[PaystackDataModel]:\n        \"\"\"Get payment requests metric\n\n        Args:\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(\"/paymentrequest/totals\")\n        return self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or PaymentRequestStat,\n        )\n\n    def finalize(\n        self,\n        id_or_code: int | str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[PaymentRequest] | Response[PaystackDataModel]:\n        \"\"\"Finalize a draft payment request\n\n        Args:\n            id_or_code: Payment Request id or code\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/paymentrequest/finalize/{id_or_code}\")\n        return self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            response_data_model_class=alternate_model_class or PaymentRequest,\n        )\n\n    def update(\n        self,\n        id_or_code: int | str,\n        customer: int | str,\n        amount: int,\n        due_date: str | None = None,\n        description: str | None = None,\n        line_items: list[LineItem] | None = None,\n        tax: list[Tax] | None = None,\n        currency: Currency | None = None,\n        send_notification: bool | None = None,\n        draft: bool | None = None,\n        invoice_number: int | None = None,\n        split_code: str | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[PaymentRequest] | Response[PaystackDataModel]:\n        \"\"\"Update the payment request details on your integration\n\n        Args:\n            id_or_code: Payment Request id or code\n            customer: Customer id or code\n            amount: Payment request amount. Only useful if line items and tax values are ignored.\n                method will throw a friendly warning in the response if neither is available.\n            due_date: ISO 8601 representation of request due date\n            description: A short description of the payment request\n            line_items: List of line items in the format [{\"name\":\"item 1\", \"amount\":2000}]\n            tax: List of taxes to be charged in the format [{\"name\":\"VAT\", \"amount\":2000}]\n            currency: Specify the currency of the Payment Request id or code. Any value from the ``Currency`` enum\n            send_notification: Indicates whether Paystack sends an email notification to customer. Defaults to ``True``\n            draft: Indicate if request should be saved as draft. Defaults to false and overrides send_notification\n            invoice_number: Numeric value of invoice. Invoice will start from 1 and auto increment from there.\n                This field is to help override whatever value Paystack decides. Auto increment for\n                subsequent invoices continue from this point.\n            split_code: The split code of the transaction split. e.g. SPL_98WF13Eb3w\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        _line_items: list[dict[str, Any]] | None = None\n        _tax: list[dict[str, Any]] | None = None\n\n        if line_items:\n            _line_items = [item.model_dump() for item in line_items]\n        if tax:\n            _tax = [unit_tax.model_dump() for unit_tax in tax]\n\n        url = self._full_url(f\"/paymentrequest/{id_or_code}\")\n        payload = {\n            \"customer\": customer,\n            \"amount\": amount,\n        }\n        optional_params = [\n            (\"due_date\", due_date),\n            (\"description\", description),\n            (\"line_items\", _line_items),\n            (\"tax\", _tax),\n            (\"currency\", currency),\n            (\"send_notification\", send_notification),\n            (\"draft\", draft),\n            (\"invoice_number\", invoice_number),\n            (\"split_code\", split_code),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return self._handle_request(  # type: ignore\n            HTTPMethod.PUT,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or PaymentRequest,\n        )\n\n    def archive(\n        self,\n        id_or_code: int | str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[None] | Response[PaystackDataModel]:\n        \"\"\"Used to archive a payment request. A payment request will no longer be fetched on list or returned on verify.\n\n        Args:\n            id_or_code: Payment Request id or code\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n         Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/paymentrequest/archive/{id_or_code}\")\n        return self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            response_data_model_class=alternate_model_class,\n        )\n</code></pre>"},{"location":"reference/payment_requests/#pypaystack2.sub_clients.sync_clients.payment_requests.PaymentRequestClient.archive","title":"<code>archive(id_or_code, alternate_model_class=None)</code>","text":"<p>Used to archive a payment request. A payment request will no longer be fetched on list or returned on verify.</p> <p>Parameters:</p> Name Type Description Default <code>id_or_code</code> <code>int | str</code> <p>Payment Request id or code</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:     A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/payment_requests.py</code> <pre><code>def archive(\n    self,\n    id_or_code: int | str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[None] | Response[PaystackDataModel]:\n    \"\"\"Used to archive a payment request. A payment request will no longer be fetched on list or returned on verify.\n\n    Args:\n        id_or_code: Payment Request id or code\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n     Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/paymentrequest/archive/{id_or_code}\")\n    return self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        response_data_model_class=alternate_model_class,\n    )\n</code></pre>"},{"location":"reference/payment_requests/#pypaystack2.sub_clients.sync_clients.payment_requests.PaymentRequestClient.create","title":"<code>create(customer, amount, due_date=None, description=None, line_items=None, tax=None, currency=None, send_notification=None, draft=None, has_invoice=None, invoice_number=None, split_code=None, alternate_model_class=None)</code>","text":"<p>Create a payment request for a transaction on your integration</p> <p>Parameters:</p> Name Type Description Default <code>customer</code> <code>int | str</code> <p>Customer id or code</p> required <code>amount</code> <code>int</code> <p>Payment request amount. It should be used when line items and tax values aren't specified.</p> required <code>due_date</code> <code>str | None</code> <p>ISO 8601 representation of request due date</p> <code>None</code> <code>description</code> <code>str | None</code> <p>A short description of the payment request</p> <code>None</code> <code>line_items</code> <code>list[LineItem] | None</code> <p>List of line items int the format [{\"name\":\"item 1\", \"amount\":2000, \"quantity\": 1}]</p> <code>None</code> <code>tax</code> <code>list[Tax] | None</code> <p>List of taxes to be charged in the format [{\"name\":\"VAT\", \"amount\":2000}]</p> <code>None</code> <code>currency</code> <code>Currency | None</code> <p>Any value from Currency enum. default <code>Currency.NGN</code></p> <code>None</code> <code>send_notification</code> <code>bool | None</code> <p>Indicates whether Paystack sends an email notification to customer. Defaults to <code>True</code></p> <code>None</code> <code>draft</code> <code>bool | None</code> <p>Indicate if request should be saved as draft. Defaults to <code>False</code> and overrides send_notification</p> <code>None</code> <code>has_invoice</code> <code>bool | None</code> <p>Set to <code>True</code> to create a draft invoice (adds an auto-incrementing invoice number if none is provided) even if there are no line_items or tax passed</p> <code>None</code> <code>invoice_number</code> <code>int | None</code> <p>Numeric value of invoice. Invoice will start from 1 and auto increment from there. This field is to help override whatever value Paystack decides. Auto increment for subsequent invoices continue from this point.</p> <code>None</code> <code>split_code</code> <code>str | None</code> <p>The split code of the transaction split. e.g. SPL_98WF13Eb3w</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[PaymentRequest] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/payment_requests.py</code> <pre><code>def create(\n    self,\n    customer: int | str,\n    amount: int,\n    due_date: str | None = None,\n    description: str | None = None,\n    line_items: list[LineItem] | None = None,\n    tax: list[Tax] | None = None,\n    currency: Currency | None = None,\n    send_notification: bool | None = None,\n    draft: bool | None = None,\n    has_invoice: bool | None = None,\n    invoice_number: int | None = None,\n    split_code: str | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[PaymentRequest] | Response[PaystackDataModel]:\n    \"\"\"Create a payment request for a transaction on your integration\n\n    Args:\n        customer: Customer id or code\n        amount: Payment request amount. It should be used when line items and tax values aren't specified.\n        due_date: ISO 8601 representation of request due date\n        description: A short description of the payment request\n        line_items: List of line items int the format [{\"name\":\"item 1\", \"amount\":2000, \"quantity\": 1}]\n        tax: List of taxes to be charged in the format [{\"name\":\"VAT\", \"amount\":2000}]\n        currency: Any value from Currency enum. default ``Currency.NGN``\n        send_notification: Indicates whether Paystack sends an email notification to customer. Defaults to ``True``\n        draft: Indicate if request should be saved as draft. Defaults to ``False`` and overrides send_notification\n        has_invoice: Set to ``True`` to create a draft invoice (adds an auto-incrementing invoice number\n            if none is provided) even if there are no line_items or tax passed\n        invoice_number: Numeric value of invoice. Invoice will start from 1 and auto increment from there.\n            This field is to help override whatever value Paystack decides. Auto increment for\n            subsequent invoices continue from this point.\n        split_code: The split code of the transaction split. e.g. SPL_98WF13Eb3w\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n    _line_items: list[dict[str, Any]] | None = None\n    _tax: list[dict[str, Any]] | None = None\n    if line_items:\n        _line_items = [item.model_dump() for item in line_items]\n    if tax:\n        _tax = [unit_tax.model_dump() for unit_tax in tax]\n\n    url = self._full_url(\"/paymentrequest\")\n\n    payload = {\"customer\": customer, \"amount\": amount}\n    optional_params = [\n        (\"due_date\", due_date),\n        (\"description\", description),\n        (\"line_items\", _line_items),\n        (\"tax\", _tax),\n        (\"currency\", currency),\n        (\"send_notification\", send_notification),\n        (\"draft\", draft),\n        (\"has_invoice\", has_invoice),\n        (\"invoice_number\", invoice_number),\n        (\"split_code\", split_code),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or PaymentRequest,\n    )\n</code></pre>"},{"location":"reference/payment_requests/#pypaystack2.sub_clients.sync_clients.payment_requests.PaymentRequestClient.finalize","title":"<code>finalize(id_or_code, alternate_model_class=None)</code>","text":"<p>Finalize a draft payment request</p> <p>Parameters:</p> Name Type Description Default <code>id_or_code</code> <code>int | str</code> <p>Payment Request id or code</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[PaymentRequest] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/payment_requests.py</code> <pre><code>def finalize(\n    self,\n    id_or_code: int | str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[PaymentRequest] | Response[PaystackDataModel]:\n    \"\"\"Finalize a draft payment request\n\n    Args:\n        id_or_code: Payment Request id or code\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/paymentrequest/finalize/{id_or_code}\")\n    return self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        response_data_model_class=alternate_model_class or PaymentRequest,\n    )\n</code></pre>"},{"location":"reference/payment_requests/#pypaystack2.sub_clients.sync_clients.payment_requests.PaymentRequestClient.get_payment_request","title":"<code>get_payment_request(id_or_code, alternate_model_class=None)</code>","text":"<p>Get details of a payment request on your integration</p> <p>Parameters:</p> Name Type Description Default <code>id_or_code</code> <code>int | str</code> <p>The payment request ID or code you want to fetch</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[PaymentRequest] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/payment_requests.py</code> <pre><code>def get_payment_request(\n    self,\n    id_or_code: int | str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[PaymentRequest] | Response[PaystackDataModel]:\n    \"\"\"Get details of a payment request on your integration\n\n    Args:\n        id_or_code: The payment request ID or code you want to fetch\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/paymentrequest/{id_or_code}\")\n    return self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or PaymentRequest,\n    )\n</code></pre>"},{"location":"reference/payment_requests/#pypaystack2.sub_clients.sync_clients.payment_requests.PaymentRequestClient.get_payment_requests","title":"<code>get_payment_requests(customer=None, status=None, currency=None, include_archive=False, page=1, pagination=50, start_date=None, end_date=None, alternate_model_class=None)</code>","text":"<p>Fetches the payment requests available on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>customer</code> <code>str | int | None</code> <p>Filter by customer ID</p> <code>None</code> <code>status</code> <code>Status | None</code> <p>Filter by payment request status. Any value from enum of <code>Status</code></p> <code>None</code> <code>currency</code> <code>Currency | None</code> <p>Filter by currency. Any value from enum of <code>Currency</code></p> <code>None</code> <code>include_archive</code> <code>bool</code> <p>Show archived payment requests.</p> <code>False</code> <code>page</code> <code>int</code> <p>Specify exactly what payment request you want to page. If not specified, we use a default value of 1.</p> <code>1</code> <code>pagination</code> <code>int</code> <p>Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50.</p> <code>50</code> <code>start_date</code> <code>str | None</code> <p>A timestamp from which to start listing payment requests e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>end_date</code> <code>str | None</code> <p>A timestamp at which to stop listing payment requests e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[list[PaymentRequest]] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/payment_requests.py</code> <pre><code>def get_payment_requests(\n    self,\n    customer: str | int | None = None,\n    status: Status | None = None,\n    currency: Currency | None = None,\n    include_archive: bool = False,\n    page: int = 1,\n    pagination: int = 50,\n    start_date: str | None = None,\n    end_date: str | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[list[PaymentRequest]] | Response[PaystackDataModel]:\n    \"\"\"Fetches the payment requests available on your integration.\n\n    Args:\n        customer: Filter by customer ID\n        status: Filter by payment request status. Any value from enum of ``Status``\n        currency: Filter by currency. Any value from enum of ``Currency``\n        include_archive: Show archived payment requests.\n        page: Specify exactly what payment request you want to page. If not specified, we use a default value of 1.\n        pagination: Specifies how many records you want to retrieve per page. If not specified,\n            we use a default value of 50.\n        start_date: A timestamp from which to start listing payment requests\n            e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        end_date: A timestamp at which to stop listing payment requests e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/paymentrequest?perPage={pagination}\")\n    query_params = [\n        (\"customer\", customer),\n        (\"status\", status),\n        (\"currency\", currency),\n        (\"include_archive\", include_archive),\n        (\"page\", page),\n        (\"start_date\", start_date),\n        (\"end_date\", end_date),\n    ]\n    url = append_query_params(query_params, url)\n    return self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or PaymentRequest,\n    )\n</code></pre>"},{"location":"reference/payment_requests/#pypaystack2.sub_clients.sync_clients.payment_requests.PaymentRequestClient.get_total","title":"<code>get_total(alternate_model_class=None)</code>","text":"<p>Get payment requests metric</p> <p>Parameters:</p> Name Type Description Default <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[PaymentRequestStat] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/payment_requests.py</code> <pre><code>def get_total(\n    self,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[PaymentRequestStat] | Response[PaystackDataModel]:\n    \"\"\"Get payment requests metric\n\n    Args:\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(\"/paymentrequest/totals\")\n    return self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or PaymentRequestStat,\n    )\n</code></pre>"},{"location":"reference/payment_requests/#pypaystack2.sub_clients.sync_clients.payment_requests.PaymentRequestClient.send_notification","title":"<code>send_notification(id_or_code, alternate_model_class=None)</code>","text":"<p>Send notification of a payment request to your customers</p> <p>Parameters:</p> Name Type Description Default <code>id_or_code</code> <code>int | str</code> <p>Payment Request id or code</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[None] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/payment_requests.py</code> <pre><code>def send_notification(\n    self,\n    id_or_code: int | str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[None] | Response[PaystackDataModel]:\n    \"\"\"Send notification of a payment request to your customers\n\n    Args:\n        id_or_code: Payment Request id or code\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/paymentrequest/notify/{id_or_code}\")\n    return self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        response_data_model_class=alternate_model_class,\n    )\n</code></pre>"},{"location":"reference/payment_requests/#pypaystack2.sub_clients.sync_clients.payment_requests.PaymentRequestClient.update","title":"<code>update(id_or_code, customer, amount, due_date=None, description=None, line_items=None, tax=None, currency=None, send_notification=None, draft=None, invoice_number=None, split_code=None, alternate_model_class=None)</code>","text":"<p>Update the payment request details on your integration</p> <p>Parameters:</p> Name Type Description Default <code>id_or_code</code> <code>int | str</code> <p>Payment Request id or code</p> required <code>customer</code> <code>int | str</code> <p>Customer id or code</p> required <code>amount</code> <code>int</code> <p>Payment request amount. Only useful if line items and tax values are ignored. method will throw a friendly warning in the response if neither is available.</p> required <code>due_date</code> <code>str | None</code> <p>ISO 8601 representation of request due date</p> <code>None</code> <code>description</code> <code>str | None</code> <p>A short description of the payment request</p> <code>None</code> <code>line_items</code> <code>list[LineItem] | None</code> <p>List of line items in the format [{\"name\":\"item 1\", \"amount\":2000}]</p> <code>None</code> <code>tax</code> <code>list[Tax] | None</code> <p>List of taxes to be charged in the format [{\"name\":\"VAT\", \"amount\":2000}]</p> <code>None</code> <code>currency</code> <code>Currency | None</code> <p>Specify the currency of the Payment Request id or code. Any value from the <code>Currency</code> enum</p> <code>None</code> <code>send_notification</code> <code>bool | None</code> <p>Indicates whether Paystack sends an email notification to customer. Defaults to <code>True</code></p> <code>None</code> <code>draft</code> <code>bool | None</code> <p>Indicate if request should be saved as draft. Defaults to false and overrides send_notification</p> <code>None</code> <code>invoice_number</code> <code>int | None</code> <p>Numeric value of invoice. Invoice will start from 1 and auto increment from there. This field is to help override whatever value Paystack decides. Auto increment for subsequent invoices continue from this point.</p> <code>None</code> <code>split_code</code> <code>str | None</code> <p>The split code of the transaction split. e.g. SPL_98WF13Eb3w</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[PaymentRequest] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/payment_requests.py</code> <pre><code>def update(\n    self,\n    id_or_code: int | str,\n    customer: int | str,\n    amount: int,\n    due_date: str | None = None,\n    description: str | None = None,\n    line_items: list[LineItem] | None = None,\n    tax: list[Tax] | None = None,\n    currency: Currency | None = None,\n    send_notification: bool | None = None,\n    draft: bool | None = None,\n    invoice_number: int | None = None,\n    split_code: str | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[PaymentRequest] | Response[PaystackDataModel]:\n    \"\"\"Update the payment request details on your integration\n\n    Args:\n        id_or_code: Payment Request id or code\n        customer: Customer id or code\n        amount: Payment request amount. Only useful if line items and tax values are ignored.\n            method will throw a friendly warning in the response if neither is available.\n        due_date: ISO 8601 representation of request due date\n        description: A short description of the payment request\n        line_items: List of line items in the format [{\"name\":\"item 1\", \"amount\":2000}]\n        tax: List of taxes to be charged in the format [{\"name\":\"VAT\", \"amount\":2000}]\n        currency: Specify the currency of the Payment Request id or code. Any value from the ``Currency`` enum\n        send_notification: Indicates whether Paystack sends an email notification to customer. Defaults to ``True``\n        draft: Indicate if request should be saved as draft. Defaults to false and overrides send_notification\n        invoice_number: Numeric value of invoice. Invoice will start from 1 and auto increment from there.\n            This field is to help override whatever value Paystack decides. Auto increment for\n            subsequent invoices continue from this point.\n        split_code: The split code of the transaction split. e.g. SPL_98WF13Eb3w\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    _line_items: list[dict[str, Any]] | None = None\n    _tax: list[dict[str, Any]] | None = None\n\n    if line_items:\n        _line_items = [item.model_dump() for item in line_items]\n    if tax:\n        _tax = [unit_tax.model_dump() for unit_tax in tax]\n\n    url = self._full_url(f\"/paymentrequest/{id_or_code}\")\n    payload = {\n        \"customer\": customer,\n        \"amount\": amount,\n    }\n    optional_params = [\n        (\"due_date\", due_date),\n        (\"description\", description),\n        (\"line_items\", _line_items),\n        (\"tax\", _tax),\n        (\"currency\", currency),\n        (\"send_notification\", send_notification),\n        (\"draft\", draft),\n        (\"invoice_number\", invoice_number),\n        (\"split_code\", split_code),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return self._handle_request(  # type: ignore\n        HTTPMethod.PUT,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or PaymentRequest,\n    )\n</code></pre>"},{"location":"reference/payment_requests/#pypaystack2.sub_clients.sync_clients.payment_requests.PaymentRequestClient.verify","title":"<code>verify(id_or_code, alternate_model_class=None)</code>","text":"<p>Verify details of a payment request on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>id_or_code</code> <code>int | str</code> <p>Payment Request id or code</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[PaymentRequest] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/payment_requests.py</code> <pre><code>def verify(\n    self,\n    id_or_code: int | str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[PaymentRequest] | Response[PaystackDataModel]:\n    \"\"\"Verify details of a payment request on your integration.\n\n    Args:\n        id_or_code: Payment Request id or code\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/paymentrequest/verify/{id_or_code}\")\n    return self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or PaymentRequest,\n    )\n</code></pre>"},{"location":"reference/payment_requests/#pypaystack2.sub_clients.async_clients.payment_requests.AsyncPaymentRequestClient","title":"<code>AsyncPaymentRequestClient</code>","text":"<p>               Bases: <code>BaseAsyncAPIClient</code></p> <p>Provides a wrapper for paystack Payment Requests API</p> <p>The Payment Requests API allows you to manage requests for payment of goods and services. https://paystack.com/docs/api/payment-request/</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/payment_requests.py</code> <pre><code>class AsyncPaymentRequestClient(BaseAsyncAPIClient):\n    \"\"\"Provides a wrapper for paystack Payment Requests API\n\n    The Payment Requests API allows you to manage requests for payment of goods and services.\n    https://paystack.com/docs/api/payment-request/\n    \"\"\"\n\n    async def create(\n        self,\n        customer: int | str,\n        amount: int,\n        due_date: str | None = None,\n        description: str | None = None,\n        line_items: list[LineItem] | None = None,\n        tax: list[Tax] | None = None,\n        currency: Currency | None = None,\n        send_notification: bool | None = None,\n        draft: bool | None = None,\n        has_invoice: bool | None = None,\n        invoice_number: int | None = None,\n        split_code: str | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[PaymentRequest] | Response[PaystackDataModel]:\n        \"\"\"Create a payment request for a transaction on your integration\n\n        Args:\n            customer: Customer id or code\n            amount: Payment request amount. It should be used when line items and tax values aren't specified.\n            due_date: ISO 8601 representation of request due date\n            description: A short description of the payment request\n            line_items: List of line items int the format [{\"name\":\"item 1\", \"amount\":2000, \"quantity\": 1}]\n            tax: List of taxes to be charged in the format [{\"name\":\"VAT\", \"amount\":2000}]\n            currency: Any value from Currency enum. default ``Currency.NGN``\n            send_notification: Indicates whether Paystack sends an email notification to customer. Defaults to ``True``\n            draft: Indicate if request should be saved as draft. Defaults to ``False`` and overrides send_notification\n            has_invoice: Set to ``True`` to create a draft invoice (adds an auto incrementing invoice number\n                if none is provided) even if there are no line_items or tax passed\n            invoice_number: Numeric value of invoice. Invoice will start from 1 and auto increment from there.\n                This field is to help override whatever value Paystack decides. Auto increment for\n                subsequent invoices continue from this point.\n            split_code: The split code of the transaction split. e.g. SPL_98WF13Eb3w\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n        _line_items: list[dict[str, Any]] | None = None\n        _tax: list[dict[str, Any]] | None = None\n        if line_items:\n            _line_items = [item.model_dump() for item in line_items]\n        if tax:\n            _tax = [unit_tax.model_dump() for unit_tax in tax]\n\n        url = self._full_url(\"/paymentrequest\")\n\n        payload = {\"customer\": customer, \"amount\": amount}\n        optional_params = [\n            (\"due_date\", due_date),\n            (\"description\", description),\n            (\"line_items\", _line_items),\n            (\"tax\", _tax),\n            (\"currency\", currency),\n            (\"send_notification\", send_notification),\n            (\"draft\", draft),\n            (\"has_invoice\", has_invoice),\n            (\"invoice_number\", invoice_number),\n            (\"split_code\", split_code),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or PaymentRequest,\n        )\n\n    async def get_payment_requests(\n        self,\n        customer: str | int | None = None,\n        status: Status | None = None,\n        currency: Currency | None = None,\n        include_archive: bool = False,\n        page: int = 1,\n        pagination: int = 50,\n        start_date: str | None = None,\n        end_date: str | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[list[PaymentRequest]] | Response[PaystackDataModel]:\n        \"\"\"Fetches the payment requests available on your integration.\n\n        Args:\n            customer: Filter by customer ID\n            status: Filter by payment request status. Any value from enum of ``Status``\n            currency: Filter by currency. Any value from enum of ``Currency``\n            include_archive: Show archived payment requests.\n            page: Specify exactly what payment request you want to page. If not specify we use a default value of 1.\n            pagination: Specifies how many records you want to retrieve per page. If not specified\n                we use a default value of 50.\n            start_date: A timestamp from which to start listing payment request\n                e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            end_date: A timestamp at which to stop listing payment request e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/paymentrequest?perPage={pagination}\")\n        query_params = [\n            (\"customer\", customer),\n            (\"status\", status),\n            (\"currency\", currency),\n            (\"include_archive\", include_archive),\n            (\"page\", page),\n            (\"start_date\", start_date),\n            (\"end_date\", end_date),\n        ]\n        url = append_query_params(query_params, url)\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or PaymentRequest,\n        )\n\n    async def get_payment_request(\n        self,\n        id_or_code: int | str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[PaymentRequest] | Response[PaystackDataModel]:\n        \"\"\"Get details of a payment request on your integration.\n\n        Args:\n            id_or_code: Payment Request id or code\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/paymentrequest/{id_or_code}\")\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or PaymentRequest,\n        )\n\n    async def verify(\n        self,\n        id_or_code: int | str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[PaymentRequest] | Response[PaystackDataModel]:\n        \"\"\"Verify details of a payment request on your integration.\n\n        Args:\n            id_or_code: Payment Request id or code\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/paymentrequest/verify/{id_or_code}\")\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or PaymentRequest,\n        )\n\n    async def send_notification(\n        self,\n        id_or_code: int | str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[None] | Response[PaystackDataModel]:\n        \"\"\"Send notification of a payment request to your customers\n\n        Args:\n            id_or_code: Payment Request id or code\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/paymentrequest/notify/{id_or_code}\")\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            response_data_model_class=alternate_model_class,\n        )\n\n    async def get_total(\n        self,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[PaymentRequestStat] | Response[PaystackDataModel]:\n        \"\"\"Get payment requests metric\n\n        Args:\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(\"/paymentrequest/totals\")\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or PaymentRequestStat,\n        )\n\n    async def finalize(\n        self,\n        id_or_code: int | str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[PaymentRequest] | Response[PaystackDataModel]:\n        \"\"\"Finalize a draft payment request\n\n        Args:\n            id_or_code: Payment Request id or code\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/paymentrequest/finalize/{id_or_code}\")\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            response_data_model_class=alternate_model_class or PaymentRequest,\n        )\n\n    async def update(\n        self,\n        id_or_code: int | str,\n        customer: int | str,\n        amount: int,\n        due_date: str | None = None,\n        description: str | None = None,\n        line_items: list[LineItem] | None = None,\n        tax: list[Tax] | None = None,\n        currency: Currency | None = None,\n        send_notification: bool | None = None,\n        draft: bool | None = None,\n        invoice_number: int | None = None,\n        split_code: str | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[PaymentRequest] | Response[PaystackDataModel]:\n        \"\"\"Update a payment request details on your integration\n\n        Args:\n            id_or_code: Payment Request id or code\n            customer: Customer id or code\n            amount: Payment request amount. Only useful if line items and tax values are ignored.\n                method will throw a friendly warning in the response if neither is available.\n            due_date: ISO 8601 representation of request due date\n            description: A short description of the payment request\n            line_items: List of line items in the format [{\"name\":\"item 1\", \"amount\":2000}]\n            tax: List of taxes to be charged in the format [{\"name\":\"VAT\", \"amount\":2000}]\n            currency: Specify the currency of the payment request. Any value from the ``Currency`` enum\n            send_notification: Indicates whether Paystack sends an email notification to customer. Defaults to ``True``\n            draft: Indicate if request should be saved as draft. Defaults to false and overrides send_notification\n            invoice_number: Numeric value of invoice. Invoice will start from 1 and auto increment from there.\n                This field is to help override whatever value Paystack decides. Auto increment for\n                subsequent invoices continue from this point.\n            split_code: The split code of the transaction split. e.g. SPL_98WF13Eb3w\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n        _line_items: list[dict[str, Any]] | None = None\n        _tax: list[dict[str, Any]] | None = None\n\n        if line_items:\n            _line_items = [item.model_dump() for item in line_items]\n        if tax:\n            _tax = [unit_tax.model_dump() for unit_tax in tax]\n\n        url = self._full_url(f\"/paymentrequest/{id_or_code}\")\n        payload = {\n            \"customer\": customer,\n            \"amount\": amount,\n        }\n        optional_params = [\n            (\"due_date\", due_date),\n            (\"description\", description),\n            (\"line_items\", _line_items),\n            (\"tax\", _tax),\n            (\"currency\", currency),\n            (\"send_notification\", send_notification),\n            (\"draft\", draft),\n            (\"invoice_number\", invoice_number),\n            (\"split_code\", split_code),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.PUT,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or PaymentRequest,\n        )\n\n    async def archive(\n        self,\n        id_or_code: int | str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[None] | Response[PaystackDataModel]:\n        \"\"\"Used to archive a payment request. A payment request will no longer be fetched on list or returned on verify.\n\n        Args:\n            id_or_code: Payment Request id or code\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n         Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/paymentrequest/archive/{id_or_code}\")\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            response_data_model_class=alternate_model_class,\n        )\n</code></pre>"},{"location":"reference/payment_requests/#pypaystack2.sub_clients.async_clients.payment_requests.AsyncPaymentRequestClient.archive","title":"<code>archive(id_or_code, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Used to archive a payment request. A payment request will no longer be fetched on list or returned on verify.</p> <p>Parameters:</p> Name Type Description Default <code>id_or_code</code> <code>int | str</code> <p>Payment Request id or code</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:     A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/payment_requests.py</code> <pre><code>async def archive(\n    self,\n    id_or_code: int | str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[None] | Response[PaystackDataModel]:\n    \"\"\"Used to archive a payment request. A payment request will no longer be fetched on list or returned on verify.\n\n    Args:\n        id_or_code: Payment Request id or code\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n     Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/paymentrequest/archive/{id_or_code}\")\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        response_data_model_class=alternate_model_class,\n    )\n</code></pre>"},{"location":"reference/payment_requests/#pypaystack2.sub_clients.async_clients.payment_requests.AsyncPaymentRequestClient.create","title":"<code>create(customer, amount, due_date=None, description=None, line_items=None, tax=None, currency=None, send_notification=None, draft=None, has_invoice=None, invoice_number=None, split_code=None, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Create a payment request for a transaction on your integration</p> <p>Parameters:</p> Name Type Description Default <code>customer</code> <code>int | str</code> <p>Customer id or code</p> required <code>amount</code> <code>int</code> <p>Payment request amount. It should be used when line items and tax values aren't specified.</p> required <code>due_date</code> <code>str | None</code> <p>ISO 8601 representation of request due date</p> <code>None</code> <code>description</code> <code>str | None</code> <p>A short description of the payment request</p> <code>None</code> <code>line_items</code> <code>list[LineItem] | None</code> <p>List of line items int the format [{\"name\":\"item 1\", \"amount\":2000, \"quantity\": 1}]</p> <code>None</code> <code>tax</code> <code>list[Tax] | None</code> <p>List of taxes to be charged in the format [{\"name\":\"VAT\", \"amount\":2000}]</p> <code>None</code> <code>currency</code> <code>Currency | None</code> <p>Any value from Currency enum. default <code>Currency.NGN</code></p> <code>None</code> <code>send_notification</code> <code>bool | None</code> <p>Indicates whether Paystack sends an email notification to customer. Defaults to <code>True</code></p> <code>None</code> <code>draft</code> <code>bool | None</code> <p>Indicate if request should be saved as draft. Defaults to <code>False</code> and overrides send_notification</p> <code>None</code> <code>has_invoice</code> <code>bool | None</code> <p>Set to <code>True</code> to create a draft invoice (adds an auto incrementing invoice number if none is provided) even if there are no line_items or tax passed</p> <code>None</code> <code>invoice_number</code> <code>int | None</code> <p>Numeric value of invoice. Invoice will start from 1 and auto increment from there. This field is to help override whatever value Paystack decides. Auto increment for subsequent invoices continue from this point.</p> <code>None</code> <code>split_code</code> <code>str | None</code> <p>The split code of the transaction split. e.g. SPL_98WF13Eb3w</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[PaymentRequest] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/payment_requests.py</code> <pre><code>async def create(\n    self,\n    customer: int | str,\n    amount: int,\n    due_date: str | None = None,\n    description: str | None = None,\n    line_items: list[LineItem] | None = None,\n    tax: list[Tax] | None = None,\n    currency: Currency | None = None,\n    send_notification: bool | None = None,\n    draft: bool | None = None,\n    has_invoice: bool | None = None,\n    invoice_number: int | None = None,\n    split_code: str | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[PaymentRequest] | Response[PaystackDataModel]:\n    \"\"\"Create a payment request for a transaction on your integration\n\n    Args:\n        customer: Customer id or code\n        amount: Payment request amount. It should be used when line items and tax values aren't specified.\n        due_date: ISO 8601 representation of request due date\n        description: A short description of the payment request\n        line_items: List of line items int the format [{\"name\":\"item 1\", \"amount\":2000, \"quantity\": 1}]\n        tax: List of taxes to be charged in the format [{\"name\":\"VAT\", \"amount\":2000}]\n        currency: Any value from Currency enum. default ``Currency.NGN``\n        send_notification: Indicates whether Paystack sends an email notification to customer. Defaults to ``True``\n        draft: Indicate if request should be saved as draft. Defaults to ``False`` and overrides send_notification\n        has_invoice: Set to ``True`` to create a draft invoice (adds an auto incrementing invoice number\n            if none is provided) even if there are no line_items or tax passed\n        invoice_number: Numeric value of invoice. Invoice will start from 1 and auto increment from there.\n            This field is to help override whatever value Paystack decides. Auto increment for\n            subsequent invoices continue from this point.\n        split_code: The split code of the transaction split. e.g. SPL_98WF13Eb3w\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n    _line_items: list[dict[str, Any]] | None = None\n    _tax: list[dict[str, Any]] | None = None\n    if line_items:\n        _line_items = [item.model_dump() for item in line_items]\n    if tax:\n        _tax = [unit_tax.model_dump() for unit_tax in tax]\n\n    url = self._full_url(\"/paymentrequest\")\n\n    payload = {\"customer\": customer, \"amount\": amount}\n    optional_params = [\n        (\"due_date\", due_date),\n        (\"description\", description),\n        (\"line_items\", _line_items),\n        (\"tax\", _tax),\n        (\"currency\", currency),\n        (\"send_notification\", send_notification),\n        (\"draft\", draft),\n        (\"has_invoice\", has_invoice),\n        (\"invoice_number\", invoice_number),\n        (\"split_code\", split_code),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or PaymentRequest,\n    )\n</code></pre>"},{"location":"reference/payment_requests/#pypaystack2.sub_clients.async_clients.payment_requests.AsyncPaymentRequestClient.finalize","title":"<code>finalize(id_or_code, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Finalize a draft payment request</p> <p>Parameters:</p> Name Type Description Default <code>id_or_code</code> <code>int | str</code> <p>Payment Request id or code</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[PaymentRequest] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/payment_requests.py</code> <pre><code>async def finalize(\n    self,\n    id_or_code: int | str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[PaymentRequest] | Response[PaystackDataModel]:\n    \"\"\"Finalize a draft payment request\n\n    Args:\n        id_or_code: Payment Request id or code\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/paymentrequest/finalize/{id_or_code}\")\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        response_data_model_class=alternate_model_class or PaymentRequest,\n    )\n</code></pre>"},{"location":"reference/payment_requests/#pypaystack2.sub_clients.async_clients.payment_requests.AsyncPaymentRequestClient.get_payment_request","title":"<code>get_payment_request(id_or_code, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Get details of a payment request on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>id_or_code</code> <code>int | str</code> <p>Payment Request id or code</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[PaymentRequest] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/payment_requests.py</code> <pre><code>async def get_payment_request(\n    self,\n    id_or_code: int | str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[PaymentRequest] | Response[PaystackDataModel]:\n    \"\"\"Get details of a payment request on your integration.\n\n    Args:\n        id_or_code: Payment Request id or code\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/paymentrequest/{id_or_code}\")\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or PaymentRequest,\n    )\n</code></pre>"},{"location":"reference/payment_requests/#pypaystack2.sub_clients.async_clients.payment_requests.AsyncPaymentRequestClient.get_payment_requests","title":"<code>get_payment_requests(customer=None, status=None, currency=None, include_archive=False, page=1, pagination=50, start_date=None, end_date=None, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Fetches the payment requests available on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>customer</code> <code>str | int | None</code> <p>Filter by customer ID</p> <code>None</code> <code>status</code> <code>Status | None</code> <p>Filter by payment request status. Any value from enum of <code>Status</code></p> <code>None</code> <code>currency</code> <code>Currency | None</code> <p>Filter by currency. Any value from enum of <code>Currency</code></p> <code>None</code> <code>include_archive</code> <code>bool</code> <p>Show archived payment requests.</p> <code>False</code> <code>page</code> <code>int</code> <p>Specify exactly what payment request you want to page. If not specify we use a default value of 1.</p> <code>1</code> <code>pagination</code> <code>int</code> <p>Specifies how many records you want to retrieve per page. If not specified we use a default value of 50.</p> <code>50</code> <code>start_date</code> <code>str | None</code> <p>A timestamp from which to start listing payment request e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>end_date</code> <code>str | None</code> <p>A timestamp at which to stop listing payment request e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[list[PaymentRequest]] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/payment_requests.py</code> <pre><code>async def get_payment_requests(\n    self,\n    customer: str | int | None = None,\n    status: Status | None = None,\n    currency: Currency | None = None,\n    include_archive: bool = False,\n    page: int = 1,\n    pagination: int = 50,\n    start_date: str | None = None,\n    end_date: str | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[list[PaymentRequest]] | Response[PaystackDataModel]:\n    \"\"\"Fetches the payment requests available on your integration.\n\n    Args:\n        customer: Filter by customer ID\n        status: Filter by payment request status. Any value from enum of ``Status``\n        currency: Filter by currency. Any value from enum of ``Currency``\n        include_archive: Show archived payment requests.\n        page: Specify exactly what payment request you want to page. If not specify we use a default value of 1.\n        pagination: Specifies how many records you want to retrieve per page. If not specified\n            we use a default value of 50.\n        start_date: A timestamp from which to start listing payment request\n            e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        end_date: A timestamp at which to stop listing payment request e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/paymentrequest?perPage={pagination}\")\n    query_params = [\n        (\"customer\", customer),\n        (\"status\", status),\n        (\"currency\", currency),\n        (\"include_archive\", include_archive),\n        (\"page\", page),\n        (\"start_date\", start_date),\n        (\"end_date\", end_date),\n    ]\n    url = append_query_params(query_params, url)\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or PaymentRequest,\n    )\n</code></pre>"},{"location":"reference/payment_requests/#pypaystack2.sub_clients.async_clients.payment_requests.AsyncPaymentRequestClient.get_total","title":"<code>get_total(alternate_model_class=None)</code>  <code>async</code>","text":"<p>Get payment requests metric</p> <p>Parameters:</p> Name Type Description Default <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[PaymentRequestStat] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/payment_requests.py</code> <pre><code>async def get_total(\n    self,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[PaymentRequestStat] | Response[PaystackDataModel]:\n    \"\"\"Get payment requests metric\n\n    Args:\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(\"/paymentrequest/totals\")\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or PaymentRequestStat,\n    )\n</code></pre>"},{"location":"reference/payment_requests/#pypaystack2.sub_clients.async_clients.payment_requests.AsyncPaymentRequestClient.send_notification","title":"<code>send_notification(id_or_code, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Send notification of a payment request to your customers</p> <p>Parameters:</p> Name Type Description Default <code>id_or_code</code> <code>int | str</code> <p>Payment Request id or code</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[None] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/payment_requests.py</code> <pre><code>async def send_notification(\n    self,\n    id_or_code: int | str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[None] | Response[PaystackDataModel]:\n    \"\"\"Send notification of a payment request to your customers\n\n    Args:\n        id_or_code: Payment Request id or code\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/paymentrequest/notify/{id_or_code}\")\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        response_data_model_class=alternate_model_class,\n    )\n</code></pre>"},{"location":"reference/payment_requests/#pypaystack2.sub_clients.async_clients.payment_requests.AsyncPaymentRequestClient.update","title":"<code>update(id_or_code, customer, amount, due_date=None, description=None, line_items=None, tax=None, currency=None, send_notification=None, draft=None, invoice_number=None, split_code=None, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Update a payment request details on your integration</p> <p>Parameters:</p> Name Type Description Default <code>id_or_code</code> <code>int | str</code> <p>Payment Request id or code</p> required <code>customer</code> <code>int | str</code> <p>Customer id or code</p> required <code>amount</code> <code>int</code> <p>Payment request amount. Only useful if line items and tax values are ignored. method will throw a friendly warning in the response if neither is available.</p> required <code>due_date</code> <code>str | None</code> <p>ISO 8601 representation of request due date</p> <code>None</code> <code>description</code> <code>str | None</code> <p>A short description of the payment request</p> <code>None</code> <code>line_items</code> <code>list[LineItem] | None</code> <p>List of line items in the format [{\"name\":\"item 1\", \"amount\":2000}]</p> <code>None</code> <code>tax</code> <code>list[Tax] | None</code> <p>List of taxes to be charged in the format [{\"name\":\"VAT\", \"amount\":2000}]</p> <code>None</code> <code>currency</code> <code>Currency | None</code> <p>Specify the currency of the payment request. Any value from the <code>Currency</code> enum</p> <code>None</code> <code>send_notification</code> <code>bool | None</code> <p>Indicates whether Paystack sends an email notification to customer. Defaults to <code>True</code></p> <code>None</code> <code>draft</code> <code>bool | None</code> <p>Indicate if request should be saved as draft. Defaults to false and overrides send_notification</p> <code>None</code> <code>invoice_number</code> <code>int | None</code> <p>Numeric value of invoice. Invoice will start from 1 and auto increment from there. This field is to help override whatever value Paystack decides. Auto increment for subsequent invoices continue from this point.</p> <code>None</code> <code>split_code</code> <code>str | None</code> <p>The split code of the transaction split. e.g. SPL_98WF13Eb3w</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[PaymentRequest] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/payment_requests.py</code> <pre><code>async def update(\n    self,\n    id_or_code: int | str,\n    customer: int | str,\n    amount: int,\n    due_date: str | None = None,\n    description: str | None = None,\n    line_items: list[LineItem] | None = None,\n    tax: list[Tax] | None = None,\n    currency: Currency | None = None,\n    send_notification: bool | None = None,\n    draft: bool | None = None,\n    invoice_number: int | None = None,\n    split_code: str | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[PaymentRequest] | Response[PaystackDataModel]:\n    \"\"\"Update a payment request details on your integration\n\n    Args:\n        id_or_code: Payment Request id or code\n        customer: Customer id or code\n        amount: Payment request amount. Only useful if line items and tax values are ignored.\n            method will throw a friendly warning in the response if neither is available.\n        due_date: ISO 8601 representation of request due date\n        description: A short description of the payment request\n        line_items: List of line items in the format [{\"name\":\"item 1\", \"amount\":2000}]\n        tax: List of taxes to be charged in the format [{\"name\":\"VAT\", \"amount\":2000}]\n        currency: Specify the currency of the payment request. Any value from the ``Currency`` enum\n        send_notification: Indicates whether Paystack sends an email notification to customer. Defaults to ``True``\n        draft: Indicate if request should be saved as draft. Defaults to false and overrides send_notification\n        invoice_number: Numeric value of invoice. Invoice will start from 1 and auto increment from there.\n            This field is to help override whatever value Paystack decides. Auto increment for\n            subsequent invoices continue from this point.\n        split_code: The split code of the transaction split. e.g. SPL_98WF13Eb3w\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n    _line_items: list[dict[str, Any]] | None = None\n    _tax: list[dict[str, Any]] | None = None\n\n    if line_items:\n        _line_items = [item.model_dump() for item in line_items]\n    if tax:\n        _tax = [unit_tax.model_dump() for unit_tax in tax]\n\n    url = self._full_url(f\"/paymentrequest/{id_or_code}\")\n    payload = {\n        \"customer\": customer,\n        \"amount\": amount,\n    }\n    optional_params = [\n        (\"due_date\", due_date),\n        (\"description\", description),\n        (\"line_items\", _line_items),\n        (\"tax\", _tax),\n        (\"currency\", currency),\n        (\"send_notification\", send_notification),\n        (\"draft\", draft),\n        (\"invoice_number\", invoice_number),\n        (\"split_code\", split_code),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.PUT,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or PaymentRequest,\n    )\n</code></pre>"},{"location":"reference/payment_requests/#pypaystack2.sub_clients.async_clients.payment_requests.AsyncPaymentRequestClient.verify","title":"<code>verify(id_or_code, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Verify details of a payment request on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>id_or_code</code> <code>int | str</code> <p>Payment Request id or code</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[PaymentRequest] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/payment_requests.py</code> <pre><code>async def verify(\n    self,\n    id_or_code: int | str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[PaymentRequest] | Response[PaystackDataModel]:\n    \"\"\"Verify details of a payment request on your integration.\n\n    Args:\n        id_or_code: Payment Request id or code\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/paymentrequest/verify/{id_or_code}\")\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or PaymentRequest,\n    )\n</code></pre>"},{"location":"reference/plans/","title":"Plans","text":""},{"location":"reference/plans/#pypaystack2.sub_clients.sync_clients.plans.PlanClient","title":"<code>PlanClient</code>","text":"<p>               Bases: <code>BaseAPIClient</code></p> <p>Provides a wrapper for paystack Plans API</p> <p>The Plans API allows you to create and manage installment payment options on your integration. https://paystack.com/docs/api/plan/</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/plans.py</code> <pre><code>class PlanClient(BaseAPIClient):\n    \"\"\"Provides a wrapper for paystack Plans API\n\n    The Plans API allows you to create and manage installment payment options on your integration.\n    https://paystack.com/docs/api/plan/\n    \"\"\"\n\n    def create(\n        self,\n        name: str,\n        amount: int,\n        interval: Interval,\n        description: str | None = None,\n        currency: Currency | None = None,\n        invoice_limit: int | None = None,\n        send_invoices: bool = False,\n        send_sms: bool = False,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[Plan] | Response[PaystackDataModel]:\n        \"\"\"Create a plan on your integration\n\n        Args:\n            name: Name of plan\n            amount: Amount should be in kobo if currency is ``Currency.NGN``, pesewas,\n                if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR``\n            interval: Any value from the ``Interval`` enum.\n            description: A description for this plan\n            currency: Currency in which amount is set. Any of the value from\n                the ``Currency`` enum\n            invoice_limit: Number of invoices to raise during subscription to this plan.\n                Can be overridden by specifying an ``invoice_limit`` while subscribing\n            send_invoices: Set to ``False`` if you don't want invoices to be sent to your customers\n            send_sms: Set to ``False`` if you don't want text messages to be sent to your customers\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(\"/plan/\")\n\n        payload = {\n            \"name\": name,\n            \"amount\": amount,\n            \"interval\": interval,\n        }\n        optional_params = [\n            (\"send_invoices\", send_invoices),\n            (\"send_sms\", send_sms),\n            (\"description\", description),\n            (\"currency\", currency),\n            (\"invoice_limit\", invoice_limit),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or Plan,\n        )\n\n    def get_plans(\n        self,\n        page: int = 1,\n        pagination: int = 50,\n        status: Status | None = None,\n        interval: Interval | None = None,\n        amount: int | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[list[Plan]] | Response[PaystackDataModel]:\n        \"\"\"Fetch plans available on your integration.\n\n        Args:\n            page: Specifies exactly what page you want to retrieve.\n                If not specified, we use a default value of 1.\n            pagination: Specifies how many records you want to retrieve per page.\n                If not specified, we use a default value of 50.\n            status: Filter list by plans with specified status\n            interval: Filter list by plans with specified interval\n            amount: Filter list by plans with specified amount ( kobo if currency\n                is ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``,\n                and cents, if currency is ``Currency.ZAR``)\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/plan/?perPage={pagination}\")\n        query_params = [\n            (\"page\", page),\n            (\"status\", status),\n            (\"interval\", interval),\n            (\"amount\", amount),\n        ]\n        url = append_query_params(query_params, url)\n        return self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or Plan,\n        )\n\n    def get_plan(\n        self,\n        id_or_code: int | str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[Plan] | Response[PaystackDataModel]:\n        \"\"\"Get details of a plan on your integration.\n\n        Args:\n            id_or_code: The plan ``ID`` or ``code`` you want to fetch\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._full_url(\"/plan/{}/\".format(id_or_code))\n        return self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or Plan,\n        )\n\n    def update(\n        self,\n        id_or_code: int | str,\n        name: str | None = None,\n        amount: int | None = None,\n        interval: Interval | None = None,\n        description: str | None = None,\n        currency: Currency | None = None,\n        invoice_limit: int | None = None,\n        send_invoices: bool = False,\n        send_sms: bool = False,\n        update_existing_subscriptions: bool = True,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[None] | Response[PaystackDataModel]:\n        \"\"\"update a plan details on your integration\n\n        Args:\n            id_or_code: Plan's ID or code\n            name: Name of plan\n            amount: Amount should be in kobo if currency is\n                ``Currency.NGN`` and pesewas for ``Currency.GHS``\n            interval: Any value from the ``Interval`` enum.\n            description: A description for this plan.\n            currency: Any value from the ``Currency`` enum.\n            invoice_limit: Number of invoices to raise during subscription to this plan.\n                Can be overridden by specifying an ``invoice_limit`` while subscribing.\n            send_invoices: Set to ``False`` if you don't want invoices\n                to be sent to your customers\n            send_sms: Set to ``False`` if you don't want text messages to\n                be sent to your customers\n            update_existing_subscriptions: Flag to determine whether to update existing subscriptions based on the new\n                changes made to the plan.\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/plan/{id_or_code}/\")\n        payload = {\n            \"name\": name,\n            \"amount\": amount,\n            \"interval\": interval,\n        }\n\n        optional_params = [\n            (\"send_invoices\", send_invoices),\n            (\"send_sms\", send_sms),\n            (\"description\", description),\n            (\"currency\", currency),\n            (\"invoice_limit\", invoice_limit),\n            (\"update_existing_subscriptions\", update_existing_subscriptions),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return self._handle_request(  # type: ignore\n            HTTPMethod.PUT,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class,\n        )\n</code></pre>"},{"location":"reference/plans/#pypaystack2.sub_clients.sync_clients.plans.PlanClient.create","title":"<code>create(name, amount, interval, description=None, currency=None, invoice_limit=None, send_invoices=False, send_sms=False, alternate_model_class=None)</code>","text":"<p>Create a plan on your integration</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of plan</p> required <code>amount</code> <code>int</code> <p>Amount should be in kobo if currency is <code>Currency.NGN</code>, pesewas, if currency is <code>Currency.GHS</code>, and cents, if currency is <code>Currency.ZAR</code></p> required <code>interval</code> <code>Interval</code> <p>Any value from the <code>Interval</code> enum.</p> required <code>description</code> <code>str | None</code> <p>A description for this plan</p> <code>None</code> <code>currency</code> <code>Currency | None</code> <p>Currency in which amount is set. Any of the value from the <code>Currency</code> enum</p> <code>None</code> <code>invoice_limit</code> <code>int | None</code> <p>Number of invoices to raise during subscription to this plan. Can be overridden by specifying an <code>invoice_limit</code> while subscribing</p> <code>None</code> <code>send_invoices</code> <code>bool</code> <p>Set to <code>False</code> if you don't want invoices to be sent to your customers</p> <code>False</code> <code>send_sms</code> <code>bool</code> <p>Set to <code>False</code> if you don't want text messages to be sent to your customers</p> <code>False</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[Plan] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/plans.py</code> <pre><code>def create(\n    self,\n    name: str,\n    amount: int,\n    interval: Interval,\n    description: str | None = None,\n    currency: Currency | None = None,\n    invoice_limit: int | None = None,\n    send_invoices: bool = False,\n    send_sms: bool = False,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[Plan] | Response[PaystackDataModel]:\n    \"\"\"Create a plan on your integration\n\n    Args:\n        name: Name of plan\n        amount: Amount should be in kobo if currency is ``Currency.NGN``, pesewas,\n            if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR``\n        interval: Any value from the ``Interval`` enum.\n        description: A description for this plan\n        currency: Currency in which amount is set. Any of the value from\n            the ``Currency`` enum\n        invoice_limit: Number of invoices to raise during subscription to this plan.\n            Can be overridden by specifying an ``invoice_limit`` while subscribing\n        send_invoices: Set to ``False`` if you don't want invoices to be sent to your customers\n        send_sms: Set to ``False`` if you don't want text messages to be sent to your customers\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(\"/plan/\")\n\n    payload = {\n        \"name\": name,\n        \"amount\": amount,\n        \"interval\": interval,\n    }\n    optional_params = [\n        (\"send_invoices\", send_invoices),\n        (\"send_sms\", send_sms),\n        (\"description\", description),\n        (\"currency\", currency),\n        (\"invoice_limit\", invoice_limit),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or Plan,\n    )\n</code></pre>"},{"location":"reference/plans/#pypaystack2.sub_clients.sync_clients.plans.PlanClient.get_plan","title":"<code>get_plan(id_or_code, alternate_model_class=None)</code>","text":"<p>Get details of a plan on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>id_or_code</code> <code>int | str</code> <p>The plan <code>ID</code> or <code>code</code> you want to fetch</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[Plan] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/plans.py</code> <pre><code>def get_plan(\n    self,\n    id_or_code: int | str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[Plan] | Response[PaystackDataModel]:\n    \"\"\"Get details of a plan on your integration.\n\n    Args:\n        id_or_code: The plan ``ID`` or ``code`` you want to fetch\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._full_url(\"/plan/{}/\".format(id_or_code))\n    return self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or Plan,\n    )\n</code></pre>"},{"location":"reference/plans/#pypaystack2.sub_clients.sync_clients.plans.PlanClient.get_plans","title":"<code>get_plans(page=1, pagination=50, status=None, interval=None, amount=None, alternate_model_class=None)</code>","text":"<p>Fetch plans available on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>int</code> <p>Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1.</p> <code>1</code> <code>pagination</code> <code>int</code> <p>Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50.</p> <code>50</code> <code>status</code> <code>Status | None</code> <p>Filter list by plans with specified status</p> <code>None</code> <code>interval</code> <code>Interval | None</code> <p>Filter list by plans with specified interval</p> <code>None</code> <code>amount</code> <code>int | None</code> <p>Filter list by plans with specified amount ( kobo if currency is <code>Currency.NGN</code>, pesewas, if currency is <code>Currency.GHS</code>, and cents, if currency is <code>Currency.ZAR</code>)</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[list[Plan]] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/plans.py</code> <pre><code>def get_plans(\n    self,\n    page: int = 1,\n    pagination: int = 50,\n    status: Status | None = None,\n    interval: Interval | None = None,\n    amount: int | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[list[Plan]] | Response[PaystackDataModel]:\n    \"\"\"Fetch plans available on your integration.\n\n    Args:\n        page: Specifies exactly what page you want to retrieve.\n            If not specified, we use a default value of 1.\n        pagination: Specifies how many records you want to retrieve per page.\n            If not specified, we use a default value of 50.\n        status: Filter list by plans with specified status\n        interval: Filter list by plans with specified interval\n        amount: Filter list by plans with specified amount ( kobo if currency\n            is ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``,\n            and cents, if currency is ``Currency.ZAR``)\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/plan/?perPage={pagination}\")\n    query_params = [\n        (\"page\", page),\n        (\"status\", status),\n        (\"interval\", interval),\n        (\"amount\", amount),\n    ]\n    url = append_query_params(query_params, url)\n    return self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or Plan,\n    )\n</code></pre>"},{"location":"reference/plans/#pypaystack2.sub_clients.sync_clients.plans.PlanClient.update","title":"<code>update(id_or_code, name=None, amount=None, interval=None, description=None, currency=None, invoice_limit=None, send_invoices=False, send_sms=False, update_existing_subscriptions=True, alternate_model_class=None)</code>","text":"<p>update a plan details on your integration</p> <p>Parameters:</p> Name Type Description Default <code>id_or_code</code> <code>int | str</code> <p>Plan's ID or code</p> required <code>name</code> <code>str | None</code> <p>Name of plan</p> <code>None</code> <code>amount</code> <code>int | None</code> <p>Amount should be in kobo if currency is <code>Currency.NGN</code> and pesewas for <code>Currency.GHS</code></p> <code>None</code> <code>interval</code> <code>Interval | None</code> <p>Any value from the <code>Interval</code> enum.</p> <code>None</code> <code>description</code> <code>str | None</code> <p>A description for this plan.</p> <code>None</code> <code>currency</code> <code>Currency | None</code> <p>Any value from the <code>Currency</code> enum.</p> <code>None</code> <code>invoice_limit</code> <code>int | None</code> <p>Number of invoices to raise during subscription to this plan. Can be overridden by specifying an <code>invoice_limit</code> while subscribing.</p> <code>None</code> <code>send_invoices</code> <code>bool</code> <p>Set to <code>False</code> if you don't want invoices to be sent to your customers</p> <code>False</code> <code>send_sms</code> <code>bool</code> <p>Set to <code>False</code> if you don't want text messages to be sent to your customers</p> <code>False</code> <code>update_existing_subscriptions</code> <code>bool</code> <p>Flag to determine whether to update existing subscriptions based on the new changes made to the plan.</p> <code>True</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[None] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/plans.py</code> <pre><code>def update(\n    self,\n    id_or_code: int | str,\n    name: str | None = None,\n    amount: int | None = None,\n    interval: Interval | None = None,\n    description: str | None = None,\n    currency: Currency | None = None,\n    invoice_limit: int | None = None,\n    send_invoices: bool = False,\n    send_sms: bool = False,\n    update_existing_subscriptions: bool = True,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[None] | Response[PaystackDataModel]:\n    \"\"\"update a plan details on your integration\n\n    Args:\n        id_or_code: Plan's ID or code\n        name: Name of plan\n        amount: Amount should be in kobo if currency is\n            ``Currency.NGN`` and pesewas for ``Currency.GHS``\n        interval: Any value from the ``Interval`` enum.\n        description: A description for this plan.\n        currency: Any value from the ``Currency`` enum.\n        invoice_limit: Number of invoices to raise during subscription to this plan.\n            Can be overridden by specifying an ``invoice_limit`` while subscribing.\n        send_invoices: Set to ``False`` if you don't want invoices\n            to be sent to your customers\n        send_sms: Set to ``False`` if you don't want text messages to\n            be sent to your customers\n        update_existing_subscriptions: Flag to determine whether to update existing subscriptions based on the new\n            changes made to the plan.\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/plan/{id_or_code}/\")\n    payload = {\n        \"name\": name,\n        \"amount\": amount,\n        \"interval\": interval,\n    }\n\n    optional_params = [\n        (\"send_invoices\", send_invoices),\n        (\"send_sms\", send_sms),\n        (\"description\", description),\n        (\"currency\", currency),\n        (\"invoice_limit\", invoice_limit),\n        (\"update_existing_subscriptions\", update_existing_subscriptions),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return self._handle_request(  # type: ignore\n        HTTPMethod.PUT,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class,\n    )\n</code></pre>"},{"location":"reference/plans/#pypaystack2.sub_clients.async_clients.plans.AsyncPlanClient","title":"<code>AsyncPlanClient</code>","text":"<p>               Bases: <code>BaseAsyncAPIClient</code></p> <p>Provides a wrapper for paystack Plans API</p> <p>The Plans API allows you to create and manage installment payment options on your integration. https://paystack.com/docs/api/plan/</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/plans.py</code> <pre><code>class AsyncPlanClient(BaseAsyncAPIClient):\n    \"\"\"Provides a wrapper for paystack Plans API\n\n    The Plans API allows you to create and manage installment payment options on your integration.\n    https://paystack.com/docs/api/plan/\n    \"\"\"\n\n    async def create(\n        self,\n        name: str,\n        amount: int,\n        interval: Interval,\n        description: str | None = None,\n        currency: Currency | None = None,\n        invoice_limit: int | None = None,\n        send_invoices: bool = False,\n        send_sms: bool = False,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[Plan] | Response[PaystackDataModel]:\n        \"\"\"Create a plan on your integration\n\n        Args:\n            name: Name of plan\n            amount: Amount should be in kobo if currency is ``Currency.NGN``, pesewas,\n                if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR``\n            interval: Any value from the ``Interval`` enum.\n            description: A description for this plan\n            currency: Currency in which amount is set. Any of the value from\n                the ``Currency`` enum\n            invoice_limit: Number of invoices to raise during subscription to this plan.\n                Can be overridden by specifying an ``invoice_limit`` while subscribing\n            send_invoices: Set to ``False`` if you don't want invoices to be sent to your customers\n            send_sms: Set to ``False`` if you don't want text messages to be sent to your customers\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(\"/plan/\")\n\n        payload = {\n            \"name\": name,\n            \"amount\": amount,\n            \"interval\": interval,\n        }\n        optional_params = [\n            (\"send_invoices\", send_invoices),\n            (\"send_sms\", send_sms),\n            (\"description\", description),\n            (\"currency\", currency),\n            (\"invoice_limit\", invoice_limit),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or Plan,\n        )\n\n    async def get_plans(\n        self,\n        page: int = 1,\n        pagination: int = 50,\n        status: Status | None = None,\n        interval: Interval | None = None,\n        amount: int | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[list[Plan]] | Response[PaystackDataModel]:\n        \"\"\"Fetch plans available on your integration.\n\n        Args:\n            page: Specifies exactly what page you want to retrieve.\n                If not specified we use a default value of 1.\n            pagination: Specifies how many records you want to retrieve per page.\n                If not specified we use a default value of 50.\n            status: Filter list by plans with specified status\n            interval: Filter list by plans with specified interval\n            amount: Filter list by plans with specified amount ( kobo if currency\n                is ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``,\n                and cents, if currency is ``Currency.ZAR``)\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/plan/?perPage={pagination}\")\n        query_params = [\n            (\"page\", page),\n            (\"status\", status),\n            (\"interval\", interval),\n            (\"amount\", amount),\n        ]\n        url = append_query_params(query_params, url)\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or Plan,\n        )\n\n    async def get_plan(\n        self,\n        id_or_code: int | str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[Plan] | Response[PaystackDataModel]:\n        \"\"\"Get details of a plan on your integration.\n\n        Args:\n            id_or_code: The plan ``ID`` or ``code`` you want to fetch\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._full_url(\"/plan/{}/\".format(id_or_code))\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or Plan,\n        )\n\n    async def update(\n        self,\n        id_or_code: int | str,\n        name: str | None = None,\n        amount: int | None = None,\n        interval: Interval | None = None,\n        description: str | None = None,\n        currency: Currency | None = None,\n        invoice_limit: int | None = None,\n        send_invoices: bool = False,\n        send_sms: bool = False,\n        update_existing_subscriptions: bool = True,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[None] | Response[PaystackDataModel]:\n        \"\"\"Update a plan details on your integration\n\n        Args:\n            id_or_code: Plan's ID or code\n            name: Name of plan\n            amount: Amount should be in kobo if currency is\n                ``Currency.NGN`` and pesewas for ``Currency.GHS``\n            interval: Any value from the ``Interval`` enum.\n            description: A description for this plan.\n            currency: Any value from the ``Currency`` enum.\n            invoice_limit: Number of invoices to raise during subscription to this plan.\n                Can be overridden by specifying an ``invoice_limit`` while subscribing.\n            send_invoices: Set to ``False`` if you don't want invoices\n                to be sent to your customers\n            send_sms: Set to ``False`` if you don't want text messages to\n                be sent to your customers\n            update_existing_subscriptions: Flag to determine whether to update existing subscriptions based on the new\n                changes made to the plan.\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/plan/{id_or_code}/\")\n        payload = {\n            \"name\": name,\n            \"amount\": amount,\n            \"interval\": interval,\n        }\n\n        optional_params = [\n            (\"send_invoices\", send_invoices),\n            (\"send_sms\", send_sms),\n            (\"description\", description),\n            (\"currency\", currency),\n            (\"invoice_limit\", invoice_limit),\n            (\"update_existing_subscriptions\", update_existing_subscriptions),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.PUT,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class,\n        )\n</code></pre>"},{"location":"reference/plans/#pypaystack2.sub_clients.async_clients.plans.AsyncPlanClient.create","title":"<code>create(name, amount, interval, description=None, currency=None, invoice_limit=None, send_invoices=False, send_sms=False, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Create a plan on your integration</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of plan</p> required <code>amount</code> <code>int</code> <p>Amount should be in kobo if currency is <code>Currency.NGN</code>, pesewas, if currency is <code>Currency.GHS</code>, and cents, if currency is <code>Currency.ZAR</code></p> required <code>interval</code> <code>Interval</code> <p>Any value from the <code>Interval</code> enum.</p> required <code>description</code> <code>str | None</code> <p>A description for this plan</p> <code>None</code> <code>currency</code> <code>Currency | None</code> <p>Currency in which amount is set. Any of the value from the <code>Currency</code> enum</p> <code>None</code> <code>invoice_limit</code> <code>int | None</code> <p>Number of invoices to raise during subscription to this plan. Can be overridden by specifying an <code>invoice_limit</code> while subscribing</p> <code>None</code> <code>send_invoices</code> <code>bool</code> <p>Set to <code>False</code> if you don't want invoices to be sent to your customers</p> <code>False</code> <code>send_sms</code> <code>bool</code> <p>Set to <code>False</code> if you don't want text messages to be sent to your customers</p> <code>False</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[Plan] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/plans.py</code> <pre><code>async def create(\n    self,\n    name: str,\n    amount: int,\n    interval: Interval,\n    description: str | None = None,\n    currency: Currency | None = None,\n    invoice_limit: int | None = None,\n    send_invoices: bool = False,\n    send_sms: bool = False,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[Plan] | Response[PaystackDataModel]:\n    \"\"\"Create a plan on your integration\n\n    Args:\n        name: Name of plan\n        amount: Amount should be in kobo if currency is ``Currency.NGN``, pesewas,\n            if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR``\n        interval: Any value from the ``Interval`` enum.\n        description: A description for this plan\n        currency: Currency in which amount is set. Any of the value from\n            the ``Currency`` enum\n        invoice_limit: Number of invoices to raise during subscription to this plan.\n            Can be overridden by specifying an ``invoice_limit`` while subscribing\n        send_invoices: Set to ``False`` if you don't want invoices to be sent to your customers\n        send_sms: Set to ``False`` if you don't want text messages to be sent to your customers\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(\"/plan/\")\n\n    payload = {\n        \"name\": name,\n        \"amount\": amount,\n        \"interval\": interval,\n    }\n    optional_params = [\n        (\"send_invoices\", send_invoices),\n        (\"send_sms\", send_sms),\n        (\"description\", description),\n        (\"currency\", currency),\n        (\"invoice_limit\", invoice_limit),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or Plan,\n    )\n</code></pre>"},{"location":"reference/plans/#pypaystack2.sub_clients.async_clients.plans.AsyncPlanClient.get_plan","title":"<code>get_plan(id_or_code, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Get details of a plan on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>id_or_code</code> <code>int | str</code> <p>The plan <code>ID</code> or <code>code</code> you want to fetch</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[Plan] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/plans.py</code> <pre><code>async def get_plan(\n    self,\n    id_or_code: int | str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[Plan] | Response[PaystackDataModel]:\n    \"\"\"Get details of a plan on your integration.\n\n    Args:\n        id_or_code: The plan ``ID`` or ``code`` you want to fetch\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._full_url(\"/plan/{}/\".format(id_or_code))\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or Plan,\n    )\n</code></pre>"},{"location":"reference/plans/#pypaystack2.sub_clients.async_clients.plans.AsyncPlanClient.get_plans","title":"<code>get_plans(page=1, pagination=50, status=None, interval=None, amount=None, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Fetch plans available on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>int</code> <p>Specifies exactly what page you want to retrieve. If not specified we use a default value of 1.</p> <code>1</code> <code>pagination</code> <code>int</code> <p>Specifies how many records you want to retrieve per page. If not specified we use a default value of 50.</p> <code>50</code> <code>status</code> <code>Status | None</code> <p>Filter list by plans with specified status</p> <code>None</code> <code>interval</code> <code>Interval | None</code> <p>Filter list by plans with specified interval</p> <code>None</code> <code>amount</code> <code>int | None</code> <p>Filter list by plans with specified amount ( kobo if currency is <code>Currency.NGN</code>, pesewas, if currency is <code>Currency.GHS</code>, and cents, if currency is <code>Currency.ZAR</code>)</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[list[Plan]] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/plans.py</code> <pre><code>async def get_plans(\n    self,\n    page: int = 1,\n    pagination: int = 50,\n    status: Status | None = None,\n    interval: Interval | None = None,\n    amount: int | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[list[Plan]] | Response[PaystackDataModel]:\n    \"\"\"Fetch plans available on your integration.\n\n    Args:\n        page: Specifies exactly what page you want to retrieve.\n            If not specified we use a default value of 1.\n        pagination: Specifies how many records you want to retrieve per page.\n            If not specified we use a default value of 50.\n        status: Filter list by plans with specified status\n        interval: Filter list by plans with specified interval\n        amount: Filter list by plans with specified amount ( kobo if currency\n            is ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``,\n            and cents, if currency is ``Currency.ZAR``)\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/plan/?perPage={pagination}\")\n    query_params = [\n        (\"page\", page),\n        (\"status\", status),\n        (\"interval\", interval),\n        (\"amount\", amount),\n    ]\n    url = append_query_params(query_params, url)\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or Plan,\n    )\n</code></pre>"},{"location":"reference/plans/#pypaystack2.sub_clients.async_clients.plans.AsyncPlanClient.update","title":"<code>update(id_or_code, name=None, amount=None, interval=None, description=None, currency=None, invoice_limit=None, send_invoices=False, send_sms=False, update_existing_subscriptions=True, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Update a plan details on your integration</p> <p>Parameters:</p> Name Type Description Default <code>id_or_code</code> <code>int | str</code> <p>Plan's ID or code</p> required <code>name</code> <code>str | None</code> <p>Name of plan</p> <code>None</code> <code>amount</code> <code>int | None</code> <p>Amount should be in kobo if currency is <code>Currency.NGN</code> and pesewas for <code>Currency.GHS</code></p> <code>None</code> <code>interval</code> <code>Interval | None</code> <p>Any value from the <code>Interval</code> enum.</p> <code>None</code> <code>description</code> <code>str | None</code> <p>A description for this plan.</p> <code>None</code> <code>currency</code> <code>Currency | None</code> <p>Any value from the <code>Currency</code> enum.</p> <code>None</code> <code>invoice_limit</code> <code>int | None</code> <p>Number of invoices to raise during subscription to this plan. Can be overridden by specifying an <code>invoice_limit</code> while subscribing.</p> <code>None</code> <code>send_invoices</code> <code>bool</code> <p>Set to <code>False</code> if you don't want invoices to be sent to your customers</p> <code>False</code> <code>send_sms</code> <code>bool</code> <p>Set to <code>False</code> if you don't want text messages to be sent to your customers</p> <code>False</code> <code>update_existing_subscriptions</code> <code>bool</code> <p>Flag to determine whether to update existing subscriptions based on the new changes made to the plan.</p> <code>True</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[None] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/plans.py</code> <pre><code>async def update(\n    self,\n    id_or_code: int | str,\n    name: str | None = None,\n    amount: int | None = None,\n    interval: Interval | None = None,\n    description: str | None = None,\n    currency: Currency | None = None,\n    invoice_limit: int | None = None,\n    send_invoices: bool = False,\n    send_sms: bool = False,\n    update_existing_subscriptions: bool = True,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[None] | Response[PaystackDataModel]:\n    \"\"\"Update a plan details on your integration\n\n    Args:\n        id_or_code: Plan's ID or code\n        name: Name of plan\n        amount: Amount should be in kobo if currency is\n            ``Currency.NGN`` and pesewas for ``Currency.GHS``\n        interval: Any value from the ``Interval`` enum.\n        description: A description for this plan.\n        currency: Any value from the ``Currency`` enum.\n        invoice_limit: Number of invoices to raise during subscription to this plan.\n            Can be overridden by specifying an ``invoice_limit`` while subscribing.\n        send_invoices: Set to ``False`` if you don't want invoices\n            to be sent to your customers\n        send_sms: Set to ``False`` if you don't want text messages to\n            be sent to your customers\n        update_existing_subscriptions: Flag to determine whether to update existing subscriptions based on the new\n            changes made to the plan.\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/plan/{id_or_code}/\")\n    payload = {\n        \"name\": name,\n        \"amount\": amount,\n        \"interval\": interval,\n    }\n\n    optional_params = [\n        (\"send_invoices\", send_invoices),\n        (\"send_sms\", send_sms),\n        (\"description\", description),\n        (\"currency\", currency),\n        (\"invoice_limit\", invoice_limit),\n        (\"update_existing_subscriptions\", update_existing_subscriptions),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.PUT,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class,\n    )\n</code></pre>"},{"location":"reference/products/","title":"Products","text":""},{"location":"reference/products/#pypaystack2.sub_clients.sync_clients.products.ProductClient","title":"<code>ProductClient</code>","text":"<p>               Bases: <code>BaseAPIClient</code></p> <p>Provides a wrapper for paystack Products API</p> <p>The Products API allows you to create and manage inventories on your integration. https://paystack.com/docs/api/product/</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/products.py</code> <pre><code>class ProductClient(BaseAPIClient):\n    \"\"\"Provides a wrapper for paystack Products API\n\n    The Products API allows you to create and manage inventories on your integration.\n    https://paystack.com/docs/api/product/\n    \"\"\"\n\n    def create(\n        self,\n        name: str,\n        description: str,\n        price: int,\n        currency: Currency,\n        unlimited: bool | None = None,\n        quantity: int | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[Product] | Response[PaystackDataModel]:\n        \"\"\"Create a product on your integration\n\n        Args:\n            name: Name of product\n            description: A description for this product\n            price: Price should be in kobo if currency is ``Currency.NGN``, pesewas,\n                if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR``\n            currency: Any value from the ``Currency`` enum\n            unlimited: Set to ``True`` if the product has unlimited stock.\n                Leave as ``False`` if the product has limited stock\n            quantity: Number of products in stock. Use if unlimited is ``False``\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n\n        Raises:\n            InvalidDataError: When unlimited is set to True and quantity has a value.\n        \"\"\"\n\n        if unlimited is True and quantity is not None:\n            raise ValueError(\n                \"You can't have unlimited set to True and have a quantity value.\"\n            )\n\n        url = self._full_url(\"/product\")\n\n        payload = {\n            \"name\": name,\n            \"description\": description,\n            \"price\": price,\n            \"currency\": currency,\n        }\n        optional_params = [\n            (\"unlimited\", unlimited),\n            (\"quantity\", quantity),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or Product,\n        )\n\n    def get_products(\n        self,\n        page: int = 1,\n        pagination: int = 50,\n        start_date: str | None = None,\n        end_date: str | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[list[Product]] | Response[PaystackDataModel]:\n        \"\"\"Fetches products available on your integration.\n\n        Args:\n            page: Specifies exactly what page you want to retrieve.\n                If not specified we use a default value of 1.\n            pagination: Specifies how many records you want to retrieve per page.\n                If not specified we use a default value of 50.\n            start_date: A timestamp from which to start listing product e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            end_date: timestamp at which to stop listing product e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(\"/product?perPage=\" + str(pagination))\n        query_params = [\n            (\"page\", page),\n            (\"start_date\", start_date),\n            (\"end_date\", end_date),\n        ]\n        url = append_query_params(query_params, url)\n        return self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or Product,\n        )\n\n    def get_product(\n        self,\n        id_: int | str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[Product] | Response[PaystackDataModel]:\n        \"\"\"Get details of a product on your integration.\n\n        Args:\n            id_: The product ``ID`` you want to fetch\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/product/{id_}\")\n        return self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or Product,\n        )\n\n    def update(\n        self,\n        id_: int | str,\n        name: str,\n        description: str,\n        price: int,\n        currency: Currency,\n        unlimited: bool | None = None,\n        quantity: int | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[Product] | Response[PaystackDataModel]:\n        \"\"\"Update a product details on your integration\n\n        Args:\n            id_: Product ID\n            name: Name of product\n            description: A description for this product\n            price: Price should be in kobo if currency is ``Currency.NGN``, pesewas,\n                if currency is GHS, and cents, if currency is ``Currency.ZAR``\n            currency: Any value from the ``Currency`` enum\n            unlimited: Set to ``True`` if the product has unlimited stock.\n                Leave as ``False`` if the product has limited stock\n            quantity: Number of products in stock. Use if unlimited is ``False``\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n\n        Raises:\n            InvalidDataError: When unlimited is set to True and quantity has a value.\n        \"\"\"\n\n        if unlimited is True and quantity is not None:\n            raise ValueError(\n                \"You can't have unlimited set to True and quantity have a value.\"\n            )\n        url = self._full_url(f\"/product/{id_}\")\n        payload = {\n            \"name\": name,\n            \"description\": description,\n            \"price\": price,\n            \"currency\": currency,\n        }\n        optional_params = [\n            (\"unlimited\", unlimited),\n            (\"quantity\", quantity),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return self._handle_request(  # type: ignore\n            HTTPMethod.PUT,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or Product,\n        )\n</code></pre>"},{"location":"reference/products/#pypaystack2.sub_clients.sync_clients.products.ProductClient.create","title":"<code>create(name, description, price, currency, unlimited=None, quantity=None, alternate_model_class=None)</code>","text":"<p>Create a product on your integration</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of product</p> required <code>description</code> <code>str</code> <p>A description for this product</p> required <code>price</code> <code>int</code> <p>Price should be in kobo if currency is <code>Currency.NGN</code>, pesewas, if currency is <code>Currency.GHS</code>, and cents, if currency is <code>Currency.ZAR</code></p> required <code>currency</code> <code>Currency</code> <p>Any value from the <code>Currency</code> enum</p> required <code>unlimited</code> <code>bool | None</code> <p>Set to <code>True</code> if the product has unlimited stock. Leave as <code>False</code> if the product has limited stock</p> <code>None</code> <code>quantity</code> <code>int | None</code> <p>Number of products in stock. Use if unlimited is <code>False</code></p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[Product] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> <p>Raises:</p> Type Description <code>InvalidDataError</code> <p>When unlimited is set to True and quantity has a value.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/products.py</code> <pre><code>def create(\n    self,\n    name: str,\n    description: str,\n    price: int,\n    currency: Currency,\n    unlimited: bool | None = None,\n    quantity: int | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[Product] | Response[PaystackDataModel]:\n    \"\"\"Create a product on your integration\n\n    Args:\n        name: Name of product\n        description: A description for this product\n        price: Price should be in kobo if currency is ``Currency.NGN``, pesewas,\n            if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR``\n        currency: Any value from the ``Currency`` enum\n        unlimited: Set to ``True`` if the product has unlimited stock.\n            Leave as ``False`` if the product has limited stock\n        quantity: Number of products in stock. Use if unlimited is ``False``\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n\n    Raises:\n        InvalidDataError: When unlimited is set to True and quantity has a value.\n    \"\"\"\n\n    if unlimited is True and quantity is not None:\n        raise ValueError(\n            \"You can't have unlimited set to True and have a quantity value.\"\n        )\n\n    url = self._full_url(\"/product\")\n\n    payload = {\n        \"name\": name,\n        \"description\": description,\n        \"price\": price,\n        \"currency\": currency,\n    }\n    optional_params = [\n        (\"unlimited\", unlimited),\n        (\"quantity\", quantity),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or Product,\n    )\n</code></pre>"},{"location":"reference/products/#pypaystack2.sub_clients.sync_clients.products.ProductClient.get_product","title":"<code>get_product(id_, alternate_model_class=None)</code>","text":"<p>Get details of a product on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>int | str</code> <p>The product <code>ID</code> you want to fetch</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[Product] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/products.py</code> <pre><code>def get_product(\n    self,\n    id_: int | str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[Product] | Response[PaystackDataModel]:\n    \"\"\"Get details of a product on your integration.\n\n    Args:\n        id_: The product ``ID`` you want to fetch\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/product/{id_}\")\n    return self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or Product,\n    )\n</code></pre>"},{"location":"reference/products/#pypaystack2.sub_clients.sync_clients.products.ProductClient.get_products","title":"<code>get_products(page=1, pagination=50, start_date=None, end_date=None, alternate_model_class=None)</code>","text":"<p>Fetches products available on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>int</code> <p>Specifies exactly what page you want to retrieve. If not specified we use a default value of 1.</p> <code>1</code> <code>pagination</code> <code>int</code> <p>Specifies how many records you want to retrieve per page. If not specified we use a default value of 50.</p> <code>50</code> <code>start_date</code> <code>str | None</code> <p>A timestamp from which to start listing product e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>end_date</code> <code>str | None</code> <p>timestamp at which to stop listing product e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[list[Product]] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/products.py</code> <pre><code>def get_products(\n    self,\n    page: int = 1,\n    pagination: int = 50,\n    start_date: str | None = None,\n    end_date: str | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[list[Product]] | Response[PaystackDataModel]:\n    \"\"\"Fetches products available on your integration.\n\n    Args:\n        page: Specifies exactly what page you want to retrieve.\n            If not specified we use a default value of 1.\n        pagination: Specifies how many records you want to retrieve per page.\n            If not specified we use a default value of 50.\n        start_date: A timestamp from which to start listing product e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        end_date: timestamp at which to stop listing product e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(\"/product?perPage=\" + str(pagination))\n    query_params = [\n        (\"page\", page),\n        (\"start_date\", start_date),\n        (\"end_date\", end_date),\n    ]\n    url = append_query_params(query_params, url)\n    return self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or Product,\n    )\n</code></pre>"},{"location":"reference/products/#pypaystack2.sub_clients.sync_clients.products.ProductClient.update","title":"<code>update(id_, name, description, price, currency, unlimited=None, quantity=None, alternate_model_class=None)</code>","text":"<p>Update a product details on your integration</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>int | str</code> <p>Product ID</p> required <code>name</code> <code>str</code> <p>Name of product</p> required <code>description</code> <code>str</code> <p>A description for this product</p> required <code>price</code> <code>int</code> <p>Price should be in kobo if currency is <code>Currency.NGN</code>, pesewas, if currency is GHS, and cents, if currency is <code>Currency.ZAR</code></p> required <code>currency</code> <code>Currency</code> <p>Any value from the <code>Currency</code> enum</p> required <code>unlimited</code> <code>bool | None</code> <p>Set to <code>True</code> if the product has unlimited stock. Leave as <code>False</code> if the product has limited stock</p> <code>None</code> <code>quantity</code> <code>int | None</code> <p>Number of products in stock. Use if unlimited is <code>False</code></p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[Product] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> <p>Raises:</p> Type Description <code>InvalidDataError</code> <p>When unlimited is set to True and quantity has a value.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/products.py</code> <pre><code>def update(\n    self,\n    id_: int | str,\n    name: str,\n    description: str,\n    price: int,\n    currency: Currency,\n    unlimited: bool | None = None,\n    quantity: int | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[Product] | Response[PaystackDataModel]:\n    \"\"\"Update a product details on your integration\n\n    Args:\n        id_: Product ID\n        name: Name of product\n        description: A description for this product\n        price: Price should be in kobo if currency is ``Currency.NGN``, pesewas,\n            if currency is GHS, and cents, if currency is ``Currency.ZAR``\n        currency: Any value from the ``Currency`` enum\n        unlimited: Set to ``True`` if the product has unlimited stock.\n            Leave as ``False`` if the product has limited stock\n        quantity: Number of products in stock. Use if unlimited is ``False``\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n\n    Raises:\n        InvalidDataError: When unlimited is set to True and quantity has a value.\n    \"\"\"\n\n    if unlimited is True and quantity is not None:\n        raise ValueError(\n            \"You can't have unlimited set to True and quantity have a value.\"\n        )\n    url = self._full_url(f\"/product/{id_}\")\n    payload = {\n        \"name\": name,\n        \"description\": description,\n        \"price\": price,\n        \"currency\": currency,\n    }\n    optional_params = [\n        (\"unlimited\", unlimited),\n        (\"quantity\", quantity),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return self._handle_request(  # type: ignore\n        HTTPMethod.PUT,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or Product,\n    )\n</code></pre>"},{"location":"reference/products/#pypaystack2.sub_clients.async_clients.products.AsyncProductClient","title":"<code>AsyncProductClient</code>","text":"<p>               Bases: <code>BaseAsyncAPIClient</code></p> <p>Provides a wrapper for paystack Products API</p> <p>The Products API allows you to create and manage inventories on your integration. https://paystack.com/docs/api/product/</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/products.py</code> <pre><code>class AsyncProductClient(BaseAsyncAPIClient):\n    \"\"\"Provides a wrapper for paystack Products API\n\n    The Products API allows you to create and manage inventories on your integration.\n    https://paystack.com/docs/api/product/\n    \"\"\"\n\n    async def create(\n        self,\n        name: str,\n        description: str,\n        price: int,\n        currency: Currency,\n        unlimited: bool | None = None,\n        quantity: int | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[Product] | Response[PaystackDataModel]:\n        \"\"\"Create a product on your integration\n\n        Args:\n            name: Name of product\n            description: A description for this product\n            price: Price should be in kobo if currency is ``Currency.NGN``, pesewas,\n                if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR``\n            currency: Any value from the ``Currency`` enum\n            unlimited: Set to ``True`` if the product has unlimited stock.\n                Leave as ``False`` if the product has limited stock\n            quantity: Number of products in stock. Use if unlimited is ``False``\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n\n        Raises:\n            InvalidDataError: When unlimited is set to True and quantity has a value.\n        \"\"\"\n\n        if unlimited is True and quantity is not None:\n            raise ValueError(\n                \"You can't have unlimited set to True and have a quantity value.\"\n            )\n\n        url = self._full_url(\"/product\")\n\n        payload = {\n            \"name\": name,\n            \"description\": description,\n            \"price\": price,\n            \"currency\": currency,\n        }\n        optional_params = [\n            (\"unlimited\", unlimited),\n            (\"quantity\", quantity),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or Product,\n        )\n\n    async def get_products(\n        self,\n        page: int = 1,\n        pagination: int = 50,\n        start_date: str | None = None,\n        end_date: str | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[list[Product]] | Response[PaystackDataModel]:\n        \"\"\"Fetches products available on your integration.\n\n        Args:\n            page: Specifies exactly what page you want to retrieve.\n                If not specified we use a default value of 1.\n            pagination: Specifies how many records you want to retrieve per page.\n                If not specified we use a default value of 50.\n            start_date: A timestamp from which to start listing product e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            end_date: timestamp at which to stop listing product e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(\"/product?perPage=\" + str(pagination))\n        query_params = [\n            (\"page\", page),\n            (\"start_date\", start_date),\n            (\"end_date\", end_date),\n        ]\n        url = append_query_params(query_params, url)\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or Product,\n        )\n\n    async def get_product(\n        self,\n        id_: int | str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[Product] | Response[PaystackDataModel]:\n        \"\"\"Get details of a product on your integration.\n\n        Args:\n            id_: The product ``ID`` you want to fetch\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/product/{id_}\")\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or Product,\n        )\n\n    async def update(\n        self,\n        id_: str | int,\n        name: str,\n        description: str,\n        price: int,\n        currency: Currency,\n        unlimited: bool | None = None,\n        quantity: int | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[Product] | Response[PaystackDataModel]:\n        \"\"\"Update a product details on your integration\n\n        Args:\n            id_: Product ID\n            name: Name of product\n            description: A description for this product\n            price: Price should be in kobo if currency is ``Currency.NGN``, pesewas,\n                if currency is GHS, and cents, if currency is ``Currency.ZAR``\n            currency: Any value from the ``Currency`` enum\n            unlimited: Set to ``True`` if the product has unlimited stock.\n                Leave as ``False`` if the product has limited stock\n            quantity: Number of products in stock. Use if unlimited is ``False``\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n\n        Raises:\n            InvalidDataError: When unlimited is set to True and quantity has a value.\n        \"\"\"\n\n        if unlimited is True and quantity is not None:\n            raise ValueError(\n                \"You can't have unlimited set to True and quantity have a value.\"\n            )\n        url = self._full_url(f\"/product/{id_}\")\n        payload = {\n            \"name\": name,\n            \"description\": description,\n            \"price\": price,\n            \"currency\": currency,\n        }\n        optional_params = [\n            (\"unlimited\", unlimited),\n            (\"quantity\", quantity),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.PUT,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or Product,\n        )\n</code></pre>"},{"location":"reference/products/#pypaystack2.sub_clients.async_clients.products.AsyncProductClient.create","title":"<code>create(name, description, price, currency, unlimited=None, quantity=None, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Create a product on your integration</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of product</p> required <code>description</code> <code>str</code> <p>A description for this product</p> required <code>price</code> <code>int</code> <p>Price should be in kobo if currency is <code>Currency.NGN</code>, pesewas, if currency is <code>Currency.GHS</code>, and cents, if currency is <code>Currency.ZAR</code></p> required <code>currency</code> <code>Currency</code> <p>Any value from the <code>Currency</code> enum</p> required <code>unlimited</code> <code>bool | None</code> <p>Set to <code>True</code> if the product has unlimited stock. Leave as <code>False</code> if the product has limited stock</p> <code>None</code> <code>quantity</code> <code>int | None</code> <p>Number of products in stock. Use if unlimited is <code>False</code></p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[Product] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> <p>Raises:</p> Type Description <code>InvalidDataError</code> <p>When unlimited is set to True and quantity has a value.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/products.py</code> <pre><code>async def create(\n    self,\n    name: str,\n    description: str,\n    price: int,\n    currency: Currency,\n    unlimited: bool | None = None,\n    quantity: int | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[Product] | Response[PaystackDataModel]:\n    \"\"\"Create a product on your integration\n\n    Args:\n        name: Name of product\n        description: A description for this product\n        price: Price should be in kobo if currency is ``Currency.NGN``, pesewas,\n            if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR``\n        currency: Any value from the ``Currency`` enum\n        unlimited: Set to ``True`` if the product has unlimited stock.\n            Leave as ``False`` if the product has limited stock\n        quantity: Number of products in stock. Use if unlimited is ``False``\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n\n    Raises:\n        InvalidDataError: When unlimited is set to True and quantity has a value.\n    \"\"\"\n\n    if unlimited is True and quantity is not None:\n        raise ValueError(\n            \"You can't have unlimited set to True and have a quantity value.\"\n        )\n\n    url = self._full_url(\"/product\")\n\n    payload = {\n        \"name\": name,\n        \"description\": description,\n        \"price\": price,\n        \"currency\": currency,\n    }\n    optional_params = [\n        (\"unlimited\", unlimited),\n        (\"quantity\", quantity),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or Product,\n    )\n</code></pre>"},{"location":"reference/products/#pypaystack2.sub_clients.async_clients.products.AsyncProductClient.get_product","title":"<code>get_product(id_, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Get details of a product on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>int | str</code> <p>The product <code>ID</code> you want to fetch</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[Product] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/products.py</code> <pre><code>async def get_product(\n    self,\n    id_: int | str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[Product] | Response[PaystackDataModel]:\n    \"\"\"Get details of a product on your integration.\n\n    Args:\n        id_: The product ``ID`` you want to fetch\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/product/{id_}\")\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or Product,\n    )\n</code></pre>"},{"location":"reference/products/#pypaystack2.sub_clients.async_clients.products.AsyncProductClient.get_products","title":"<code>get_products(page=1, pagination=50, start_date=None, end_date=None, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Fetches products available on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>int</code> <p>Specifies exactly what page you want to retrieve. If not specified we use a default value of 1.</p> <code>1</code> <code>pagination</code> <code>int</code> <p>Specifies how many records you want to retrieve per page. If not specified we use a default value of 50.</p> <code>50</code> <code>start_date</code> <code>str | None</code> <p>A timestamp from which to start listing product e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>end_date</code> <code>str | None</code> <p>timestamp at which to stop listing product e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[list[Product]] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/products.py</code> <pre><code>async def get_products(\n    self,\n    page: int = 1,\n    pagination: int = 50,\n    start_date: str | None = None,\n    end_date: str | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[list[Product]] | Response[PaystackDataModel]:\n    \"\"\"Fetches products available on your integration.\n\n    Args:\n        page: Specifies exactly what page you want to retrieve.\n            If not specified we use a default value of 1.\n        pagination: Specifies how many records you want to retrieve per page.\n            If not specified we use a default value of 50.\n        start_date: A timestamp from which to start listing product e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        end_date: timestamp at which to stop listing product e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(\"/product?perPage=\" + str(pagination))\n    query_params = [\n        (\"page\", page),\n        (\"start_date\", start_date),\n        (\"end_date\", end_date),\n    ]\n    url = append_query_params(query_params, url)\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or Product,\n    )\n</code></pre>"},{"location":"reference/products/#pypaystack2.sub_clients.async_clients.products.AsyncProductClient.update","title":"<code>update(id_, name, description, price, currency, unlimited=None, quantity=None, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Update a product details on your integration</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str | int</code> <p>Product ID</p> required <code>name</code> <code>str</code> <p>Name of product</p> required <code>description</code> <code>str</code> <p>A description for this product</p> required <code>price</code> <code>int</code> <p>Price should be in kobo if currency is <code>Currency.NGN</code>, pesewas, if currency is GHS, and cents, if currency is <code>Currency.ZAR</code></p> required <code>currency</code> <code>Currency</code> <p>Any value from the <code>Currency</code> enum</p> required <code>unlimited</code> <code>bool | None</code> <p>Set to <code>True</code> if the product has unlimited stock. Leave as <code>False</code> if the product has limited stock</p> <code>None</code> <code>quantity</code> <code>int | None</code> <p>Number of products in stock. Use if unlimited is <code>False</code></p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[Product] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> <p>Raises:</p> Type Description <code>InvalidDataError</code> <p>When unlimited is set to True and quantity has a value.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/products.py</code> <pre><code>async def update(\n    self,\n    id_: str | int,\n    name: str,\n    description: str,\n    price: int,\n    currency: Currency,\n    unlimited: bool | None = None,\n    quantity: int | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[Product] | Response[PaystackDataModel]:\n    \"\"\"Update a product details on your integration\n\n    Args:\n        id_: Product ID\n        name: Name of product\n        description: A description for this product\n        price: Price should be in kobo if currency is ``Currency.NGN``, pesewas,\n            if currency is GHS, and cents, if currency is ``Currency.ZAR``\n        currency: Any value from the ``Currency`` enum\n        unlimited: Set to ``True`` if the product has unlimited stock.\n            Leave as ``False`` if the product has limited stock\n        quantity: Number of products in stock. Use if unlimited is ``False``\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n\n    Raises:\n        InvalidDataError: When unlimited is set to True and quantity has a value.\n    \"\"\"\n\n    if unlimited is True and quantity is not None:\n        raise ValueError(\n            \"You can't have unlimited set to True and quantity have a value.\"\n        )\n    url = self._full_url(f\"/product/{id_}\")\n    payload = {\n        \"name\": name,\n        \"description\": description,\n        \"price\": price,\n        \"currency\": currency,\n    }\n    optional_params = [\n        (\"unlimited\", unlimited),\n        (\"quantity\", quantity),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.PUT,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or Product,\n    )\n</code></pre>"},{"location":"reference/refunds/","title":"Refunds","text":""},{"location":"reference/refunds/#pypaystack2.sub_clients.sync_clients.refunds.RefundClient","title":"<code>RefundClient</code>","text":"<p>               Bases: <code>BaseAPIClient</code></p> <p>Provides a wrapper for paystack Refunds API</p> <p>The Refunds API allows you to create and manage transaction refunds. https://paystack.com/docs/api/refund/</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/refunds.py</code> <pre><code>class RefundClient(BaseAPIClient):\n    \"\"\"Provides a wrapper for paystack Refunds API\n\n    The Refunds API allows you to create and manage transaction refunds.\n    https://paystack.com/docs/api/refund/\n    \"\"\"\n\n    def create(\n        self,\n        transaction: int | str,\n        amount: int | None = None,\n        currency: Currency | None = None,\n        customer_note: str | None = None,\n        merchant_note: str | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[Refund] | Response[PaystackDataModel]:\n        \"\"\"Initiate a refund on your integration\n\n        Args:\n            transaction: Transaction reference or id\n            amount: Amount ( in kobo if currency is NGN, pesewas, if currency is\n                GHS, and cents, if currency is ZAR ) to be refunded to the\n                customer. Amount is optional(defaults to original\n                transaction amount) and cannot be more than the original\n                transaction amount\n            currency: Any value from the ``Currency`` enum\n            customer_note: Customer reason\n            merchant_note: Merchant reason\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(\"/refund\")\n        payload = {\"transaction\": transaction}\n        optional_params = [\n            (\"amount\", amount),\n            (\"currency\", currency),\n            (\"customer_note\", customer_note),\n            (\"merchant_note\", merchant_note),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or Refund,\n        )\n\n    def get_refunds(\n        self,\n        reference: str | None = None,\n        currency: Currency | None = None,\n        pagination: int = 50,\n        page: int = 1,\n        start_date: str | None = None,\n        end_date: str | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[list[Refund]] | Response[PaystackDataModel]:\n        \"\"\"Fetch refunds available on your integration.\n\n        Args:\n            reference: Identifier for transaction to be refunded\n            currency: Any value from the ``Currency`` enum\n            pagination: Specifies how many records you want to retrieve per page.\n                If not specified we use a default value of 50.\n            page: Specifies exactly what refund you want to page.\n                If not specified we use a default value of 1.\n            start_date: A timestamp from which to start listing refund e.g. 2016-09-21\n            end_date: A timestamp at which to stop listing refund e.g. 2016-09-21\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/refund?perPage={pagination}\")\n        query_params = [\n            (\"reference\", reference),\n            (\"currency\", currency),\n            (\"page\", page),\n            (\"start_date\", start_date),\n            (\"end_date\", end_date),\n        ]\n        url = append_query_params(query_params, url)\n        return self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or Refund,\n        )\n\n    def get_refund(\n        self,\n        reference: str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[Refund] | Response[PaystackDataModel]:\n        \"\"\"Get details of a refund on your integration.\n\n        Args:\n            reference: Identifier for transaction to be refunded\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/refund/{reference}\")\n        return self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or Refund,\n        )\n</code></pre>"},{"location":"reference/refunds/#pypaystack2.sub_clients.sync_clients.refunds.RefundClient.create","title":"<code>create(transaction, amount=None, currency=None, customer_note=None, merchant_note=None, alternate_model_class=None)</code>","text":"<p>Initiate a refund on your integration</p> <p>Parameters:</p> Name Type Description Default <code>transaction</code> <code>int | str</code> <p>Transaction reference or id</p> required <code>amount</code> <code>int | None</code> <p>Amount ( in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR ) to be refunded to the customer. Amount is optional(defaults to original transaction amount) and cannot be more than the original transaction amount</p> <code>None</code> <code>currency</code> <code>Currency | None</code> <p>Any value from the <code>Currency</code> enum</p> <code>None</code> <code>customer_note</code> <code>str | None</code> <p>Customer reason</p> <code>None</code> <code>merchant_note</code> <code>str | None</code> <p>Merchant reason</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[Refund] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/refunds.py</code> <pre><code>def create(\n    self,\n    transaction: int | str,\n    amount: int | None = None,\n    currency: Currency | None = None,\n    customer_note: str | None = None,\n    merchant_note: str | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[Refund] | Response[PaystackDataModel]:\n    \"\"\"Initiate a refund on your integration\n\n    Args:\n        transaction: Transaction reference or id\n        amount: Amount ( in kobo if currency is NGN, pesewas, if currency is\n            GHS, and cents, if currency is ZAR ) to be refunded to the\n            customer. Amount is optional(defaults to original\n            transaction amount) and cannot be more than the original\n            transaction amount\n        currency: Any value from the ``Currency`` enum\n        customer_note: Customer reason\n        merchant_note: Merchant reason\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(\"/refund\")\n    payload = {\"transaction\": transaction}\n    optional_params = [\n        (\"amount\", amount),\n        (\"currency\", currency),\n        (\"customer_note\", customer_note),\n        (\"merchant_note\", merchant_note),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or Refund,\n    )\n</code></pre>"},{"location":"reference/refunds/#pypaystack2.sub_clients.sync_clients.refunds.RefundClient.get_refund","title":"<code>get_refund(reference, alternate_model_class=None)</code>","text":"<p>Get details of a refund on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>reference</code> <code>str</code> <p>Identifier for transaction to be refunded</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[Refund] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/refunds.py</code> <pre><code>def get_refund(\n    self,\n    reference: str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[Refund] | Response[PaystackDataModel]:\n    \"\"\"Get details of a refund on your integration.\n\n    Args:\n        reference: Identifier for transaction to be refunded\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/refund/{reference}\")\n    return self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or Refund,\n    )\n</code></pre>"},{"location":"reference/refunds/#pypaystack2.sub_clients.sync_clients.refunds.RefundClient.get_refunds","title":"<code>get_refunds(reference=None, currency=None, pagination=50, page=1, start_date=None, end_date=None, alternate_model_class=None)</code>","text":"<p>Fetch refunds available on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>reference</code> <code>str | None</code> <p>Identifier for transaction to be refunded</p> <code>None</code> <code>currency</code> <code>Currency | None</code> <p>Any value from the <code>Currency</code> enum</p> <code>None</code> <code>pagination</code> <code>int</code> <p>Specifies how many records you want to retrieve per page. If not specified we use a default value of 50.</p> <code>50</code> <code>page</code> <code>int</code> <p>Specifies exactly what refund you want to page. If not specified we use a default value of 1.</p> <code>1</code> <code>start_date</code> <code>str | None</code> <p>A timestamp from which to start listing refund e.g. 2016-09-21</p> <code>None</code> <code>end_date</code> <code>str | None</code> <p>A timestamp at which to stop listing refund e.g. 2016-09-21</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[list[Refund]] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/refunds.py</code> <pre><code>def get_refunds(\n    self,\n    reference: str | None = None,\n    currency: Currency | None = None,\n    pagination: int = 50,\n    page: int = 1,\n    start_date: str | None = None,\n    end_date: str | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[list[Refund]] | Response[PaystackDataModel]:\n    \"\"\"Fetch refunds available on your integration.\n\n    Args:\n        reference: Identifier for transaction to be refunded\n        currency: Any value from the ``Currency`` enum\n        pagination: Specifies how many records you want to retrieve per page.\n            If not specified we use a default value of 50.\n        page: Specifies exactly what refund you want to page.\n            If not specified we use a default value of 1.\n        start_date: A timestamp from which to start listing refund e.g. 2016-09-21\n        end_date: A timestamp at which to stop listing refund e.g. 2016-09-21\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/refund?perPage={pagination}\")\n    query_params = [\n        (\"reference\", reference),\n        (\"currency\", currency),\n        (\"page\", page),\n        (\"start_date\", start_date),\n        (\"end_date\", end_date),\n    ]\n    url = append_query_params(query_params, url)\n    return self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or Refund,\n    )\n</code></pre>"},{"location":"reference/refunds/#pypaystack2.sub_clients.async_clients.refunds.AsyncRefundClient","title":"<code>AsyncRefundClient</code>","text":"<p>               Bases: <code>BaseAsyncAPIClient</code></p> <p>Provides a wrapper for paystack Refunds API</p> <p>The Refunds API allows you to create and manage transaction refunds. https://paystack.com/docs/api/refund/</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/refunds.py</code> <pre><code>class AsyncRefundClient(BaseAsyncAPIClient):\n    \"\"\"Provides a wrapper for paystack Refunds API\n\n    The Refunds API allows you to create and manage transaction refunds.\n    https://paystack.com/docs/api/refund/\n    \"\"\"\n\n    async def create(\n        self,\n        transaction: str,\n        amount: int | None = None,\n        currency: Currency | None = None,\n        customer_note: str | None = None,\n        merchant_note: str | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[Refund] | Response[PaystackDataModel]:\n        \"\"\"Initiate a refund on your integration\n\n        Args:\n            transaction: Transaction reference or id\n            amount: Amount ( in kobo if currency is NGN, pesewas, if currency is\n                GHS, and cents, if currency is ZAR ) to be refunded to the\n                customer. Amount is optional(defaults to original\n                transaction amount) and cannot be more than the original\n                transaction amount\n            currency: Any value from the ``Currency`` enum\n            customer_note: Customer reason\n            merchant_note: Merchant reason\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(\"/refund\")\n        payload = {\"transaction\": transaction}\n        optional_params = [\n            (\"amount\", amount),\n            (\"currency\", currency),\n            (\"customer_note\", customer_note),\n            (\"merchant_note\", merchant_note),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or Refund,\n        )\n\n    async def get_refunds(\n        self,\n        reference: str | None = None,\n        currency: Currency | None = None,\n        pagination: int = 50,\n        page: int = 1,\n        start_date: str | None = None,\n        end_date: str | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[list[Refund]] | Response[PaystackDataModel]:\n        \"\"\"Fetch refunds available on your integration.\n\n        Args:\n            reference: Identifier for transaction to be refunded\n            currency: Any value from the ``Currency`` enum\n            pagination: Specifies how many records you want to retrieve per page.\n                If not specified we use a default value of 50.\n            page: Specifies exactly what refund you want to page.\n                If not specified we use a default value of 1.\n            start_date: A timestamp from which to start listing refund e.g. 2016-09-21\n            end_date: A timestamp at which to stop listing refund e.g. 2016-09-21\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/refund?perPage={pagination}\")\n        query_params = [\n            (\"reference\", reference),\n            (\"currency\", currency),\n            (\"page\", page),\n            (\"start_date\", start_date),\n            (\"end_date\", end_date),\n        ]\n        url = append_query_params(query_params, url)\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or Refund,\n        )\n\n    async def get_refund(\n        self,\n        reference: str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[Refund] | Response[PaystackDataModel]:\n        \"\"\"Get details of a refund on your integration.\n\n        Args:\n            reference: Identifier for transaction to be refunded\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/refund/{reference}\")\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or Refund,\n        )\n</code></pre>"},{"location":"reference/refunds/#pypaystack2.sub_clients.async_clients.refunds.AsyncRefundClient.create","title":"<code>create(transaction, amount=None, currency=None, customer_note=None, merchant_note=None, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Initiate a refund on your integration</p> <p>Parameters:</p> Name Type Description Default <code>transaction</code> <code>str</code> <p>Transaction reference or id</p> required <code>amount</code> <code>int | None</code> <p>Amount ( in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR ) to be refunded to the customer. Amount is optional(defaults to original transaction amount) and cannot be more than the original transaction amount</p> <code>None</code> <code>currency</code> <code>Currency | None</code> <p>Any value from the <code>Currency</code> enum</p> <code>None</code> <code>customer_note</code> <code>str | None</code> <p>Customer reason</p> <code>None</code> <code>merchant_note</code> <code>str | None</code> <p>Merchant reason</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[Refund] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/refunds.py</code> <pre><code>async def create(\n    self,\n    transaction: str,\n    amount: int | None = None,\n    currency: Currency | None = None,\n    customer_note: str | None = None,\n    merchant_note: str | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[Refund] | Response[PaystackDataModel]:\n    \"\"\"Initiate a refund on your integration\n\n    Args:\n        transaction: Transaction reference or id\n        amount: Amount ( in kobo if currency is NGN, pesewas, if currency is\n            GHS, and cents, if currency is ZAR ) to be refunded to the\n            customer. Amount is optional(defaults to original\n            transaction amount) and cannot be more than the original\n            transaction amount\n        currency: Any value from the ``Currency`` enum\n        customer_note: Customer reason\n        merchant_note: Merchant reason\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(\"/refund\")\n    payload = {\"transaction\": transaction}\n    optional_params = [\n        (\"amount\", amount),\n        (\"currency\", currency),\n        (\"customer_note\", customer_note),\n        (\"merchant_note\", merchant_note),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or Refund,\n    )\n</code></pre>"},{"location":"reference/refunds/#pypaystack2.sub_clients.async_clients.refunds.AsyncRefundClient.get_refund","title":"<code>get_refund(reference, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Get details of a refund on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>reference</code> <code>str</code> <p>Identifier for transaction to be refunded</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[Refund] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/refunds.py</code> <pre><code>async def get_refund(\n    self,\n    reference: str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[Refund] | Response[PaystackDataModel]:\n    \"\"\"Get details of a refund on your integration.\n\n    Args:\n        reference: Identifier for transaction to be refunded\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/refund/{reference}\")\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or Refund,\n    )\n</code></pre>"},{"location":"reference/refunds/#pypaystack2.sub_clients.async_clients.refunds.AsyncRefundClient.get_refunds","title":"<code>get_refunds(reference=None, currency=None, pagination=50, page=1, start_date=None, end_date=None, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Fetch refunds available on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>reference</code> <code>str | None</code> <p>Identifier for transaction to be refunded</p> <code>None</code> <code>currency</code> <code>Currency | None</code> <p>Any value from the <code>Currency</code> enum</p> <code>None</code> <code>pagination</code> <code>int</code> <p>Specifies how many records you want to retrieve per page. If not specified we use a default value of 50.</p> <code>50</code> <code>page</code> <code>int</code> <p>Specifies exactly what refund you want to page. If not specified we use a default value of 1.</p> <code>1</code> <code>start_date</code> <code>str | None</code> <p>A timestamp from which to start listing refund e.g. 2016-09-21</p> <code>None</code> <code>end_date</code> <code>str | None</code> <p>A timestamp at which to stop listing refund e.g. 2016-09-21</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[list[Refund]] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/refunds.py</code> <pre><code>async def get_refunds(\n    self,\n    reference: str | None = None,\n    currency: Currency | None = None,\n    pagination: int = 50,\n    page: int = 1,\n    start_date: str | None = None,\n    end_date: str | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[list[Refund]] | Response[PaystackDataModel]:\n    \"\"\"Fetch refunds available on your integration.\n\n    Args:\n        reference: Identifier for transaction to be refunded\n        currency: Any value from the ``Currency`` enum\n        pagination: Specifies how many records you want to retrieve per page.\n            If not specified we use a default value of 50.\n        page: Specifies exactly what refund you want to page.\n            If not specified we use a default value of 1.\n        start_date: A timestamp from which to start listing refund e.g. 2016-09-21\n        end_date: A timestamp at which to stop listing refund e.g. 2016-09-21\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/refund?perPage={pagination}\")\n    query_params = [\n        (\"reference\", reference),\n        (\"currency\", currency),\n        (\"page\", page),\n        (\"start_date\", start_date),\n        (\"end_date\", end_date),\n    ]\n    url = append_query_params(query_params, url)\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or Refund,\n    )\n</code></pre>"},{"location":"reference/settlements/","title":"Settlements","text":""},{"location":"reference/settlements/#pypaystack2.sub_clients.sync_clients.settlements.SettlementClient","title":"<code>SettlementClient</code>","text":"<p>               Bases: <code>BaseAPIClient</code></p> <p>Provides a wrapper for paystack Settlement API</p> <p>The Settlements API allows you to gain insights into payouts made by Paystack to your bank account. https://paystack.com/docs/api/settlement/</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/settlements.py</code> <pre><code>class SettlementClient(BaseAPIClient):\n    \"\"\"Provides a wrapper for paystack Settlement API\n\n    The Settlements API allows you to gain insights into payouts made by Paystack to your bank account.\n    https://paystack.com/docs/api/settlement/\n    \"\"\"\n\n    def get_settlements(\n        self,\n        page: int = 1,\n        pagination: int = 50,\n        start_date: str | None = None,\n        end_date: str | None = None,\n        subaccount: str | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[list[Settlement]] | Response[PaystackDataModel]:\n        \"\"\"Fetch settlements made to your settlement accounts.\n\n        Args:\n            page: Specifies exactly what page you want to retrieve.\n                If not specified we use a default value of 1.\n            pagination: Specifies how many records you want to retrieve per page.\n                If not specified we use a default value of 50.\n            start_date: A timestamp from which to start listing settlements e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            end_date: A timestamp at which to stop listing settlements e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            subaccount: Provide a subaccount ID to export only settlements for that subaccount.\n                Set to ``none`` to export only transactions for the account.\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/settlement?perPage={pagination}\")\n        query_params = [\n            (\"subaccount\", subaccount),\n            (\"page\", page),\n            (\"start_date\", start_date),\n            (\"end_date\", end_date),\n        ]\n        url = append_query_params(query_params, url)\n        return self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or Settlement,\n        )\n\n    def get_settlement_transactions(\n        self,\n        id_: int | str,\n        pagination: int = 50,\n        page: int = 1,\n        start_date: str | None = None,\n        end_date: str | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[Transaction] | Response[PaystackDataModel]:\n        \"\"\"Get the transactions that make up a particular settlement\n\n        Args:\n            id_: The settlement ID in which you want to fetch its transactions\n            pagination: Specifies how many records you want to retrieve per page. If not specified we\n                use a default value of 50.\n            page: Specifies exactly what page you want to retrieve. If not specified we use a default value of 1.\n            start_date: A timestamp from which to start listing settlement transactions\n                e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            end_date: A timestamp at which to stop listing settlement transactions\n                e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/settlement/{id_}/transactions?perPage={pagination}\")\n        query_params = [\n            (\"page\", page),\n            (\"start_date\", start_date),\n            (\"end_date\", end_date),\n        ]\n        url = append_query_params(query_params, url)\n        return self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or Transaction,\n        )\n</code></pre>"},{"location":"reference/settlements/#pypaystack2.sub_clients.sync_clients.settlements.SettlementClient.get_settlement_transactions","title":"<code>get_settlement_transactions(id_, pagination=50, page=1, start_date=None, end_date=None, alternate_model_class=None)</code>","text":"<p>Get the transactions that make up a particular settlement</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>int | str</code> <p>The settlement ID in which you want to fetch its transactions</p> required <code>pagination</code> <code>int</code> <p>Specifies how many records you want to retrieve per page. If not specified we use a default value of 50.</p> <code>50</code> <code>page</code> <code>int</code> <p>Specifies exactly what page you want to retrieve. If not specified we use a default value of 1.</p> <code>1</code> <code>start_date</code> <code>str | None</code> <p>A timestamp from which to start listing settlement transactions e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>end_date</code> <code>str | None</code> <p>A timestamp at which to stop listing settlement transactions e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[Transaction] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/settlements.py</code> <pre><code>def get_settlement_transactions(\n    self,\n    id_: int | str,\n    pagination: int = 50,\n    page: int = 1,\n    start_date: str | None = None,\n    end_date: str | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[Transaction] | Response[PaystackDataModel]:\n    \"\"\"Get the transactions that make up a particular settlement\n\n    Args:\n        id_: The settlement ID in which you want to fetch its transactions\n        pagination: Specifies how many records you want to retrieve per page. If not specified we\n            use a default value of 50.\n        page: Specifies exactly what page you want to retrieve. If not specified we use a default value of 1.\n        start_date: A timestamp from which to start listing settlement transactions\n            e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        end_date: A timestamp at which to stop listing settlement transactions\n            e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/settlement/{id_}/transactions?perPage={pagination}\")\n    query_params = [\n        (\"page\", page),\n        (\"start_date\", start_date),\n        (\"end_date\", end_date),\n    ]\n    url = append_query_params(query_params, url)\n    return self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or Transaction,\n    )\n</code></pre>"},{"location":"reference/settlements/#pypaystack2.sub_clients.sync_clients.settlements.SettlementClient.get_settlements","title":"<code>get_settlements(page=1, pagination=50, start_date=None, end_date=None, subaccount=None, alternate_model_class=None)</code>","text":"<p>Fetch settlements made to your settlement accounts.</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>int</code> <p>Specifies exactly what page you want to retrieve. If not specified we use a default value of 1.</p> <code>1</code> <code>pagination</code> <code>int</code> <p>Specifies how many records you want to retrieve per page. If not specified we use a default value of 50.</p> <code>50</code> <code>start_date</code> <code>str | None</code> <p>A timestamp from which to start listing settlements e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>end_date</code> <code>str | None</code> <p>A timestamp at which to stop listing settlements e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>subaccount</code> <code>str | None</code> <p>Provide a subaccount ID to export only settlements for that subaccount. Set to <code>none</code> to export only transactions for the account.</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[list[Settlement]] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/settlements.py</code> <pre><code>def get_settlements(\n    self,\n    page: int = 1,\n    pagination: int = 50,\n    start_date: str | None = None,\n    end_date: str | None = None,\n    subaccount: str | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[list[Settlement]] | Response[PaystackDataModel]:\n    \"\"\"Fetch settlements made to your settlement accounts.\n\n    Args:\n        page: Specifies exactly what page you want to retrieve.\n            If not specified we use a default value of 1.\n        pagination: Specifies how many records you want to retrieve per page.\n            If not specified we use a default value of 50.\n        start_date: A timestamp from which to start listing settlements e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        end_date: A timestamp at which to stop listing settlements e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        subaccount: Provide a subaccount ID to export only settlements for that subaccount.\n            Set to ``none`` to export only transactions for the account.\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/settlement?perPage={pagination}\")\n    query_params = [\n        (\"subaccount\", subaccount),\n        (\"page\", page),\n        (\"start_date\", start_date),\n        (\"end_date\", end_date),\n    ]\n    url = append_query_params(query_params, url)\n    return self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or Settlement,\n    )\n</code></pre>"},{"location":"reference/settlements/#pypaystack2.sub_clients.async_clients.settlements.AsyncSettlementClient","title":"<code>AsyncSettlementClient</code>","text":"<p>               Bases: <code>BaseAsyncAPIClient</code></p> <p>Provides a wrapper for paystack Settlement API</p> <p>The Settlements API allows you to gain insights into payouts made by Paystack to your bank account. https://paystack.com/docs/api/settlement/</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/settlements.py</code> <pre><code>class AsyncSettlementClient(BaseAsyncAPIClient):\n    \"\"\"Provides a wrapper for paystack Settlement API\n\n    The Settlements API allows you to gain insights into payouts made by Paystack to your bank account.\n    https://paystack.com/docs/api/settlement/\n    \"\"\"\n\n    async def get_settlements(\n        self,\n        page: int = 1,\n        pagination: int = 50,\n        start_date: str | None = None,\n        end_date: str | None = None,\n        subaccount: str | None = None,\n        alternate_model_class: Type[PaystackDataModel] | None = None,\n    ) -&gt; Response[list[Settlement]] | Response[PaystackDataModel]:\n        \"\"\"Fetch settlements made to your settlement accounts.\n\n        Args:\n            page: Specifies exactly what page you want to retrieve.\n                If not specified we use a default value of 1.\n            pagination: Specifies how many records you want to retrieve per page.\n                If not specified we use a default value of 50.\n            start_date: A timestamp from which to start listing settlements e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            end_date: A timestamp at which to stop listing settlements e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            subaccount: Provide a subaccount ID to export only settlements for that subaccount.\n                Set to ``none`` to export only transactions for the account.\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/settlement?perPage={pagination}\")\n        query_params = [\n            (\"subaccount\", subaccount),\n            (\"page\", page),\n            (\"start_date\", start_date),\n            (\"end_date\", end_date),\n        ]\n        url = append_query_params(query_params, url)\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or Settlement,\n        )\n\n    async def get_settlement_transactions(\n        self,\n        id_: int | str,\n        pagination: int = 50,\n        page: int = 1,\n        start_date: str | None = None,\n        end_date: str | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[Transaction] | Response[PaystackDataModel]:\n        \"\"\"Get the transactions that make up a particular settlement\n\n        Args:\n            id_: The settlement ID in which you want to fetch its transactions\n            pagination: Specifies how many records you want to retrieve per page. If not specified we\n                use a default value of 50.\n            page: Specifies exactly what page you want to retrieve. If not specified we use a default value of 1.\n            start_date: A timestamp from which to start listing settlement transactions\n                e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            end_date: A timestamp at which to stop listing settlement transactions\n                e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/settlement/{id_}/transactions?perPage={pagination}\")\n        query_params = [\n            (\"page\", page),\n            (\"start_date\", start_date),\n            (\"end_date\", end_date),\n        ]\n        url = append_query_params(query_params, url)\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or Transaction,\n        )\n</code></pre>"},{"location":"reference/settlements/#pypaystack2.sub_clients.async_clients.settlements.AsyncSettlementClient.get_settlement_transactions","title":"<code>get_settlement_transactions(id_, pagination=50, page=1, start_date=None, end_date=None, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Get the transactions that make up a particular settlement</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>int | str</code> <p>The settlement ID in which you want to fetch its transactions</p> required <code>pagination</code> <code>int</code> <p>Specifies how many records you want to retrieve per page. If not specified we use a default value of 50.</p> <code>50</code> <code>page</code> <code>int</code> <p>Specifies exactly what page you want to retrieve. If not specified we use a default value of 1.</p> <code>1</code> <code>start_date</code> <code>str | None</code> <p>A timestamp from which to start listing settlement transactions e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>end_date</code> <code>str | None</code> <p>A timestamp at which to stop listing settlement transactions e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[Transaction] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/settlements.py</code> <pre><code>async def get_settlement_transactions(\n    self,\n    id_: int | str,\n    pagination: int = 50,\n    page: int = 1,\n    start_date: str | None = None,\n    end_date: str | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[Transaction] | Response[PaystackDataModel]:\n    \"\"\"Get the transactions that make up a particular settlement\n\n    Args:\n        id_: The settlement ID in which you want to fetch its transactions\n        pagination: Specifies how many records you want to retrieve per page. If not specified we\n            use a default value of 50.\n        page: Specifies exactly what page you want to retrieve. If not specified we use a default value of 1.\n        start_date: A timestamp from which to start listing settlement transactions\n            e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        end_date: A timestamp at which to stop listing settlement transactions\n            e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/settlement/{id_}/transactions?perPage={pagination}\")\n    query_params = [\n        (\"page\", page),\n        (\"start_date\", start_date),\n        (\"end_date\", end_date),\n    ]\n    url = append_query_params(query_params, url)\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or Transaction,\n    )\n</code></pre>"},{"location":"reference/settlements/#pypaystack2.sub_clients.async_clients.settlements.AsyncSettlementClient.get_settlements","title":"<code>get_settlements(page=1, pagination=50, start_date=None, end_date=None, subaccount=None, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Fetch settlements made to your settlement accounts.</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>int</code> <p>Specifies exactly what page you want to retrieve. If not specified we use a default value of 1.</p> <code>1</code> <code>pagination</code> <code>int</code> <p>Specifies how many records you want to retrieve per page. If not specified we use a default value of 50.</p> <code>50</code> <code>start_date</code> <code>str | None</code> <p>A timestamp from which to start listing settlements e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>end_date</code> <code>str | None</code> <p>A timestamp at which to stop listing settlements e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>subaccount</code> <code>str | None</code> <p>Provide a subaccount ID to export only settlements for that subaccount. Set to <code>none</code> to export only transactions for the account.</p> <code>None</code> <code>alternate_model_class</code> <code>Type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[list[Settlement]] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/settlements.py</code> <pre><code>async def get_settlements(\n    self,\n    page: int = 1,\n    pagination: int = 50,\n    start_date: str | None = None,\n    end_date: str | None = None,\n    subaccount: str | None = None,\n    alternate_model_class: Type[PaystackDataModel] | None = None,\n) -&gt; Response[list[Settlement]] | Response[PaystackDataModel]:\n    \"\"\"Fetch settlements made to your settlement accounts.\n\n    Args:\n        page: Specifies exactly what page you want to retrieve.\n            If not specified we use a default value of 1.\n        pagination: Specifies how many records you want to retrieve per page.\n            If not specified we use a default value of 50.\n        start_date: A timestamp from which to start listing settlements e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        end_date: A timestamp at which to stop listing settlements e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        subaccount: Provide a subaccount ID to export only settlements for that subaccount.\n            Set to ``none`` to export only transactions for the account.\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/settlement?perPage={pagination}\")\n    query_params = [\n        (\"subaccount\", subaccount),\n        (\"page\", page),\n        (\"start_date\", start_date),\n        (\"end_date\", end_date),\n    ]\n    url = append_query_params(query_params, url)\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or Settlement,\n    )\n</code></pre>"},{"location":"reference/splits/","title":"Splits","text":""},{"location":"reference/splits/#pypaystack2.sub_clients.sync_clients.splits.TransactionSplitClient","title":"<code>TransactionSplitClient</code>","text":"<p>               Bases: <code>BaseAPIClient</code></p> <p>Provides a wrapper for paystack Transaction Splits API</p> <p>The Transaction Splits API enables merchants split the settlement for a transaction across their payout account, and one or more Subaccounts. https://paystack.com/docs/api/split/</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/splits.py</code> <pre><code>class TransactionSplitClient(BaseAPIClient):\n    \"\"\"Provides a wrapper for paystack Transaction Splits API\n\n    The Transaction Splits API enables merchants split the settlement for a transaction\n    across their payout account, and one or more Subaccounts.\n    https://paystack.com/docs/api/split/\n    \"\"\"\n\n    def create(\n        self,\n        name: str,\n        type_: Split,\n        currency: Currency,\n        subaccounts: list[SplitAccount],\n        bearer_type: Bearer,\n        bearer_subaccount: str | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[TransactionSplit] | Response[PaystackDataModel]:\n        \"\"\"Create a split payment on your integration\n\n        Args:\n            name: Name of the transaction split\n            type_: The type of transaction split you want to create.\n                Any value from the ``SplitType`` enum\n            currency: Any value from the ``Currency`` enum\n            subaccounts: A list of dictionaries containing subaccount code and\n                number of shares: ``[{subaccount: 'ACT_xxxxxxxxxx', share: xxx},{...}]``\n            bearer_type: Any value from the ``Bearer`` enum\n            bearer_subaccount: Subaccount code\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n        _subaccounts = [account.model_dump() for account in subaccounts]\n\n        url = self._full_url(\"/split\")\n        payload = {\n            \"name\": name,\n            \"type\": type_,\n            \"currency\": currency,\n            \"subaccounts\": _subaccounts,\n            \"bearer_type\": bearer_type,\n            \"bearer_subaccount\": bearer_subaccount,\n        }\n        return self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or TransactionSplit,\n        )\n\n    def get_splits(\n        self,\n        name: str | None = None,\n        sort_by: str | None = None,\n        page: int | None = None,\n        start_date: str | None = None,\n        end_date: str | None = None,\n        active: bool = True,\n        pagination: int = 50,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[list[TransactionSplit]] | Response[PaystackDataModel]:\n        \"\"\"Get/search for the transaction splits available on your integration.\n\n        Args:\n            name: The name of the split\n            sort_by: Sort by name, defaults to createdAt date\n            page: Page number to view. If not specify we use a default value of 1.\n            start_date: A timestamp from which to start listing splits e.g. 2019-09-24T00:00:05.000Z, 2019-09-21\n            end_date: A timestamp at which to stop listing splits e.g. 2019-09-24T00:00:05.000Z, 2019-09-21\n            active: Flag to filter by active\n            pagination: Number of splits per page. If not specified we use a default value of 50.\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/split?perPage={pagination}\")\n        query_params = [\n            (\"name\", name),\n            (\"sort_by\", sort_by),\n            (\"page\", page),\n            (\"from\", start_date),\n            (\"to\", end_date),\n            (\"active\", str(active).lower()),\n        ]\n        url = append_query_params(query_params, url)\n\n        return self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or TransactionSplit,\n        )\n\n    def get_split(\n        self,\n        id_or_code: int | str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[TransactionSplit] | Response[PaystackDataModel]:\n        \"\"\"Get details of a split on your integration.\n\n        Args:\n            id_or_code: The id of the split\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._full_url(f\"/split/{id_or_code}/\")\n        return self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or TransactionSplit,\n        )\n\n    def update(\n        self,\n        id_: int | str,\n        name: str,\n        active: bool,\n        bearer_type: Bearer | None = None,\n        bearer_subaccount: str | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[TransactionSplit] | Response[PaystackDataModel]:\n        \"\"\"Update a transaction split details on your integration\n\n        Args:\n            id_: Split ID\n            name: Name of the transaction split\n            active: Flag for active\n            bearer_type: Any value from the Bearer enum\n            bearer_subaccount: Subaccount code of a subaccount in the split group.\n                This should be specified only if the bearer_type\n                is ``Bearer.subaccount``\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        if bearer_subaccount:\n            if bearer_type != Bearer.SUB_ACCOUNT:\n                raise ValueError(\n                    \"`bearer_subaccount` can only have a value if `bearer_type` is `Bearer.SUBACCOUNT`\"\n                )\n\n        payload = {\n            \"name\": name,\n            \"active\": active,\n        }\n        optional_params = [\n            (\"bearer_type\", bearer_type),\n            (\"bearer_subaccount\", bearer_subaccount),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        url = self._full_url(f\"/split/{id_}/\")\n        return self._handle_request(  # type: ignore\n            HTTPMethod.PUT,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or TransactionSplit,\n        )\n\n    def add_or_update(\n        self,\n        id_: int | str,\n        subaccount: str,\n        share: int | float,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[TransactionSplit] | Response[PaystackDataModel]:\n        \"\"\"\n        Add a Subaccount to a Transaction Split, or update\n        the share of an existing Subaccount in a Transaction Split\n\n        Args:\n         id_: Split ID\n         subaccount: This is the subaccount code\n         share: This is the transaction share for the subaccount\n         alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        payload = {\"subaccount\": subaccount, \"share\": share}\n        url = self._full_url(f\"/split/{id_}/subaccount/add\")\n        return self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or TransactionSplit,\n        )\n\n    def remove(\n        self,\n        id_: int | str,\n        subaccount: str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[None] | Response[PaystackDataModel]:\n        \"\"\"Remove a subaccount from a transaction split\n\n        Args:\n            id_: Split ID\n            subaccount: This is the subaccount code\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        payload = {\"subaccount\": subaccount}\n        url = self._full_url(f\"/split/{id_}/subaccount/remove\")\n        return self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class,\n        )\n</code></pre>"},{"location":"reference/splits/#pypaystack2.sub_clients.sync_clients.splits.TransactionSplitClient.add_or_update","title":"<code>add_or_update(id_, subaccount, share, alternate_model_class=None)</code>","text":"<p>Add a Subaccount to a Transaction Split, or update the share of an existing Subaccount in a Transaction Split</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>int | str</code> <p>Split ID</p> required <code>subaccount</code> <code>str</code> <p>This is the subaccount code</p> required <code>share</code> <code>int | float</code> <p>This is the transaction share for the subaccount</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the   default pydantic model used by the library to present the data in   the <code>Response.data</code>. The default behaviour of the library is to   set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data   returned from paystack with the model provided in the library.   Providing a pydantic model class via this parameter overrides   the library default model with the model class you provide.   This can come in handy when the models in the library do not   accurately represent the data returned, and you prefer working with the   data as a pydantic model instead of as a dict of the response returned   by  paystack before it is serialized with pydantic models, The original   data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[TransactionSplit] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/splits.py</code> <pre><code>def add_or_update(\n    self,\n    id_: int | str,\n    subaccount: str,\n    share: int | float,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[TransactionSplit] | Response[PaystackDataModel]:\n    \"\"\"\n    Add a Subaccount to a Transaction Split, or update\n    the share of an existing Subaccount in a Transaction Split\n\n    Args:\n     id_: Split ID\n     subaccount: This is the subaccount code\n     share: This is the transaction share for the subaccount\n     alternate_model_class: A pydantic model class to use instead of the\n        default pydantic model used by the library to present the data in\n        the `Response.data`. The default behaviour of the library is to\n        set  `Response.data` to `None` if it fails to serialize the data\n        returned from paystack with the model provided in the library.\n        Providing a pydantic model class via this parameter overrides\n        the library default model with the model class you provide.\n        This can come in handy when the models in the library do not\n        accurately represent the data returned, and you prefer working with the\n        data as a pydantic model instead of as a dict of the response returned\n        by  paystack before it is serialized with pydantic models, The original\n        data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    payload = {\"subaccount\": subaccount, \"share\": share}\n    url = self._full_url(f\"/split/{id_}/subaccount/add\")\n    return self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or TransactionSplit,\n    )\n</code></pre>"},{"location":"reference/splits/#pypaystack2.sub_clients.sync_clients.splits.TransactionSplitClient.create","title":"<code>create(name, type_, currency, subaccounts, bearer_type, bearer_subaccount=None, alternate_model_class=None)</code>","text":"<p>Create a split payment on your integration</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the transaction split</p> required <code>type_</code> <code>Split</code> <p>The type of transaction split you want to create. Any value from the <code>SplitType</code> enum</p> required <code>currency</code> <code>Currency</code> <p>Any value from the <code>Currency</code> enum</p> required <code>subaccounts</code> <code>list[SplitAccount]</code> <p>A list of dictionaries containing subaccount code and number of shares: <code>[{subaccount: 'ACT_xxxxxxxxxx', share: xxx},{...}]</code></p> required <code>bearer_type</code> <code>Bearer</code> <p>Any value from the <code>Bearer</code> enum</p> required <code>bearer_subaccount</code> <code>str | None</code> <p>Subaccount code</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[TransactionSplit] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/splits.py</code> <pre><code>def create(\n    self,\n    name: str,\n    type_: Split,\n    currency: Currency,\n    subaccounts: list[SplitAccount],\n    bearer_type: Bearer,\n    bearer_subaccount: str | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[TransactionSplit] | Response[PaystackDataModel]:\n    \"\"\"Create a split payment on your integration\n\n    Args:\n        name: Name of the transaction split\n        type_: The type of transaction split you want to create.\n            Any value from the ``SplitType`` enum\n        currency: Any value from the ``Currency`` enum\n        subaccounts: A list of dictionaries containing subaccount code and\n            number of shares: ``[{subaccount: 'ACT_xxxxxxxxxx', share: xxx},{...}]``\n        bearer_type: Any value from the ``Bearer`` enum\n        bearer_subaccount: Subaccount code\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n    _subaccounts = [account.model_dump() for account in subaccounts]\n\n    url = self._full_url(\"/split\")\n    payload = {\n        \"name\": name,\n        \"type\": type_,\n        \"currency\": currency,\n        \"subaccounts\": _subaccounts,\n        \"bearer_type\": bearer_type,\n        \"bearer_subaccount\": bearer_subaccount,\n    }\n    return self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or TransactionSplit,\n    )\n</code></pre>"},{"location":"reference/splits/#pypaystack2.sub_clients.sync_clients.splits.TransactionSplitClient.get_split","title":"<code>get_split(id_or_code, alternate_model_class=None)</code>","text":"<p>Get details of a split on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>id_or_code</code> <code>int | str</code> <p>The id of the split</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[TransactionSplit] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/splits.py</code> <pre><code>def get_split(\n    self,\n    id_or_code: int | str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[TransactionSplit] | Response[PaystackDataModel]:\n    \"\"\"Get details of a split on your integration.\n\n    Args:\n        id_or_code: The id of the split\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._full_url(f\"/split/{id_or_code}/\")\n    return self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or TransactionSplit,\n    )\n</code></pre>"},{"location":"reference/splits/#pypaystack2.sub_clients.sync_clients.splits.TransactionSplitClient.get_splits","title":"<code>get_splits(name=None, sort_by=None, page=None, start_date=None, end_date=None, active=True, pagination=50, alternate_model_class=None)</code>","text":"<p>Get/search for the transaction splits available on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>The name of the split</p> <code>None</code> <code>sort_by</code> <code>str | None</code> <p>Sort by name, defaults to createdAt date</p> <code>None</code> <code>page</code> <code>int | None</code> <p>Page number to view. If not specify we use a default value of 1.</p> <code>None</code> <code>start_date</code> <code>str | None</code> <p>A timestamp from which to start listing splits e.g. 2019-09-24T00:00:05.000Z, 2019-09-21</p> <code>None</code> <code>end_date</code> <code>str | None</code> <p>A timestamp at which to stop listing splits e.g. 2019-09-24T00:00:05.000Z, 2019-09-21</p> <code>None</code> <code>active</code> <code>bool</code> <p>Flag to filter by active</p> <code>True</code> <code>pagination</code> <code>int</code> <p>Number of splits per page. If not specified we use a default value of 50.</p> <code>50</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[list[TransactionSplit]] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/splits.py</code> <pre><code>def get_splits(\n    self,\n    name: str | None = None,\n    sort_by: str | None = None,\n    page: int | None = None,\n    start_date: str | None = None,\n    end_date: str | None = None,\n    active: bool = True,\n    pagination: int = 50,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[list[TransactionSplit]] | Response[PaystackDataModel]:\n    \"\"\"Get/search for the transaction splits available on your integration.\n\n    Args:\n        name: The name of the split\n        sort_by: Sort by name, defaults to createdAt date\n        page: Page number to view. If not specify we use a default value of 1.\n        start_date: A timestamp from which to start listing splits e.g. 2019-09-24T00:00:05.000Z, 2019-09-21\n        end_date: A timestamp at which to stop listing splits e.g. 2019-09-24T00:00:05.000Z, 2019-09-21\n        active: Flag to filter by active\n        pagination: Number of splits per page. If not specified we use a default value of 50.\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/split?perPage={pagination}\")\n    query_params = [\n        (\"name\", name),\n        (\"sort_by\", sort_by),\n        (\"page\", page),\n        (\"from\", start_date),\n        (\"to\", end_date),\n        (\"active\", str(active).lower()),\n    ]\n    url = append_query_params(query_params, url)\n\n    return self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or TransactionSplit,\n    )\n</code></pre>"},{"location":"reference/splits/#pypaystack2.sub_clients.sync_clients.splits.TransactionSplitClient.remove","title":"<code>remove(id_, subaccount, alternate_model_class=None)</code>","text":"<p>Remove a subaccount from a transaction split</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>int | str</code> <p>Split ID</p> required <code>subaccount</code> <code>str</code> <p>This is the subaccount code</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[None] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/splits.py</code> <pre><code>def remove(\n    self,\n    id_: int | str,\n    subaccount: str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[None] | Response[PaystackDataModel]:\n    \"\"\"Remove a subaccount from a transaction split\n\n    Args:\n        id_: Split ID\n        subaccount: This is the subaccount code\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    payload = {\"subaccount\": subaccount}\n    url = self._full_url(f\"/split/{id_}/subaccount/remove\")\n    return self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class,\n    )\n</code></pre>"},{"location":"reference/splits/#pypaystack2.sub_clients.sync_clients.splits.TransactionSplitClient.update","title":"<code>update(id_, name, active, bearer_type=None, bearer_subaccount=None, alternate_model_class=None)</code>","text":"<p>Update a transaction split details on your integration</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>int | str</code> <p>Split ID</p> required <code>name</code> <code>str</code> <p>Name of the transaction split</p> required <code>active</code> <code>bool</code> <p>Flag for active</p> required <code>bearer_type</code> <code>Bearer | None</code> <p>Any value from the Bearer enum</p> <code>None</code> <code>bearer_subaccount</code> <code>str | None</code> <p>Subaccount code of a subaccount in the split group. This should be specified only if the bearer_type is <code>Bearer.subaccount</code></p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[TransactionSplit] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/splits.py</code> <pre><code>def update(\n    self,\n    id_: int | str,\n    name: str,\n    active: bool,\n    bearer_type: Bearer | None = None,\n    bearer_subaccount: str | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[TransactionSplit] | Response[PaystackDataModel]:\n    \"\"\"Update a transaction split details on your integration\n\n    Args:\n        id_: Split ID\n        name: Name of the transaction split\n        active: Flag for active\n        bearer_type: Any value from the Bearer enum\n        bearer_subaccount: Subaccount code of a subaccount in the split group.\n            This should be specified only if the bearer_type\n            is ``Bearer.subaccount``\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    if bearer_subaccount:\n        if bearer_type != Bearer.SUB_ACCOUNT:\n            raise ValueError(\n                \"`bearer_subaccount` can only have a value if `bearer_type` is `Bearer.SUBACCOUNT`\"\n            )\n\n    payload = {\n        \"name\": name,\n        \"active\": active,\n    }\n    optional_params = [\n        (\"bearer_type\", bearer_type),\n        (\"bearer_subaccount\", bearer_subaccount),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    url = self._full_url(f\"/split/{id_}/\")\n    return self._handle_request(  # type: ignore\n        HTTPMethod.PUT,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or TransactionSplit,\n    )\n</code></pre>"},{"location":"reference/splits/#pypaystack2.sub_clients.async_clients.splits.AsyncTransactionSplitClient","title":"<code>AsyncTransactionSplitClient</code>","text":"<p>               Bases: <code>BaseAsyncAPIClient</code></p> <p>Provides a wrapper for paystack Transaction Splits API</p> <p>The Transaction Splits API enables merchants split the settlement for a transaction across their payout account, and one or more Subaccounts. https://paystack.com/docs/api/split/</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/splits.py</code> <pre><code>class AsyncTransactionSplitClient(BaseAsyncAPIClient):\n    \"\"\"Provides a wrapper for paystack Transaction Splits API\n\n    The Transaction Splits API enables merchants split the settlement for a transaction\n    across their payout account, and one or more Subaccounts.\n    https://paystack.com/docs/api/split/\n    \"\"\"\n\n    async def create(\n        self,\n        name: str,\n        type_: Split,\n        currency: Currency,\n        subaccounts: list[SplitAccount],\n        bearer_type: Bearer,\n        bearer_subaccount: str | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[TransactionSplit] | Response[PaystackDataModel]:\n        \"\"\"Create a split payment on your integration\n\n        Args:\n            name: Name of the transaction split\n            type_: The type of transaction split you want to create.\n                Any value from the ``SplitType`` enum\n            currency: Any value from the ``Currency`` enum\n            subaccounts: A list of dictionaries containing subaccount code and\n                number of shares: ``[{subaccount: 'ACT_xxxxxxxxxx', share: xxx},{...}]``\n            bearer_type: Any value from the ``Bearer`` enum\n            bearer_subaccount: Subaccount code\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n        _subaccounts = [account.model_dump() for account in subaccounts]\n\n        url = self._full_url(\"/split\")\n        payload = {\n            \"name\": name,\n            \"type\": type_,\n            \"currency\": currency,\n            \"subaccounts\": _subaccounts,\n            \"bearer_type\": bearer_type,\n            \"bearer_subaccount\": bearer_subaccount,\n        }\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or TransactionSplit,\n        )\n\n    async def get_splits(\n        self,\n        name: str | None = None,\n        sort_by: str | None = None,\n        page: int | None = None,\n        start_date: str | None = None,\n        end_date: str | None = None,\n        active: bool = True,\n        pagination: int = 50,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[list[TransactionSplit]] | Response[PaystackDataModel]:\n        \"\"\"Get/search for the transaction splits available on your integration.\n\n        Args:\n            name: The name of the split\n            sort_by: Sort by name, defaults to createdAt date\n            page: Page number to view. If not specify we use a default value of 1.\n            start_date: A timestamp from which to start listing splits e.g. 2019-09-24T00:00:05.000Z, 2019-09-21\n            end_date: A timestamp at which to stop listing splits e.g. 2019-09-24T00:00:05.000Z, 2019-09-21\n            active: Flag to filter by active\n            pagination: Number of splits per page. If not specified we use a default value of 50.\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/split?perPage={pagination}\")\n        query_params = [\n            (\"name\", name),\n            (\"sort_by\", sort_by),\n            (\"page\", page),\n            (\"from\", start_date),\n            (\"to\", end_date),\n            (\"active\", str(active).lower()),\n        ]\n        url = append_query_params(query_params, url)\n\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or TransactionSplit,\n        )\n\n    async def get_split(\n        self,\n        id_or_code: int | str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[TransactionSplit] | Response[PaystackDataModel]:\n        \"\"\"Get details of a split on your integration.\n\n        Args:\n            id_or_code: The id of the split\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._full_url(f\"/split/{id_or_code}/\")\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or TransactionSplit,\n        )\n\n    async def update(\n        self,\n        id_: int | str,\n        name: str,\n        active: bool,\n        bearer_type: Bearer | None = None,\n        bearer_subaccount: str | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[TransactionSplit] | Response[PaystackDataModel]:\n        \"\"\"Update a transaction split details on your integration\n\n        Args:\n            id_: Split ID\n            name: Name of the transaction split\n            active: Flag for active\n            bearer_type: Any value from the Bearer enum\n            bearer_subaccount: Subaccount code of a subaccount in the split group.\n                This should be specified only if the bearer_type\n                is ``Bearer.subaccount``\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        if bearer_subaccount:\n            if bearer_type != Bearer.SUB_ACCOUNT:\n                raise ValueError(\n                    \"`bearer_subaccount` can only have a value if `bearer_type` is `Bearer.SUBACCOUNT`\"\n                )\n\n        payload = {\n            \"name\": name,\n            \"active\": active,\n        }\n        optional_params = [\n            (\"bearer_type\", bearer_type),\n            (\"bearer_subaccount\", bearer_subaccount),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        url = self._full_url(f\"/split/{id_}/\")\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.PUT,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or TransactionSplit,\n        )\n\n    async def add_or_update(\n        self,\n        id_: int | str,\n        subaccount: str,\n        share: int | float,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[TransactionSplit] | Response[PaystackDataModel]:\n        \"\"\"\n        Add a Subaccount to a Transaction Split, or update\n        the share of an existing Subaccount in a Transaction Split\n\n        Args:\n         id_: Split ID\n         subaccount: This is the subaccount code\n         share: This is the transaction share for the subaccount\n         alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        payload = {\"subaccount\": subaccount, \"share\": share}\n        url = self._full_url(f\"/split/{id_}/subaccount/add\")\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or TransactionSplit,\n        )\n\n    async def remove(\n        self,\n        id_: int | str,\n        subaccount: str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[None] | Response[PaystackDataModel]:\n        \"\"\"Remove a subaccount from a transaction split\n\n        Args:\n            id_: Split ID\n            subaccount: This is the subaccount code\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        payload = {\"subaccount\": subaccount}\n        url = self._full_url(f\"/split/{id_}/subaccount/remove\")\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class,\n        )\n</code></pre>"},{"location":"reference/splits/#pypaystack2.sub_clients.async_clients.splits.AsyncTransactionSplitClient.add_or_update","title":"<code>add_or_update(id_, subaccount, share, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Add a Subaccount to a Transaction Split, or update the share of an existing Subaccount in a Transaction Split</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>int | str</code> <p>Split ID</p> required <code>subaccount</code> <code>str</code> <p>This is the subaccount code</p> required <code>share</code> <code>int | float</code> <p>This is the transaction share for the subaccount</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the   default pydantic model used by the library to present the data in   the <code>Response.data</code>. The default behaviour of the library is to   set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data   returned from paystack with the model provided in the library.   Providing a pydantic model class via this parameter overrides   the library default model with the model class you provide.   This can come in handy when the models in the library do not   accurately represent the data returned, and you prefer working with the   data as a pydantic model instead of as a dict of the response returned   by  paystack before it is serialized with pydantic models, The original   data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[TransactionSplit] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/splits.py</code> <pre><code>async def add_or_update(\n    self,\n    id_: int | str,\n    subaccount: str,\n    share: int | float,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[TransactionSplit] | Response[PaystackDataModel]:\n    \"\"\"\n    Add a Subaccount to a Transaction Split, or update\n    the share of an existing Subaccount in a Transaction Split\n\n    Args:\n     id_: Split ID\n     subaccount: This is the subaccount code\n     share: This is the transaction share for the subaccount\n     alternate_model_class: A pydantic model class to use instead of the\n        default pydantic model used by the library to present the data in\n        the `Response.data`. The default behaviour of the library is to\n        set  `Response.data` to `None` if it fails to serialize the data\n        returned from paystack with the model provided in the library.\n        Providing a pydantic model class via this parameter overrides\n        the library default model with the model class you provide.\n        This can come in handy when the models in the library do not\n        accurately represent the data returned, and you prefer working with the\n        data as a pydantic model instead of as a dict of the response returned\n        by  paystack before it is serialized with pydantic models, The original\n        data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    payload = {\"subaccount\": subaccount, \"share\": share}\n    url = self._full_url(f\"/split/{id_}/subaccount/add\")\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or TransactionSplit,\n    )\n</code></pre>"},{"location":"reference/splits/#pypaystack2.sub_clients.async_clients.splits.AsyncTransactionSplitClient.create","title":"<code>create(name, type_, currency, subaccounts, bearer_type, bearer_subaccount=None, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Create a split payment on your integration</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the transaction split</p> required <code>type_</code> <code>Split</code> <p>The type of transaction split you want to create. Any value from the <code>SplitType</code> enum</p> required <code>currency</code> <code>Currency</code> <p>Any value from the <code>Currency</code> enum</p> required <code>subaccounts</code> <code>list[SplitAccount]</code> <p>A list of dictionaries containing subaccount code and number of shares: <code>[{subaccount: 'ACT_xxxxxxxxxx', share: xxx},{...}]</code></p> required <code>bearer_type</code> <code>Bearer</code> <p>Any value from the <code>Bearer</code> enum</p> required <code>bearer_subaccount</code> <code>str | None</code> <p>Subaccount code</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[TransactionSplit] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/splits.py</code> <pre><code>async def create(\n    self,\n    name: str,\n    type_: Split,\n    currency: Currency,\n    subaccounts: list[SplitAccount],\n    bearer_type: Bearer,\n    bearer_subaccount: str | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[TransactionSplit] | Response[PaystackDataModel]:\n    \"\"\"Create a split payment on your integration\n\n    Args:\n        name: Name of the transaction split\n        type_: The type of transaction split you want to create.\n            Any value from the ``SplitType`` enum\n        currency: Any value from the ``Currency`` enum\n        subaccounts: A list of dictionaries containing subaccount code and\n            number of shares: ``[{subaccount: 'ACT_xxxxxxxxxx', share: xxx},{...}]``\n        bearer_type: Any value from the ``Bearer`` enum\n        bearer_subaccount: Subaccount code\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n    _subaccounts = [account.model_dump() for account in subaccounts]\n\n    url = self._full_url(\"/split\")\n    payload = {\n        \"name\": name,\n        \"type\": type_,\n        \"currency\": currency,\n        \"subaccounts\": _subaccounts,\n        \"bearer_type\": bearer_type,\n        \"bearer_subaccount\": bearer_subaccount,\n    }\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or TransactionSplit,\n    )\n</code></pre>"},{"location":"reference/splits/#pypaystack2.sub_clients.async_clients.splits.AsyncTransactionSplitClient.get_split","title":"<code>get_split(id_or_code, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Get details of a split on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>id_or_code</code> <code>int | str</code> <p>The id of the split</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[TransactionSplit] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/splits.py</code> <pre><code>async def get_split(\n    self,\n    id_or_code: int | str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[TransactionSplit] | Response[PaystackDataModel]:\n    \"\"\"Get details of a split on your integration.\n\n    Args:\n        id_or_code: The id of the split\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._full_url(f\"/split/{id_or_code}/\")\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or TransactionSplit,\n    )\n</code></pre>"},{"location":"reference/splits/#pypaystack2.sub_clients.async_clients.splits.AsyncTransactionSplitClient.get_splits","title":"<code>get_splits(name=None, sort_by=None, page=None, start_date=None, end_date=None, active=True, pagination=50, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Get/search for the transaction splits available on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>The name of the split</p> <code>None</code> <code>sort_by</code> <code>str | None</code> <p>Sort by name, defaults to createdAt date</p> <code>None</code> <code>page</code> <code>int | None</code> <p>Page number to view. If not specify we use a default value of 1.</p> <code>None</code> <code>start_date</code> <code>str | None</code> <p>A timestamp from which to start listing splits e.g. 2019-09-24T00:00:05.000Z, 2019-09-21</p> <code>None</code> <code>end_date</code> <code>str | None</code> <p>A timestamp at which to stop listing splits e.g. 2019-09-24T00:00:05.000Z, 2019-09-21</p> <code>None</code> <code>active</code> <code>bool</code> <p>Flag to filter by active</p> <code>True</code> <code>pagination</code> <code>int</code> <p>Number of splits per page. If not specified we use a default value of 50.</p> <code>50</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[list[TransactionSplit]] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/splits.py</code> <pre><code>async def get_splits(\n    self,\n    name: str | None = None,\n    sort_by: str | None = None,\n    page: int | None = None,\n    start_date: str | None = None,\n    end_date: str | None = None,\n    active: bool = True,\n    pagination: int = 50,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[list[TransactionSplit]] | Response[PaystackDataModel]:\n    \"\"\"Get/search for the transaction splits available on your integration.\n\n    Args:\n        name: The name of the split\n        sort_by: Sort by name, defaults to createdAt date\n        page: Page number to view. If not specify we use a default value of 1.\n        start_date: A timestamp from which to start listing splits e.g. 2019-09-24T00:00:05.000Z, 2019-09-21\n        end_date: A timestamp at which to stop listing splits e.g. 2019-09-24T00:00:05.000Z, 2019-09-21\n        active: Flag to filter by active\n        pagination: Number of splits per page. If not specified we use a default value of 50.\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/split?perPage={pagination}\")\n    query_params = [\n        (\"name\", name),\n        (\"sort_by\", sort_by),\n        (\"page\", page),\n        (\"from\", start_date),\n        (\"to\", end_date),\n        (\"active\", str(active).lower()),\n    ]\n    url = append_query_params(query_params, url)\n\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or TransactionSplit,\n    )\n</code></pre>"},{"location":"reference/splits/#pypaystack2.sub_clients.async_clients.splits.AsyncTransactionSplitClient.remove","title":"<code>remove(id_, subaccount, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Remove a subaccount from a transaction split</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>int | str</code> <p>Split ID</p> required <code>subaccount</code> <code>str</code> <p>This is the subaccount code</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[None] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/splits.py</code> <pre><code>async def remove(\n    self,\n    id_: int | str,\n    subaccount: str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[None] | Response[PaystackDataModel]:\n    \"\"\"Remove a subaccount from a transaction split\n\n    Args:\n        id_: Split ID\n        subaccount: This is the subaccount code\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    payload = {\"subaccount\": subaccount}\n    url = self._full_url(f\"/split/{id_}/subaccount/remove\")\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class,\n    )\n</code></pre>"},{"location":"reference/splits/#pypaystack2.sub_clients.async_clients.splits.AsyncTransactionSplitClient.update","title":"<code>update(id_, name, active, bearer_type=None, bearer_subaccount=None, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Update a transaction split details on your integration</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>int | str</code> <p>Split ID</p> required <code>name</code> <code>str</code> <p>Name of the transaction split</p> required <code>active</code> <code>bool</code> <p>Flag for active</p> required <code>bearer_type</code> <code>Bearer | None</code> <p>Any value from the Bearer enum</p> <code>None</code> <code>bearer_subaccount</code> <code>str | None</code> <p>Subaccount code of a subaccount in the split group. This should be specified only if the bearer_type is <code>Bearer.subaccount</code></p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[TransactionSplit] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/splits.py</code> <pre><code>async def update(\n    self,\n    id_: int | str,\n    name: str,\n    active: bool,\n    bearer_type: Bearer | None = None,\n    bearer_subaccount: str | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[TransactionSplit] | Response[PaystackDataModel]:\n    \"\"\"Update a transaction split details on your integration\n\n    Args:\n        id_: Split ID\n        name: Name of the transaction split\n        active: Flag for active\n        bearer_type: Any value from the Bearer enum\n        bearer_subaccount: Subaccount code of a subaccount in the split group.\n            This should be specified only if the bearer_type\n            is ``Bearer.subaccount``\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    if bearer_subaccount:\n        if bearer_type != Bearer.SUB_ACCOUNT:\n            raise ValueError(\n                \"`bearer_subaccount` can only have a value if `bearer_type` is `Bearer.SUBACCOUNT`\"\n            )\n\n    payload = {\n        \"name\": name,\n        \"active\": active,\n    }\n    optional_params = [\n        (\"bearer_type\", bearer_type),\n        (\"bearer_subaccount\", bearer_subaccount),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    url = self._full_url(f\"/split/{id_}/\")\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.PUT,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or TransactionSplit,\n    )\n</code></pre>"},{"location":"reference/subaccounts/","title":"Subaccounts","text":""},{"location":"reference/subaccounts/#pypaystack2.sub_clients.sync_clients.subaccounts.SubAccountClient","title":"<code>SubAccountClient</code>","text":"<p>               Bases: <code>BaseAPIClient</code></p> <p>Provides a wrapper for paystack Subaccounts API</p> <p>The Subaccounts API allows you to create and manage subaccounts on your integration. Subaccounts can be used to split payment between two accounts (your main account and a sub account). https://paystack.com/docs/api/subaccount/</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/subaccounts.py</code> <pre><code>class SubAccountClient(BaseAPIClient):\n    \"\"\"Provides a wrapper for paystack Subaccounts API\n\n    The Subaccounts API allows you to create and manage subaccounts on your integration.\n    Subaccounts can be used to split payment between two accounts\n    (your main account and a sub account).\n    https://paystack.com/docs/api/subaccount/\n    \"\"\"\n\n    def create(\n        self,\n        business_name: str,\n        settlement_bank: str,\n        account_number: str,\n        percentage_charge: float | int,\n        description: str | None = None,\n        primary_contact_email: str | None = None,\n        primary_contact_name: str | None = None,\n        primary_contact_phone: str | None = None,\n        metadata: dict[str, Any] | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[SubAccount] | Response[PaystackDataModel]:\n        \"\"\"Create a subacount on your integration.\n\n        Args:\n            business_name: Name of business for subaccount\n            settlement_bank: Bank Code for the bank. You can get the\n                list of Bank Codes by calling the ``.get_banks``\n                method from the Miscellaneous API wrapper\n            account_number: Bank Account Number\n            percentage_charge: The default percentage charged when receiving on behalf of this subaccount\n            description: A description for this subaccount\n            primary_contact_email: A contact email for the subaccount\n            primary_contact_name: A name for the contact person for this subaccount\n            primary_contact_phone: A phone number to call for this subaccount\n            metadata: Add a custom_fields attribute which has a list of dictionaries if\n                you would like the fields to be added to your transaction when\n                displayed on the dashboard.\n                Sample: ``{\"custom_fields\":[{\"display_name\":\"Cart ID\",\n                \"variable_name\": \"cart_id\",\"value\": \"8393\"}]}``\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(\"/subaccount\")\n        payload = {\n            \"business_name\": business_name,\n            \"settlement_bank\": settlement_bank,\n            \"account_number\": account_number,\n            \"percentage_charge\": percentage_charge,\n            \"description\": description,\n        }\n        optional_params = [\n            (\"primary_contact_email\", primary_contact_email),\n            (\"primary_contact_name\", primary_contact_name),\n            (\"primary_contact_phone\", primary_contact_phone),\n            (\"metadata\", metadata),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or SubAccount,\n        )\n\n    def get_subaccounts(\n        self,\n        start_date: str | None = None,\n        end_date: str | None = None,\n        page: int = 1,\n        pagination: int = 50,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[list[SubAccount]] | Response[PaystackDataModel]:\n        \"\"\"Fetch subaccounts available on your integration.\n\n        Args:\n            start_date: A timestamp from which to start listing subaccounts e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            end_date: A timestamp at which to stop listing subaccounts e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            page: Specifies exactly what page you want to retrieve. If not specified we use a default value of 1.\n            pagination: Specifies how many records you want to retrieve per page.\n                If not specified we use a default value of 50.\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._full_url(f\"/subaccount?perPage={pagination}\")\n        query_params = [\n            (\"from\", start_date),\n            (\"to\", end_date),\n            (\"page\", page),\n        ]\n        url = append_query_params(query_params, url)\n        return self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or SubAccount,\n        )\n\n    def get_subaccount(\n        self,\n        id_or_code: int | str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[SubAccount] | Response[PaystackDataModel]:\n        \"\"\"Get details of a subaccount on your integration.\n\n        Args:\n            id_or_code: The subaccount ``ID`` or ``code`` you want to fetch\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/subaccount/{id_or_code}\")\n        return self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or SubAccount,\n        )\n\n    def update(\n        self,\n        id_or_code: int | str,\n        business_name: str | None = None,\n        settlement_bank: str | None = None,\n        account_number: str | None = None,\n        active: bool | None = None,\n        percentage_charge: float | int | None = None,\n        description: str | None = None,\n        primary_contact_email: str | None = None,\n        primary_contact_name: str | None = None,\n        primary_contact_phone: str | None = None,\n        settlement_schedule: Schedule | None = None,\n        metadata: dict[str, Any] | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[SubAccount] | Response[PaystackDataModel]:\n        \"\"\"Update a subaccount details on your integration.\n\n        Args:\n            id_or_code: Subaccount's ID or code\n            business_name: Name of business for subaccount\n            settlement_bank: Bank Code for the bank. You can get the\n                list of Bank Codes by calling the ``.get_banks``\n                method from the Miscellaneous API wrapper\n            account_number: Bank Account Number\n            active: Activate or deactivate a subaccount.\n            percentage_charge: The default percentage charged when\n                receiving on behalf of this subaccount\n            description: A description for this subaccount\n            primary_contact_email: A contact email for the subaccount\n            primary_contact_name: A name for the contact person for this subaccount\n            primary_contact_phone: A phone number to call for this subaccount\n            settlement_schedule: ``Schedule.AUTO`` means payout is T+1 and manual means payout to the\n                subaccount should only be made when requested.\n                Defaults to ``Schedule.AUTO``\n            metadata: Add a custom_fields attribute which has a list of dictionaries if you would\n                like the fields to be added to your transaction when displayed on the\n                dashboard. Sample: ``{\"custom_fields\":[{\"display_name\":\"Cart ID\",\n                \"variable_name\": \"cart_id\",\"value\": \"8393\"}]}``\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        payload = {\n            \"id_or_code\": id_or_code,\n            \"business_name\": business_name,\n            \"settlement_bank\": settlement_bank,\n        }\n        optional_params = [\n            (\"account_number\", account_number),\n            (\"active\", active),\n            (\"percentage_charge\", percentage_charge),\n            (\"description\", description),\n            (\"primary_contact_email\", primary_contact_email),\n            (\"primary_contact_name\", primary_contact_name),\n            (\"primary_contact_phone\", primary_contact_phone),\n            (\"settlement_schedule\", settlement_schedule),\n            (\"metadata\", metadata),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        url = self._full_url(f\"/subaccount/{id_or_code}\")\n        return self._handle_request(  # type: ignore\n            HTTPMethod.PUT,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or SubAccount,\n        )\n</code></pre>"},{"location":"reference/subaccounts/#pypaystack2.sub_clients.sync_clients.subaccounts.SubAccountClient.create","title":"<code>create(business_name, settlement_bank, account_number, percentage_charge, description=None, primary_contact_email=None, primary_contact_name=None, primary_contact_phone=None, metadata=None, alternate_model_class=None)</code>","text":"<p>Create a subacount on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>business_name</code> <code>str</code> <p>Name of business for subaccount</p> required <code>settlement_bank</code> <code>str</code> <p>Bank Code for the bank. You can get the list of Bank Codes by calling the <code>.get_banks</code> method from the Miscellaneous API wrapper</p> required <code>account_number</code> <code>str</code> <p>Bank Account Number</p> required <code>percentage_charge</code> <code>float | int</code> <p>The default percentage charged when receiving on behalf of this subaccount</p> required <code>description</code> <code>str | None</code> <p>A description for this subaccount</p> <code>None</code> <code>primary_contact_email</code> <code>str | None</code> <p>A contact email for the subaccount</p> <code>None</code> <code>primary_contact_name</code> <code>str | None</code> <p>A name for the contact person for this subaccount</p> <code>None</code> <code>primary_contact_phone</code> <code>str | None</code> <p>A phone number to call for this subaccount</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>Add a custom_fields attribute which has a list of dictionaries if you would like the fields to be added to your transaction when displayed on the dashboard. Sample: <code>{\"custom_fields\":[{\"display_name\":\"Cart ID\", \"variable_name\": \"cart_id\",\"value\": \"8393\"}]}</code></p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[SubAccount] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/subaccounts.py</code> <pre><code>def create(\n    self,\n    business_name: str,\n    settlement_bank: str,\n    account_number: str,\n    percentage_charge: float | int,\n    description: str | None = None,\n    primary_contact_email: str | None = None,\n    primary_contact_name: str | None = None,\n    primary_contact_phone: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[SubAccount] | Response[PaystackDataModel]:\n    \"\"\"Create a subacount on your integration.\n\n    Args:\n        business_name: Name of business for subaccount\n        settlement_bank: Bank Code for the bank. You can get the\n            list of Bank Codes by calling the ``.get_banks``\n            method from the Miscellaneous API wrapper\n        account_number: Bank Account Number\n        percentage_charge: The default percentage charged when receiving on behalf of this subaccount\n        description: A description for this subaccount\n        primary_contact_email: A contact email for the subaccount\n        primary_contact_name: A name for the contact person for this subaccount\n        primary_contact_phone: A phone number to call for this subaccount\n        metadata: Add a custom_fields attribute which has a list of dictionaries if\n            you would like the fields to be added to your transaction when\n            displayed on the dashboard.\n            Sample: ``{\"custom_fields\":[{\"display_name\":\"Cart ID\",\n            \"variable_name\": \"cart_id\",\"value\": \"8393\"}]}``\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(\"/subaccount\")\n    payload = {\n        \"business_name\": business_name,\n        \"settlement_bank\": settlement_bank,\n        \"account_number\": account_number,\n        \"percentage_charge\": percentage_charge,\n        \"description\": description,\n    }\n    optional_params = [\n        (\"primary_contact_email\", primary_contact_email),\n        (\"primary_contact_name\", primary_contact_name),\n        (\"primary_contact_phone\", primary_contact_phone),\n        (\"metadata\", metadata),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or SubAccount,\n    )\n</code></pre>"},{"location":"reference/subaccounts/#pypaystack2.sub_clients.sync_clients.subaccounts.SubAccountClient.get_subaccount","title":"<code>get_subaccount(id_or_code, alternate_model_class=None)</code>","text":"<p>Get details of a subaccount on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>id_or_code</code> <code>int | str</code> <p>The subaccount <code>ID</code> or <code>code</code> you want to fetch</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[SubAccount] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/subaccounts.py</code> <pre><code>def get_subaccount(\n    self,\n    id_or_code: int | str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[SubAccount] | Response[PaystackDataModel]:\n    \"\"\"Get details of a subaccount on your integration.\n\n    Args:\n        id_or_code: The subaccount ``ID`` or ``code`` you want to fetch\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/subaccount/{id_or_code}\")\n    return self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or SubAccount,\n    )\n</code></pre>"},{"location":"reference/subaccounts/#pypaystack2.sub_clients.sync_clients.subaccounts.SubAccountClient.get_subaccounts","title":"<code>get_subaccounts(start_date=None, end_date=None, page=1, pagination=50, alternate_model_class=None)</code>","text":"<p>Fetch subaccounts available on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>start_date</code> <code>str | None</code> <p>A timestamp from which to start listing subaccounts e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>end_date</code> <code>str | None</code> <p>A timestamp at which to stop listing subaccounts e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>page</code> <code>int</code> <p>Specifies exactly what page you want to retrieve. If not specified we use a default value of 1.</p> <code>1</code> <code>pagination</code> <code>int</code> <p>Specifies how many records you want to retrieve per page. If not specified we use a default value of 50.</p> <code>50</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[list[SubAccount]] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/subaccounts.py</code> <pre><code>def get_subaccounts(\n    self,\n    start_date: str | None = None,\n    end_date: str | None = None,\n    page: int = 1,\n    pagination: int = 50,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[list[SubAccount]] | Response[PaystackDataModel]:\n    \"\"\"Fetch subaccounts available on your integration.\n\n    Args:\n        start_date: A timestamp from which to start listing subaccounts e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        end_date: A timestamp at which to stop listing subaccounts e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        page: Specifies exactly what page you want to retrieve. If not specified we use a default value of 1.\n        pagination: Specifies how many records you want to retrieve per page.\n            If not specified we use a default value of 50.\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._full_url(f\"/subaccount?perPage={pagination}\")\n    query_params = [\n        (\"from\", start_date),\n        (\"to\", end_date),\n        (\"page\", page),\n    ]\n    url = append_query_params(query_params, url)\n    return self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or SubAccount,\n    )\n</code></pre>"},{"location":"reference/subaccounts/#pypaystack2.sub_clients.sync_clients.subaccounts.SubAccountClient.update","title":"<code>update(id_or_code, business_name=None, settlement_bank=None, account_number=None, active=None, percentage_charge=None, description=None, primary_contact_email=None, primary_contact_name=None, primary_contact_phone=None, settlement_schedule=None, metadata=None, alternate_model_class=None)</code>","text":"<p>Update a subaccount details on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>id_or_code</code> <code>int | str</code> <p>Subaccount's ID or code</p> required <code>business_name</code> <code>str | None</code> <p>Name of business for subaccount</p> <code>None</code> <code>settlement_bank</code> <code>str | None</code> <p>Bank Code for the bank. You can get the list of Bank Codes by calling the <code>.get_banks</code> method from the Miscellaneous API wrapper</p> <code>None</code> <code>account_number</code> <code>str | None</code> <p>Bank Account Number</p> <code>None</code> <code>active</code> <code>bool | None</code> <p>Activate or deactivate a subaccount.</p> <code>None</code> <code>percentage_charge</code> <code>float | int | None</code> <p>The default percentage charged when receiving on behalf of this subaccount</p> <code>None</code> <code>description</code> <code>str | None</code> <p>A description for this subaccount</p> <code>None</code> <code>primary_contact_email</code> <code>str | None</code> <p>A contact email for the subaccount</p> <code>None</code> <code>primary_contact_name</code> <code>str | None</code> <p>A name for the contact person for this subaccount</p> <code>None</code> <code>primary_contact_phone</code> <code>str | None</code> <p>A phone number to call for this subaccount</p> <code>None</code> <code>settlement_schedule</code> <code>Schedule | None</code> <p><code>Schedule.AUTO</code> means payout is T+1 and manual means payout to the subaccount should only be made when requested. Defaults to <code>Schedule.AUTO</code></p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>Add a custom_fields attribute which has a list of dictionaries if you would like the fields to be added to your transaction when displayed on the dashboard. Sample: <code>{\"custom_fields\":[{\"display_name\":\"Cart ID\", \"variable_name\": \"cart_id\",\"value\": \"8393\"}]}</code></p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[SubAccount] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/subaccounts.py</code> <pre><code>def update(\n    self,\n    id_or_code: int | str,\n    business_name: str | None = None,\n    settlement_bank: str | None = None,\n    account_number: str | None = None,\n    active: bool | None = None,\n    percentage_charge: float | int | None = None,\n    description: str | None = None,\n    primary_contact_email: str | None = None,\n    primary_contact_name: str | None = None,\n    primary_contact_phone: str | None = None,\n    settlement_schedule: Schedule | None = None,\n    metadata: dict[str, Any] | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[SubAccount] | Response[PaystackDataModel]:\n    \"\"\"Update a subaccount details on your integration.\n\n    Args:\n        id_or_code: Subaccount's ID or code\n        business_name: Name of business for subaccount\n        settlement_bank: Bank Code for the bank. You can get the\n            list of Bank Codes by calling the ``.get_banks``\n            method from the Miscellaneous API wrapper\n        account_number: Bank Account Number\n        active: Activate or deactivate a subaccount.\n        percentage_charge: The default percentage charged when\n            receiving on behalf of this subaccount\n        description: A description for this subaccount\n        primary_contact_email: A contact email for the subaccount\n        primary_contact_name: A name for the contact person for this subaccount\n        primary_contact_phone: A phone number to call for this subaccount\n        settlement_schedule: ``Schedule.AUTO`` means payout is T+1 and manual means payout to the\n            subaccount should only be made when requested.\n            Defaults to ``Schedule.AUTO``\n        metadata: Add a custom_fields attribute which has a list of dictionaries if you would\n            like the fields to be added to your transaction when displayed on the\n            dashboard. Sample: ``{\"custom_fields\":[{\"display_name\":\"Cart ID\",\n            \"variable_name\": \"cart_id\",\"value\": \"8393\"}]}``\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    payload = {\n        \"id_or_code\": id_or_code,\n        \"business_name\": business_name,\n        \"settlement_bank\": settlement_bank,\n    }\n    optional_params = [\n        (\"account_number\", account_number),\n        (\"active\", active),\n        (\"percentage_charge\", percentage_charge),\n        (\"description\", description),\n        (\"primary_contact_email\", primary_contact_email),\n        (\"primary_contact_name\", primary_contact_name),\n        (\"primary_contact_phone\", primary_contact_phone),\n        (\"settlement_schedule\", settlement_schedule),\n        (\"metadata\", metadata),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    url = self._full_url(f\"/subaccount/{id_or_code}\")\n    return self._handle_request(  # type: ignore\n        HTTPMethod.PUT,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or SubAccount,\n    )\n</code></pre>"},{"location":"reference/subaccounts/#pypaystack2.sub_clients.async_clients.subaccounts.AsyncSubAccountClient","title":"<code>AsyncSubAccountClient</code>","text":"<p>               Bases: <code>BaseAsyncAPIClient</code></p> <p>Provides a wrapper for paystack Subaccounts API</p> <p>The Subaccounts API allows you to create and manage subaccounts on your integration. Subaccounts can be used to split payment between two accounts (your main account and a sub account). https://paystack.com/docs/api/subaccount/</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/subaccounts.py</code> <pre><code>class AsyncSubAccountClient(BaseAsyncAPIClient):\n    \"\"\"Provides a wrapper for paystack Subaccounts API\n\n    The Subaccounts API allows you to create and manage subaccounts on your integration.\n    Subaccounts can be used to split payment between two accounts\n    (your main account and a sub account).\n    https://paystack.com/docs/api/subaccount/\n    \"\"\"\n\n    async def create(\n        self,\n        business_name: str,\n        settlement_bank: str,\n        account_number: str,\n        percentage_charge: float | int,\n        description: str | None = None,\n        primary_contact_email: str | None = None,\n        primary_contact_name: str | None = None,\n        primary_contact_phone: str | None = None,\n        metadata: dict[str, Any] | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[SubAccount] | Response[PaystackDataModel]:\n        \"\"\"Create a subacount on your integration.\n\n        Args:\n            business_name: Name of business for subaccount\n            settlement_bank: Bank Code for the bank. You can get the\n                list of Bank Codes by calling the ``.get_banks``\n                method from the Miscellaneous API wrapper\n            account_number: Bank Account Number\n            percentage_charge: The default percentage charged when receiving on behalf of this subaccount\n            description: A description for this subaccount\n            primary_contact_email: A contact email for the subaccount\n            primary_contact_name: A name for the contact person for this subaccount\n            primary_contact_phone: A phone number to call for this subaccount\n            metadata: Add a custom_fields attribute which has a list of dictionaries if\n                you would like the fields to be added to your transaction when\n                displayed on the dashboard.\n                Sample: ``{\"custom_fields\":[{\"display_name\":\"Cart ID\",\n                \"variable_name\": \"cart_id\",\"value\": \"8393\"}]}``\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(\"/subaccount\")\n        payload = {\n            \"business_name\": business_name,\n            \"settlement_bank\": settlement_bank,\n            \"account_number\": account_number,\n            \"percentage_charge\": percentage_charge,\n            \"description\": description,\n        }\n        optional_params = [\n            (\"primary_contact_email\", primary_contact_email),\n            (\"primary_contact_name\", primary_contact_name),\n            (\"primary_contact_phone\", primary_contact_phone),\n            (\"metadata\", metadata),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or SubAccount,\n        )\n\n    async def get_subaccounts(\n        self,\n        start_date: str | None = None,\n        end_date: str | None = None,\n        page: int = 1,\n        pagination: int = 50,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[list[SubAccount]] | Response[PaystackDataModel]:\n        \"\"\"Fetch subaccounts available on your integration.\n\n        Args:\n            start_date: A timestamp from which to start listing subaccounts e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            end_date: A timestamp at which to stop listing subaccounts e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            page: Specifies exactly what page you want to retrieve. If not specified we use a default value of 1.\n            pagination: Specifies how many records you want to retrieve per page.\n                If not specified we use a default value of 50.\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._full_url(f\"/subaccount?perPage={pagination}\")\n        query_params = [\n            (\"from\", start_date),\n            (\"to\", end_date),\n            (\"page\", page),\n        ]\n        url = append_query_params(query_params, url)\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or SubAccount,\n        )\n\n    async def get_subaccount(\n        self,\n        id_or_code: int | str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[SubAccount] | Response[PaystackDataModel]:\n        \"\"\"Get details of a subaccount on your integration.\n\n        Args:\n            id_or_code: The subaccount ``ID`` or ``code`` you want to fetch\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/subaccount/{id_or_code}\")\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or SubAccount,\n        )\n\n    async def update(\n        self,\n        id_or_code: int | str,\n        business_name: str | None = None,\n        settlement_bank: str | None = None,\n        account_number: str | None = None,\n        active: bool | None = None,\n        percentage_charge: float | int | None = None,\n        description: str | None = None,\n        primary_contact_email: str | None = None,\n        primary_contact_name: str | None = None,\n        primary_contact_phone: str | None = None,\n        settlement_schedule: Schedule | None = None,\n        metadata: dict[str, Any] | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[SubAccount] | Response[PaystackDataModel]:\n        \"\"\"Update a subaccount details on your integration.\n\n        Args:\n            id_or_code: Subaccount's ID or code\n            business_name: Name of business for subaccount\n            settlement_bank: Bank Code for the bank. You can get the\n                list of Bank Codes by calling the ``.get_banks``\n                method from the Miscellaneous API wrapper\n            account_number: Bank Account Number\n            active: Activate or deactivate a subaccount.\n            percentage_charge: The default percentage charged when\n                receiving on behalf of this subaccount\n            description: A description for this subaccount\n            primary_contact_email: A contact email for the subaccount\n            primary_contact_name: A name for the contact person for this subaccount\n            primary_contact_phone: A phone number to call for this subaccount\n            settlement_schedule: ``Schedule.AUTO`` means payout is T+1 and manual means payout to the\n                subaccount should only be made when requested.\n                Defaults to ``Schedule.AUTO``\n            metadata: Add a custom_fields attribute which has a list of dictionaries if you would\n                like the fields to be added to your transaction when displayed on the\n                dashboard. Sample: ``{\"custom_fields\":[{\"display_name\":\"Cart ID\",\n                \"variable_name\": \"cart_id\",\"value\": \"8393\"}]}``\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        payload = {\n            \"id_or_code\": id_or_code,\n            \"business_name\": business_name,\n            \"settlement_bank\": settlement_bank,\n        }\n        optional_params = [\n            (\"account_number\", account_number),\n            (\"active\", active),\n            (\"percentage_charge\", percentage_charge),\n            (\"description\", description),\n            (\"primary_contact_email\", primary_contact_email),\n            (\"primary_contact_name\", primary_contact_name),\n            (\"primary_contact_phone\", primary_contact_phone),\n            (\"settlement_schedule\", settlement_schedule),\n            (\"metadata\", metadata),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        url = self._full_url(f\"/subaccount/{id_or_code}\")\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.PUT,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or SubAccount,\n        )\n</code></pre>"},{"location":"reference/subaccounts/#pypaystack2.sub_clients.async_clients.subaccounts.AsyncSubAccountClient.create","title":"<code>create(business_name, settlement_bank, account_number, percentage_charge, description=None, primary_contact_email=None, primary_contact_name=None, primary_contact_phone=None, metadata=None, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Create a subacount on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>business_name</code> <code>str</code> <p>Name of business for subaccount</p> required <code>settlement_bank</code> <code>str</code> <p>Bank Code for the bank. You can get the list of Bank Codes by calling the <code>.get_banks</code> method from the Miscellaneous API wrapper</p> required <code>account_number</code> <code>str</code> <p>Bank Account Number</p> required <code>percentage_charge</code> <code>float | int</code> <p>The default percentage charged when receiving on behalf of this subaccount</p> required <code>description</code> <code>str | None</code> <p>A description for this subaccount</p> <code>None</code> <code>primary_contact_email</code> <code>str | None</code> <p>A contact email for the subaccount</p> <code>None</code> <code>primary_contact_name</code> <code>str | None</code> <p>A name for the contact person for this subaccount</p> <code>None</code> <code>primary_contact_phone</code> <code>str | None</code> <p>A phone number to call for this subaccount</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>Add a custom_fields attribute which has a list of dictionaries if you would like the fields to be added to your transaction when displayed on the dashboard. Sample: <code>{\"custom_fields\":[{\"display_name\":\"Cart ID\", \"variable_name\": \"cart_id\",\"value\": \"8393\"}]}</code></p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[SubAccount] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/subaccounts.py</code> <pre><code>async def create(\n    self,\n    business_name: str,\n    settlement_bank: str,\n    account_number: str,\n    percentage_charge: float | int,\n    description: str | None = None,\n    primary_contact_email: str | None = None,\n    primary_contact_name: str | None = None,\n    primary_contact_phone: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[SubAccount] | Response[PaystackDataModel]:\n    \"\"\"Create a subacount on your integration.\n\n    Args:\n        business_name: Name of business for subaccount\n        settlement_bank: Bank Code for the bank. You can get the\n            list of Bank Codes by calling the ``.get_banks``\n            method from the Miscellaneous API wrapper\n        account_number: Bank Account Number\n        percentage_charge: The default percentage charged when receiving on behalf of this subaccount\n        description: A description for this subaccount\n        primary_contact_email: A contact email for the subaccount\n        primary_contact_name: A name for the contact person for this subaccount\n        primary_contact_phone: A phone number to call for this subaccount\n        metadata: Add a custom_fields attribute which has a list of dictionaries if\n            you would like the fields to be added to your transaction when\n            displayed on the dashboard.\n            Sample: ``{\"custom_fields\":[{\"display_name\":\"Cart ID\",\n            \"variable_name\": \"cart_id\",\"value\": \"8393\"}]}``\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(\"/subaccount\")\n    payload = {\n        \"business_name\": business_name,\n        \"settlement_bank\": settlement_bank,\n        \"account_number\": account_number,\n        \"percentage_charge\": percentage_charge,\n        \"description\": description,\n    }\n    optional_params = [\n        (\"primary_contact_email\", primary_contact_email),\n        (\"primary_contact_name\", primary_contact_name),\n        (\"primary_contact_phone\", primary_contact_phone),\n        (\"metadata\", metadata),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or SubAccount,\n    )\n</code></pre>"},{"location":"reference/subaccounts/#pypaystack2.sub_clients.async_clients.subaccounts.AsyncSubAccountClient.get_subaccount","title":"<code>get_subaccount(id_or_code, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Get details of a subaccount on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>id_or_code</code> <code>int | str</code> <p>The subaccount <code>ID</code> or <code>code</code> you want to fetch</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[SubAccount] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/subaccounts.py</code> <pre><code>async def get_subaccount(\n    self,\n    id_or_code: int | str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[SubAccount] | Response[PaystackDataModel]:\n    \"\"\"Get details of a subaccount on your integration.\n\n    Args:\n        id_or_code: The subaccount ``ID`` or ``code`` you want to fetch\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/subaccount/{id_or_code}\")\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or SubAccount,\n    )\n</code></pre>"},{"location":"reference/subaccounts/#pypaystack2.sub_clients.async_clients.subaccounts.AsyncSubAccountClient.get_subaccounts","title":"<code>get_subaccounts(start_date=None, end_date=None, page=1, pagination=50, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Fetch subaccounts available on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>start_date</code> <code>str | None</code> <p>A timestamp from which to start listing subaccounts e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>end_date</code> <code>str | None</code> <p>A timestamp at which to stop listing subaccounts e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>page</code> <code>int</code> <p>Specifies exactly what page you want to retrieve. If not specified we use a default value of 1.</p> <code>1</code> <code>pagination</code> <code>int</code> <p>Specifies how many records you want to retrieve per page. If not specified we use a default value of 50.</p> <code>50</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[list[SubAccount]] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/subaccounts.py</code> <pre><code>async def get_subaccounts(\n    self,\n    start_date: str | None = None,\n    end_date: str | None = None,\n    page: int = 1,\n    pagination: int = 50,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[list[SubAccount]] | Response[PaystackDataModel]:\n    \"\"\"Fetch subaccounts available on your integration.\n\n    Args:\n        start_date: A timestamp from which to start listing subaccounts e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        end_date: A timestamp at which to stop listing subaccounts e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        page: Specifies exactly what page you want to retrieve. If not specified we use a default value of 1.\n        pagination: Specifies how many records you want to retrieve per page.\n            If not specified we use a default value of 50.\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._full_url(f\"/subaccount?perPage={pagination}\")\n    query_params = [\n        (\"from\", start_date),\n        (\"to\", end_date),\n        (\"page\", page),\n    ]\n    url = append_query_params(query_params, url)\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or SubAccount,\n    )\n</code></pre>"},{"location":"reference/subaccounts/#pypaystack2.sub_clients.async_clients.subaccounts.AsyncSubAccountClient.update","title":"<code>update(id_or_code, business_name=None, settlement_bank=None, account_number=None, active=None, percentage_charge=None, description=None, primary_contact_email=None, primary_contact_name=None, primary_contact_phone=None, settlement_schedule=None, metadata=None, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Update a subaccount details on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>id_or_code</code> <code>int | str</code> <p>Subaccount's ID or code</p> required <code>business_name</code> <code>str | None</code> <p>Name of business for subaccount</p> <code>None</code> <code>settlement_bank</code> <code>str | None</code> <p>Bank Code for the bank. You can get the list of Bank Codes by calling the <code>.get_banks</code> method from the Miscellaneous API wrapper</p> <code>None</code> <code>account_number</code> <code>str | None</code> <p>Bank Account Number</p> <code>None</code> <code>active</code> <code>bool | None</code> <p>Activate or deactivate a subaccount.</p> <code>None</code> <code>percentage_charge</code> <code>float | int | None</code> <p>The default percentage charged when receiving on behalf of this subaccount</p> <code>None</code> <code>description</code> <code>str | None</code> <p>A description for this subaccount</p> <code>None</code> <code>primary_contact_email</code> <code>str | None</code> <p>A contact email for the subaccount</p> <code>None</code> <code>primary_contact_name</code> <code>str | None</code> <p>A name for the contact person for this subaccount</p> <code>None</code> <code>primary_contact_phone</code> <code>str | None</code> <p>A phone number to call for this subaccount</p> <code>None</code> <code>settlement_schedule</code> <code>Schedule | None</code> <p><code>Schedule.AUTO</code> means payout is T+1 and manual means payout to the subaccount should only be made when requested. Defaults to <code>Schedule.AUTO</code></p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>Add a custom_fields attribute which has a list of dictionaries if you would like the fields to be added to your transaction when displayed on the dashboard. Sample: <code>{\"custom_fields\":[{\"display_name\":\"Cart ID\", \"variable_name\": \"cart_id\",\"value\": \"8393\"}]}</code></p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[SubAccount] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/subaccounts.py</code> <pre><code>async def update(\n    self,\n    id_or_code: int | str,\n    business_name: str | None = None,\n    settlement_bank: str | None = None,\n    account_number: str | None = None,\n    active: bool | None = None,\n    percentage_charge: float | int | None = None,\n    description: str | None = None,\n    primary_contact_email: str | None = None,\n    primary_contact_name: str | None = None,\n    primary_contact_phone: str | None = None,\n    settlement_schedule: Schedule | None = None,\n    metadata: dict[str, Any] | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[SubAccount] | Response[PaystackDataModel]:\n    \"\"\"Update a subaccount details on your integration.\n\n    Args:\n        id_or_code: Subaccount's ID or code\n        business_name: Name of business for subaccount\n        settlement_bank: Bank Code for the bank. You can get the\n            list of Bank Codes by calling the ``.get_banks``\n            method from the Miscellaneous API wrapper\n        account_number: Bank Account Number\n        active: Activate or deactivate a subaccount.\n        percentage_charge: The default percentage charged when\n            receiving on behalf of this subaccount\n        description: A description for this subaccount\n        primary_contact_email: A contact email for the subaccount\n        primary_contact_name: A name for the contact person for this subaccount\n        primary_contact_phone: A phone number to call for this subaccount\n        settlement_schedule: ``Schedule.AUTO`` means payout is T+1 and manual means payout to the\n            subaccount should only be made when requested.\n            Defaults to ``Schedule.AUTO``\n        metadata: Add a custom_fields attribute which has a list of dictionaries if you would\n            like the fields to be added to your transaction when displayed on the\n            dashboard. Sample: ``{\"custom_fields\":[{\"display_name\":\"Cart ID\",\n            \"variable_name\": \"cart_id\",\"value\": \"8393\"}]}``\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    payload = {\n        \"id_or_code\": id_or_code,\n        \"business_name\": business_name,\n        \"settlement_bank\": settlement_bank,\n    }\n    optional_params = [\n        (\"account_number\", account_number),\n        (\"active\", active),\n        (\"percentage_charge\", percentage_charge),\n        (\"description\", description),\n        (\"primary_contact_email\", primary_contact_email),\n        (\"primary_contact_name\", primary_contact_name),\n        (\"primary_contact_phone\", primary_contact_phone),\n        (\"settlement_schedule\", settlement_schedule),\n        (\"metadata\", metadata),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    url = self._full_url(f\"/subaccount/{id_or_code}\")\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.PUT,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or SubAccount,\n    )\n</code></pre>"},{"location":"reference/subscriptions/","title":"Subscriptions","text":""},{"location":"reference/subscriptions/#pypaystack2.sub_clients.sync_clients.subscriptions.SubscriptionClient","title":"<code>SubscriptionClient</code>","text":"<p>               Bases: <code>BaseAPIClient</code></p> <p>Provides a wrapper for paystack Subscriptions API</p> <p>The Subscriptions API allows you to create and manage recurring payment on your integration. https://paystack.com/docs/api/subscription/</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/subscriptions.py</code> <pre><code>class SubscriptionClient(BaseAPIClient):\n    \"\"\"Provides a wrapper for paystack Subscriptions API\n\n    The Subscriptions API allows you to create and manage recurring\n    payment on your integration.\n    https://paystack.com/docs/api/subscription/\n    \"\"\"\n\n    def create(\n        self,\n        customer: int | str,\n        plan: str,\n        authorization: str | None = None,\n        start_date: str | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[Subscription] | Response[PaystackDataModel]:\n        \"\"\"Create a subscription on your integration\n\n        Note:\n            Email Token\n                paystack creates an email token on each subscription to allow customers\n                cancel their subscriptions from within the invoices sent to their mailboxes.\n                Since they are not authorized, the email tokens are what we use to authenticate\n                the requests over the API.\n\n        Args:\n            customer: Customer's email address or customer code\n            plan: Plan code\n            authorization: If customer has multiple authorizations, you can set\n                the desired authorization you wish to use for this\n                subscription here. If this is not supplied, the\n                customer's most recent authorization would be used\n            start_date: Set the date for the first debit. (ISO 8601 format) e.g. 2017-05-16T00:30:13+01:00\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(\"/subscription\")\n\n        payload = {\"customer\": customer, \"plan\": plan}\n        optional_params = [\n            (\"start_date\", start_date),\n            (\"authorization\", authorization),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or Subscription,\n        )\n\n    def get_subscriptions(\n        self,\n        page: int = 1,\n        pagination: int = 50,\n        customer: int | None = None,\n        plan: str | int | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[list[Subscription]] | Response[PaystackDataModel]:\n        \"\"\"Fetch subscriptions available on your integration.\n\n        Args:\n            page: Specifies exactly what page you want to retrieve.\n                If not specified we use a default value of 1.\n            pagination: Specifies how many records you want to retrieve per page.\n                If not specified we use a default value of 50.\n            customer: Filter by Customer ID\n            plan: Filter by Plan ID\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(\"/subscription/?perPage=\" + str(pagination))\n        query_params = [\n            (\"page\", page),\n            (\"customer\", customer),\n            (\"plan\", plan),\n        ]\n        url = append_query_params(query_params, url)\n        return self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or Subscription,\n        )\n\n    def get_subscription(\n        self,\n        id_or_code: int | str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[Subscription] | Response[PaystackDataModel]:\n        \"\"\"Fetch details of a subscription on your integration.\n\n        Args:\n            id_or_code: The subscription ``ID`` or ``code`` you want to fetch\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/subscription/{id_or_code}\")\n        return self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or Subscription,\n        )\n\n    def enable(\n        self,\n        code: str,\n        token: str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[None] | Response[PaystackDataModel]:\n        \"\"\"Enable a subscription on your integration\n\n        Args:\n            code: Subscription code\n            token: Email token\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(\"/subscription/enable\")\n        payload = {\n            \"code\": code,\n            \"token\": token,\n        }\n        return self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class,\n        )\n\n    def disable(\n        self,\n        code: str,\n        token: str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[None] | Response[PaystackDataModel]:\n        \"\"\"Disable a subscription on your integration\n\n        Args:\n            code: Subscription code\n            token: Email token\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._full_url(\"/subscription/disable\")\n        payload = {\n            \"code\": code,\n            \"token\": token,\n        }\n        return self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class,\n        )\n\n    def get_update_link(\n        self,\n        code: str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[SubscriptionLink] | Response[PaystackDataModel]:\n        \"\"\"Generate a link for updating the card on a subscription\n\n        Args:\n            code: Subscription code\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/subscription/{code}/manage/link/\")\n        return self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or SubscriptionLink,\n        )\n\n    def send_update_link(\n        self,\n        code: str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[None] | Response[PaystackDataModel]:\n        \"\"\"Email a customer a link for updating the card on their subscription\n\n        Args:\n            code: Subscription code\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/subscription/{code}/manage/email/\")\n        return self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            response_data_model_class=alternate_model_class,\n        )\n</code></pre>"},{"location":"reference/subscriptions/#pypaystack2.sub_clients.sync_clients.subscriptions.SubscriptionClient.create","title":"<code>create(customer, plan, authorization=None, start_date=None, alternate_model_class=None)</code>","text":"<p>Create a subscription on your integration</p> Note <p>Email Token     paystack creates an email token on each subscription to allow customers     cancel their subscriptions from within the invoices sent to their mailboxes.     Since they are not authorized, the email tokens are what we use to authenticate     the requests over the API.</p> <p>Parameters:</p> Name Type Description Default <code>customer</code> <code>int | str</code> <p>Customer's email address or customer code</p> required <code>plan</code> <code>str</code> <p>Plan code</p> required <code>authorization</code> <code>str | None</code> <p>If customer has multiple authorizations, you can set the desired authorization you wish to use for this subscription here. If this is not supplied, the customer's most recent authorization would be used</p> <code>None</code> <code>start_date</code> <code>str | None</code> <p>Set the date for the first debit. (ISO 8601 format) e.g. 2017-05-16T00:30:13+01:00</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[Subscription] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/subscriptions.py</code> <pre><code>def create(\n    self,\n    customer: int | str,\n    plan: str,\n    authorization: str | None = None,\n    start_date: str | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[Subscription] | Response[PaystackDataModel]:\n    \"\"\"Create a subscription on your integration\n\n    Note:\n        Email Token\n            paystack creates an email token on each subscription to allow customers\n            cancel their subscriptions from within the invoices sent to their mailboxes.\n            Since they are not authorized, the email tokens are what we use to authenticate\n            the requests over the API.\n\n    Args:\n        customer: Customer's email address or customer code\n        plan: Plan code\n        authorization: If customer has multiple authorizations, you can set\n            the desired authorization you wish to use for this\n            subscription here. If this is not supplied, the\n            customer's most recent authorization would be used\n        start_date: Set the date for the first debit. (ISO 8601 format) e.g. 2017-05-16T00:30:13+01:00\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(\"/subscription\")\n\n    payload = {\"customer\": customer, \"plan\": plan}\n    optional_params = [\n        (\"start_date\", start_date),\n        (\"authorization\", authorization),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or Subscription,\n    )\n</code></pre>"},{"location":"reference/subscriptions/#pypaystack2.sub_clients.sync_clients.subscriptions.SubscriptionClient.disable","title":"<code>disable(code, token, alternate_model_class=None)</code>","text":"<p>Disable a subscription on your integration</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>Subscription code</p> required <code>token</code> <code>str</code> <p>Email token</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[None] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/subscriptions.py</code> <pre><code>def disable(\n    self,\n    code: str,\n    token: str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[None] | Response[PaystackDataModel]:\n    \"\"\"Disable a subscription on your integration\n\n    Args:\n        code: Subscription code\n        token: Email token\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._full_url(\"/subscription/disable\")\n    payload = {\n        \"code\": code,\n        \"token\": token,\n    }\n    return self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class,\n    )\n</code></pre>"},{"location":"reference/subscriptions/#pypaystack2.sub_clients.sync_clients.subscriptions.SubscriptionClient.enable","title":"<code>enable(code, token, alternate_model_class=None)</code>","text":"<p>Enable a subscription on your integration</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>Subscription code</p> required <code>token</code> <code>str</code> <p>Email token</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[None] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/subscriptions.py</code> <pre><code>def enable(\n    self,\n    code: str,\n    token: str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[None] | Response[PaystackDataModel]:\n    \"\"\"Enable a subscription on your integration\n\n    Args:\n        code: Subscription code\n        token: Email token\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(\"/subscription/enable\")\n    payload = {\n        \"code\": code,\n        \"token\": token,\n    }\n    return self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class,\n    )\n</code></pre>"},{"location":"reference/subscriptions/#pypaystack2.sub_clients.sync_clients.subscriptions.SubscriptionClient.get_subscription","title":"<code>get_subscription(id_or_code, alternate_model_class=None)</code>","text":"<p>Fetch details of a subscription on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>id_or_code</code> <code>int | str</code> <p>The subscription <code>ID</code> or <code>code</code> you want to fetch</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[Subscription] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/subscriptions.py</code> <pre><code>def get_subscription(\n    self,\n    id_or_code: int | str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[Subscription] | Response[PaystackDataModel]:\n    \"\"\"Fetch details of a subscription on your integration.\n\n    Args:\n        id_or_code: The subscription ``ID`` or ``code`` you want to fetch\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/subscription/{id_or_code}\")\n    return self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or Subscription,\n    )\n</code></pre>"},{"location":"reference/subscriptions/#pypaystack2.sub_clients.sync_clients.subscriptions.SubscriptionClient.get_subscriptions","title":"<code>get_subscriptions(page=1, pagination=50, customer=None, plan=None, alternate_model_class=None)</code>","text":"<p>Fetch subscriptions available on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>int</code> <p>Specifies exactly what page you want to retrieve. If not specified we use a default value of 1.</p> <code>1</code> <code>pagination</code> <code>int</code> <p>Specifies how many records you want to retrieve per page. If not specified we use a default value of 50.</p> <code>50</code> <code>customer</code> <code>int | None</code> <p>Filter by Customer ID</p> <code>None</code> <code>plan</code> <code>str | int | None</code> <p>Filter by Plan ID</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[list[Subscription]] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/subscriptions.py</code> <pre><code>def get_subscriptions(\n    self,\n    page: int = 1,\n    pagination: int = 50,\n    customer: int | None = None,\n    plan: str | int | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[list[Subscription]] | Response[PaystackDataModel]:\n    \"\"\"Fetch subscriptions available on your integration.\n\n    Args:\n        page: Specifies exactly what page you want to retrieve.\n            If not specified we use a default value of 1.\n        pagination: Specifies how many records you want to retrieve per page.\n            If not specified we use a default value of 50.\n        customer: Filter by Customer ID\n        plan: Filter by Plan ID\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(\"/subscription/?perPage=\" + str(pagination))\n    query_params = [\n        (\"page\", page),\n        (\"customer\", customer),\n        (\"plan\", plan),\n    ]\n    url = append_query_params(query_params, url)\n    return self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or Subscription,\n    )\n</code></pre>"},{"location":"reference/subscriptions/#pypaystack2.sub_clients.sync_clients.subscriptions.SubscriptionClient.get_update_link","title":"<code>get_update_link(code, alternate_model_class=None)</code>","text":"<p>Generate a link for updating the card on a subscription</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>Subscription code</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[SubscriptionLink] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/subscriptions.py</code> <pre><code>def get_update_link(\n    self,\n    code: str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[SubscriptionLink] | Response[PaystackDataModel]:\n    \"\"\"Generate a link for updating the card on a subscription\n\n    Args:\n        code: Subscription code\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/subscription/{code}/manage/link/\")\n    return self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or SubscriptionLink,\n    )\n</code></pre>"},{"location":"reference/subscriptions/#pypaystack2.sub_clients.sync_clients.subscriptions.SubscriptionClient.send_update_link","title":"<code>send_update_link(code, alternate_model_class=None)</code>","text":"<p>Email a customer a link for updating the card on their subscription</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>Subscription code</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[None] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/subscriptions.py</code> <pre><code>def send_update_link(\n    self,\n    code: str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[None] | Response[PaystackDataModel]:\n    \"\"\"Email a customer a link for updating the card on their subscription\n\n    Args:\n        code: Subscription code\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/subscription/{code}/manage/email/\")\n    return self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        response_data_model_class=alternate_model_class,\n    )\n</code></pre>"},{"location":"reference/subscriptions/#pypaystack2.sub_clients.async_clients.subscriptions.AsyncSubscriptionClient","title":"<code>AsyncSubscriptionClient</code>","text":"<p>               Bases: <code>BaseAsyncAPIClient</code></p> <p>Provides a wrapper for paystack Subscriptions API</p> <p>The Subscriptions API allows you to create and manage recurring payment on your integration. https://paystack.com/docs/api/subscription/</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/subscriptions.py</code> <pre><code>class AsyncSubscriptionClient(BaseAsyncAPIClient):\n    \"\"\"Provides a wrapper for paystack Subscriptions API\n\n    The Subscriptions API allows you to create and manage recurring\n    payment on your integration.\n    https://paystack.com/docs/api/subscription/\n    \"\"\"\n\n    async def create(\n        self,\n        customer: int | str,\n        plan: str,\n        authorization: str | None = None,\n        start_date: str | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[Subscription] | Response[PaystackDataModel]:\n        \"\"\"Create a subscription on your integration\n\n        Note:\n            Email Token\n                paystack creates an email token on each subscription to allow customers\n                cancel their subscriptions from within the invoices sent to their mailboxes.\n                Since they are not authorized, the email tokens are what we use to authenticate\n                the requests over the API.\n\n        Args:\n            customer: Customer's email address or customer code\n            plan: Plan code\n            authorization: If customer has multiple authorizations, you can set\n                the desired authorization you wish to use for this\n                subscription here. If this is not supplied, the\n                customer's most recent authorization would be used\n            start_date: Set the date for the first debit. (ISO 8601 format) e.g. 2017-05-16T00:30:13+01:00\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(\"/subscription\")\n\n        payload = {\"customer\": customer, \"plan\": plan}\n        optional_params = [\n            (\"start_date\", start_date),\n            (\"authorization\", authorization),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or Subscription,\n        )\n\n    async def get_subscriptions(\n        self,\n        page: int = 1,\n        pagination: int = 50,\n        customer: int | None = None,\n        plan: str | int | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[list[Subscription]] | Response[PaystackDataModel]:\n        \"\"\"Fetch subscriptions available on your integration.\n\n        Args:\n            page: Specifies exactly what page you want to retrieve.\n                If not specified we use a default value of 1.\n            pagination: Specifies how many records you want to retrieve per page.\n                If not specified we use a default value of 50.\n            customer: Filter by Customer ID\n            plan: Filter by Plan ID\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(\"/subscription/?perPage=\" + str(pagination))\n        query_params = [\n            (\"page\", page),\n            (\"customer\", customer),\n            (\"plan\", plan),\n        ]\n        url = append_query_params(query_params, url)\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or Subscription,\n        )\n\n    async def get_subscription(\n        self,\n        id_or_code: int | str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[Subscription] | Response[PaystackDataModel]:\n        \"\"\"Fetch details of a subscription on your integration.\n\n        Args:\n            id_or_code: The subscription ``ID`` or ``code`` you want to fetch\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/subscription/{id_or_code}\")\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or Subscription,\n        )\n\n    async def enable(\n        self,\n        code: str,\n        token: str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[None] | Response[PaystackDataModel]:\n        \"\"\"Enable a subscription on your integration\n\n        Args:\n            code: Subscription code\n            token: Email token\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(\"/subscription/enable\")\n        payload = {\n            \"code\": code,\n            \"token\": token,\n        }\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class,\n        )\n\n    async def disable(\n        self,\n        code: str,\n        token: str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[None] | Response[PaystackDataModel]:\n        \"\"\"Disable a subscription on your integration\n\n        Args:\n            code: Subscription code\n            token: Email token\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._full_url(\"/subscription/disable\")\n        payload = {\n            \"code\": code,\n            \"token\": token,\n        }\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class,\n        )\n\n    async def get_update_link(\n        self,\n        code: str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[SubscriptionLink] | Response[PaystackDataModel]:\n        \"\"\"Generate a link for updating the card on a subscription\n\n        Args:\n            code: Subscription code\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/subscription/{code}/manage/link/\")\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or SubscriptionLink,\n        )\n\n    async def send_update_link(\n        self,\n        code: str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[None] | Response[PaystackDataModel]:\n        \"\"\"Email a customer a link for updating the card on their subscription\n\n        Args:\n            code: Subscription code\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/subscription/{code}/manage/email/\")\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            response_data_model_class=alternate_model_class,\n        )\n</code></pre>"},{"location":"reference/subscriptions/#pypaystack2.sub_clients.async_clients.subscriptions.AsyncSubscriptionClient.create","title":"<code>create(customer, plan, authorization=None, start_date=None, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Create a subscription on your integration</p> Note <p>Email Token     paystack creates an email token on each subscription to allow customers     cancel their subscriptions from within the invoices sent to their mailboxes.     Since they are not authorized, the email tokens are what we use to authenticate     the requests over the API.</p> <p>Parameters:</p> Name Type Description Default <code>customer</code> <code>int | str</code> <p>Customer's email address or customer code</p> required <code>plan</code> <code>str</code> <p>Plan code</p> required <code>authorization</code> <code>str | None</code> <p>If customer has multiple authorizations, you can set the desired authorization you wish to use for this subscription here. If this is not supplied, the customer's most recent authorization would be used</p> <code>None</code> <code>start_date</code> <code>str | None</code> <p>Set the date for the first debit. (ISO 8601 format) e.g. 2017-05-16T00:30:13+01:00</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[Subscription] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/subscriptions.py</code> <pre><code>async def create(\n    self,\n    customer: int | str,\n    plan: str,\n    authorization: str | None = None,\n    start_date: str | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[Subscription] | Response[PaystackDataModel]:\n    \"\"\"Create a subscription on your integration\n\n    Note:\n        Email Token\n            paystack creates an email token on each subscription to allow customers\n            cancel their subscriptions from within the invoices sent to their mailboxes.\n            Since they are not authorized, the email tokens are what we use to authenticate\n            the requests over the API.\n\n    Args:\n        customer: Customer's email address or customer code\n        plan: Plan code\n        authorization: If customer has multiple authorizations, you can set\n            the desired authorization you wish to use for this\n            subscription here. If this is not supplied, the\n            customer's most recent authorization would be used\n        start_date: Set the date for the first debit. (ISO 8601 format) e.g. 2017-05-16T00:30:13+01:00\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(\"/subscription\")\n\n    payload = {\"customer\": customer, \"plan\": plan}\n    optional_params = [\n        (\"start_date\", start_date),\n        (\"authorization\", authorization),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or Subscription,\n    )\n</code></pre>"},{"location":"reference/subscriptions/#pypaystack2.sub_clients.async_clients.subscriptions.AsyncSubscriptionClient.disable","title":"<code>disable(code, token, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Disable a subscription on your integration</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>Subscription code</p> required <code>token</code> <code>str</code> <p>Email token</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[None] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/subscriptions.py</code> <pre><code>async def disable(\n    self,\n    code: str,\n    token: str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[None] | Response[PaystackDataModel]:\n    \"\"\"Disable a subscription on your integration\n\n    Args:\n        code: Subscription code\n        token: Email token\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._full_url(\"/subscription/disable\")\n    payload = {\n        \"code\": code,\n        \"token\": token,\n    }\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class,\n    )\n</code></pre>"},{"location":"reference/subscriptions/#pypaystack2.sub_clients.async_clients.subscriptions.AsyncSubscriptionClient.enable","title":"<code>enable(code, token, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Enable a subscription on your integration</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>Subscription code</p> required <code>token</code> <code>str</code> <p>Email token</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[None] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/subscriptions.py</code> <pre><code>async def enable(\n    self,\n    code: str,\n    token: str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[None] | Response[PaystackDataModel]:\n    \"\"\"Enable a subscription on your integration\n\n    Args:\n        code: Subscription code\n        token: Email token\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(\"/subscription/enable\")\n    payload = {\n        \"code\": code,\n        \"token\": token,\n    }\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class,\n    )\n</code></pre>"},{"location":"reference/subscriptions/#pypaystack2.sub_clients.async_clients.subscriptions.AsyncSubscriptionClient.get_subscription","title":"<code>get_subscription(id_or_code, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Fetch details of a subscription on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>id_or_code</code> <code>int | str</code> <p>The subscription <code>ID</code> or <code>code</code> you want to fetch</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[Subscription] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/subscriptions.py</code> <pre><code>async def get_subscription(\n    self,\n    id_or_code: int | str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[Subscription] | Response[PaystackDataModel]:\n    \"\"\"Fetch details of a subscription on your integration.\n\n    Args:\n        id_or_code: The subscription ``ID`` or ``code`` you want to fetch\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/subscription/{id_or_code}\")\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or Subscription,\n    )\n</code></pre>"},{"location":"reference/subscriptions/#pypaystack2.sub_clients.async_clients.subscriptions.AsyncSubscriptionClient.get_subscriptions","title":"<code>get_subscriptions(page=1, pagination=50, customer=None, plan=None, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Fetch subscriptions available on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>int</code> <p>Specifies exactly what page you want to retrieve. If not specified we use a default value of 1.</p> <code>1</code> <code>pagination</code> <code>int</code> <p>Specifies how many records you want to retrieve per page. If not specified we use a default value of 50.</p> <code>50</code> <code>customer</code> <code>int | None</code> <p>Filter by Customer ID</p> <code>None</code> <code>plan</code> <code>str | int | None</code> <p>Filter by Plan ID</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[list[Subscription]] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/subscriptions.py</code> <pre><code>async def get_subscriptions(\n    self,\n    page: int = 1,\n    pagination: int = 50,\n    customer: int | None = None,\n    plan: str | int | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[list[Subscription]] | Response[PaystackDataModel]:\n    \"\"\"Fetch subscriptions available on your integration.\n\n    Args:\n        page: Specifies exactly what page you want to retrieve.\n            If not specified we use a default value of 1.\n        pagination: Specifies how many records you want to retrieve per page.\n            If not specified we use a default value of 50.\n        customer: Filter by Customer ID\n        plan: Filter by Plan ID\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(\"/subscription/?perPage=\" + str(pagination))\n    query_params = [\n        (\"page\", page),\n        (\"customer\", customer),\n        (\"plan\", plan),\n    ]\n    url = append_query_params(query_params, url)\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or Subscription,\n    )\n</code></pre>"},{"location":"reference/subscriptions/#pypaystack2.sub_clients.async_clients.subscriptions.AsyncSubscriptionClient.get_update_link","title":"<code>get_update_link(code, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Generate a link for updating the card on a subscription</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>Subscription code</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[SubscriptionLink] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/subscriptions.py</code> <pre><code>async def get_update_link(\n    self,\n    code: str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[SubscriptionLink] | Response[PaystackDataModel]:\n    \"\"\"Generate a link for updating the card on a subscription\n\n    Args:\n        code: Subscription code\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/subscription/{code}/manage/link/\")\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or SubscriptionLink,\n    )\n</code></pre>"},{"location":"reference/subscriptions/#pypaystack2.sub_clients.async_clients.subscriptions.AsyncSubscriptionClient.send_update_link","title":"<code>send_update_link(code, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Email a customer a link for updating the card on their subscription</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>Subscription code</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[None] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/subscriptions.py</code> <pre><code>async def send_update_link(\n    self,\n    code: str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[None] | Response[PaystackDataModel]:\n    \"\"\"Email a customer a link for updating the card on their subscription\n\n    Args:\n        code: Subscription code\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/subscription/{code}/manage/email/\")\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        response_data_model_class=alternate_model_class,\n    )\n</code></pre>"},{"location":"reference/terminals/","title":"Terminals","text":""},{"location":"reference/terminals/#pypaystack2.sub_clients.sync_clients.terminals.TerminalClient","title":"<code>TerminalClient</code>","text":"<p>               Bases: <code>BaseAPIClient</code></p> <p>Provides a wrapper for paystack Terminal API</p> <p>The Terminal API allows you to build delightful in-person payment experiences. https://paystack.com/docs/api/terminal/</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/terminals.py</code> <pre><code>class TerminalClient(BaseAPIClient):\n    \"\"\"Provides a wrapper for paystack Terminal API\n\n    The Terminal API allows you to build delightful in-person payment experiences.\n    https://paystack.com/docs/api/terminal/\n    \"\"\"\n\n    def send_event(\n        self,\n        terminal_id: int | str,\n        type_: TerminalEvent,\n        action: TerminalEventAction,\n        data: dict[str, Any],\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[TerminalEventData] | Response[PaystackDataModel]:\n        \"\"\"Send an event from your application to the Paystack Terminal\n\n        Args:\n            terminal_id: The ID of the Terminal the event should be sent to.\n            type_: The type of event to push. Paystack currently supports `TerminalEventType.INVOICE` and\n                `TerminalEventType.TRANSACTION`.\n            action: The action the Terminal needs to perform. For the `TerminalEventType.INVOICE` type,\n                the action can either be `TerminalEventAction.PROCESS` or TerminalEventAction.VIEW.\n                For the `TerminalEventType.TRANSACTION` type, the action can either be\n                `TerminalEventAction.PROCESS` or `TerminalEventAction.PRINT`.\n            data: The parameters needed to perform the specified action. For the invoice type, you need to\n                pass the invoice id and offline reference: {id: invoice_id, reference: offline_reference}.\n                For the transaction type, you can pass the transaction id: {id: transaction_id}\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n        supported_actions_mapping = {\n            TerminalEvent.TRANSACTION: {\n                TerminalEventAction.PROCESS,\n                TerminalEventAction.PRINT,\n            },\n            TerminalEvent.INVOICE: {\n                TerminalEventAction.PROCESS,\n                TerminalEventAction.VIEW,\n            },\n        }\n        if action not in supported_actions_mapping[type_]:\n            raise ValueError(\n                f\"Terminal Event: {type_} does not support Terminal Event Action: {action}\"\n            )\n\n        url = self._full_url(f\"/terminal/{terminal_id}/event\")\n\n        payload = {\n            \"type\": type_,\n            \"action\": action,\n            \"data\": data,\n        }\n        return self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or TerminalEventData,\n        )\n\n    def get_event_status(\n        self,\n        terminal_id: int | str,\n        event_id: int | str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[TerminalEventStatusData] | Response[PaystackDataModel]:\n        \"\"\"Check the status of an event sent to the Terminal\n\n        Args:\n            terminal_id: The ID of the Terminal the event was sent to.\n            event_id: The ID of the event that was sent to the Terminal\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._full_url(f\"/terminal/{terminal_id}/event/{event_id}\")\n        return self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or TerminalEventStatusData,\n        )\n\n    def get_terminal_status(\n        self,\n        terminal_id: int | str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[TerminalStatusData] | Response[PaystackDataModel]:\n        \"\"\"Check the availability of a Terminal before sending an event to it.\n\n        Args:\n            terminal_id: The ID of the Terminal you want to check\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._full_url(f\"/terminal/{terminal_id}/presence\")\n        return self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or TerminalStatusData,\n        )\n\n    def get_terminals(\n        self,\n        pagination: int = 50,\n        next_: str | None = None,\n        previous: str | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[list[Terminal]] | Response[PaystackDataModel]:\n        \"\"\"List the Terminals available on your integration\n\n        Args:\n            pagination: Specifies how many records you want to retrieve per page. If not specified, it defaults to 50.\n            next_: Specifies how many records you want to retrieve per page. If not specified\n                we use a default value of 50.\n            previous: A cursor that indicates your place in the list. It should be used to fetch the\n                previous page of the list after an initial next request\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._full_url(f\"/terminal?perPage={pagination}\")\n        query_params = [\n            (\"next\", next_),\n            (\"previous\", previous),\n        ]\n        url = append_query_params(query_params, url)\n        return self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or Terminal,\n        )\n\n    def get_terminal(\n        self,\n        terminal_id: int | str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[Terminal] | Response[PaystackDataModel]:\n        \"\"\"Get the details of a Terminal\n\n        Args:\n            terminal_id: The ID of the Terminal the event was sent to.\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._full_url(f\"/terminal/{terminal_id}/\")\n        return self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or Terminal,\n        )\n\n    def update_terminal(\n        self,\n        terminal_id: int | str,\n        name: str,\n        address: str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[None] | Response[PaystackDataModel]:\n        \"\"\"Update the details of a Terminal\n\n        Args:\n            terminal_id: The ID of the Terminal you want to update\n            name: Name of the terminal\n            address: The address of the Terminal\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._full_url(f\"/terminal/{terminal_id}\")\n\n        payload = {\"name\": name, \"address\": address}\n        return self._handle_request(  # type: ignore\n            HTTPMethod.PUT,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class,\n        )\n\n    def commission_terminal(\n        self,\n        serial_number: str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[None] | Response[PaystackDataModel]:\n        \"\"\"Activate your debug device by linking it to your integration\n\n        Args:\n            serial_number: Device Serial Number\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(\"/terminal/commission_device\")\n\n        payload = {\n            \"serial_number\": serial_number,\n        }\n        return self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class,\n        )\n\n    def decommission_terminal(\n        self,\n        serial_number: str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[None] | Response[PaystackDataModel]:\n        \"\"\"Unlink your debug device from your integration\n\n        Args:\n            serial_number: Device Serial Number\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._full_url(\"/terminal/decommission_device\")\n\n        payload = {\n            \"serial_number\": serial_number,\n        }\n        return self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class,\n        )\n</code></pre>"},{"location":"reference/terminals/#pypaystack2.sub_clients.sync_clients.terminals.TerminalClient.commission_terminal","title":"<code>commission_terminal(serial_number, alternate_model_class=None)</code>","text":"<p>Activate your debug device by linking it to your integration</p> <p>Parameters:</p> Name Type Description Default <code>serial_number</code> <code>str</code> <p>Device Serial Number</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[None] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/terminals.py</code> <pre><code>def commission_terminal(\n    self,\n    serial_number: str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[None] | Response[PaystackDataModel]:\n    \"\"\"Activate your debug device by linking it to your integration\n\n    Args:\n        serial_number: Device Serial Number\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(\"/terminal/commission_device\")\n\n    payload = {\n        \"serial_number\": serial_number,\n    }\n    return self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class,\n    )\n</code></pre>"},{"location":"reference/terminals/#pypaystack2.sub_clients.sync_clients.terminals.TerminalClient.decommission_terminal","title":"<code>decommission_terminal(serial_number, alternate_model_class=None)</code>","text":"<p>Unlink your debug device from your integration</p> <p>Parameters:</p> Name Type Description Default <code>serial_number</code> <code>str</code> <p>Device Serial Number</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[None] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/terminals.py</code> <pre><code>def decommission_terminal(\n    self,\n    serial_number: str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[None] | Response[PaystackDataModel]:\n    \"\"\"Unlink your debug device from your integration\n\n    Args:\n        serial_number: Device Serial Number\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._full_url(\"/terminal/decommission_device\")\n\n    payload = {\n        \"serial_number\": serial_number,\n    }\n    return self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class,\n    )\n</code></pre>"},{"location":"reference/terminals/#pypaystack2.sub_clients.sync_clients.terminals.TerminalClient.get_event_status","title":"<code>get_event_status(terminal_id, event_id, alternate_model_class=None)</code>","text":"<p>Check the status of an event sent to the Terminal</p> <p>Parameters:</p> Name Type Description Default <code>terminal_id</code> <code>int | str</code> <p>The ID of the Terminal the event was sent to.</p> required <code>event_id</code> <code>int | str</code> <p>The ID of the event that was sent to the Terminal</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[TerminalEventStatusData] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/terminals.py</code> <pre><code>def get_event_status(\n    self,\n    terminal_id: int | str,\n    event_id: int | str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[TerminalEventStatusData] | Response[PaystackDataModel]:\n    \"\"\"Check the status of an event sent to the Terminal\n\n    Args:\n        terminal_id: The ID of the Terminal the event was sent to.\n        event_id: The ID of the event that was sent to the Terminal\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._full_url(f\"/terminal/{terminal_id}/event/{event_id}\")\n    return self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or TerminalEventStatusData,\n    )\n</code></pre>"},{"location":"reference/terminals/#pypaystack2.sub_clients.sync_clients.terminals.TerminalClient.get_terminal","title":"<code>get_terminal(terminal_id, alternate_model_class=None)</code>","text":"<p>Get the details of a Terminal</p> <p>Parameters:</p> Name Type Description Default <code>terminal_id</code> <code>int | str</code> <p>The ID of the Terminal the event was sent to.</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[Terminal] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/terminals.py</code> <pre><code>def get_terminal(\n    self,\n    terminal_id: int | str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[Terminal] | Response[PaystackDataModel]:\n    \"\"\"Get the details of a Terminal\n\n    Args:\n        terminal_id: The ID of the Terminal the event was sent to.\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._full_url(f\"/terminal/{terminal_id}/\")\n    return self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or Terminal,\n    )\n</code></pre>"},{"location":"reference/terminals/#pypaystack2.sub_clients.sync_clients.terminals.TerminalClient.get_terminal_status","title":"<code>get_terminal_status(terminal_id, alternate_model_class=None)</code>","text":"<p>Check the availability of a Terminal before sending an event to it.</p> <p>Parameters:</p> Name Type Description Default <code>terminal_id</code> <code>int | str</code> <p>The ID of the Terminal you want to check</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[TerminalStatusData] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/terminals.py</code> <pre><code>def get_terminal_status(\n    self,\n    terminal_id: int | str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[TerminalStatusData] | Response[PaystackDataModel]:\n    \"\"\"Check the availability of a Terminal before sending an event to it.\n\n    Args:\n        terminal_id: The ID of the Terminal you want to check\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._full_url(f\"/terminal/{terminal_id}/presence\")\n    return self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or TerminalStatusData,\n    )\n</code></pre>"},{"location":"reference/terminals/#pypaystack2.sub_clients.sync_clients.terminals.TerminalClient.get_terminals","title":"<code>get_terminals(pagination=50, next_=None, previous=None, alternate_model_class=None)</code>","text":"<p>List the Terminals available on your integration</p> <p>Parameters:</p> Name Type Description Default <code>pagination</code> <code>int</code> <p>Specifies how many records you want to retrieve per page. If not specified, it defaults to 50.</p> <code>50</code> <code>next_</code> <code>str | None</code> <p>Specifies how many records you want to retrieve per page. If not specified we use a default value of 50.</p> <code>None</code> <code>previous</code> <code>str | None</code> <p>A cursor that indicates your place in the list. It should be used to fetch the previous page of the list after an initial next request</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[list[Terminal]] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/terminals.py</code> <pre><code>def get_terminals(\n    self,\n    pagination: int = 50,\n    next_: str | None = None,\n    previous: str | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[list[Terminal]] | Response[PaystackDataModel]:\n    \"\"\"List the Terminals available on your integration\n\n    Args:\n        pagination: Specifies how many records you want to retrieve per page. If not specified, it defaults to 50.\n        next_: Specifies how many records you want to retrieve per page. If not specified\n            we use a default value of 50.\n        previous: A cursor that indicates your place in the list. It should be used to fetch the\n            previous page of the list after an initial next request\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._full_url(f\"/terminal?perPage={pagination}\")\n    query_params = [\n        (\"next\", next_),\n        (\"previous\", previous),\n    ]\n    url = append_query_params(query_params, url)\n    return self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or Terminal,\n    )\n</code></pre>"},{"location":"reference/terminals/#pypaystack2.sub_clients.sync_clients.terminals.TerminalClient.send_event","title":"<code>send_event(terminal_id, type_, action, data, alternate_model_class=None)</code>","text":"<p>Send an event from your application to the Paystack Terminal</p> <p>Parameters:</p> Name Type Description Default <code>terminal_id</code> <code>int | str</code> <p>The ID of the Terminal the event should be sent to.</p> required <code>type_</code> <code>TerminalEvent</code> <p>The type of event to push. Paystack currently supports <code>TerminalEventType.INVOICE</code> and <code>TerminalEventType.TRANSACTION</code>.</p> required <code>action</code> <code>TerminalEventAction</code> <p>The action the Terminal needs to perform. For the <code>TerminalEventType.INVOICE</code> type, the action can either be <code>TerminalEventAction.PROCESS</code> or TerminalEventAction.VIEW. For the <code>TerminalEventType.TRANSACTION</code> type, the action can either be <code>TerminalEventAction.PROCESS</code> or <code>TerminalEventAction.PRINT</code>.</p> required <code>data</code> <code>dict[str, Any]</code> <p>The parameters needed to perform the specified action. For the invoice type, you need to pass the invoice id and offline reference: {id: invoice_id, reference: offline_reference}. For the transaction type, you can pass the transaction id: {id: transaction_id}</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[TerminalEventData] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/terminals.py</code> <pre><code>def send_event(\n    self,\n    terminal_id: int | str,\n    type_: TerminalEvent,\n    action: TerminalEventAction,\n    data: dict[str, Any],\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[TerminalEventData] | Response[PaystackDataModel]:\n    \"\"\"Send an event from your application to the Paystack Terminal\n\n    Args:\n        terminal_id: The ID of the Terminal the event should be sent to.\n        type_: The type of event to push. Paystack currently supports `TerminalEventType.INVOICE` and\n            `TerminalEventType.TRANSACTION`.\n        action: The action the Terminal needs to perform. For the `TerminalEventType.INVOICE` type,\n            the action can either be `TerminalEventAction.PROCESS` or TerminalEventAction.VIEW.\n            For the `TerminalEventType.TRANSACTION` type, the action can either be\n            `TerminalEventAction.PROCESS` or `TerminalEventAction.PRINT`.\n        data: The parameters needed to perform the specified action. For the invoice type, you need to\n            pass the invoice id and offline reference: {id: invoice_id, reference: offline_reference}.\n            For the transaction type, you can pass the transaction id: {id: transaction_id}\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n    supported_actions_mapping = {\n        TerminalEvent.TRANSACTION: {\n            TerminalEventAction.PROCESS,\n            TerminalEventAction.PRINT,\n        },\n        TerminalEvent.INVOICE: {\n            TerminalEventAction.PROCESS,\n            TerminalEventAction.VIEW,\n        },\n    }\n    if action not in supported_actions_mapping[type_]:\n        raise ValueError(\n            f\"Terminal Event: {type_} does not support Terminal Event Action: {action}\"\n        )\n\n    url = self._full_url(f\"/terminal/{terminal_id}/event\")\n\n    payload = {\n        \"type\": type_,\n        \"action\": action,\n        \"data\": data,\n    }\n    return self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or TerminalEventData,\n    )\n</code></pre>"},{"location":"reference/terminals/#pypaystack2.sub_clients.sync_clients.terminals.TerminalClient.update_terminal","title":"<code>update_terminal(terminal_id, name, address, alternate_model_class=None)</code>","text":"<p>Update the details of a Terminal</p> <p>Parameters:</p> Name Type Description Default <code>terminal_id</code> <code>int | str</code> <p>The ID of the Terminal you want to update</p> required <code>name</code> <code>str</code> <p>Name of the terminal</p> required <code>address</code> <code>str</code> <p>The address of the Terminal</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[None] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/terminals.py</code> <pre><code>def update_terminal(\n    self,\n    terminal_id: int | str,\n    name: str,\n    address: str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[None] | Response[PaystackDataModel]:\n    \"\"\"Update the details of a Terminal\n\n    Args:\n        terminal_id: The ID of the Terminal you want to update\n        name: Name of the terminal\n        address: The address of the Terminal\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._full_url(f\"/terminal/{terminal_id}\")\n\n    payload = {\"name\": name, \"address\": address}\n    return self._handle_request(  # type: ignore\n        HTTPMethod.PUT,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class,\n    )\n</code></pre>"},{"location":"reference/terminals/#pypaystack2.sub_clients.async_clients.terminals.AsyncTerminalClient","title":"<code>AsyncTerminalClient</code>","text":"<p>               Bases: <code>BaseAsyncAPIClient</code></p> <p>Provides a wrapper for paystack Terminal API</p> <p>The Terminal API allows you to create and manage recurring payment on your integration. https://paystack.com/docs/api/terminal/</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/terminals.py</code> <pre><code>class AsyncTerminalClient(BaseAsyncAPIClient):\n    \"\"\"Provides a wrapper for paystack Terminal API\n\n    The Terminal API allows you to create and manage recurring\n    payment on your integration.\n    https://paystack.com/docs/api/terminal/\n    \"\"\"\n\n    async def send_event(\n        self,\n        terminal_id: int | str,\n        type_: TerminalEvent,\n        action: TerminalEventAction,\n        data: dict[str, Any],\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[TerminalEventData] | Response[PaystackDataModel]:\n        \"\"\"Send an event from your application to the Paystack Terminal\n\n        Args:\n            terminal_id: The ID of the Terminal the event should be sent to.\n            type_: The type of event to push. Paystack currently supports `TerminalEventType.INVOICE` and\n                `TerminalEventType.TRANSACTION`.\n            action: The action the Terminal needs to perform. For the `TerminalEventType.INVOICE` type,\n                the action can either be `TerminalEventAction.PROCESS` or TerminalEventAction.VIEW.\n                For the `TerminalEventType.TRANSACTION` type, the action can either be\n                `TerminalEventAction.PROCESS` or `TerminalEventAction.PRINT`.\n            data: The parameters needed to perform the specified action. For the invoice type, you need to\n                pass the invoice id and offline reference: {id: invoice_id, reference: offline_reference}.\n                For the transaction type, you can pass the transaction id: {id: transaction_id}\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n        supported_actions_mapping = {\n            TerminalEvent.TRANSACTION: {\n                TerminalEventAction.PROCESS,\n                TerminalEventAction.PRINT,\n            },\n            TerminalEvent.INVOICE: {\n                TerminalEventAction.PROCESS,\n                TerminalEventAction.VIEW,\n            },\n        }\n        if action not in supported_actions_mapping[type_]:\n            raise ValueError(\n                f\"Terminal Event: {type_} does not support Terminal Event Action: {action}\"\n            )\n\n        url = self._full_url(f\"/terminal/{terminal_id}/event\")\n\n        payload = {\n            \"type\": type_,\n            \"action\": action,\n            \"data\": data,\n        }\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or TerminalEventData,\n        )\n\n    async def get_event_status(\n        self,\n        terminal_id: int | str,\n        event_id: int | str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[TerminalEventStatusData] | Response[PaystackDataModel]:\n        \"\"\"Check the status of an event sent to the Terminal\n\n        Args:\n            terminal_id: The ID of the Terminal the event was sent to.\n            event_id: The ID of the event that was sent to the Terminal\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._full_url(f\"/terminal/{terminal_id}/event/{event_id}\")\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or TerminalEventStatusData,\n        )\n\n    async def get_terminal_status(\n        self,\n        terminal_id: int | str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[TerminalStatusData] | Response[PaystackDataModel]:\n        \"\"\"Check the availability of a Terminal before sending an event to it.\n\n        Args:\n            terminal_id: The ID of the Terminal you want to check\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._full_url(f\"/terminal/{terminal_id}/presence\")\n        return await self._handle_request(\n            HTTPMethod.GET,\n            url,  # type: ignore\n            response_data_model_class=alternate_model_class or TerminalStatusData,\n        )\n\n    async def get_terminals(\n        self,\n        pagination: int = 50,\n        next_: str | None = None,\n        previous: str | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[list[Terminal]] | Response[PaystackDataModel]:\n        \"\"\"List the Terminals available on your integration\n\n        Args:\n            pagination: Specifies how many records you want to retrieve per page. If not specified, it defaults to 50.\n            next_: Specifies how many records you want to retrieve per page. If not specified\n                we use a default value of 50.\n            previous: A cursor that indicates your place in the list. It should be used to fetch the\n                previous page of the list after an initial next request\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._full_url(f\"/terminal?perPage={pagination}\")\n        query_params = [\n            (\"next\", next_),\n            (\"previous\", previous),\n        ]\n        url = append_query_params(query_params, url)\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or Terminal,\n        )\n\n    async def get_terminal(\n        self,\n        terminal_id: int | str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[Terminal] | Response[PaystackDataModel]:\n        \"\"\"Get the details of a Terminal\n\n        Args:\n            terminal_id: The ID of the Terminal the event was sent to.\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._full_url(f\"/terminal/{terminal_id}/\")\n        return await self._handle_request(\n            HTTPMethod.GET,\n            url,  # type: ignore\n            response_data_model_class=alternate_model_class or Terminal,\n        )\n\n    async def update_terminal(\n        self,\n        terminal_id: int | str,\n        name: str,\n        address: str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[None] | Response[PaystackDataModel]:\n        \"\"\"Update the details of a Terminal\n\n        Args:\n            terminal_id: The ID of the Terminal you want to update\n            name: Name of the terminal\n            address: The address of the Terminal\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._full_url(f\"/terminal/{terminal_id}\")\n\n        payload = {\"name\": name, \"address\": address}\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.PUT,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class,\n        )\n\n    async def commission_terminal(\n        self,\n        serial_number: str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[None] | Response[PaystackDataModel]:\n        \"\"\"Activate your debug device by linking it to your integration\n\n        Args:\n            serial_number: Device Serial Number\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(\"/terminal/commission_device\")\n\n        payload = {\n            \"serial_number\": serial_number,\n        }\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class,\n        )\n\n    async def decommission_terminal(\n        self,\n        serial_number: str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[None] | Response[PaystackDataModel]:\n        \"\"\"Unlink your debug device from your integration\n\n        Args:\n            serial_number: Device Serial Number\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._full_url(\"/terminal/decommission_device\")\n\n        payload = {\n            \"serial_number\": serial_number,\n        }\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class,\n        )\n</code></pre>"},{"location":"reference/terminals/#pypaystack2.sub_clients.async_clients.terminals.AsyncTerminalClient.commission_terminal","title":"<code>commission_terminal(serial_number, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Activate your debug device by linking it to your integration</p> <p>Parameters:</p> Name Type Description Default <code>serial_number</code> <code>str</code> <p>Device Serial Number</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[None] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/terminals.py</code> <pre><code>async def commission_terminal(\n    self,\n    serial_number: str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[None] | Response[PaystackDataModel]:\n    \"\"\"Activate your debug device by linking it to your integration\n\n    Args:\n        serial_number: Device Serial Number\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(\"/terminal/commission_device\")\n\n    payload = {\n        \"serial_number\": serial_number,\n    }\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class,\n    )\n</code></pre>"},{"location":"reference/terminals/#pypaystack2.sub_clients.async_clients.terminals.AsyncTerminalClient.decommission_terminal","title":"<code>decommission_terminal(serial_number, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Unlink your debug device from your integration</p> <p>Parameters:</p> Name Type Description Default <code>serial_number</code> <code>str</code> <p>Device Serial Number</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[None] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/terminals.py</code> <pre><code>async def decommission_terminal(\n    self,\n    serial_number: str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[None] | Response[PaystackDataModel]:\n    \"\"\"Unlink your debug device from your integration\n\n    Args:\n        serial_number: Device Serial Number\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._full_url(\"/terminal/decommission_device\")\n\n    payload = {\n        \"serial_number\": serial_number,\n    }\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class,\n    )\n</code></pre>"},{"location":"reference/terminals/#pypaystack2.sub_clients.async_clients.terminals.AsyncTerminalClient.get_event_status","title":"<code>get_event_status(terminal_id, event_id, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Check the status of an event sent to the Terminal</p> <p>Parameters:</p> Name Type Description Default <code>terminal_id</code> <code>int | str</code> <p>The ID of the Terminal the event was sent to.</p> required <code>event_id</code> <code>int | str</code> <p>The ID of the event that was sent to the Terminal</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[TerminalEventStatusData] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/terminals.py</code> <pre><code>async def get_event_status(\n    self,\n    terminal_id: int | str,\n    event_id: int | str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[TerminalEventStatusData] | Response[PaystackDataModel]:\n    \"\"\"Check the status of an event sent to the Terminal\n\n    Args:\n        terminal_id: The ID of the Terminal the event was sent to.\n        event_id: The ID of the event that was sent to the Terminal\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._full_url(f\"/terminal/{terminal_id}/event/{event_id}\")\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or TerminalEventStatusData,\n    )\n</code></pre>"},{"location":"reference/terminals/#pypaystack2.sub_clients.async_clients.terminals.AsyncTerminalClient.get_terminal","title":"<code>get_terminal(terminal_id, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Get the details of a Terminal</p> <p>Parameters:</p> Name Type Description Default <code>terminal_id</code> <code>int | str</code> <p>The ID of the Terminal the event was sent to.</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[Terminal] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/terminals.py</code> <pre><code>async def get_terminal(\n    self,\n    terminal_id: int | str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[Terminal] | Response[PaystackDataModel]:\n    \"\"\"Get the details of a Terminal\n\n    Args:\n        terminal_id: The ID of the Terminal the event was sent to.\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._full_url(f\"/terminal/{terminal_id}/\")\n    return await self._handle_request(\n        HTTPMethod.GET,\n        url,  # type: ignore\n        response_data_model_class=alternate_model_class or Terminal,\n    )\n</code></pre>"},{"location":"reference/terminals/#pypaystack2.sub_clients.async_clients.terminals.AsyncTerminalClient.get_terminal_status","title":"<code>get_terminal_status(terminal_id, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Check the availability of a Terminal before sending an event to it.</p> <p>Parameters:</p> Name Type Description Default <code>terminal_id</code> <code>int | str</code> <p>The ID of the Terminal you want to check</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[TerminalStatusData] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/terminals.py</code> <pre><code>async def get_terminal_status(\n    self,\n    terminal_id: int | str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[TerminalStatusData] | Response[PaystackDataModel]:\n    \"\"\"Check the availability of a Terminal before sending an event to it.\n\n    Args:\n        terminal_id: The ID of the Terminal you want to check\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._full_url(f\"/terminal/{terminal_id}/presence\")\n    return await self._handle_request(\n        HTTPMethod.GET,\n        url,  # type: ignore\n        response_data_model_class=alternate_model_class or TerminalStatusData,\n    )\n</code></pre>"},{"location":"reference/terminals/#pypaystack2.sub_clients.async_clients.terminals.AsyncTerminalClient.get_terminals","title":"<code>get_terminals(pagination=50, next_=None, previous=None, alternate_model_class=None)</code>  <code>async</code>","text":"<p>List the Terminals available on your integration</p> <p>Parameters:</p> Name Type Description Default <code>pagination</code> <code>int</code> <p>Specifies how many records you want to retrieve per page. If not specified, it defaults to 50.</p> <code>50</code> <code>next_</code> <code>str | None</code> <p>Specifies how many records you want to retrieve per page. If not specified we use a default value of 50.</p> <code>None</code> <code>previous</code> <code>str | None</code> <p>A cursor that indicates your place in the list. It should be used to fetch the previous page of the list after an initial next request</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[list[Terminal]] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/terminals.py</code> <pre><code>async def get_terminals(\n    self,\n    pagination: int = 50,\n    next_: str | None = None,\n    previous: str | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[list[Terminal]] | Response[PaystackDataModel]:\n    \"\"\"List the Terminals available on your integration\n\n    Args:\n        pagination: Specifies how many records you want to retrieve per page. If not specified, it defaults to 50.\n        next_: Specifies how many records you want to retrieve per page. If not specified\n            we use a default value of 50.\n        previous: A cursor that indicates your place in the list. It should be used to fetch the\n            previous page of the list after an initial next request\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._full_url(f\"/terminal?perPage={pagination}\")\n    query_params = [\n        (\"next\", next_),\n        (\"previous\", previous),\n    ]\n    url = append_query_params(query_params, url)\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or Terminal,\n    )\n</code></pre>"},{"location":"reference/terminals/#pypaystack2.sub_clients.async_clients.terminals.AsyncTerminalClient.send_event","title":"<code>send_event(terminal_id, type_, action, data, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Send an event from your application to the Paystack Terminal</p> <p>Parameters:</p> Name Type Description Default <code>terminal_id</code> <code>int | str</code> <p>The ID of the Terminal the event should be sent to.</p> required <code>type_</code> <code>TerminalEvent</code> <p>The type of event to push. Paystack currently supports <code>TerminalEventType.INVOICE</code> and <code>TerminalEventType.TRANSACTION</code>.</p> required <code>action</code> <code>TerminalEventAction</code> <p>The action the Terminal needs to perform. For the <code>TerminalEventType.INVOICE</code> type, the action can either be <code>TerminalEventAction.PROCESS</code> or TerminalEventAction.VIEW. For the <code>TerminalEventType.TRANSACTION</code> type, the action can either be <code>TerminalEventAction.PROCESS</code> or <code>TerminalEventAction.PRINT</code>.</p> required <code>data</code> <code>dict[str, Any]</code> <p>The parameters needed to perform the specified action. For the invoice type, you need to pass the invoice id and offline reference: {id: invoice_id, reference: offline_reference}. For the transaction type, you can pass the transaction id: {id: transaction_id}</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[TerminalEventData] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/terminals.py</code> <pre><code>async def send_event(\n    self,\n    terminal_id: int | str,\n    type_: TerminalEvent,\n    action: TerminalEventAction,\n    data: dict[str, Any],\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[TerminalEventData] | Response[PaystackDataModel]:\n    \"\"\"Send an event from your application to the Paystack Terminal\n\n    Args:\n        terminal_id: The ID of the Terminal the event should be sent to.\n        type_: The type of event to push. Paystack currently supports `TerminalEventType.INVOICE` and\n            `TerminalEventType.TRANSACTION`.\n        action: The action the Terminal needs to perform. For the `TerminalEventType.INVOICE` type,\n            the action can either be `TerminalEventAction.PROCESS` or TerminalEventAction.VIEW.\n            For the `TerminalEventType.TRANSACTION` type, the action can either be\n            `TerminalEventAction.PROCESS` or `TerminalEventAction.PRINT`.\n        data: The parameters needed to perform the specified action. For the invoice type, you need to\n            pass the invoice id and offline reference: {id: invoice_id, reference: offline_reference}.\n            For the transaction type, you can pass the transaction id: {id: transaction_id}\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n    supported_actions_mapping = {\n        TerminalEvent.TRANSACTION: {\n            TerminalEventAction.PROCESS,\n            TerminalEventAction.PRINT,\n        },\n        TerminalEvent.INVOICE: {\n            TerminalEventAction.PROCESS,\n            TerminalEventAction.VIEW,\n        },\n    }\n    if action not in supported_actions_mapping[type_]:\n        raise ValueError(\n            f\"Terminal Event: {type_} does not support Terminal Event Action: {action}\"\n        )\n\n    url = self._full_url(f\"/terminal/{terminal_id}/event\")\n\n    payload = {\n        \"type\": type_,\n        \"action\": action,\n        \"data\": data,\n    }\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or TerminalEventData,\n    )\n</code></pre>"},{"location":"reference/terminals/#pypaystack2.sub_clients.async_clients.terminals.AsyncTerminalClient.update_terminal","title":"<code>update_terminal(terminal_id, name, address, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Update the details of a Terminal</p> <p>Parameters:</p> Name Type Description Default <code>terminal_id</code> <code>int | str</code> <p>The ID of the Terminal you want to update</p> required <code>name</code> <code>str</code> <p>Name of the terminal</p> required <code>address</code> <code>str</code> <p>The address of the Terminal</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[None] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/terminals.py</code> <pre><code>async def update_terminal(\n    self,\n    terminal_id: int | str,\n    name: str,\n    address: str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[None] | Response[PaystackDataModel]:\n    \"\"\"Update the details of a Terminal\n\n    Args:\n        terminal_id: The ID of the Terminal you want to update\n        name: Name of the terminal\n        address: The address of the Terminal\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._full_url(f\"/terminal/{terminal_id}\")\n\n    payload = {\"name\": name, \"address\": address}\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.PUT,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class,\n    )\n</code></pre>"},{"location":"reference/transactions/","title":"Transactions","text":""},{"location":"reference/transactions/#pypaystack2.sub_clients.sync_clients.transactions.TransactionClient","title":"<code>TransactionClient</code>","text":"<p>               Bases: <code>BaseAPIClient</code></p> <p>Provides a wrapper for paystack Transactions API</p> <p>The Transactions API allows you to create and manage payments on your integration. see https://paystack.com/docs/api/transaction/</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/transactions.py</code> <pre><code>class TransactionClient(BaseAPIClient):\n    \"\"\"Provides a wrapper for paystack Transactions API\n\n    The Transactions API allows you to create and manage payments on your integration.\n    see https://paystack.com/docs/api/transaction/\n    \"\"\"\n\n    def initialize(\n        self,\n        amount: int,\n        email: str,\n        currency: Currency | None = None,\n        reference: str | None = None,\n        callback_url: str | None = None,\n        plan: str | None = None,\n        invoice_limit: int | None = None,\n        metadata: dict[str, Any] | None = None,\n        channels: list[Channel] | None = None,\n        split_code: str | None = None,\n        subaccount: str | None = None,\n        transfer_charge: int | None = None,\n        bearer: Bearer | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[InitTransaction] | Response[PaystackDataModel]:\n        \"\"\"Initialize a transaction from your backend\n\n        Args:\n            amount: Amount should be in kobo if currency is ``Currency.NGN``, pesewas,\n                if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR``\n            email: Customer's email address\n            currency: Any value from the ``Currency`` enum.\n            reference: Unique transaction reference. Only ``-, ., =`` and alphanumeric characters allowed.\n            callback_url: Fully qualified url, e.g. ``https://example.com/`` . Use this to override the callback url\n                provided on the dashboard for this transaction\n            plan: If transaction is to create a subscription to a predefined plan, provide plan code here.\n                This would invalidate the value provided in ``amount``\n            invoice_limit: Number of times to charge customer during subscription to plan\n            metadata: A dictionary of additional info. check out this link\n                for more information. https://paystack.com/docs/payments/metadata\n            channels: A list of ``Channel`` enum values to control what channels you want to make available\n                to the user to make a payment with\n            split_code: The split code of the transaction split. e.g. SPL_98WF13Eb3w\n            subaccount: The code for the subaccount that owns the payment. e.g. ACCT_8f4s1eq7ml6rlzj\n            transfer_charge: An amount used to override the split configuration for a single split payment. If set,\n                the amount specified goes to the main account regardless of the split configuration.\n            bearer: Any value from the ``Bearer`` enum. Who bears Paystack charges?\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n\n        Raises:\n            InvalidDataError: When email is not provided.\n        \"\"\"\n\n        if not email:\n            raise ValueError(\"Customer's Email is required for initialization\")\n\n        url = self._full_url(\"/transaction/initialize\")\n        payload = {\n            \"email\": email,\n            \"amount\": amount,\n        }\n\n        optional_params = [\n            (\"currency\", currency),\n            (\"reference\", reference),\n            (\"callback_url\", callback_url),\n            (\"plan\", plan),\n            (\"invoice_limit\", invoice_limit),\n            (\"metadata\", metadata),\n            (\"channels\", channels),\n            (\"split_code\", split_code),\n            (\"subaccount\", subaccount),\n            (\"transfer_charge\", transfer_charge),\n            (\"bearer\", bearer),\n        ]\n        payload = add_to_payload(optional_params, payload)\n\n        return self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or InitTransaction,\n        )\n\n    def verify(\n        self,\n        reference: str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[Transaction] | Response[PaystackDataModel]:\n        \"\"\"Confirm the status of a transaction\n\n        Args:\n            reference: The transaction reference used to initiate the transaction\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        reference = str(reference)\n        url = self._full_url(f\"/transaction/verify/{reference}\")\n        return self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or Transaction,\n        )\n\n    def get_transactions(\n        self,\n        customer: int | str | None = None,\n        start_date: str | None = None,\n        end_date: str | None = None,\n        status: TransactionStatus | None = None,\n        page: int | None = None,\n        amount: int | None = None,\n        pagination: int = 50,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[list[Transaction]] | Response[PaystackDataModel]:\n        \"\"\"Fetch transactions carried out on your integration.\n\n        Args:\n            customer: Specify an ID for the customer whose transactions you want to retrieve\n            start_date: A timestamp from which to start listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            end_date: A timestamp at which to stop listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            status: Filter transactions by status. any value from the ``TransactionStatus`` enum\n            page: Specify exactly what page you want to retrieve.\n                If not specified, we use a default value of 1.\n            amount: Optional[int]\n                Filter transactions by amount. Specify the amount (in kobo if currency is\n                ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``, and cents, if\n                currency is ``Currency.ZAR``)\n            pagination: Specifies how many records you want to retrieve per page. If not specified, we\n                use a default value of 50.\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/transaction/?perPage={pagination}\")\n        query_params = [\n            (\"page\", page),\n            (\"customer\", customer),\n            (\"status\", status),\n            (\"from\", start_date),\n            (\"to\", end_date),\n            (\"amount\", amount),\n        ]\n        url = append_query_params(query_params, url)\n\n        return self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or Transaction,\n        )\n\n    def get_transaction(\n        self,\n        id_: int | str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[Transaction] | Response[PaystackDataModel]:\n        \"\"\"Get details of a transaction carried out on your integration.\n\n        Args:\n            id_: An ID for the transaction to fetch\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/transaction/{id_}/\")\n        return self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or Transaction,\n        )\n\n    def charge(\n        self,\n        amount: int,\n        email: str,\n        auth_code: str,\n        reference: str | None = None,\n        currency: Currency | None = None,\n        metadata: dict[str, Any] | None = None,\n        channels: list[Channel] | None = None,\n        subaccount: str | None = None,\n        transaction_charge: int | None = None,\n        bearer: Bearer | None = None,\n        queue: bool = False,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[Transaction] | Response[PaystackDataModel]:\n        \"\"\"\n        All authorizations marked as reusable can be charged with this\n        endpoint whenever you need to receive payments.\n\n        Args:\n            amount: amount to charge.\n            email: Customer's email address\n            auth_code: Valid authorization code to charge\n            reference: Unique transaction reference. Only ``-, ., =`` and alphanumeric\n                characters allowed.\n            currency: Currency in which amount should be charged. Any value from the\n                ``Currency`` enum.\n            metadata: Add a custom_fields attribute which has an array of objects if\n                you would like the fields to be added to your transaction when\n                displayed on the dashboard.\n                Sample: ``{\"custom_fields\":[{\"display_name\":\"Cart ID\",\n                \"variable_name\": \"cart_id\",\"value\": \"8393\"}]}``\n            channels: A list of ``Channel`` enum values to control what channels you want to make available\n                to the user to make a payment with\n            subaccount: The code for the subaccount that owns the payment. e.g. ACCT_8f4s1eq7ml6rlzj\n            transaction_charge: A flat fee to charge the subaccount for this transaction (in kobo if currency is NGN,\n                pesewas, if currency is GHS, and cents, if currency is ZAR). This overrides the split\n                percentage set when the subaccount was created. Ideally, you will need to use this if\n                you are splitting in flat rates (since subaccount creation only allows for percentage split).\n                e.g., 7000 for a 70 naira\n            bearer: Who bears Paystack charges? any value from the ``Beaer`` enum\n            queue: If you are making a scheduled charge call, it is a good idea to queue them so the processing\n                system does not get overloaded causing transaction processing errors. Set ``queue=True`` to\n                take advantage of our queued charging.\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        if not email:\n            raise ValueError(\"Customer's Email is required to charge\")\n\n        if not auth_code:\n            raise ValueError(\"Customer's Auth code is required to charge\")\n\n        url = self._full_url(\"/transaction/charge_authorization\")\n        payload = {\n            \"authorization_code\": auth_code,\n            \"email\": email,\n            \"amount\": amount,\n        }\n        optional_params = [\n            (\"reference\", reference),\n            (\"currency\", currency),\n            (\"metadata\", metadata),\n            (\"channels\", channels),\n            (\"subaccount\", subaccount),\n            (\"transaction_charge\", transaction_charge),\n            (\"bearer\", bearer),\n            (\"queue\", queue),\n        ]\n        payload = add_to_payload(optional_params, payload)\n\n        return self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or Transaction,\n        )\n\n    def get_timeline(\n        self,\n        id_or_ref: int | str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[TransactionLog] | Response[PaystackDataModel]:\n        \"\"\"View the timeline of a transaction\n\n        Args:\n            id_or_ref: The ID or the reference of the transaction\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/transaction/timeline/{id_or_ref}\")\n        return self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or TransactionLog,\n        )\n\n    def totals(\n        self,\n        page: int | None = None,\n        start_date: str | None = None,\n        end_date: str | None = None,\n        pagination: int = 50,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[TransactionTotal] | Response[PaystackDataModel]:\n        \"\"\"Total amount received on your account\n\n        Args:\n            page: Specifies exactly what page you want to retrieve.\n                If not specified, we use a default value of 1.\n            start_date: A timestamp from which to start listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            end_date: A timestamp at which to stop listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            pagination: Specifies how many records you want to retrieve per page.\n                If not specified, we use a default value of 50.\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/transaction/totals/?perPage={pagination}\")\n        query_params = [\n            (\"page\", page),\n            (\"from\", start_date),\n            (\"to\", end_date),\n        ]\n        url = append_query_params(query_params, url)\n        return self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or TransactionTotal,\n        )\n\n    def export(\n        self,\n        page: int | None = None,\n        start_date: str | None = None,\n        end_date: str | None = None,\n        customer: str | int | None = None,\n        status: TransactionStatus | None = None,\n        currency: Currency | None = None,\n        amount: int | None = None,\n        settled: bool | None = None,\n        settlement: str | None = None,\n        payment_page: str | None = None,\n        pagination: int = 50,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[TransactionExport] | Response[PaystackDataModel]:\n        \"\"\"Fetch transactions carried out on your integration.\n\n        Args:\n            page: Specifies exactly what page you want to retrieve.\n                If not specified, we use a default value of 1.\n            start_date: A timestamp from which to start listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            end_date: A timestamp at which to stop listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            customer: Specify an ID for the customer whose transactions you want to retrieve\n            status: Filter transactions by status. Any value from the ``TransactionStatus`` enum\n            currency: Specify the transaction currency to export. Any value from the ``Currency`` enum\n            amount: Filter transactions by amount. Specify the amount, in\n                kobo if currency is ``Currency.NGN``, pesewas, if currency\n                is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR``\n            settled: Set to ``True`` to export only settled transactions. ``False`` for\n                pending transactions. Leave undefined to export all transaction\n            settlement: An ID for the settlement whose transactions we should export\n            payment_page: Optional[int]\n                Specify a payment page's id to export only transactions conducted on said page\n            pagination: int\n                Specifies how many records you want to retrieve per page.\n                If not specified, we use a default value of 50.\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/transaction/export/?perPage={pagination}\")\n        query_params = [\n            (\"page\", page),\n            (\"from\", start_date),\n            (\"to\", end_date),\n            (\"customer\", customer),\n            (\"status\", status),\n            (\"currency\", currency),\n            (\"amount\", amount),\n            (\"settled\", settled),\n            (\"settlement\", settlement),\n            (\"payment_page\", payment_page),\n        ]\n        url = append_query_params(query_params, url)\n        return self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or TransactionExport,\n        )\n\n    def partial_debit(\n        self,\n        auth_code: str,\n        currency: Currency,\n        amount: int,\n        email: str,\n        reference: str | None = None,\n        at_least: int | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[Transaction] | Response[PaystackDataModel]:\n        \"\"\"Retrieve part of a payment from a customer\n\n        Args:\n            auth_code: Authorization Code\n            currency: Specify the currency you want to debit. Any value\n                from the ``Currency`` enum.\n            amount: Amount should be in kobo if currency is ``Currency.NGN``, pesewas,\n                if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR``\n            email: Customer's email address (attached to the authorization code)\n            reference: Unique transaction reference. Only `-, ., =`\n                 and alphanumeric characters allowed.\n            at_least: Minimum amount to charge\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n\n        Raises:\n            InvalidDataError: When Customer's email is not provided. When Customer's auth code is not provided.\n        \"\"\"\n\n        if not email:\n            raise ValueError(\"Customer's Email is required to charge\")\n\n        if not auth_code:\n            raise ValueError(\"Customer's Auth code is required to charge\")\n\n        url = self._full_url(\"/transaction/partial_debit\")\n        payload = {\n            \"authorization_code\": auth_code,\n            \"currency\": currency,\n            \"amount\": amount,\n            \"email\": email,\n        }\n        optional_params = [(\"reference\", reference), (\"at_least\", at_least)]\n        payload = add_to_payload(optional_params, payload)\n\n        return self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or Transaction,\n        )\n</code></pre>"},{"location":"reference/transactions/#pypaystack2.sub_clients.sync_clients.transactions.TransactionClient.charge","title":"<code>charge(amount, email, auth_code, reference=None, currency=None, metadata=None, channels=None, subaccount=None, transaction_charge=None, bearer=None, queue=False, alternate_model_class=None)</code>","text":"<p>All authorizations marked as reusable can be charged with this endpoint whenever you need to receive payments.</p> <p>Parameters:</p> Name Type Description Default <code>amount</code> <code>int</code> <p>amount to charge.</p> required <code>email</code> <code>str</code> <p>Customer's email address</p> required <code>auth_code</code> <code>str</code> <p>Valid authorization code to charge</p> required <code>reference</code> <code>str | None</code> <p>Unique transaction reference. Only <code>-, ., =</code> and alphanumeric characters allowed.</p> <code>None</code> <code>currency</code> <code>Currency | None</code> <p>Currency in which amount should be charged. Any value from the <code>Currency</code> enum.</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>Add a custom_fields attribute which has an array of objects if you would like the fields to be added to your transaction when displayed on the dashboard. Sample: <code>{\"custom_fields\":[{\"display_name\":\"Cart ID\", \"variable_name\": \"cart_id\",\"value\": \"8393\"}]}</code></p> <code>None</code> <code>channels</code> <code>list[Channel] | None</code> <p>A list of <code>Channel</code> enum values to control what channels you want to make available to the user to make a payment with</p> <code>None</code> <code>subaccount</code> <code>str | None</code> <p>The code for the subaccount that owns the payment. e.g. ACCT_8f4s1eq7ml6rlzj</p> <code>None</code> <code>transaction_charge</code> <code>int | None</code> <p>A flat fee to charge the subaccount for this transaction (in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR). This overrides the split percentage set when the subaccount was created. Ideally, you will need to use this if you are splitting in flat rates (since subaccount creation only allows for percentage split). e.g., 7000 for a 70 naira</p> <code>None</code> <code>bearer</code> <code>Bearer | None</code> <p>Who bears Paystack charges? any value from the <code>Beaer</code> enum</p> <code>None</code> <code>queue</code> <code>bool</code> <p>If you are making a scheduled charge call, it is a good idea to queue them so the processing system does not get overloaded causing transaction processing errors. Set <code>queue=True</code> to take advantage of our queued charging.</p> <code>False</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[Transaction] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/transactions.py</code> <pre><code>def charge(\n    self,\n    amount: int,\n    email: str,\n    auth_code: str,\n    reference: str | None = None,\n    currency: Currency | None = None,\n    metadata: dict[str, Any] | None = None,\n    channels: list[Channel] | None = None,\n    subaccount: str | None = None,\n    transaction_charge: int | None = None,\n    bearer: Bearer | None = None,\n    queue: bool = False,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[Transaction] | Response[PaystackDataModel]:\n    \"\"\"\n    All authorizations marked as reusable can be charged with this\n    endpoint whenever you need to receive payments.\n\n    Args:\n        amount: amount to charge.\n        email: Customer's email address\n        auth_code: Valid authorization code to charge\n        reference: Unique transaction reference. Only ``-, ., =`` and alphanumeric\n            characters allowed.\n        currency: Currency in which amount should be charged. Any value from the\n            ``Currency`` enum.\n        metadata: Add a custom_fields attribute which has an array of objects if\n            you would like the fields to be added to your transaction when\n            displayed on the dashboard.\n            Sample: ``{\"custom_fields\":[{\"display_name\":\"Cart ID\",\n            \"variable_name\": \"cart_id\",\"value\": \"8393\"}]}``\n        channels: A list of ``Channel`` enum values to control what channels you want to make available\n            to the user to make a payment with\n        subaccount: The code for the subaccount that owns the payment. e.g. ACCT_8f4s1eq7ml6rlzj\n        transaction_charge: A flat fee to charge the subaccount for this transaction (in kobo if currency is NGN,\n            pesewas, if currency is GHS, and cents, if currency is ZAR). This overrides the split\n            percentage set when the subaccount was created. Ideally, you will need to use this if\n            you are splitting in flat rates (since subaccount creation only allows for percentage split).\n            e.g., 7000 for a 70 naira\n        bearer: Who bears Paystack charges? any value from the ``Beaer`` enum\n        queue: If you are making a scheduled charge call, it is a good idea to queue them so the processing\n            system does not get overloaded causing transaction processing errors. Set ``queue=True`` to\n            take advantage of our queued charging.\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    if not email:\n        raise ValueError(\"Customer's Email is required to charge\")\n\n    if not auth_code:\n        raise ValueError(\"Customer's Auth code is required to charge\")\n\n    url = self._full_url(\"/transaction/charge_authorization\")\n    payload = {\n        \"authorization_code\": auth_code,\n        \"email\": email,\n        \"amount\": amount,\n    }\n    optional_params = [\n        (\"reference\", reference),\n        (\"currency\", currency),\n        (\"metadata\", metadata),\n        (\"channels\", channels),\n        (\"subaccount\", subaccount),\n        (\"transaction_charge\", transaction_charge),\n        (\"bearer\", bearer),\n        (\"queue\", queue),\n    ]\n    payload = add_to_payload(optional_params, payload)\n\n    return self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or Transaction,\n    )\n</code></pre>"},{"location":"reference/transactions/#pypaystack2.sub_clients.sync_clients.transactions.TransactionClient.export","title":"<code>export(page=None, start_date=None, end_date=None, customer=None, status=None, currency=None, amount=None, settled=None, settlement=None, payment_page=None, pagination=50, alternate_model_class=None)</code>","text":"<p>Fetch transactions carried out on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>int | None</code> <p>Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1.</p> <code>None</code> <code>start_date</code> <code>str | None</code> <p>A timestamp from which to start listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>end_date</code> <code>str | None</code> <p>A timestamp at which to stop listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>customer</code> <code>str | int | None</code> <p>Specify an ID for the customer whose transactions you want to retrieve</p> <code>None</code> <code>status</code> <code>TransactionStatus | None</code> <p>Filter transactions by status. Any value from the <code>TransactionStatus</code> enum</p> <code>None</code> <code>currency</code> <code>Currency | None</code> <p>Specify the transaction currency to export. Any value from the <code>Currency</code> enum</p> <code>None</code> <code>amount</code> <code>int | None</code> <p>Filter transactions by amount. Specify the amount, in kobo if currency is <code>Currency.NGN</code>, pesewas, if currency is <code>Currency.GHS</code>, and cents, if currency is <code>Currency.ZAR</code></p> <code>None</code> <code>settled</code> <code>bool | None</code> <p>Set to <code>True</code> to export only settled transactions. <code>False</code> for pending transactions. Leave undefined to export all transaction</p> <code>None</code> <code>settlement</code> <code>str | None</code> <p>An ID for the settlement whose transactions we should export</p> <code>None</code> <code>payment_page</code> <code>str | None</code> <p>Optional[int] Specify a payment page's id to export only transactions conducted on said page</p> <code>None</code> <code>pagination</code> <code>int</code> <p>int Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50.</p> <code>50</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[TransactionExport] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/transactions.py</code> <pre><code>def export(\n    self,\n    page: int | None = None,\n    start_date: str | None = None,\n    end_date: str | None = None,\n    customer: str | int | None = None,\n    status: TransactionStatus | None = None,\n    currency: Currency | None = None,\n    amount: int | None = None,\n    settled: bool | None = None,\n    settlement: str | None = None,\n    payment_page: str | None = None,\n    pagination: int = 50,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[TransactionExport] | Response[PaystackDataModel]:\n    \"\"\"Fetch transactions carried out on your integration.\n\n    Args:\n        page: Specifies exactly what page you want to retrieve.\n            If not specified, we use a default value of 1.\n        start_date: A timestamp from which to start listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        end_date: A timestamp at which to stop listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        customer: Specify an ID for the customer whose transactions you want to retrieve\n        status: Filter transactions by status. Any value from the ``TransactionStatus`` enum\n        currency: Specify the transaction currency to export. Any value from the ``Currency`` enum\n        amount: Filter transactions by amount. Specify the amount, in\n            kobo if currency is ``Currency.NGN``, pesewas, if currency\n            is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR``\n        settled: Set to ``True`` to export only settled transactions. ``False`` for\n            pending transactions. Leave undefined to export all transaction\n        settlement: An ID for the settlement whose transactions we should export\n        payment_page: Optional[int]\n            Specify a payment page's id to export only transactions conducted on said page\n        pagination: int\n            Specifies how many records you want to retrieve per page.\n            If not specified, we use a default value of 50.\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/transaction/export/?perPage={pagination}\")\n    query_params = [\n        (\"page\", page),\n        (\"from\", start_date),\n        (\"to\", end_date),\n        (\"customer\", customer),\n        (\"status\", status),\n        (\"currency\", currency),\n        (\"amount\", amount),\n        (\"settled\", settled),\n        (\"settlement\", settlement),\n        (\"payment_page\", payment_page),\n    ]\n    url = append_query_params(query_params, url)\n    return self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or TransactionExport,\n    )\n</code></pre>"},{"location":"reference/transactions/#pypaystack2.sub_clients.sync_clients.transactions.TransactionClient.get_timeline","title":"<code>get_timeline(id_or_ref, alternate_model_class=None)</code>","text":"<p>View the timeline of a transaction</p> <p>Parameters:</p> Name Type Description Default <code>id_or_ref</code> <code>int | str</code> <p>The ID or the reference of the transaction</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[TransactionLog] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/transactions.py</code> <pre><code>def get_timeline(\n    self,\n    id_or_ref: int | str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[TransactionLog] | Response[PaystackDataModel]:\n    \"\"\"View the timeline of a transaction\n\n    Args:\n        id_or_ref: The ID or the reference of the transaction\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/transaction/timeline/{id_or_ref}\")\n    return self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or TransactionLog,\n    )\n</code></pre>"},{"location":"reference/transactions/#pypaystack2.sub_clients.sync_clients.transactions.TransactionClient.get_transaction","title":"<code>get_transaction(id_, alternate_model_class=None)</code>","text":"<p>Get details of a transaction carried out on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>int | str</code> <p>An ID for the transaction to fetch</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[Transaction] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/transactions.py</code> <pre><code>def get_transaction(\n    self,\n    id_: int | str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[Transaction] | Response[PaystackDataModel]:\n    \"\"\"Get details of a transaction carried out on your integration.\n\n    Args:\n        id_: An ID for the transaction to fetch\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/transaction/{id_}/\")\n    return self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or Transaction,\n    )\n</code></pre>"},{"location":"reference/transactions/#pypaystack2.sub_clients.sync_clients.transactions.TransactionClient.get_transactions","title":"<code>get_transactions(customer=None, start_date=None, end_date=None, status=None, page=None, amount=None, pagination=50, alternate_model_class=None)</code>","text":"<p>Fetch transactions carried out on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>customer</code> <code>int | str | None</code> <p>Specify an ID for the customer whose transactions you want to retrieve</p> <code>None</code> <code>start_date</code> <code>str | None</code> <p>A timestamp from which to start listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>end_date</code> <code>str | None</code> <p>A timestamp at which to stop listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>status</code> <code>TransactionStatus | None</code> <p>Filter transactions by status. any value from the <code>TransactionStatus</code> enum</p> <code>None</code> <code>page</code> <code>int | None</code> <p>Specify exactly what page you want to retrieve. If not specified, we use a default value of 1.</p> <code>None</code> <code>amount</code> <code>int | None</code> <p>Optional[int] Filter transactions by amount. Specify the amount (in kobo if currency is <code>Currency.NGN</code>, pesewas, if currency is <code>Currency.GHS</code>, and cents, if currency is <code>Currency.ZAR</code>)</p> <code>None</code> <code>pagination</code> <code>int</code> <p>Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50.</p> <code>50</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[list[Transaction]] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/transactions.py</code> <pre><code>def get_transactions(\n    self,\n    customer: int | str | None = None,\n    start_date: str | None = None,\n    end_date: str | None = None,\n    status: TransactionStatus | None = None,\n    page: int | None = None,\n    amount: int | None = None,\n    pagination: int = 50,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[list[Transaction]] | Response[PaystackDataModel]:\n    \"\"\"Fetch transactions carried out on your integration.\n\n    Args:\n        customer: Specify an ID for the customer whose transactions you want to retrieve\n        start_date: A timestamp from which to start listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        end_date: A timestamp at which to stop listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        status: Filter transactions by status. any value from the ``TransactionStatus`` enum\n        page: Specify exactly what page you want to retrieve.\n            If not specified, we use a default value of 1.\n        amount: Optional[int]\n            Filter transactions by amount. Specify the amount (in kobo if currency is\n            ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``, and cents, if\n            currency is ``Currency.ZAR``)\n        pagination: Specifies how many records you want to retrieve per page. If not specified, we\n            use a default value of 50.\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/transaction/?perPage={pagination}\")\n    query_params = [\n        (\"page\", page),\n        (\"customer\", customer),\n        (\"status\", status),\n        (\"from\", start_date),\n        (\"to\", end_date),\n        (\"amount\", amount),\n    ]\n    url = append_query_params(query_params, url)\n\n    return self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or Transaction,\n    )\n</code></pre>"},{"location":"reference/transactions/#pypaystack2.sub_clients.sync_clients.transactions.TransactionClient.initialize","title":"<code>initialize(amount, email, currency=None, reference=None, callback_url=None, plan=None, invoice_limit=None, metadata=None, channels=None, split_code=None, subaccount=None, transfer_charge=None, bearer=None, alternate_model_class=None)</code>","text":"<p>Initialize a transaction from your backend</p> <p>Parameters:</p> Name Type Description Default <code>amount</code> <code>int</code> <p>Amount should be in kobo if currency is <code>Currency.NGN</code>, pesewas, if currency is <code>Currency.GHS</code>, and cents, if currency is <code>Currency.ZAR</code></p> required <code>email</code> <code>str</code> <p>Customer's email address</p> required <code>currency</code> <code>Currency | None</code> <p>Any value from the <code>Currency</code> enum.</p> <code>None</code> <code>reference</code> <code>str | None</code> <p>Unique transaction reference. Only <code>-, ., =</code> and alphanumeric characters allowed.</p> <code>None</code> <code>callback_url</code> <code>str | None</code> <p>Fully qualified url, e.g. <code>https://example.com/</code> . Use this to override the callback url provided on the dashboard for this transaction</p> <code>None</code> <code>plan</code> <code>str | None</code> <p>If transaction is to create a subscription to a predefined plan, provide plan code here. This would invalidate the value provided in <code>amount</code></p> <code>None</code> <code>invoice_limit</code> <code>int | None</code> <p>Number of times to charge customer during subscription to plan</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>A dictionary of additional info. check out this link for more information. https://paystack.com/docs/payments/metadata</p> <code>None</code> <code>channels</code> <code>list[Channel] | None</code> <p>A list of <code>Channel</code> enum values to control what channels you want to make available to the user to make a payment with</p> <code>None</code> <code>split_code</code> <code>str | None</code> <p>The split code of the transaction split. e.g. SPL_98WF13Eb3w</p> <code>None</code> <code>subaccount</code> <code>str | None</code> <p>The code for the subaccount that owns the payment. e.g. ACCT_8f4s1eq7ml6rlzj</p> <code>None</code> <code>transfer_charge</code> <code>int | None</code> <p>An amount used to override the split configuration for a single split payment. If set, the amount specified goes to the main account regardless of the split configuration.</p> <code>None</code> <code>bearer</code> <code>Bearer | None</code> <p>Any value from the <code>Bearer</code> enum. Who bears Paystack charges?</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[InitTransaction] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> <p>Raises:</p> Type Description <code>InvalidDataError</code> <p>When email is not provided.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/transactions.py</code> <pre><code>def initialize(\n    self,\n    amount: int,\n    email: str,\n    currency: Currency | None = None,\n    reference: str | None = None,\n    callback_url: str | None = None,\n    plan: str | None = None,\n    invoice_limit: int | None = None,\n    metadata: dict[str, Any] | None = None,\n    channels: list[Channel] | None = None,\n    split_code: str | None = None,\n    subaccount: str | None = None,\n    transfer_charge: int | None = None,\n    bearer: Bearer | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[InitTransaction] | Response[PaystackDataModel]:\n    \"\"\"Initialize a transaction from your backend\n\n    Args:\n        amount: Amount should be in kobo if currency is ``Currency.NGN``, pesewas,\n            if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR``\n        email: Customer's email address\n        currency: Any value from the ``Currency`` enum.\n        reference: Unique transaction reference. Only ``-, ., =`` and alphanumeric characters allowed.\n        callback_url: Fully qualified url, e.g. ``https://example.com/`` . Use this to override the callback url\n            provided on the dashboard for this transaction\n        plan: If transaction is to create a subscription to a predefined plan, provide plan code here.\n            This would invalidate the value provided in ``amount``\n        invoice_limit: Number of times to charge customer during subscription to plan\n        metadata: A dictionary of additional info. check out this link\n            for more information. https://paystack.com/docs/payments/metadata\n        channels: A list of ``Channel`` enum values to control what channels you want to make available\n            to the user to make a payment with\n        split_code: The split code of the transaction split. e.g. SPL_98WF13Eb3w\n        subaccount: The code for the subaccount that owns the payment. e.g. ACCT_8f4s1eq7ml6rlzj\n        transfer_charge: An amount used to override the split configuration for a single split payment. If set,\n            the amount specified goes to the main account regardless of the split configuration.\n        bearer: Any value from the ``Bearer`` enum. Who bears Paystack charges?\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n\n    Raises:\n        InvalidDataError: When email is not provided.\n    \"\"\"\n\n    if not email:\n        raise ValueError(\"Customer's Email is required for initialization\")\n\n    url = self._full_url(\"/transaction/initialize\")\n    payload = {\n        \"email\": email,\n        \"amount\": amount,\n    }\n\n    optional_params = [\n        (\"currency\", currency),\n        (\"reference\", reference),\n        (\"callback_url\", callback_url),\n        (\"plan\", plan),\n        (\"invoice_limit\", invoice_limit),\n        (\"metadata\", metadata),\n        (\"channels\", channels),\n        (\"split_code\", split_code),\n        (\"subaccount\", subaccount),\n        (\"transfer_charge\", transfer_charge),\n        (\"bearer\", bearer),\n    ]\n    payload = add_to_payload(optional_params, payload)\n\n    return self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or InitTransaction,\n    )\n</code></pre>"},{"location":"reference/transactions/#pypaystack2.sub_clients.sync_clients.transactions.TransactionClient.partial_debit","title":"<code>partial_debit(auth_code, currency, amount, email, reference=None, at_least=None, alternate_model_class=None)</code>","text":"<p>Retrieve part of a payment from a customer</p> <p>Parameters:</p> Name Type Description Default <code>auth_code</code> <code>str</code> <p>Authorization Code</p> required <code>currency</code> <code>Currency</code> <p>Specify the currency you want to debit. Any value from the <code>Currency</code> enum.</p> required <code>amount</code> <code>int</code> <p>Amount should be in kobo if currency is <code>Currency.NGN</code>, pesewas, if currency is <code>Currency.GHS</code>, and cents, if currency is <code>Currency.ZAR</code></p> required <code>email</code> <code>str</code> <p>Customer's email address (attached to the authorization code)</p> required <code>reference</code> <code>str | None</code> <p>Unique transaction reference. Only <code>-, ., =</code>  and alphanumeric characters allowed.</p> <code>None</code> <code>at_least</code> <code>int | None</code> <p>Minimum amount to charge</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[Transaction] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> <p>Raises:</p> Type Description <code>InvalidDataError</code> <p>When Customer's email is not provided. When Customer's auth code is not provided.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/transactions.py</code> <pre><code>def partial_debit(\n    self,\n    auth_code: str,\n    currency: Currency,\n    amount: int,\n    email: str,\n    reference: str | None = None,\n    at_least: int | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[Transaction] | Response[PaystackDataModel]:\n    \"\"\"Retrieve part of a payment from a customer\n\n    Args:\n        auth_code: Authorization Code\n        currency: Specify the currency you want to debit. Any value\n            from the ``Currency`` enum.\n        amount: Amount should be in kobo if currency is ``Currency.NGN``, pesewas,\n            if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR``\n        email: Customer's email address (attached to the authorization code)\n        reference: Unique transaction reference. Only `-, ., =`\n             and alphanumeric characters allowed.\n        at_least: Minimum amount to charge\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n\n    Raises:\n        InvalidDataError: When Customer's email is not provided. When Customer's auth code is not provided.\n    \"\"\"\n\n    if not email:\n        raise ValueError(\"Customer's Email is required to charge\")\n\n    if not auth_code:\n        raise ValueError(\"Customer's Auth code is required to charge\")\n\n    url = self._full_url(\"/transaction/partial_debit\")\n    payload = {\n        \"authorization_code\": auth_code,\n        \"currency\": currency,\n        \"amount\": amount,\n        \"email\": email,\n    }\n    optional_params = [(\"reference\", reference), (\"at_least\", at_least)]\n    payload = add_to_payload(optional_params, payload)\n\n    return self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or Transaction,\n    )\n</code></pre>"},{"location":"reference/transactions/#pypaystack2.sub_clients.sync_clients.transactions.TransactionClient.totals","title":"<code>totals(page=None, start_date=None, end_date=None, pagination=50, alternate_model_class=None)</code>","text":"<p>Total amount received on your account</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>int | None</code> <p>Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1.</p> <code>None</code> <code>start_date</code> <code>str | None</code> <p>A timestamp from which to start listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>end_date</code> <code>str | None</code> <p>A timestamp at which to stop listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>pagination</code> <code>int</code> <p>Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50.</p> <code>50</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[TransactionTotal] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/transactions.py</code> <pre><code>def totals(\n    self,\n    page: int | None = None,\n    start_date: str | None = None,\n    end_date: str | None = None,\n    pagination: int = 50,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[TransactionTotal] | Response[PaystackDataModel]:\n    \"\"\"Total amount received on your account\n\n    Args:\n        page: Specifies exactly what page you want to retrieve.\n            If not specified, we use a default value of 1.\n        start_date: A timestamp from which to start listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        end_date: A timestamp at which to stop listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        pagination: Specifies how many records you want to retrieve per page.\n            If not specified, we use a default value of 50.\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/transaction/totals/?perPage={pagination}\")\n    query_params = [\n        (\"page\", page),\n        (\"from\", start_date),\n        (\"to\", end_date),\n    ]\n    url = append_query_params(query_params, url)\n    return self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or TransactionTotal,\n    )\n</code></pre>"},{"location":"reference/transactions/#pypaystack2.sub_clients.sync_clients.transactions.TransactionClient.verify","title":"<code>verify(reference, alternate_model_class=None)</code>","text":"<p>Confirm the status of a transaction</p> <p>Parameters:</p> Name Type Description Default <code>reference</code> <code>str</code> <p>The transaction reference used to initiate the transaction</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[Transaction] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/transactions.py</code> <pre><code>def verify(\n    self,\n    reference: str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[Transaction] | Response[PaystackDataModel]:\n    \"\"\"Confirm the status of a transaction\n\n    Args:\n        reference: The transaction reference used to initiate the transaction\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    reference = str(reference)\n    url = self._full_url(f\"/transaction/verify/{reference}\")\n    return self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or Transaction,\n    )\n</code></pre>"},{"location":"reference/transactions/#pypaystack2.sub_clients.async_clients.transactions.AsyncTransactionClient","title":"<code>AsyncTransactionClient</code>","text":"<p>               Bases: <code>BaseAsyncAPIClient</code></p> <p>Provides a wrapper for paystack Transactions API</p> <p>The Transactions API allows you to create and manage payments on your integration. https://paystack.com/docs/api/transaction/</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/transactions.py</code> <pre><code>class AsyncTransactionClient(BaseAsyncAPIClient):\n    \"\"\"Provides a wrapper for paystack Transactions API\n\n    The Transactions API allows you to create and manage payments on your integration.\n    https://paystack.com/docs/api/transaction/\n    \"\"\"\n\n    async def initialize(\n        self,\n        amount: int,\n        email: str,\n        currency: Currency | None = None,\n        reference: str | None = None,\n        callback_url: str | None = None,\n        plan: str | None = None,\n        invoice_limit: int | None = None,\n        metadata: dict[str, Any] | None = None,\n        channels: list[Channel] | None = None,\n        split_code: str | None = None,\n        subaccount: str | None = None,\n        transfer_charge: int | None = None,\n        bearer: Bearer | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[InitTransaction] | Response[PaystackDataModel]:\n        \"\"\"Initialize a transaction from your backend\n\n        Args:\n            amount: Amount should be in kobo if currency is ``Currency.NGN``, pesewas,\n                if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR``\n            email: Customer's email address\n            currency: Any value from the ``Currency`` enum.\n            reference: Unique transaction reference. Only ``-, ., =`` and alphanumeric characters allowed.\n            callback_url: Fully qualified url, e.g. ``https://example.com/`` . Use this to override the callback url\n                provided on the dashboard for this transaction\n            plan: If transaction is to create a subscription to a predefined plan, provide plan code here.\n                This would invalidate the value provided in ``amount``\n            invoice_limit: Number of times to charge customer during subscription to plan\n            metadata: A dictionary of additional info. check out this link\n                for more information. https://paystack.com/docs/payments/metadata\n            channels: A list of ``Channel`` enum values to control what channels you want to make available\n                to the user to make a payment with\n            split_code: The split code of the transaction split. e.g. SPL_98WF13Eb3w\n            subaccount: The code for the subaccount that owns the payment. e.g. ACCT_8f4s1eq7ml6rlzj\n            transfer_charge: An amount used to override the split configuration for a single split payment. If set,\n                the amount specified goes to the main account regardless of the split configuration.\n            bearer: Any value from the ``Bearer`` enum. Who bears Paystack charges?\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n\n        Raises:\n            InvalidDataError: When email is not provided.\n        \"\"\"\n\n        if not email:\n            raise ValueError(\"Customer's Email is required for initialization\")\n\n        url = self._full_url(\"/transaction/initialize\")\n        payload = {\n            \"email\": email,\n            \"amount\": amount,\n        }\n\n        optional_params = [\n            (\"currency\", currency),\n            (\"reference\", reference),\n            (\"callback_url\", callback_url),\n            (\"plan\", plan),\n            (\"invoice_limit\", invoice_limit),\n            (\"metadata\", metadata),\n            (\"channels\", channels),\n            (\"split_code\", split_code),\n            (\"subaccount\", subaccount),\n            (\"transfer_charge\", transfer_charge),\n            (\"bearer\", bearer),\n        ]\n        payload = add_to_payload(\n            optional_params,\n            payload,\n        )\n\n        return await self._handle_request(\n            HTTPMethod.POST,\n            url,\n            payload,  # type: ignore\n            response_data_model_class=alternate_model_class or InitTransaction,\n        )\n\n    async def verify(\n        self,\n        reference: str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[Transaction] | Response[PaystackDataModel]:\n        \"\"\"Confirm the status of a transaction\n\n        Args:\n            reference: The transaction reference used to initiate the transaction\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        reference = str(reference)\n        url = self._full_url(f\"/transaction/verify/{reference}\")\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or Transaction,\n        )\n\n    async def get_transactions(\n        self,\n        customer: int | str | None = None,\n        start_date: str | None = None,\n        end_date: str | None = None,\n        status: TransactionStatus | None = None,\n        page: int | None = None,\n        amount: int | None = None,\n        pagination: int = 50,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[list[Transaction]] | Response[PaystackDataModel]:\n        \"\"\"Fetch transactions carried out on your integration.\n\n        Args:\n            customer: Specify an ID for the customer whose transactions you want to retrieve\n            start_date: A timestamp from which to start listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            end_date: A timestamp at which to stop listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            status: Filter transactions by status. any value from the ``TransactionStatus`` enum\n            page: Specify exactly what page you want to retrieve.\n                If not specified, we use a default value of 1.\n            amount: Optional[int]\n                Filter transactions by amount. Specify the amount (in kobo if currency is\n                ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``, and cents, if\n                currency is ``Currency.ZAR``)\n            pagination: Specifies how many records you want to retrieve per page. If not specified, we\n                use a default value of 50.\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/transaction/?perPage={pagination}\")\n        query_params = [\n            (\"page\", page),\n            (\"customer\", customer),\n            (\"status\", status),\n            (\"from\", start_date),\n            (\"to\", end_date),\n            (\"amount\", amount),\n        ]\n        url = append_query_params(query_params, url)\n\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or Transaction,\n        )\n\n    async def get_transaction(\n        self,\n        id_: str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[Transaction] | Response[PaystackDataModel]:\n        \"\"\"Get details of a transaction carried out on your integration.\n\n        Args:\n            id_: An ID for the transaction to fetch\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/transaction/{id_}/\")\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or Transaction,\n        )\n\n    async def charge(\n        self,\n        amount: int,\n        email: str,\n        auth_code: str,\n        reference: str | None = None,\n        currency: Currency | None = None,\n        metadata: dict[str, Any] | None = None,\n        channels: list[Channel] | None = None,\n        subaccount: str | None = None,\n        transaction_charge: int | None = None,\n        bearer: Bearer | None = None,\n        queue: bool = False,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[Transaction] | Response[PaystackDataModel]:\n        \"\"\"\n        All authorizations marked as reusable can be charged with this\n        endpoint whenever you need to receive payments.\n\n        Args:\n            amount: amount to charge.\n            email: Customer's email address\n            auth_code: Valid authorization code to charge\n            reference: Unique transaction reference. Only ``-, ., =`` and alphanumeric\n                characters allowed.\n            currency: Currency in which amount should be charged. Any value from the\n                ``Currency`` enum.\n            metadata: Add a custom_fields attribute which has an array of objects if\n                you would like the fields to be added to your transaction when\n                displayed on the dashboard.\n                Sample: ``{\"custom_fields\":[{\"display_name\":\"Cart ID\",\n                \"variable_name\": \"cart_id\",\"value\": \"8393\"}]}``\n            channels: A list of ``Channel`` enum values to control what channels you want to make available\n                to the user to make a payment with\n            subaccount: The code for the subaccount that owns the payment. e.g. ACCT_8f4s1eq7ml6rlzj\n            transaction_charge: A flat fee to charge the subaccount for this transaction (in kobo if currency is NGN,\n                pesewas, if currency is GHS, and cents, if currency is ZAR). This overrides the split\n                percentage set when the subaccount was created. Ideally, you will need to use this if\n                you are splitting in flat rates (since subaccount creation only allows for percentage split).\n                e.g., 7000 for a 70 naira\n            bearer: Who bears Paystack charges? any value from the ``Beaer`` enum\n            queue: If you are making a scheduled charge call, it is a good idea to queue them so the processing\n                system does not get overloaded causing transaction processing errors. Set ``queue=True`` to\n                take advantage of our queued charging.\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        if not email:\n            raise ValueError(\"Customer's Email is required to charge\")\n\n        if not auth_code:\n            raise ValueError(\"Customer's Auth code is required to charge\")\n\n        url = self._full_url(\"/transaction/charge_authorization\")\n        payload = {\n            \"authorization_code\": auth_code,\n            \"email\": email,\n            \"amount\": amount,\n        }\n        optional_params = [\n            (\"reference\", reference),\n            (\"currency\", currency),\n            (\"metadata\", metadata),\n            (\"channels\", channels),\n            (\"subaccount\", subaccount),\n            (\"transaction_charge\", transaction_charge),\n            (\"bearer\", bearer),\n            (\"queue\", queue),\n        ]\n        payload = add_to_payload(optional_params, payload)\n\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or Transaction,\n        )\n\n    async def get_timeline(\n        self,\n        id_or_ref: int | str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[TransactionLog] | Response[PaystackDataModel]:\n        \"\"\"View the timeline of a transaction\n\n        Args:\n            id_or_ref: The ID or the reference of the transaction\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/transaction/timeline/{id_or_ref}\")\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or TransactionLog,\n        )\n\n    async def totals(\n        self,\n        page: int | None = None,\n        start_date: str | None = None,\n        end_date: str | None = None,\n        pagination: int = 50,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[TransactionTotal] | Response[PaystackDataModel]:\n        \"\"\"Total amount received on your account\n\n        Args:\n            page: Specifies exactly what page you want to retrieve.\n                If not specified, we use a default value of 1.\n            start_date: A timestamp from which to start listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            end_date: A timestamp at which to stop listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            pagination: Specifies how many records you want to retrieve per page.\n                If not specified, we use a default value of 50.\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/transaction/totals/?perPage={pagination}\")\n        query_params = [\n            (\"page\", page),\n            (\"from\", start_date),\n            (\"to\", end_date),\n        ]\n        url = append_query_params(query_params, url)\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or TransactionTotal,\n        )\n\n    async def export(\n        self,\n        page: int | None = None,\n        start_date: str | None = None,\n        end_date: str | None = None,\n        customer: str | int | None = None,\n        status: TransactionStatus | None = None,\n        currency: Currency | None = None,\n        amount: int | None = None,\n        settled: bool | None = None,\n        settlement: str | None = None,\n        payment_page: str | None = None,\n        pagination: int = 50,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[TransactionExport] | Response[PaystackDataModel]:\n        \"\"\"Fetch transactions carried out on your integration.\n\n        Args:\n            page: Specifies exactly what page you want to retrieve.\n                If not specified, we use a default value of 1.\n            start_date: A timestamp from which to start listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            end_date: A timestamp at which to stop listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            customer: Specify an ID for the customer whose transactions you want to retrieve\n            status: Filter transactions by status. Any value from the ``TransactionStatus`` enum\n            currency: Specify the transaction currency to export. Any value from the ``Currency`` enum\n            amount: Filter transactions by amount. Specify the amount, in\n                kobo if currency is ``Currency.NGN``, pesewas, if currency\n                is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR``\n            settled: Set to ``True`` to export only settled transactions. ``False`` for\n                pending transactions. Leave undefined to export all transaction\n            settlement: An ID for the settlement whose transactions we should export\n            payment_page: Optional[int]\n                Specify a payment page's id to export only transactions conducted on said page\n            pagination: int\n                Specifies how many records you want to retrieve per page.\n                If not specified, we use a default value of 50.\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/transaction/export/?perPage={pagination}\")\n        query_params = [\n            (\"page\", page),\n            (\"from\", start_date),\n            (\"to\", end_date),\n            (\"customer\", customer),\n            (\"status\", status),\n            (\"currency\", currency),\n            (\"amount\", amount),\n            (\"settled\", settled),\n            (\"settlement\", settlement),\n            (\"payment_page\", payment_page),\n        ]\n        url = append_query_params(query_params, url)\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or TransactionExport,\n        )\n\n    async def partial_debit(\n        self,\n        auth_code: str,\n        currency: Currency,\n        amount: int,\n        email: str,\n        reference: str | None = None,\n        at_least: int | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[Transaction] | Response[PaystackDataModel]:\n        \"\"\"Retrieve part of a payment from a customer\n\n        Args:\n            auth_code: Authorization Code\n            currency: Specify the currency you want to debit. Any value\n                from the ``Currency`` enum.\n            amount: Amount should be in kobo if currency is ``Currency.NGN``, pesewas,\n                if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR``\n            email: Customer's email address (attached to the authorization code)\n            reference: Unique transaction reference. Only `-, ., =`\n                 and alphanumeric characters allowed.\n            at_least: Minimum amount to charge\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n\n        Raises:\n            InvalidDataError: When Customer's email is not provided. When Customer's auth code is not provided.\n        \"\"\"\n\n        if not email:\n            raise ValueError(\"Customer's Email is required to charge\")\n\n        if not auth_code:\n            raise ValueError(\"Customer's Auth code is required to charge\")\n\n        url = self._full_url(\"/transaction/partial_debit\")\n        payload = {\n            \"authorization_code\": auth_code,\n            \"currency\": currency,\n            \"amount\": amount,\n            \"email\": email,\n        }\n        optional_params = [(\"reference\", reference), (\"at_least\", at_least)]\n        payload = add_to_payload(optional_params, payload)\n\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or Transaction,\n        )\n</code></pre>"},{"location":"reference/transactions/#pypaystack2.sub_clients.async_clients.transactions.AsyncTransactionClient.charge","title":"<code>charge(amount, email, auth_code, reference=None, currency=None, metadata=None, channels=None, subaccount=None, transaction_charge=None, bearer=None, queue=False, alternate_model_class=None)</code>  <code>async</code>","text":"<p>All authorizations marked as reusable can be charged with this endpoint whenever you need to receive payments.</p> <p>Parameters:</p> Name Type Description Default <code>amount</code> <code>int</code> <p>amount to charge.</p> required <code>email</code> <code>str</code> <p>Customer's email address</p> required <code>auth_code</code> <code>str</code> <p>Valid authorization code to charge</p> required <code>reference</code> <code>str | None</code> <p>Unique transaction reference. Only <code>-, ., =</code> and alphanumeric characters allowed.</p> <code>None</code> <code>currency</code> <code>Currency | None</code> <p>Currency in which amount should be charged. Any value from the <code>Currency</code> enum.</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>Add a custom_fields attribute which has an array of objects if you would like the fields to be added to your transaction when displayed on the dashboard. Sample: <code>{\"custom_fields\":[{\"display_name\":\"Cart ID\", \"variable_name\": \"cart_id\",\"value\": \"8393\"}]}</code></p> <code>None</code> <code>channels</code> <code>list[Channel] | None</code> <p>A list of <code>Channel</code> enum values to control what channels you want to make available to the user to make a payment with</p> <code>None</code> <code>subaccount</code> <code>str | None</code> <p>The code for the subaccount that owns the payment. e.g. ACCT_8f4s1eq7ml6rlzj</p> <code>None</code> <code>transaction_charge</code> <code>int | None</code> <p>A flat fee to charge the subaccount for this transaction (in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR). This overrides the split percentage set when the subaccount was created. Ideally, you will need to use this if you are splitting in flat rates (since subaccount creation only allows for percentage split). e.g., 7000 for a 70 naira</p> <code>None</code> <code>bearer</code> <code>Bearer | None</code> <p>Who bears Paystack charges? any value from the <code>Beaer</code> enum</p> <code>None</code> <code>queue</code> <code>bool</code> <p>If you are making a scheduled charge call, it is a good idea to queue them so the processing system does not get overloaded causing transaction processing errors. Set <code>queue=True</code> to take advantage of our queued charging.</p> <code>False</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[Transaction] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/transactions.py</code> <pre><code>async def charge(\n    self,\n    amount: int,\n    email: str,\n    auth_code: str,\n    reference: str | None = None,\n    currency: Currency | None = None,\n    metadata: dict[str, Any] | None = None,\n    channels: list[Channel] | None = None,\n    subaccount: str | None = None,\n    transaction_charge: int | None = None,\n    bearer: Bearer | None = None,\n    queue: bool = False,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[Transaction] | Response[PaystackDataModel]:\n    \"\"\"\n    All authorizations marked as reusable can be charged with this\n    endpoint whenever you need to receive payments.\n\n    Args:\n        amount: amount to charge.\n        email: Customer's email address\n        auth_code: Valid authorization code to charge\n        reference: Unique transaction reference. Only ``-, ., =`` and alphanumeric\n            characters allowed.\n        currency: Currency in which amount should be charged. Any value from the\n            ``Currency`` enum.\n        metadata: Add a custom_fields attribute which has an array of objects if\n            you would like the fields to be added to your transaction when\n            displayed on the dashboard.\n            Sample: ``{\"custom_fields\":[{\"display_name\":\"Cart ID\",\n            \"variable_name\": \"cart_id\",\"value\": \"8393\"}]}``\n        channels: A list of ``Channel`` enum values to control what channels you want to make available\n            to the user to make a payment with\n        subaccount: The code for the subaccount that owns the payment. e.g. ACCT_8f4s1eq7ml6rlzj\n        transaction_charge: A flat fee to charge the subaccount for this transaction (in kobo if currency is NGN,\n            pesewas, if currency is GHS, and cents, if currency is ZAR). This overrides the split\n            percentage set when the subaccount was created. Ideally, you will need to use this if\n            you are splitting in flat rates (since subaccount creation only allows for percentage split).\n            e.g., 7000 for a 70 naira\n        bearer: Who bears Paystack charges? any value from the ``Beaer`` enum\n        queue: If you are making a scheduled charge call, it is a good idea to queue them so the processing\n            system does not get overloaded causing transaction processing errors. Set ``queue=True`` to\n            take advantage of our queued charging.\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    if not email:\n        raise ValueError(\"Customer's Email is required to charge\")\n\n    if not auth_code:\n        raise ValueError(\"Customer's Auth code is required to charge\")\n\n    url = self._full_url(\"/transaction/charge_authorization\")\n    payload = {\n        \"authorization_code\": auth_code,\n        \"email\": email,\n        \"amount\": amount,\n    }\n    optional_params = [\n        (\"reference\", reference),\n        (\"currency\", currency),\n        (\"metadata\", metadata),\n        (\"channels\", channels),\n        (\"subaccount\", subaccount),\n        (\"transaction_charge\", transaction_charge),\n        (\"bearer\", bearer),\n        (\"queue\", queue),\n    ]\n    payload = add_to_payload(optional_params, payload)\n\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or Transaction,\n    )\n</code></pre>"},{"location":"reference/transactions/#pypaystack2.sub_clients.async_clients.transactions.AsyncTransactionClient.export","title":"<code>export(page=None, start_date=None, end_date=None, customer=None, status=None, currency=None, amount=None, settled=None, settlement=None, payment_page=None, pagination=50, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Fetch transactions carried out on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>int | None</code> <p>Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1.</p> <code>None</code> <code>start_date</code> <code>str | None</code> <p>A timestamp from which to start listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>end_date</code> <code>str | None</code> <p>A timestamp at which to stop listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>customer</code> <code>str | int | None</code> <p>Specify an ID for the customer whose transactions you want to retrieve</p> <code>None</code> <code>status</code> <code>TransactionStatus | None</code> <p>Filter transactions by status. Any value from the <code>TransactionStatus</code> enum</p> <code>None</code> <code>currency</code> <code>Currency | None</code> <p>Specify the transaction currency to export. Any value from the <code>Currency</code> enum</p> <code>None</code> <code>amount</code> <code>int | None</code> <p>Filter transactions by amount. Specify the amount, in kobo if currency is <code>Currency.NGN</code>, pesewas, if currency is <code>Currency.GHS</code>, and cents, if currency is <code>Currency.ZAR</code></p> <code>None</code> <code>settled</code> <code>bool | None</code> <p>Set to <code>True</code> to export only settled transactions. <code>False</code> for pending transactions. Leave undefined to export all transaction</p> <code>None</code> <code>settlement</code> <code>str | None</code> <p>An ID for the settlement whose transactions we should export</p> <code>None</code> <code>payment_page</code> <code>str | None</code> <p>Optional[int] Specify a payment page's id to export only transactions conducted on said page</p> <code>None</code> <code>pagination</code> <code>int</code> <p>int Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50.</p> <code>50</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[TransactionExport] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/transactions.py</code> <pre><code>async def export(\n    self,\n    page: int | None = None,\n    start_date: str | None = None,\n    end_date: str | None = None,\n    customer: str | int | None = None,\n    status: TransactionStatus | None = None,\n    currency: Currency | None = None,\n    amount: int | None = None,\n    settled: bool | None = None,\n    settlement: str | None = None,\n    payment_page: str | None = None,\n    pagination: int = 50,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[TransactionExport] | Response[PaystackDataModel]:\n    \"\"\"Fetch transactions carried out on your integration.\n\n    Args:\n        page: Specifies exactly what page you want to retrieve.\n            If not specified, we use a default value of 1.\n        start_date: A timestamp from which to start listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        end_date: A timestamp at which to stop listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        customer: Specify an ID for the customer whose transactions you want to retrieve\n        status: Filter transactions by status. Any value from the ``TransactionStatus`` enum\n        currency: Specify the transaction currency to export. Any value from the ``Currency`` enum\n        amount: Filter transactions by amount. Specify the amount, in\n            kobo if currency is ``Currency.NGN``, pesewas, if currency\n            is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR``\n        settled: Set to ``True`` to export only settled transactions. ``False`` for\n            pending transactions. Leave undefined to export all transaction\n        settlement: An ID for the settlement whose transactions we should export\n        payment_page: Optional[int]\n            Specify a payment page's id to export only transactions conducted on said page\n        pagination: int\n            Specifies how many records you want to retrieve per page.\n            If not specified, we use a default value of 50.\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/transaction/export/?perPage={pagination}\")\n    query_params = [\n        (\"page\", page),\n        (\"from\", start_date),\n        (\"to\", end_date),\n        (\"customer\", customer),\n        (\"status\", status),\n        (\"currency\", currency),\n        (\"amount\", amount),\n        (\"settled\", settled),\n        (\"settlement\", settlement),\n        (\"payment_page\", payment_page),\n    ]\n    url = append_query_params(query_params, url)\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or TransactionExport,\n    )\n</code></pre>"},{"location":"reference/transactions/#pypaystack2.sub_clients.async_clients.transactions.AsyncTransactionClient.get_timeline","title":"<code>get_timeline(id_or_ref, alternate_model_class=None)</code>  <code>async</code>","text":"<p>View the timeline of a transaction</p> <p>Parameters:</p> Name Type Description Default <code>id_or_ref</code> <code>int | str</code> <p>The ID or the reference of the transaction</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[TransactionLog] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/transactions.py</code> <pre><code>async def get_timeline(\n    self,\n    id_or_ref: int | str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[TransactionLog] | Response[PaystackDataModel]:\n    \"\"\"View the timeline of a transaction\n\n    Args:\n        id_or_ref: The ID or the reference of the transaction\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/transaction/timeline/{id_or_ref}\")\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or TransactionLog,\n    )\n</code></pre>"},{"location":"reference/transactions/#pypaystack2.sub_clients.async_clients.transactions.AsyncTransactionClient.get_transaction","title":"<code>get_transaction(id_, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Get details of a transaction carried out on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>An ID for the transaction to fetch</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[Transaction] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/transactions.py</code> <pre><code>async def get_transaction(\n    self,\n    id_: str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[Transaction] | Response[PaystackDataModel]:\n    \"\"\"Get details of a transaction carried out on your integration.\n\n    Args:\n        id_: An ID for the transaction to fetch\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/transaction/{id_}/\")\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or Transaction,\n    )\n</code></pre>"},{"location":"reference/transactions/#pypaystack2.sub_clients.async_clients.transactions.AsyncTransactionClient.get_transactions","title":"<code>get_transactions(customer=None, start_date=None, end_date=None, status=None, page=None, amount=None, pagination=50, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Fetch transactions carried out on your integration.</p> <p>Parameters:</p> Name Type Description Default <code>customer</code> <code>int | str | None</code> <p>Specify an ID for the customer whose transactions you want to retrieve</p> <code>None</code> <code>start_date</code> <code>str | None</code> <p>A timestamp from which to start listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>end_date</code> <code>str | None</code> <p>A timestamp at which to stop listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>status</code> <code>TransactionStatus | None</code> <p>Filter transactions by status. any value from the <code>TransactionStatus</code> enum</p> <code>None</code> <code>page</code> <code>int | None</code> <p>Specify exactly what page you want to retrieve. If not specified, we use a default value of 1.</p> <code>None</code> <code>amount</code> <code>int | None</code> <p>Optional[int] Filter transactions by amount. Specify the amount (in kobo if currency is <code>Currency.NGN</code>, pesewas, if currency is <code>Currency.GHS</code>, and cents, if currency is <code>Currency.ZAR</code>)</p> <code>None</code> <code>pagination</code> <code>int</code> <p>Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50.</p> <code>50</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[list[Transaction]] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/transactions.py</code> <pre><code>async def get_transactions(\n    self,\n    customer: int | str | None = None,\n    start_date: str | None = None,\n    end_date: str | None = None,\n    status: TransactionStatus | None = None,\n    page: int | None = None,\n    amount: int | None = None,\n    pagination: int = 50,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[list[Transaction]] | Response[PaystackDataModel]:\n    \"\"\"Fetch transactions carried out on your integration.\n\n    Args:\n        customer: Specify an ID for the customer whose transactions you want to retrieve\n        start_date: A timestamp from which to start listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        end_date: A timestamp at which to stop listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        status: Filter transactions by status. any value from the ``TransactionStatus`` enum\n        page: Specify exactly what page you want to retrieve.\n            If not specified, we use a default value of 1.\n        amount: Optional[int]\n            Filter transactions by amount. Specify the amount (in kobo if currency is\n            ``Currency.NGN``, pesewas, if currency is ``Currency.GHS``, and cents, if\n            currency is ``Currency.ZAR``)\n        pagination: Specifies how many records you want to retrieve per page. If not specified, we\n            use a default value of 50.\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/transaction/?perPage={pagination}\")\n    query_params = [\n        (\"page\", page),\n        (\"customer\", customer),\n        (\"status\", status),\n        (\"from\", start_date),\n        (\"to\", end_date),\n        (\"amount\", amount),\n    ]\n    url = append_query_params(query_params, url)\n\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or Transaction,\n    )\n</code></pre>"},{"location":"reference/transactions/#pypaystack2.sub_clients.async_clients.transactions.AsyncTransactionClient.initialize","title":"<code>initialize(amount, email, currency=None, reference=None, callback_url=None, plan=None, invoice_limit=None, metadata=None, channels=None, split_code=None, subaccount=None, transfer_charge=None, bearer=None, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Initialize a transaction from your backend</p> <p>Parameters:</p> Name Type Description Default <code>amount</code> <code>int</code> <p>Amount should be in kobo if currency is <code>Currency.NGN</code>, pesewas, if currency is <code>Currency.GHS</code>, and cents, if currency is <code>Currency.ZAR</code></p> required <code>email</code> <code>str</code> <p>Customer's email address</p> required <code>currency</code> <code>Currency | None</code> <p>Any value from the <code>Currency</code> enum.</p> <code>None</code> <code>reference</code> <code>str | None</code> <p>Unique transaction reference. Only <code>-, ., =</code> and alphanumeric characters allowed.</p> <code>None</code> <code>callback_url</code> <code>str | None</code> <p>Fully qualified url, e.g. <code>https://example.com/</code> . Use this to override the callback url provided on the dashboard for this transaction</p> <code>None</code> <code>plan</code> <code>str | None</code> <p>If transaction is to create a subscription to a predefined plan, provide plan code here. This would invalidate the value provided in <code>amount</code></p> <code>None</code> <code>invoice_limit</code> <code>int | None</code> <p>Number of times to charge customer during subscription to plan</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>A dictionary of additional info. check out this link for more information. https://paystack.com/docs/payments/metadata</p> <code>None</code> <code>channels</code> <code>list[Channel] | None</code> <p>A list of <code>Channel</code> enum values to control what channels you want to make available to the user to make a payment with</p> <code>None</code> <code>split_code</code> <code>str | None</code> <p>The split code of the transaction split. e.g. SPL_98WF13Eb3w</p> <code>None</code> <code>subaccount</code> <code>str | None</code> <p>The code for the subaccount that owns the payment. e.g. ACCT_8f4s1eq7ml6rlzj</p> <code>None</code> <code>transfer_charge</code> <code>int | None</code> <p>An amount used to override the split configuration for a single split payment. If set, the amount specified goes to the main account regardless of the split configuration.</p> <code>None</code> <code>bearer</code> <code>Bearer | None</code> <p>Any value from the <code>Bearer</code> enum. Who bears Paystack charges?</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[InitTransaction] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> <p>Raises:</p> Type Description <code>InvalidDataError</code> <p>When email is not provided.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/transactions.py</code> <pre><code>async def initialize(\n    self,\n    amount: int,\n    email: str,\n    currency: Currency | None = None,\n    reference: str | None = None,\n    callback_url: str | None = None,\n    plan: str | None = None,\n    invoice_limit: int | None = None,\n    metadata: dict[str, Any] | None = None,\n    channels: list[Channel] | None = None,\n    split_code: str | None = None,\n    subaccount: str | None = None,\n    transfer_charge: int | None = None,\n    bearer: Bearer | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[InitTransaction] | Response[PaystackDataModel]:\n    \"\"\"Initialize a transaction from your backend\n\n    Args:\n        amount: Amount should be in kobo if currency is ``Currency.NGN``, pesewas,\n            if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR``\n        email: Customer's email address\n        currency: Any value from the ``Currency`` enum.\n        reference: Unique transaction reference. Only ``-, ., =`` and alphanumeric characters allowed.\n        callback_url: Fully qualified url, e.g. ``https://example.com/`` . Use this to override the callback url\n            provided on the dashboard for this transaction\n        plan: If transaction is to create a subscription to a predefined plan, provide plan code here.\n            This would invalidate the value provided in ``amount``\n        invoice_limit: Number of times to charge customer during subscription to plan\n        metadata: A dictionary of additional info. check out this link\n            for more information. https://paystack.com/docs/payments/metadata\n        channels: A list of ``Channel`` enum values to control what channels you want to make available\n            to the user to make a payment with\n        split_code: The split code of the transaction split. e.g. SPL_98WF13Eb3w\n        subaccount: The code for the subaccount that owns the payment. e.g. ACCT_8f4s1eq7ml6rlzj\n        transfer_charge: An amount used to override the split configuration for a single split payment. If set,\n            the amount specified goes to the main account regardless of the split configuration.\n        bearer: Any value from the ``Bearer`` enum. Who bears Paystack charges?\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n\n    Raises:\n        InvalidDataError: When email is not provided.\n    \"\"\"\n\n    if not email:\n        raise ValueError(\"Customer's Email is required for initialization\")\n\n    url = self._full_url(\"/transaction/initialize\")\n    payload = {\n        \"email\": email,\n        \"amount\": amount,\n    }\n\n    optional_params = [\n        (\"currency\", currency),\n        (\"reference\", reference),\n        (\"callback_url\", callback_url),\n        (\"plan\", plan),\n        (\"invoice_limit\", invoice_limit),\n        (\"metadata\", metadata),\n        (\"channels\", channels),\n        (\"split_code\", split_code),\n        (\"subaccount\", subaccount),\n        (\"transfer_charge\", transfer_charge),\n        (\"bearer\", bearer),\n    ]\n    payload = add_to_payload(\n        optional_params,\n        payload,\n    )\n\n    return await self._handle_request(\n        HTTPMethod.POST,\n        url,\n        payload,  # type: ignore\n        response_data_model_class=alternate_model_class or InitTransaction,\n    )\n</code></pre>"},{"location":"reference/transactions/#pypaystack2.sub_clients.async_clients.transactions.AsyncTransactionClient.partial_debit","title":"<code>partial_debit(auth_code, currency, amount, email, reference=None, at_least=None, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Retrieve part of a payment from a customer</p> <p>Parameters:</p> Name Type Description Default <code>auth_code</code> <code>str</code> <p>Authorization Code</p> required <code>currency</code> <code>Currency</code> <p>Specify the currency you want to debit. Any value from the <code>Currency</code> enum.</p> required <code>amount</code> <code>int</code> <p>Amount should be in kobo if currency is <code>Currency.NGN</code>, pesewas, if currency is <code>Currency.GHS</code>, and cents, if currency is <code>Currency.ZAR</code></p> required <code>email</code> <code>str</code> <p>Customer's email address (attached to the authorization code)</p> required <code>reference</code> <code>str | None</code> <p>Unique transaction reference. Only <code>-, ., =</code>  and alphanumeric characters allowed.</p> <code>None</code> <code>at_least</code> <code>int | None</code> <p>Minimum amount to charge</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[Transaction] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> <p>Raises:</p> Type Description <code>InvalidDataError</code> <p>When Customer's email is not provided. When Customer's auth code is not provided.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/transactions.py</code> <pre><code>async def partial_debit(\n    self,\n    auth_code: str,\n    currency: Currency,\n    amount: int,\n    email: str,\n    reference: str | None = None,\n    at_least: int | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[Transaction] | Response[PaystackDataModel]:\n    \"\"\"Retrieve part of a payment from a customer\n\n    Args:\n        auth_code: Authorization Code\n        currency: Specify the currency you want to debit. Any value\n            from the ``Currency`` enum.\n        amount: Amount should be in kobo if currency is ``Currency.NGN``, pesewas,\n            if currency is ``Currency.GHS``, and cents, if currency is ``Currency.ZAR``\n        email: Customer's email address (attached to the authorization code)\n        reference: Unique transaction reference. Only `-, ., =`\n             and alphanumeric characters allowed.\n        at_least: Minimum amount to charge\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n\n    Raises:\n        InvalidDataError: When Customer's email is not provided. When Customer's auth code is not provided.\n    \"\"\"\n\n    if not email:\n        raise ValueError(\"Customer's Email is required to charge\")\n\n    if not auth_code:\n        raise ValueError(\"Customer's Auth code is required to charge\")\n\n    url = self._full_url(\"/transaction/partial_debit\")\n    payload = {\n        \"authorization_code\": auth_code,\n        \"currency\": currency,\n        \"amount\": amount,\n        \"email\": email,\n    }\n    optional_params = [(\"reference\", reference), (\"at_least\", at_least)]\n    payload = add_to_payload(optional_params, payload)\n\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or Transaction,\n    )\n</code></pre>"},{"location":"reference/transactions/#pypaystack2.sub_clients.async_clients.transactions.AsyncTransactionClient.totals","title":"<code>totals(page=None, start_date=None, end_date=None, pagination=50, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Total amount received on your account</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>int | None</code> <p>Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1.</p> <code>None</code> <code>start_date</code> <code>str | None</code> <p>A timestamp from which to start listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>end_date</code> <code>str | None</code> <p>A timestamp at which to stop listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>pagination</code> <code>int</code> <p>Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50.</p> <code>50</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[TransactionTotal] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/transactions.py</code> <pre><code>async def totals(\n    self,\n    page: int | None = None,\n    start_date: str | None = None,\n    end_date: str | None = None,\n    pagination: int = 50,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[TransactionTotal] | Response[PaystackDataModel]:\n    \"\"\"Total amount received on your account\n\n    Args:\n        page: Specifies exactly what page you want to retrieve.\n            If not specified, we use a default value of 1.\n        start_date: A timestamp from which to start listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        end_date: A timestamp at which to stop listing transaction e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        pagination: Specifies how many records you want to retrieve per page.\n            If not specified, we use a default value of 50.\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/transaction/totals/?perPage={pagination}\")\n    query_params = [\n        (\"page\", page),\n        (\"from\", start_date),\n        (\"to\", end_date),\n    ]\n    url = append_query_params(query_params, url)\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or TransactionTotal,\n    )\n</code></pre>"},{"location":"reference/transactions/#pypaystack2.sub_clients.async_clients.transactions.AsyncTransactionClient.verify","title":"<code>verify(reference, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Confirm the status of a transaction</p> <p>Parameters:</p> Name Type Description Default <code>reference</code> <code>str</code> <p>The transaction reference used to initiate the transaction</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[Transaction] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/transactions.py</code> <pre><code>async def verify(\n    self,\n    reference: str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[Transaction] | Response[PaystackDataModel]:\n    \"\"\"Confirm the status of a transaction\n\n    Args:\n        reference: The transaction reference used to initiate the transaction\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    reference = str(reference)\n    url = self._full_url(f\"/transaction/verify/{reference}\")\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or Transaction,\n    )\n</code></pre>"},{"location":"reference/transfer_recipients/","title":"Transfer recipients","text":""},{"location":"reference/transfer_recipients/#pypaystack2.sub_clients.sync_clients.transfer_recipients.TransferRecipientClient","title":"<code>TransferRecipientClient</code>","text":"<p>               Bases: <code>BaseAPIClient</code></p> <p>Provides a wrapper for paystack Transfer Receipts API</p> <p>The Transfer Recipients API allows you to create and manage beneficiaries that you send money to. https://paystack.com/docs/api/transfer-recipient/</p> Note <p>Feature Availability     This feature is only available to businesses in Nigeria and Ghana.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/transfer_recipients.py</code> <pre><code>class TransferRecipientClient(BaseAPIClient):\n    \"\"\"Provides a wrapper for paystack Transfer Receipts API\n\n    The Transfer Recipients API allows you to create and manage beneficiaries that you send money to.\n    https://paystack.com/docs/api/transfer-recipient/\n\n    Note:\n        Feature Availability\n            This feature is only available to businesses in Nigeria and Ghana.\n    \"\"\"\n\n    def create(\n        self,\n        type_: RecipientType,\n        name: str,\n        account_number: str,\n        bank_code: str | None = None,\n        description: str | None = None,\n        currency: Currency | None = None,\n        auth_code: str | None = None,\n        metadata: dict[str, Any] | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[TransferRecipient] | Response[PaystackDataModel]:\n        \"\"\"\n        Creates a new recipient. A duplicate account number will lead to the\n        retrieval of the existing record.\n\n        Args:\n            type_: Recipient Type. any value from the `RecipientType` enum\n            name: A name for the recipient\n            account_number: Required if `type` is `RecipientType.NUBAN` or `RecipientType.BASA`\n            bank_code: Required if `type` is `RecipientType.NUBAN` or `RecipientType.BASA`.\n                You can get the list of Bank Codes by calling the `PaystackClient.get_banks`.\n            description: description\n            currency: currency\n            auth_code: auth code\n            metadata: metadata\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n        if type_ == RecipientType.NUBAN or type_ == RecipientType.BASA:\n            if bank_code is None:\n                raise ValueError(\n                    \"`bank_code` is required if type is `RecipientType.NUBAN` or `RecipientType.BASA`\"\n                )\n\n        url = self._full_url(\"/transferrecipient\")\n\n        payload = {\n            \"type\": type_,\n            \"name\": name,\n            \"account_number\": account_number,\n        }\n        optional_params = [\n            (\"bank_code\", bank_code),\n            (\"description\", description),\n            (\"currency\", currency),\n            (\"authorization_code\", auth_code),\n            (\"metadata\", metadata),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or TransferRecipient,\n        )\n\n    def bulk_create(\n        self,\n        batch: list[Recipient],\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[TransferRecipientBulkCreateData] | Response[PaystackDataModel]:\n        \"\"\"\n        Create multiple transfer recipients in batches. A duplicate account\n        number will lead to the retrieval of the existing record.\n\n        Args:\n            batch: recipients to be created.\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n        batch_data = [item.model_dump() for item in batch]\n\n        url = self._full_url(\"/transferrecipient/bulk\")\n\n        payload = {\n            \"batch\": batch_data,\n        }\n        return self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class\n            or TransferRecipientBulkCreateData,\n        )\n\n    def get_transfer_recipients(\n        self,\n        page: int = 1,\n        pagination: int = 50,\n        start_date: str | None = None,\n        end_date: str | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[list[TransferRecipient]] | Response[PaystackDataModel]:\n        \"\"\"Fetch transfer recipients available on your integration\n\n        Args:\n            page: Specifies exactly what page you want to retrieve.\n                If not specified, we use a default value of 1.\n            pagination: Specifies how many records you want to retrieve per page.\n                If not specified, we use a default value of 50.\n            start_date: A timestamp from which to start listing transfer recipients\n                e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            end_date: A timestamp at which to stop listing transfer recipients e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._full_url(f\"/transferrecipient?perPage={pagination}\")\n        query_params = [\n            (\"page\", page),\n            (\"from\", start_date),\n            (\"to\", end_date),\n        ]\n        url = append_query_params(query_params, url)\n        return self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or TransferRecipient,\n        )\n\n    def get_transfer_recipient(\n        self,\n        id_or_code: int | str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[TransferRecipient] | Response[PaystackDataModel]:\n        \"\"\"Fetch the details of a transfer recipient\n\n        Args:\n            id_or_code: An ID or code for the recipient whose details you want to receive.\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._full_url(f\"/transferrecipient/{id_or_code}\")\n        return self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or TransferRecipient,\n        )\n\n    def update(\n        self,\n        id_or_code: int | str,\n        name: str,\n        email: str | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[None] | Response[PaystackDataModel]:\n        \"\"\"\n        Update an existing recipient. A duplicate account number will lead\n        to the retrieval of the existing record.\n\n        Args:\n            id_or_code: Transfer Recipient's ID or code\n            name: A name for the recipient\n            email: Email address of the recipient\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/transferrecipient/{id_or_code}\")\n        payload = {\"name\": name}\n        optional_params = [(\"email\", email)]\n        payload = add_to_payload(optional_params, payload)\n        return self._handle_request(  # type: ignore\n            HTTPMethod.PUT,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class,\n        )\n\n    def delete(\n        self,\n        id_or_code: int | str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[None] | Response[PaystackDataModel]:\n        \"\"\"Deletes a transfer recipient (sets the transfer recipient to inactive)\n\n        Args:\n            id_or_code: An ID or code for the recipient who you want to delete.\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/transferrecipient/{id_or_code}\")\n        return self._handle_request(  # type: ignore\n            HTTPMethod.DELETE,\n            url,\n            response_data_model_class=alternate_model_class,\n        )\n</code></pre>"},{"location":"reference/transfer_recipients/#pypaystack2.sub_clients.sync_clients.transfer_recipients.TransferRecipientClient.bulk_create","title":"<code>bulk_create(batch, alternate_model_class=None)</code>","text":"<p>Create multiple transfer recipients in batches. A duplicate account number will lead to the retrieval of the existing record.</p> <p>Parameters:</p> Name Type Description Default <code>batch</code> <code>list[Recipient]</code> <p>recipients to be created.</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[TransferRecipientBulkCreateData] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/transfer_recipients.py</code> <pre><code>def bulk_create(\n    self,\n    batch: list[Recipient],\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[TransferRecipientBulkCreateData] | Response[PaystackDataModel]:\n    \"\"\"\n    Create multiple transfer recipients in batches. A duplicate account\n    number will lead to the retrieval of the existing record.\n\n    Args:\n        batch: recipients to be created.\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n    batch_data = [item.model_dump() for item in batch]\n\n    url = self._full_url(\"/transferrecipient/bulk\")\n\n    payload = {\n        \"batch\": batch_data,\n    }\n    return self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class\n        or TransferRecipientBulkCreateData,\n    )\n</code></pre>"},{"location":"reference/transfer_recipients/#pypaystack2.sub_clients.sync_clients.transfer_recipients.TransferRecipientClient.create","title":"<code>create(type_, name, account_number, bank_code=None, description=None, currency=None, auth_code=None, metadata=None, alternate_model_class=None)</code>","text":"<p>Creates a new recipient. A duplicate account number will lead to the retrieval of the existing record.</p> <p>Parameters:</p> Name Type Description Default <code>type_</code> <code>RecipientType</code> <p>Recipient Type. any value from the <code>RecipientType</code> enum</p> required <code>name</code> <code>str</code> <p>A name for the recipient</p> required <code>account_number</code> <code>str</code> <p>Required if <code>type</code> is <code>RecipientType.NUBAN</code> or <code>RecipientType.BASA</code></p> required <code>bank_code</code> <code>str | None</code> <p>Required if <code>type</code> is <code>RecipientType.NUBAN</code> or <code>RecipientType.BASA</code>. You can get the list of Bank Codes by calling the <code>PaystackClient.get_banks</code>.</p> <code>None</code> <code>description</code> <code>str | None</code> <p>description</p> <code>None</code> <code>currency</code> <code>Currency | None</code> <p>currency</p> <code>None</code> <code>auth_code</code> <code>str | None</code> <p>auth code</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>metadata</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[TransferRecipient] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/transfer_recipients.py</code> <pre><code>def create(\n    self,\n    type_: RecipientType,\n    name: str,\n    account_number: str,\n    bank_code: str | None = None,\n    description: str | None = None,\n    currency: Currency | None = None,\n    auth_code: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[TransferRecipient] | Response[PaystackDataModel]:\n    \"\"\"\n    Creates a new recipient. A duplicate account number will lead to the\n    retrieval of the existing record.\n\n    Args:\n        type_: Recipient Type. any value from the `RecipientType` enum\n        name: A name for the recipient\n        account_number: Required if `type` is `RecipientType.NUBAN` or `RecipientType.BASA`\n        bank_code: Required if `type` is `RecipientType.NUBAN` or `RecipientType.BASA`.\n            You can get the list of Bank Codes by calling the `PaystackClient.get_banks`.\n        description: description\n        currency: currency\n        auth_code: auth code\n        metadata: metadata\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n    if type_ == RecipientType.NUBAN or type_ == RecipientType.BASA:\n        if bank_code is None:\n            raise ValueError(\n                \"`bank_code` is required if type is `RecipientType.NUBAN` or `RecipientType.BASA`\"\n            )\n\n    url = self._full_url(\"/transferrecipient\")\n\n    payload = {\n        \"type\": type_,\n        \"name\": name,\n        \"account_number\": account_number,\n    }\n    optional_params = [\n        (\"bank_code\", bank_code),\n        (\"description\", description),\n        (\"currency\", currency),\n        (\"authorization_code\", auth_code),\n        (\"metadata\", metadata),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or TransferRecipient,\n    )\n</code></pre>"},{"location":"reference/transfer_recipients/#pypaystack2.sub_clients.sync_clients.transfer_recipients.TransferRecipientClient.delete","title":"<code>delete(id_or_code, alternate_model_class=None)</code>","text":"<p>Deletes a transfer recipient (sets the transfer recipient to inactive)</p> <p>Parameters:</p> Name Type Description Default <code>id_or_code</code> <code>int | str</code> <p>An ID or code for the recipient who you want to delete.</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[None] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/transfer_recipients.py</code> <pre><code>def delete(\n    self,\n    id_or_code: int | str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[None] | Response[PaystackDataModel]:\n    \"\"\"Deletes a transfer recipient (sets the transfer recipient to inactive)\n\n    Args:\n        id_or_code: An ID or code for the recipient who you want to delete.\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/transferrecipient/{id_or_code}\")\n    return self._handle_request(  # type: ignore\n        HTTPMethod.DELETE,\n        url,\n        response_data_model_class=alternate_model_class,\n    )\n</code></pre>"},{"location":"reference/transfer_recipients/#pypaystack2.sub_clients.sync_clients.transfer_recipients.TransferRecipientClient.get_transfer_recipient","title":"<code>get_transfer_recipient(id_or_code, alternate_model_class=None)</code>","text":"<p>Fetch the details of a transfer recipient</p> <p>Parameters:</p> Name Type Description Default <code>id_or_code</code> <code>int | str</code> <p>An ID or code for the recipient whose details you want to receive.</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[TransferRecipient] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/transfer_recipients.py</code> <pre><code>def get_transfer_recipient(\n    self,\n    id_or_code: int | str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[TransferRecipient] | Response[PaystackDataModel]:\n    \"\"\"Fetch the details of a transfer recipient\n\n    Args:\n        id_or_code: An ID or code for the recipient whose details you want to receive.\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._full_url(f\"/transferrecipient/{id_or_code}\")\n    return self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or TransferRecipient,\n    )\n</code></pre>"},{"location":"reference/transfer_recipients/#pypaystack2.sub_clients.sync_clients.transfer_recipients.TransferRecipientClient.get_transfer_recipients","title":"<code>get_transfer_recipients(page=1, pagination=50, start_date=None, end_date=None, alternate_model_class=None)</code>","text":"<p>Fetch transfer recipients available on your integration</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>int</code> <p>Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1.</p> <code>1</code> <code>pagination</code> <code>int</code> <p>Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50.</p> <code>50</code> <code>start_date</code> <code>str | None</code> <p>A timestamp from which to start listing transfer recipients e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>end_date</code> <code>str | None</code> <p>A timestamp at which to stop listing transfer recipients e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[list[TransferRecipient]] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/transfer_recipients.py</code> <pre><code>def get_transfer_recipients(\n    self,\n    page: int = 1,\n    pagination: int = 50,\n    start_date: str | None = None,\n    end_date: str | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[list[TransferRecipient]] | Response[PaystackDataModel]:\n    \"\"\"Fetch transfer recipients available on your integration\n\n    Args:\n        page: Specifies exactly what page you want to retrieve.\n            If not specified, we use a default value of 1.\n        pagination: Specifies how many records you want to retrieve per page.\n            If not specified, we use a default value of 50.\n        start_date: A timestamp from which to start listing transfer recipients\n            e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        end_date: A timestamp at which to stop listing transfer recipients e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._full_url(f\"/transferrecipient?perPage={pagination}\")\n    query_params = [\n        (\"page\", page),\n        (\"from\", start_date),\n        (\"to\", end_date),\n    ]\n    url = append_query_params(query_params, url)\n    return self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or TransferRecipient,\n    )\n</code></pre>"},{"location":"reference/transfer_recipients/#pypaystack2.sub_clients.sync_clients.transfer_recipients.TransferRecipientClient.update","title":"<code>update(id_or_code, name, email=None, alternate_model_class=None)</code>","text":"<p>Update an existing recipient. A duplicate account number will lead to the retrieval of the existing record.</p> <p>Parameters:</p> Name Type Description Default <code>id_or_code</code> <code>int | str</code> <p>Transfer Recipient's ID or code</p> required <code>name</code> <code>str</code> <p>A name for the recipient</p> required <code>email</code> <code>str | None</code> <p>Email address of the recipient</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[None] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/transfer_recipients.py</code> <pre><code>def update(\n    self,\n    id_or_code: int | str,\n    name: str,\n    email: str | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[None] | Response[PaystackDataModel]:\n    \"\"\"\n    Update an existing recipient. A duplicate account number will lead\n    to the retrieval of the existing record.\n\n    Args:\n        id_or_code: Transfer Recipient's ID or code\n        name: A name for the recipient\n        email: Email address of the recipient\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/transferrecipient/{id_or_code}\")\n    payload = {\"name\": name}\n    optional_params = [(\"email\", email)]\n    payload = add_to_payload(optional_params, payload)\n    return self._handle_request(  # type: ignore\n        HTTPMethod.PUT,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class,\n    )\n</code></pre>"},{"location":"reference/transfer_recipients/#pypaystack2.sub_clients.async_clients.transfer_recipients.AsyncTransferRecipientClient","title":"<code>AsyncTransferRecipientClient</code>","text":"<p>               Bases: <code>BaseAsyncAPIClient</code></p> <p>Provides a wrapper for paystack Transfer Receipts API</p> <p>The Transfer Recipients API allows you to create and manage beneficiaries that you send money to. https://paystack.com/docs/api/transfer-recipient/</p> Note <p>Feature Availability     This feature is only available to businesses in Nigeria and Ghana.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/transfer_recipients.py</code> <pre><code>class AsyncTransferRecipientClient(BaseAsyncAPIClient):\n    \"\"\"Provides a wrapper for paystack Transfer Receipts API\n\n    The Transfer Recipients API allows you to create and manage beneficiaries that you send money to.\n    https://paystack.com/docs/api/transfer-recipient/\n\n    Note:\n        Feature Availability\n            This feature is only available to businesses in Nigeria and Ghana.\n    \"\"\"\n\n    async def create(\n        self,\n        type_: RecipientType,\n        name: str,\n        account_number: str,\n        bank_code: str | None = None,\n        description: str | None = None,\n        currency: Currency | None = None,\n        auth_code: str | None = None,\n        metadata: dict[str, Any] | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[TransferRecipient] | Response[PaystackDataModel]:\n        \"\"\"\n        Creates a new recipient. A duplicate account number will lead to the\n        retrieval of the existing record.\n\n        Args:\n            type_: Recipient Type. any value from the `RecipientType` enum\n            name: A name for the recipient\n            account_number: Required if `type` is `RecipientType.NUBAN` or `RecipientType.BASA`\n            bank_code: Required if `type` is `RecipientType.NUBAN` or `RecipientType.BASA`.\n                You can get the list of Bank Codes by calling the `PaystackClient.get_banks`.\n            description: description\n            currency: currency\n            auth_code: auth code\n            metadata: metadata\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A named tuple containing the response gotten from paystack's server.\n        \"\"\"\n        if type_ == RecipientType.NUBAN or type_ == RecipientType.BASA:\n            if bank_code is None:\n                raise ValueError(\n                    \"`bank_code` is required if type is `TRType.NUBAN` or `TRType.BASA`\"\n                )\n\n        url = self._full_url(\"/transferrecipient\")\n\n        payload = {\n            \"type\": type_,\n            \"name\": name,\n            \"account_number\": account_number,\n        }\n        optional_params = [\n            (\"bank_code\", bank_code),\n            (\"description\", description),\n            (\"currency\", currency),\n            (\"authorization_code\", auth_code),\n            (\"metadata\", metadata),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or TransferRecipient,\n        )\n\n    async def bulk_create(\n        self,\n        batch: list[Recipient],\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[TransferRecipientBulkCreateData] | Response[PaystackDataModel]:\n        \"\"\"\n        Create multiple transfer recipients in batches. A duplicate account\n        number will lead to the retrieval of the existing record.\n\n        Ars:\n            batch: recipients to be created.\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n        batch_data = [item.model_dump() for item in batch]\n\n        url = self._full_url(\"/transferrecipient/bulk\")\n\n        payload = {\n            \"batch\": batch_data,\n        }\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class\n            or TransferRecipientBulkCreateData,\n        )\n\n    async def get_transfer_recipients(\n        self,\n        page: int = 1,\n        pagination: int = 50,\n        start_date: str | None = None,\n        end_date: str | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[list[TransferRecipient]] | Response[PaystackDataModel]:\n        \"\"\"Fetch transfer recipients available on your integration\n\n        Args:\n            page: Specifies exactly what page you want to retrieve.\n                If not specified, we use a default value of 1.\n            pagination: Specifies how many records you want to retrieve per page.\n                If not specified, we use a default value of 50.\n            start_date: A timestamp from which to start listing transfer recipients\n                e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            end_date: A timestamp at which to stop listing transfer recipients e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._full_url(f\"/transferrecipient?perPage={pagination}\")\n        query_params = [\n            (\"page\", page),\n            (\"from\", start_date),\n            (\"to\", end_date),\n        ]\n        url = append_query_params(query_params, url)\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or TransferRecipient,\n        )\n\n    async def get_transfer_recipient(\n        self,\n        id_or_code: int | str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[TransferRecipient] | Response[PaystackDataModel]:\n        \"\"\"Fetch the details of a transfer recipient\n\n        Args:\n            id_or_code: An ID or code for the recipient whose details you want to receive.\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._full_url(f\"/transferrecipient/{id_or_code}\")\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or TransferRecipient,\n        )\n\n    async def update(\n        self,\n        id_or_code: int | str,\n        name: str,\n        email: str | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[None] | Response[PaystackDataModel]:\n        \"\"\"\n        Update an existing recipient. A duplicate account number will lead\n        to the retrieval of the existing record.\n\n        Args:\n            id_or_code: Transfer Recipient's ID or code\n            name: A name for the recipient\n            email: Email address of the recipient\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/transferrecipient/{id_or_code}\")\n        payload = {\"name\": name}\n        optional_params = [(\"email\", email)]\n        payload = add_to_payload(optional_params, payload)\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.PUT,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class,\n        )\n\n    async def delete(\n        self,\n        id_or_code: int | str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[None] | Response[PaystackDataModel]:\n        \"\"\"Deletes a transfer recipient (sets the transfer recipient to inactive)\n\n        Args:\n            id_or_code: An ID or code for the recipient who you want to delete.\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/transferrecipient/{id_or_code}\")\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.DELETE,\n            url,\n            response_data_model_class=alternate_model_class,\n        )\n</code></pre>"},{"location":"reference/transfer_recipients/#pypaystack2.sub_clients.async_clients.transfer_recipients.AsyncTransferRecipientClient.bulk_create","title":"<code>bulk_create(batch, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Create multiple transfer recipients in batches. A duplicate account number will lead to the retrieval of the existing record.</p> Ars <p>batch: recipients to be created. alternate_model_class: A pydantic model class to use instead of the     default pydantic model used by the library to present the data in     the <code>Response.data</code>. The default behaviour of the library is to     set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data     returned from paystack with the model provided in the library.     Providing a pydantic model class via this parameter overrides     the library default model with the model class you provide.     This can come in handy when the models in the library do not     accurately represent the data returned, and you prefer working with the     data as a pydantic model instead of as a dict of the response returned     by  paystack before it is serialized with pydantic models, The original     data can be accessed via <code>Response.raw</code>.</p> <p>Returns:</p> Type Description <code>Response[TransferRecipientBulkCreateData] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/transfer_recipients.py</code> <pre><code>async def bulk_create(\n    self,\n    batch: list[Recipient],\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[TransferRecipientBulkCreateData] | Response[PaystackDataModel]:\n    \"\"\"\n    Create multiple transfer recipients in batches. A duplicate account\n    number will lead to the retrieval of the existing record.\n\n    Ars:\n        batch: recipients to be created.\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n    batch_data = [item.model_dump() for item in batch]\n\n    url = self._full_url(\"/transferrecipient/bulk\")\n\n    payload = {\n        \"batch\": batch_data,\n    }\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class\n        or TransferRecipientBulkCreateData,\n    )\n</code></pre>"},{"location":"reference/transfer_recipients/#pypaystack2.sub_clients.async_clients.transfer_recipients.AsyncTransferRecipientClient.create","title":"<code>create(type_, name, account_number, bank_code=None, description=None, currency=None, auth_code=None, metadata=None, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Creates a new recipient. A duplicate account number will lead to the retrieval of the existing record.</p> <p>Parameters:</p> Name Type Description Default <code>type_</code> <code>RecipientType</code> <p>Recipient Type. any value from the <code>RecipientType</code> enum</p> required <code>name</code> <code>str</code> <p>A name for the recipient</p> required <code>account_number</code> <code>str</code> <p>Required if <code>type</code> is <code>RecipientType.NUBAN</code> or <code>RecipientType.BASA</code></p> required <code>bank_code</code> <code>str | None</code> <p>Required if <code>type</code> is <code>RecipientType.NUBAN</code> or <code>RecipientType.BASA</code>. You can get the list of Bank Codes by calling the <code>PaystackClient.get_banks</code>.</p> <code>None</code> <code>description</code> <code>str | None</code> <p>description</p> <code>None</code> <code>currency</code> <code>Currency | None</code> <p>currency</p> <code>None</code> <code>auth_code</code> <code>str | None</code> <p>auth code</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>metadata</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[TransferRecipient] | Response[PaystackDataModel]</code> <p>A named tuple containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/transfer_recipients.py</code> <pre><code>async def create(\n    self,\n    type_: RecipientType,\n    name: str,\n    account_number: str,\n    bank_code: str | None = None,\n    description: str | None = None,\n    currency: Currency | None = None,\n    auth_code: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[TransferRecipient] | Response[PaystackDataModel]:\n    \"\"\"\n    Creates a new recipient. A duplicate account number will lead to the\n    retrieval of the existing record.\n\n    Args:\n        type_: Recipient Type. any value from the `RecipientType` enum\n        name: A name for the recipient\n        account_number: Required if `type` is `RecipientType.NUBAN` or `RecipientType.BASA`\n        bank_code: Required if `type` is `RecipientType.NUBAN` or `RecipientType.BASA`.\n            You can get the list of Bank Codes by calling the `PaystackClient.get_banks`.\n        description: description\n        currency: currency\n        auth_code: auth code\n        metadata: metadata\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A named tuple containing the response gotten from paystack's server.\n    \"\"\"\n    if type_ == RecipientType.NUBAN or type_ == RecipientType.BASA:\n        if bank_code is None:\n            raise ValueError(\n                \"`bank_code` is required if type is `TRType.NUBAN` or `TRType.BASA`\"\n            )\n\n    url = self._full_url(\"/transferrecipient\")\n\n    payload = {\n        \"type\": type_,\n        \"name\": name,\n        \"account_number\": account_number,\n    }\n    optional_params = [\n        (\"bank_code\", bank_code),\n        (\"description\", description),\n        (\"currency\", currency),\n        (\"authorization_code\", auth_code),\n        (\"metadata\", metadata),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or TransferRecipient,\n    )\n</code></pre>"},{"location":"reference/transfer_recipients/#pypaystack2.sub_clients.async_clients.transfer_recipients.AsyncTransferRecipientClient.delete","title":"<code>delete(id_or_code, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Deletes a transfer recipient (sets the transfer recipient to inactive)</p> <p>Parameters:</p> Name Type Description Default <code>id_or_code</code> <code>int | str</code> <p>An ID or code for the recipient who you want to delete.</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[None] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/transfer_recipients.py</code> <pre><code>async def delete(\n    self,\n    id_or_code: int | str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[None] | Response[PaystackDataModel]:\n    \"\"\"Deletes a transfer recipient (sets the transfer recipient to inactive)\n\n    Args:\n        id_or_code: An ID or code for the recipient who you want to delete.\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/transferrecipient/{id_or_code}\")\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.DELETE,\n        url,\n        response_data_model_class=alternate_model_class,\n    )\n</code></pre>"},{"location":"reference/transfer_recipients/#pypaystack2.sub_clients.async_clients.transfer_recipients.AsyncTransferRecipientClient.get_transfer_recipient","title":"<code>get_transfer_recipient(id_or_code, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Fetch the details of a transfer recipient</p> <p>Parameters:</p> Name Type Description Default <code>id_or_code</code> <code>int | str</code> <p>An ID or code for the recipient whose details you want to receive.</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[TransferRecipient] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/transfer_recipients.py</code> <pre><code>async def get_transfer_recipient(\n    self,\n    id_or_code: int | str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[TransferRecipient] | Response[PaystackDataModel]:\n    \"\"\"Fetch the details of a transfer recipient\n\n    Args:\n        id_or_code: An ID or code for the recipient whose details you want to receive.\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._full_url(f\"/transferrecipient/{id_or_code}\")\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or TransferRecipient,\n    )\n</code></pre>"},{"location":"reference/transfer_recipients/#pypaystack2.sub_clients.async_clients.transfer_recipients.AsyncTransferRecipientClient.get_transfer_recipients","title":"<code>get_transfer_recipients(page=1, pagination=50, start_date=None, end_date=None, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Fetch transfer recipients available on your integration</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>int</code> <p>Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1.</p> <code>1</code> <code>pagination</code> <code>int</code> <p>Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50.</p> <code>50</code> <code>start_date</code> <code>str | None</code> <p>A timestamp from which to start listing transfer recipients e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>end_date</code> <code>str | None</code> <p>A timestamp at which to stop listing transfer recipients e.g. 2016-09-24T00:00:05.000Z, 2016-09-21</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[list[TransferRecipient]] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/transfer_recipients.py</code> <pre><code>async def get_transfer_recipients(\n    self,\n    page: int = 1,\n    pagination: int = 50,\n    start_date: str | None = None,\n    end_date: str | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[list[TransferRecipient]] | Response[PaystackDataModel]:\n    \"\"\"Fetch transfer recipients available on your integration\n\n    Args:\n        page: Specifies exactly what page you want to retrieve.\n            If not specified, we use a default value of 1.\n        pagination: Specifies how many records you want to retrieve per page.\n            If not specified, we use a default value of 50.\n        start_date: A timestamp from which to start listing transfer recipients\n            e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        end_date: A timestamp at which to stop listing transfer recipients e.g. 2016-09-24T00:00:05.000Z, 2016-09-21\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._full_url(f\"/transferrecipient?perPage={pagination}\")\n    query_params = [\n        (\"page\", page),\n        (\"from\", start_date),\n        (\"to\", end_date),\n    ]\n    url = append_query_params(query_params, url)\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or TransferRecipient,\n    )\n</code></pre>"},{"location":"reference/transfer_recipients/#pypaystack2.sub_clients.async_clients.transfer_recipients.AsyncTransferRecipientClient.update","title":"<code>update(id_or_code, name, email=None, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Update an existing recipient. A duplicate account number will lead to the retrieval of the existing record.</p> <p>Parameters:</p> Name Type Description Default <code>id_or_code</code> <code>int | str</code> <p>Transfer Recipient's ID or code</p> required <code>name</code> <code>str</code> <p>A name for the recipient</p> required <code>email</code> <code>str | None</code> <p>Email address of the recipient</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[None] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/transfer_recipients.py</code> <pre><code>async def update(\n    self,\n    id_or_code: int | str,\n    name: str,\n    email: str | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[None] | Response[PaystackDataModel]:\n    \"\"\"\n    Update an existing recipient. A duplicate account number will lead\n    to the retrieval of the existing record.\n\n    Args:\n        id_or_code: Transfer Recipient's ID or code\n        name: A name for the recipient\n        email: Email address of the recipient\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/transferrecipient/{id_or_code}\")\n    payload = {\"name\": name}\n    optional_params = [(\"email\", email)]\n    payload = add_to_payload(optional_params, payload)\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.PUT,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class,\n    )\n</code></pre>"},{"location":"reference/transfers/","title":"Transfers","text":""},{"location":"reference/transfers/#pypaystack2.sub_clients.sync_clients.transfers.TransferClient","title":"<code>TransferClient</code>","text":"<p>               Bases: <code>BaseAPIClient</code></p> <p>Provides a wrapper for paystack Transfers API</p> <p>The Transfers API allows you to automate sending money on your integration https://paystack.com/docs/api/transfer/</p>"},{"location":"reference/transfers/#pypaystack2.sub_clients.sync_clients.transfers.TransferClient--note","title":"Note","text":"<p>This feature is only available to businesses in Nigeria and Ghana.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/transfers.py</code> <pre><code>class TransferClient(BaseAPIClient):\n    \"\"\"Provides a wrapper for paystack Transfers API\n\n    The Transfers API allows you to automate sending money on your integration\n    https://paystack.com/docs/api/transfer/\n\n    Note\n    ----\n    This feature is only available to businesses in Nigeria and Ghana.\n    \"\"\"\n\n    def initiate(\n        self,\n        amount: int,\n        recipient: str,\n        reason: str | None = None,\n        currency: Currency | None = None,\n        reference: str | None = None,\n        source: str = \"balance\",\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[Transfer] | Response[PaystackDataModel]:\n        \"\"\"Initiate transfer\n\n        Args:\n            amount: amount to transfer\n            recipient: the beneficiary of the transfer\n            reason: narration of the transfer\n            currency: transfer currency\n            reference: reference id\n            source: transfer source\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(\"/transfer\")\n\n        payload = {\n            \"amount\": amount,\n            \"recipient\": recipient,\n            \"source\": source,\n        }\n        optional_params = [\n            (\"reason\", reason),\n            (\"reference\", reference),\n            (\"currency\", currency),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or Transfer,\n        )\n\n    def finalize(\n        self,\n        transfer_code: str,\n        otp: str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[Transfer] | Response[PaystackDataModel]:\n        \"\"\"Finalize transfer\n\n        Args:\n            transfer_code: The code for transfer.\n            otp: One time password.\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(\"/transfer/finalize_transfer\")\n\n        payload = {\n            \"transfer_code\": transfer_code,\n            \"otp\": otp,\n        }\n        return self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or Transfer,\n        )\n\n    def bulk_transfer(\n        self,\n        transfers: list[TransferInstruction],\n        source: str = \"balance\",\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[list[BulkTransferItem]] | Response[PaystackDataModel]:\n        \"\"\"Transfer in bulk\n\n        Args:\n            transfers: list of transfer instructions\n            source: source of the funds to transfer\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(\"/transfer/bulk\")\n\n        payload = {\n            \"transfers\": [tx.model_dump() for tx in transfers],\n            \"source\": source,\n        }\n        return self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or BulkTransferItem,\n        )\n\n    def get_transfers(\n        self,\n        page: int = 1,\n        pagination: int = 50,\n        customer: str | int | None = None,\n        start_date: str | None = None,\n        end_date: str | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[Transfer] | Response[PaystackDataModel]:\n        \"\"\"Retrieve transfers made to a customer\n\n        Args:\n            customer: customer id\n            page: Specifies exactly what page you want to retrieve.\n                If not specified, we use a default value of 1.\n            pagination: Specifies how many records you want to retrieve per page.\n                If not specified, we use a default value of 50.\n            start_date: A timestamp from which to start listing refund e.g. 2016-09-21\n            end_date: A timestamp at which to stop listing refund e.g. 2016-09-21\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._full_url(f\"/transfer?perPage={pagination}\")\n        query_params = [\n            (\"customer\", customer),\n            (\"page\", page),\n            (\"from\", start_date),\n            (\"to\", end_date),\n        ]\n        url = append_query_params(query_params, url)\n        return self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or Transfer,\n        )\n\n    def get_transfer(\n        self,\n        id_or_code: int | str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[Transfer] | Response[PaystackDataModel]:\n        \"\"\"Retrieve a transfer\n\n        Args:\n            id_or_code: transfer ID or code\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._full_url(f\"/transfer/{id_or_code}\")\n        return self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or Transfer,\n        )\n\n    def verify(\n        self,\n        reference: str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[Transfer] | Response[PaystackDataModel]:\n        \"\"\"Verify a transfer\n\n        Args:\n            reference: str\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._full_url(f\"/transfer/verify/{reference}\")\n        return self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or Transfer,\n        )\n</code></pre>"},{"location":"reference/transfers/#pypaystack2.sub_clients.sync_clients.transfers.TransferClient.bulk_transfer","title":"<code>bulk_transfer(transfers, source='balance', alternate_model_class=None)</code>","text":"<p>Transfer in bulk</p> <p>Parameters:</p> Name Type Description Default <code>transfers</code> <code>list[TransferInstruction]</code> <p>list of transfer instructions</p> required <code>source</code> <code>str</code> <p>source of the funds to transfer</p> <code>'balance'</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[list[BulkTransferItem]] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/transfers.py</code> <pre><code>def bulk_transfer(\n    self,\n    transfers: list[TransferInstruction],\n    source: str = \"balance\",\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[list[BulkTransferItem]] | Response[PaystackDataModel]:\n    \"\"\"Transfer in bulk\n\n    Args:\n        transfers: list of transfer instructions\n        source: source of the funds to transfer\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(\"/transfer/bulk\")\n\n    payload = {\n        \"transfers\": [tx.model_dump() for tx in transfers],\n        \"source\": source,\n    }\n    return self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or BulkTransferItem,\n    )\n</code></pre>"},{"location":"reference/transfers/#pypaystack2.sub_clients.sync_clients.transfers.TransferClient.finalize","title":"<code>finalize(transfer_code, otp, alternate_model_class=None)</code>","text":"<p>Finalize transfer</p> <p>Parameters:</p> Name Type Description Default <code>transfer_code</code> <code>str</code> <p>The code for transfer.</p> required <code>otp</code> <code>str</code> <p>One time password.</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[Transfer] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/transfers.py</code> <pre><code>def finalize(\n    self,\n    transfer_code: str,\n    otp: str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[Transfer] | Response[PaystackDataModel]:\n    \"\"\"Finalize transfer\n\n    Args:\n        transfer_code: The code for transfer.\n        otp: One time password.\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(\"/transfer/finalize_transfer\")\n\n    payload = {\n        \"transfer_code\": transfer_code,\n        \"otp\": otp,\n    }\n    return self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or Transfer,\n    )\n</code></pre>"},{"location":"reference/transfers/#pypaystack2.sub_clients.sync_clients.transfers.TransferClient.get_transfer","title":"<code>get_transfer(id_or_code, alternate_model_class=None)</code>","text":"<p>Retrieve a transfer</p> <p>Parameters:</p> Name Type Description Default <code>id_or_code</code> <code>int | str</code> <p>transfer ID or code</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[Transfer] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/transfers.py</code> <pre><code>def get_transfer(\n    self,\n    id_or_code: int | str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[Transfer] | Response[PaystackDataModel]:\n    \"\"\"Retrieve a transfer\n\n    Args:\n        id_or_code: transfer ID or code\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._full_url(f\"/transfer/{id_or_code}\")\n    return self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or Transfer,\n    )\n</code></pre>"},{"location":"reference/transfers/#pypaystack2.sub_clients.sync_clients.transfers.TransferClient.get_transfers","title":"<code>get_transfers(page=1, pagination=50, customer=None, start_date=None, end_date=None, alternate_model_class=None)</code>","text":"<p>Retrieve transfers made to a customer</p> <p>Parameters:</p> Name Type Description Default <code>customer</code> <code>str | int | None</code> <p>customer id</p> <code>None</code> <code>page</code> <code>int</code> <p>Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1.</p> <code>1</code> <code>pagination</code> <code>int</code> <p>Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50.</p> <code>50</code> <code>start_date</code> <code>str | None</code> <p>A timestamp from which to start listing refund e.g. 2016-09-21</p> <code>None</code> <code>end_date</code> <code>str | None</code> <p>A timestamp at which to stop listing refund e.g. 2016-09-21</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[Transfer] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/transfers.py</code> <pre><code>def get_transfers(\n    self,\n    page: int = 1,\n    pagination: int = 50,\n    customer: str | int | None = None,\n    start_date: str | None = None,\n    end_date: str | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[Transfer] | Response[PaystackDataModel]:\n    \"\"\"Retrieve transfers made to a customer\n\n    Args:\n        customer: customer id\n        page: Specifies exactly what page you want to retrieve.\n            If not specified, we use a default value of 1.\n        pagination: Specifies how many records you want to retrieve per page.\n            If not specified, we use a default value of 50.\n        start_date: A timestamp from which to start listing refund e.g. 2016-09-21\n        end_date: A timestamp at which to stop listing refund e.g. 2016-09-21\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._full_url(f\"/transfer?perPage={pagination}\")\n    query_params = [\n        (\"customer\", customer),\n        (\"page\", page),\n        (\"from\", start_date),\n        (\"to\", end_date),\n    ]\n    url = append_query_params(query_params, url)\n    return self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or Transfer,\n    )\n</code></pre>"},{"location":"reference/transfers/#pypaystack2.sub_clients.sync_clients.transfers.TransferClient.initiate","title":"<code>initiate(amount, recipient, reason=None, currency=None, reference=None, source='balance', alternate_model_class=None)</code>","text":"<p>Initiate transfer</p> <p>Parameters:</p> Name Type Description Default <code>amount</code> <code>int</code> <p>amount to transfer</p> required <code>recipient</code> <code>str</code> <p>the beneficiary of the transfer</p> required <code>reason</code> <code>str | None</code> <p>narration of the transfer</p> <code>None</code> <code>currency</code> <code>Currency | None</code> <p>transfer currency</p> <code>None</code> <code>reference</code> <code>str | None</code> <p>reference id</p> <code>None</code> <code>source</code> <code>str</code> <p>transfer source</p> <code>'balance'</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[Transfer] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/transfers.py</code> <pre><code>def initiate(\n    self,\n    amount: int,\n    recipient: str,\n    reason: str | None = None,\n    currency: Currency | None = None,\n    reference: str | None = None,\n    source: str = \"balance\",\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[Transfer] | Response[PaystackDataModel]:\n    \"\"\"Initiate transfer\n\n    Args:\n        amount: amount to transfer\n        recipient: the beneficiary of the transfer\n        reason: narration of the transfer\n        currency: transfer currency\n        reference: reference id\n        source: transfer source\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(\"/transfer\")\n\n    payload = {\n        \"amount\": amount,\n        \"recipient\": recipient,\n        \"source\": source,\n    }\n    optional_params = [\n        (\"reason\", reason),\n        (\"reference\", reference),\n        (\"currency\", currency),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or Transfer,\n    )\n</code></pre>"},{"location":"reference/transfers/#pypaystack2.sub_clients.sync_clients.transfers.TransferClient.verify","title":"<code>verify(reference, alternate_model_class=None)</code>","text":"<p>Verify a transfer</p> <p>Parameters:</p> Name Type Description Default <code>reference</code> <code>str</code> <p>str</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[Transfer] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/transfers.py</code> <pre><code>def verify(\n    self,\n    reference: str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[Transfer] | Response[PaystackDataModel]:\n    \"\"\"Verify a transfer\n\n    Args:\n        reference: str\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._full_url(f\"/transfer/verify/{reference}\")\n    return self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or Transfer,\n    )\n</code></pre>"},{"location":"reference/transfers/#pypaystack2.sub_clients.async_clients.transfers.AsyncTransferClient","title":"<code>AsyncTransferClient</code>","text":"<p>               Bases: <code>BaseAsyncAPIClient</code></p> <p>Provides a wrapper for paystack Transfers API</p> <p>The Transfers API allows you to automate sending money on your integration https://paystack.com/docs/api/transfer/</p>"},{"location":"reference/transfers/#pypaystack2.sub_clients.async_clients.transfers.AsyncTransferClient--note","title":"Note","text":"<p>This feature is only available to businesses in Nigeria and Ghana.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/transfers.py</code> <pre><code>class AsyncTransferClient(BaseAsyncAPIClient):\n    \"\"\"Provides a wrapper for paystack Transfers API\n\n    The Transfers API allows you to automate sending money on your integration\n    https://paystack.com/docs/api/transfer/\n\n    Note\n    ----\n    This feature is only available to businesses in Nigeria and Ghana.\n    \"\"\"\n\n    async def initiate(\n        self,\n        amount: int,\n        recipient: str,\n        reason: str | None = None,\n        currency: Currency | None = None,\n        reference: str | None = None,\n        source: str = \"balance\",\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[Transfer] | Response[PaystackDataModel]:\n        \"\"\"Initiate transfer\n\n        Args:\n            amount: amount to transfer\n            recipient: the beneficiary of the transfer\n            reason: narration of the transfer\n            currency: transfer currency\n            reference: reference id\n            source: transfer source\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(\"/transfer\")\n\n        payload = {\n            \"amount\": amount,\n            \"recipient\": recipient,\n            \"source\": source,\n        }\n        optional_params = [\n            (\"reason\", reason),\n            (\"reference\", reference),\n            (\"currency\", currency),\n        ]\n        payload = add_to_payload(optional_params, payload)\n        return await self._handle_request(\n            HTTPMethod.POST,\n            url,\n            payload,  # type: ignore\n            response_data_model_class=alternate_model_class or Transfer,\n        )\n\n    async def finalize(\n        self,\n        transfer_code: str,\n        otp: str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[Transfer] | Response[PaystackDataModel]:\n        \"\"\"Finalize transfer\n\n        Args:\n            transfer_code: The code for transfer.\n            otp: One time password.\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(\"/transfer/finalize_transfer\")\n\n        payload = {\n            \"transfer_code\": transfer_code,\n            \"otp\": otp,\n        }\n        return await self._handle_request(\n            HTTPMethod.POST,\n            url,\n            payload,  # type: ignore\n            response_data_model_class=alternate_model_class or Transfer,\n        )\n\n    async def bulk_transfer(\n        self,\n        transfers: list[TransferInstruction],\n        source: str = \"balance\",\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[list[BulkTransferItem]] | Response[PaystackDataModel]:\n        \"\"\"Transfer in bulk\n\n        Args:\n            transfers: list of transfer instructions\n            source: source of the funds to transfer\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(\"/transfer/bulk\")\n\n        payload = {\n            \"transfers\": [tx.model_dump() for tx in transfers],\n            \"source\": source,\n        }\n        return await self._handle_request(\n            HTTPMethod.POST,\n            url,\n            payload,  # type: ignore\n            response_data_model_class=alternate_model_class or BulkTransferItem,\n        )\n\n    async def get_transfers(\n        self,\n        page: int = 1,\n        pagination: int = 50,\n        customer: str | int | None = None,\n        start_date: str | None = None,\n        end_date: str | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[Transfer] | Response[PaystackDataModel]:\n        \"\"\"Retrieve transfers made to a customer\n\n        Args:\n            customer: customer id\n            page: Specifies exactly what page you want to retrieve.\n                If not specified, we use a default value of 1.\n            pagination: Specifies how many records you want to retrieve per page.\n                If not specified, we use a default value of 50.\n            start_date: A timestamp from which to start listing refund e.g. 2016-09-21\n            end_date: A timestamp at which to stop listing refund e.g. 2016-09-21\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._full_url(f\"/transfer?perPage={pagination}\")\n        query_params = [\n            (\"customer\", customer),\n            (\"page\", page),\n            (\"from\", start_date),\n            (\"to\", end_date),\n        ]\n        url = append_query_params(query_params, url)\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or Transfer,\n        )\n\n    async def get_transfer(\n        self,\n        id_or_code: int | str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[Transfer] | Response[PaystackDataModel]:\n        \"\"\"Retrieve a transfer\n\n        Args:\n            id_or_code: transfer ID or code\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._full_url(f\"/transfer/{id_or_code}\")\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or Transfer,\n        )\n\n    async def verify(\n        self,\n        reference: str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[Transfer] | Response[PaystackDataModel]:\n        \"\"\"Verify a transfer\n\n        Args:\n            reference: str\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._full_url(f\"/transfer/verify/{reference}\")\n        return await self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or Transfer,\n        )\n</code></pre>"},{"location":"reference/transfers/#pypaystack2.sub_clients.async_clients.transfers.AsyncTransferClient.bulk_transfer","title":"<code>bulk_transfer(transfers, source='balance', alternate_model_class=None)</code>  <code>async</code>","text":"<p>Transfer in bulk</p> <p>Parameters:</p> Name Type Description Default <code>transfers</code> <code>list[TransferInstruction]</code> <p>list of transfer instructions</p> required <code>source</code> <code>str</code> <p>source of the funds to transfer</p> <code>'balance'</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[list[BulkTransferItem]] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/transfers.py</code> <pre><code>async def bulk_transfer(\n    self,\n    transfers: list[TransferInstruction],\n    source: str = \"balance\",\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[list[BulkTransferItem]] | Response[PaystackDataModel]:\n    \"\"\"Transfer in bulk\n\n    Args:\n        transfers: list of transfer instructions\n        source: source of the funds to transfer\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(\"/transfer/bulk\")\n\n    payload = {\n        \"transfers\": [tx.model_dump() for tx in transfers],\n        \"source\": source,\n    }\n    return await self._handle_request(\n        HTTPMethod.POST,\n        url,\n        payload,  # type: ignore\n        response_data_model_class=alternate_model_class or BulkTransferItem,\n    )\n</code></pre>"},{"location":"reference/transfers/#pypaystack2.sub_clients.async_clients.transfers.AsyncTransferClient.finalize","title":"<code>finalize(transfer_code, otp, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Finalize transfer</p> <p>Parameters:</p> Name Type Description Default <code>transfer_code</code> <code>str</code> <p>The code for transfer.</p> required <code>otp</code> <code>str</code> <p>One time password.</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[Transfer] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/transfers.py</code> <pre><code>async def finalize(\n    self,\n    transfer_code: str,\n    otp: str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[Transfer] | Response[PaystackDataModel]:\n    \"\"\"Finalize transfer\n\n    Args:\n        transfer_code: The code for transfer.\n        otp: One time password.\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(\"/transfer/finalize_transfer\")\n\n    payload = {\n        \"transfer_code\": transfer_code,\n        \"otp\": otp,\n    }\n    return await self._handle_request(\n        HTTPMethod.POST,\n        url,\n        payload,  # type: ignore\n        response_data_model_class=alternate_model_class or Transfer,\n    )\n</code></pre>"},{"location":"reference/transfers/#pypaystack2.sub_clients.async_clients.transfers.AsyncTransferClient.get_transfer","title":"<code>get_transfer(id_or_code, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Retrieve a transfer</p> <p>Parameters:</p> Name Type Description Default <code>id_or_code</code> <code>int | str</code> <p>transfer ID or code</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[Transfer] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/transfers.py</code> <pre><code>async def get_transfer(\n    self,\n    id_or_code: int | str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[Transfer] | Response[PaystackDataModel]:\n    \"\"\"Retrieve a transfer\n\n    Args:\n        id_or_code: transfer ID or code\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._full_url(f\"/transfer/{id_or_code}\")\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or Transfer,\n    )\n</code></pre>"},{"location":"reference/transfers/#pypaystack2.sub_clients.async_clients.transfers.AsyncTransferClient.get_transfers","title":"<code>get_transfers(page=1, pagination=50, customer=None, start_date=None, end_date=None, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Retrieve transfers made to a customer</p> <p>Parameters:</p> Name Type Description Default <code>customer</code> <code>str | int | None</code> <p>customer id</p> <code>None</code> <code>page</code> <code>int</code> <p>Specifies exactly what page you want to retrieve. If not specified, we use a default value of 1.</p> <code>1</code> <code>pagination</code> <code>int</code> <p>Specifies how many records you want to retrieve per page. If not specified, we use a default value of 50.</p> <code>50</code> <code>start_date</code> <code>str | None</code> <p>A timestamp from which to start listing refund e.g. 2016-09-21</p> <code>None</code> <code>end_date</code> <code>str | None</code> <p>A timestamp at which to stop listing refund e.g. 2016-09-21</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[Transfer] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/transfers.py</code> <pre><code>async def get_transfers(\n    self,\n    page: int = 1,\n    pagination: int = 50,\n    customer: str | int | None = None,\n    start_date: str | None = None,\n    end_date: str | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[Transfer] | Response[PaystackDataModel]:\n    \"\"\"Retrieve transfers made to a customer\n\n    Args:\n        customer: customer id\n        page: Specifies exactly what page you want to retrieve.\n            If not specified, we use a default value of 1.\n        pagination: Specifies how many records you want to retrieve per page.\n            If not specified, we use a default value of 50.\n        start_date: A timestamp from which to start listing refund e.g. 2016-09-21\n        end_date: A timestamp at which to stop listing refund e.g. 2016-09-21\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._full_url(f\"/transfer?perPage={pagination}\")\n    query_params = [\n        (\"customer\", customer),\n        (\"page\", page),\n        (\"from\", start_date),\n        (\"to\", end_date),\n    ]\n    url = append_query_params(query_params, url)\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or Transfer,\n    )\n</code></pre>"},{"location":"reference/transfers/#pypaystack2.sub_clients.async_clients.transfers.AsyncTransferClient.initiate","title":"<code>initiate(amount, recipient, reason=None, currency=None, reference=None, source='balance', alternate_model_class=None)</code>  <code>async</code>","text":"<p>Initiate transfer</p> <p>Parameters:</p> Name Type Description Default <code>amount</code> <code>int</code> <p>amount to transfer</p> required <code>recipient</code> <code>str</code> <p>the beneficiary of the transfer</p> required <code>reason</code> <code>str | None</code> <p>narration of the transfer</p> <code>None</code> <code>currency</code> <code>Currency | None</code> <p>transfer currency</p> <code>None</code> <code>reference</code> <code>str | None</code> <p>reference id</p> <code>None</code> <code>source</code> <code>str</code> <p>transfer source</p> <code>'balance'</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[Transfer] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/transfers.py</code> <pre><code>async def initiate(\n    self,\n    amount: int,\n    recipient: str,\n    reason: str | None = None,\n    currency: Currency | None = None,\n    reference: str | None = None,\n    source: str = \"balance\",\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[Transfer] | Response[PaystackDataModel]:\n    \"\"\"Initiate transfer\n\n    Args:\n        amount: amount to transfer\n        recipient: the beneficiary of the transfer\n        reason: narration of the transfer\n        currency: transfer currency\n        reference: reference id\n        source: transfer source\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(\"/transfer\")\n\n    payload = {\n        \"amount\": amount,\n        \"recipient\": recipient,\n        \"source\": source,\n    }\n    optional_params = [\n        (\"reason\", reason),\n        (\"reference\", reference),\n        (\"currency\", currency),\n    ]\n    payload = add_to_payload(optional_params, payload)\n    return await self._handle_request(\n        HTTPMethod.POST,\n        url,\n        payload,  # type: ignore\n        response_data_model_class=alternate_model_class or Transfer,\n    )\n</code></pre>"},{"location":"reference/transfers/#pypaystack2.sub_clients.async_clients.transfers.AsyncTransferClient.verify","title":"<code>verify(reference, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Verify a transfer</p> <p>Parameters:</p> Name Type Description Default <code>reference</code> <code>str</code> <p>str</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[Transfer] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/transfers.py</code> <pre><code>async def verify(\n    self,\n    reference: str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[Transfer] | Response[PaystackDataModel]:\n    \"\"\"Verify a transfer\n\n    Args:\n        reference: str\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._full_url(f\"/transfer/verify/{reference}\")\n    return await self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or Transfer,\n    )\n</code></pre>"},{"location":"reference/transfers_control/","title":"Transfers control","text":""},{"location":"reference/transfers_control/#pypaystack2.sub_clients.sync_clients.transfers_control.TransferControlClient","title":"<code>TransferControlClient</code>","text":"<p>               Bases: <code>BaseAPIClient</code></p> <p>Provides a wrapper for paystack Transfers Control API</p> <p>The Transfer Control API allows you to manage settings of your transfers. https://paystack.com/docs/api/transfer-control/</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/transfers_control.py</code> <pre><code>class TransferControlClient(BaseAPIClient):\n    \"\"\"Provides a wrapper for paystack Transfers Control API\n\n    The Transfer Control API allows you to manage settings of your transfers.\n    https://paystack.com/docs/api/transfer-control/\n    \"\"\"\n\n    def check_balance(\n        self,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[list[IntegrationBalance]] | Response[PaystackDataModel]:\n        \"\"\"Fetch the available balance on your integration\n\n        Args:\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._full_url(\"/balance\")\n        return self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or IntegrationBalance,\n        )\n\n    def get_balance_ledger(\n        self,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[list[BalanceLedgerItem]] | Response[PaystackDataModel]:\n        \"\"\"Fetch all pay-ins and pay-outs that occurred on your integration\n\n        Args:\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._full_url(\"/balance/ledger\")\n        return self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or BalanceLedgerItem,\n        )\n\n    def resend_otp(\n        self,\n        transfer_code: str,\n        reason: Reason,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[None] | Response[PaystackDataModel]:\n        \"\"\"\n        Generates a new OTP and sends to customer in the event they are having trouble receiving one.\n\n        Note:\n            Feature Availability\n                This feature is only available to businesses in Nigeria and Ghana.\n\n        Args:\n            transfer_code: Transfer code\n            reason: Any value from the ``Reason`` enum\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n        payload = {\"transfer_code\": transfer_code, \"reason\": reason}\n        url = self._full_url(\"/transfer/resend_otp\")\n        return self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class,\n        )\n\n    def disable_otp(\n        self,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[None] | Response[PaystackDataModel]:\n        \"\"\"\n        This is used in the event that you want to be able to complete transfers\n        programmatically without use of OTPs. No arguments required. You will get\n        an OTP to complete the request\n\n        Note:\n            Feature Availability\n                This feature is only available to businesses in Nigeria and Ghana.\n\n        Args:\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._full_url(\"/transfer/disable_otp\")\n        return self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            response_data_model_class=alternate_model_class,\n        )\n\n    def finalize_disable_otp(\n        self,\n        otp: str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[None] | Response[PaystackDataModel]:\n        \"\"\"Finalize the request to disable OTP on your transfers.\n\n        Note:\n            Feature Availability\n                This feature is only available to businesses in Nigeria and Ghana.\n\n        Args:\n            otp: One time password\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n        payload = {\"otp\": otp}\n        url = self._full_url(\"/transfer/disable_otp_finalize\")\n        return self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class,\n        )\n\n    def enable_otp(\n        self,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[None] | Response[PaystackDataModel]:\n        \"\"\"\n        In the event that a customer wants to stop being able to complete transfers\n        programmatically, this endpoint helps turn OTP requirement back on. No\n        arguments required.\n\n        Note:\n            Feature Availability\n                This feature is only available to businesses in Nigeria and Ghana.\n\n        Args:\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._full_url(\"/transfer/enable_otp\")\n        return self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            response_data_model_class=alternate_model_class,\n        )\n</code></pre>"},{"location":"reference/transfers_control/#pypaystack2.sub_clients.sync_clients.transfers_control.TransferControlClient.check_balance","title":"<code>check_balance(alternate_model_class=None)</code>","text":"<p>Fetch the available balance on your integration</p> <p>Parameters:</p> Name Type Description Default <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[list[IntegrationBalance]] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/transfers_control.py</code> <pre><code>def check_balance(\n    self,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[list[IntegrationBalance]] | Response[PaystackDataModel]:\n    \"\"\"Fetch the available balance on your integration\n\n    Args:\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._full_url(\"/balance\")\n    return self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or IntegrationBalance,\n    )\n</code></pre>"},{"location":"reference/transfers_control/#pypaystack2.sub_clients.sync_clients.transfers_control.TransferControlClient.disable_otp","title":"<code>disable_otp(alternate_model_class=None)</code>","text":"<p>This is used in the event that you want to be able to complete transfers programmatically without use of OTPs. No arguments required. You will get an OTP to complete the request</p> Note <p>Feature Availability     This feature is only available to businesses in Nigeria and Ghana.</p> <p>Parameters:</p> Name Type Description Default <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[None] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/transfers_control.py</code> <pre><code>def disable_otp(\n    self,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[None] | Response[PaystackDataModel]:\n    \"\"\"\n    This is used in the event that you want to be able to complete transfers\n    programmatically without use of OTPs. No arguments required. You will get\n    an OTP to complete the request\n\n    Note:\n        Feature Availability\n            This feature is only available to businesses in Nigeria and Ghana.\n\n    Args:\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._full_url(\"/transfer/disable_otp\")\n    return self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        response_data_model_class=alternate_model_class,\n    )\n</code></pre>"},{"location":"reference/transfers_control/#pypaystack2.sub_clients.sync_clients.transfers_control.TransferControlClient.enable_otp","title":"<code>enable_otp(alternate_model_class=None)</code>","text":"<p>In the event that a customer wants to stop being able to complete transfers programmatically, this endpoint helps turn OTP requirement back on. No arguments required.</p> Note <p>Feature Availability     This feature is only available to businesses in Nigeria and Ghana.</p> <p>Parameters:</p> Name Type Description Default <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[None] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/transfers_control.py</code> <pre><code>def enable_otp(\n    self,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[None] | Response[PaystackDataModel]:\n    \"\"\"\n    In the event that a customer wants to stop being able to complete transfers\n    programmatically, this endpoint helps turn OTP requirement back on. No\n    arguments required.\n\n    Note:\n        Feature Availability\n            This feature is only available to businesses in Nigeria and Ghana.\n\n    Args:\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._full_url(\"/transfer/enable_otp\")\n    return self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        response_data_model_class=alternate_model_class,\n    )\n</code></pre>"},{"location":"reference/transfers_control/#pypaystack2.sub_clients.sync_clients.transfers_control.TransferControlClient.finalize_disable_otp","title":"<code>finalize_disable_otp(otp, alternate_model_class=None)</code>","text":"<p>Finalize the request to disable OTP on your transfers.</p> Note <p>Feature Availability     This feature is only available to businesses in Nigeria and Ghana.</p> <p>Parameters:</p> Name Type Description Default <code>otp</code> <code>str</code> <p>One time password</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[None] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/transfers_control.py</code> <pre><code>def finalize_disable_otp(\n    self,\n    otp: str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[None] | Response[PaystackDataModel]:\n    \"\"\"Finalize the request to disable OTP on your transfers.\n\n    Note:\n        Feature Availability\n            This feature is only available to businesses in Nigeria and Ghana.\n\n    Args:\n        otp: One time password\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n    payload = {\"otp\": otp}\n    url = self._full_url(\"/transfer/disable_otp_finalize\")\n    return self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class,\n    )\n</code></pre>"},{"location":"reference/transfers_control/#pypaystack2.sub_clients.sync_clients.transfers_control.TransferControlClient.get_balance_ledger","title":"<code>get_balance_ledger(alternate_model_class=None)</code>","text":"<p>Fetch all pay-ins and pay-outs that occurred on your integration</p> <p>Parameters:</p> Name Type Description Default <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[list[BalanceLedgerItem]] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/transfers_control.py</code> <pre><code>def get_balance_ledger(\n    self,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[list[BalanceLedgerItem]] | Response[PaystackDataModel]:\n    \"\"\"Fetch all pay-ins and pay-outs that occurred on your integration\n\n    Args:\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._full_url(\"/balance/ledger\")\n    return self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or BalanceLedgerItem,\n    )\n</code></pre>"},{"location":"reference/transfers_control/#pypaystack2.sub_clients.sync_clients.transfers_control.TransferControlClient.resend_otp","title":"<code>resend_otp(transfer_code, reason, alternate_model_class=None)</code>","text":"<p>Generates a new OTP and sends to customer in the event they are having trouble receiving one.</p> Note <p>Feature Availability     This feature is only available to businesses in Nigeria and Ghana.</p> <p>Parameters:</p> Name Type Description Default <code>transfer_code</code> <code>str</code> <p>Transfer code</p> required <code>reason</code> <code>Reason</code> <p>Any value from the <code>Reason</code> enum</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[None] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/transfers_control.py</code> <pre><code>def resend_otp(\n    self,\n    transfer_code: str,\n    reason: Reason,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[None] | Response[PaystackDataModel]:\n    \"\"\"\n    Generates a new OTP and sends to customer in the event they are having trouble receiving one.\n\n    Note:\n        Feature Availability\n            This feature is only available to businesses in Nigeria and Ghana.\n\n    Args:\n        transfer_code: Transfer code\n        reason: Any value from the ``Reason`` enum\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n    payload = {\"transfer_code\": transfer_code, \"reason\": reason}\n    url = self._full_url(\"/transfer/resend_otp\")\n    return self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class,\n    )\n</code></pre>"},{"location":"reference/transfers_control/#pypaystack2.sub_clients.async_clients.transfers_control.AsyncTransferControlClient","title":"<code>AsyncTransferControlClient</code>","text":"<p>               Bases: <code>BaseAsyncAPIClient</code></p> <p>Provides a wrapper for paystack Transfers Control API</p> <p>The Transfer Control API allows you to manage settings of your transfers. https://paystack.com/docs/api/transfer-control/</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/transfers_control.py</code> <pre><code>class AsyncTransferControlClient(BaseAsyncAPIClient):\n    \"\"\"Provides a wrapper for paystack Transfers Control API\n\n    The Transfer Control API allows you to manage settings of your transfers.\n    https://paystack.com/docs/api/transfer-control/\n    \"\"\"\n\n    async def check_balance(\n        self,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[list[IntegrationBalance]] | Response[PaystackDataModel]:\n        \"\"\"Fetch the available balance on your integration\n\n        Args:\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._full_url(\"/balance\")\n        return await self._handle_request(\n            HTTPMethod.GET,\n            url,  # type: ignore\n            response_data_model_class=alternate_model_class or IntegrationBalance,\n        )\n\n    async def get_balance_ledger(\n        self,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[list[BalanceLedgerItem]] | Response[PaystackDataModel]:\n        \"\"\"Fetch all pay-ins and pay-outs that occured on your integration\n\n        Args:\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._full_url(\"balance/ledger\")\n        return await self._handle_request(\n            HTTPMethod.GET,\n            url,  # type: ignore\n            response_data_model_class=alternate_model_class or BalanceLedgerItem,\n        )\n\n    async def resend_otp(\n        self,\n        transfer_code: str,\n        reason: Reason,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[None] | Response[PaystackDataModel]:\n        \"\"\"\n        Generates a new OTP and sends to customer in the event they are having trouble receiving one.\n\n        Note:\n            Feature Availability\n                This feature is only available to businesses in Nigeria and Ghana.\n\n        Args:\n            transfer_code: Transfer code\n            reason: Any value from the ``Reason`` enum\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n        payload = {\"transfer_code\": transfer_code, \"reason\": reason}\n        url = self._full_url(\"/transfer/resend_otp\")\n        return await self._handle_request(\n            HTTPMethod.POST,\n            url,\n            payload,  # type: ignore\n            response_data_model_class=alternate_model_class,\n        )\n\n    async def disable_otp(\n        self,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[None] | Response[PaystackDataModel]:\n        \"\"\"\n        This is used in the event that you want to be able to complete transfers\n        programmatically without use of OTPs. No arguments required. You will get\n        an OTP to complete the request\n\n        Note:\n            Feature Availability\n                This feature is only available to businesses in Nigeria and Ghana.\n\n        Args:\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._full_url(\"/transfer/disable_otp\")\n        return await self._handle_request(\n            HTTPMethod.POST,\n            url,  # type: ignore\n            response_data_model_class=alternate_model_class,\n        )\n\n    async def finalize_disable_otp(\n        self,\n        otp: str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[None] | Response[PaystackDataModel]:\n        \"\"\"Finalize the request to disable OTP on your transfers.\n\n        Note:\n            Feature Availability\n                This feature is only available to businesses in Nigeria and Ghana.\n\n        Args:\n            otp: One time password\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n        payload = {\"otp\": otp}\n        url = self._full_url(\"/transfer/disable_otp_finalize\")\n        return await self._handle_request(\n            HTTPMethod.POST,\n            url,\n            payload,  # type: ignore\n            response_data_model_class=alternate_model_class,\n        )\n\n    async def enable_otp(\n        self,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[None] | Response[PaystackDataModel]:\n        \"\"\"\n        In the event that a customer wants to stop being able to complete transfers\n        programmatically, this endpoint helps turn OTP requirement back on. No\n        arguments required.\n\n        Note:\n            Feature Availability\n                This feature is only available to businesses in Nigeria and Ghana.\n\n        Args:\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._full_url(\"/transfer/enable_otp\")\n        return await self._handle_request(\n            HTTPMethod.POST,\n            url,  # type: ignore\n            response_data_model_class=alternate_model_class,\n        )\n</code></pre>"},{"location":"reference/transfers_control/#pypaystack2.sub_clients.async_clients.transfers_control.AsyncTransferControlClient.check_balance","title":"<code>check_balance(alternate_model_class=None)</code>  <code>async</code>","text":"<p>Fetch the available balance on your integration</p> <p>Parameters:</p> Name Type Description Default <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[list[IntegrationBalance]] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/transfers_control.py</code> <pre><code>async def check_balance(\n    self,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[list[IntegrationBalance]] | Response[PaystackDataModel]:\n    \"\"\"Fetch the available balance on your integration\n\n    Args:\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._full_url(\"/balance\")\n    return await self._handle_request(\n        HTTPMethod.GET,\n        url,  # type: ignore\n        response_data_model_class=alternate_model_class or IntegrationBalance,\n    )\n</code></pre>"},{"location":"reference/transfers_control/#pypaystack2.sub_clients.async_clients.transfers_control.AsyncTransferControlClient.disable_otp","title":"<code>disable_otp(alternate_model_class=None)</code>  <code>async</code>","text":"<p>This is used in the event that you want to be able to complete transfers programmatically without use of OTPs. No arguments required. You will get an OTP to complete the request</p> Note <p>Feature Availability     This feature is only available to businesses in Nigeria and Ghana.</p> <p>Parameters:</p> Name Type Description Default <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[None] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/transfers_control.py</code> <pre><code>async def disable_otp(\n    self,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[None] | Response[PaystackDataModel]:\n    \"\"\"\n    This is used in the event that you want to be able to complete transfers\n    programmatically without use of OTPs. No arguments required. You will get\n    an OTP to complete the request\n\n    Note:\n        Feature Availability\n            This feature is only available to businesses in Nigeria and Ghana.\n\n    Args:\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._full_url(\"/transfer/disable_otp\")\n    return await self._handle_request(\n        HTTPMethod.POST,\n        url,  # type: ignore\n        response_data_model_class=alternate_model_class,\n    )\n</code></pre>"},{"location":"reference/transfers_control/#pypaystack2.sub_clients.async_clients.transfers_control.AsyncTransferControlClient.enable_otp","title":"<code>enable_otp(alternate_model_class=None)</code>  <code>async</code>","text":"<p>In the event that a customer wants to stop being able to complete transfers programmatically, this endpoint helps turn OTP requirement back on. No arguments required.</p> Note <p>Feature Availability     This feature is only available to businesses in Nigeria and Ghana.</p> <p>Parameters:</p> Name Type Description Default <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[None] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/transfers_control.py</code> <pre><code>async def enable_otp(\n    self,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[None] | Response[PaystackDataModel]:\n    \"\"\"\n    In the event that a customer wants to stop being able to complete transfers\n    programmatically, this endpoint helps turn OTP requirement back on. No\n    arguments required.\n\n    Note:\n        Feature Availability\n            This feature is only available to businesses in Nigeria and Ghana.\n\n    Args:\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._full_url(\"/transfer/enable_otp\")\n    return await self._handle_request(\n        HTTPMethod.POST,\n        url,  # type: ignore\n        response_data_model_class=alternate_model_class,\n    )\n</code></pre>"},{"location":"reference/transfers_control/#pypaystack2.sub_clients.async_clients.transfers_control.AsyncTransferControlClient.finalize_disable_otp","title":"<code>finalize_disable_otp(otp, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Finalize the request to disable OTP on your transfers.</p> Note <p>Feature Availability     This feature is only available to businesses in Nigeria and Ghana.</p> <p>Parameters:</p> Name Type Description Default <code>otp</code> <code>str</code> <p>One time password</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[None] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/transfers_control.py</code> <pre><code>async def finalize_disable_otp(\n    self,\n    otp: str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[None] | Response[PaystackDataModel]:\n    \"\"\"Finalize the request to disable OTP on your transfers.\n\n    Note:\n        Feature Availability\n            This feature is only available to businesses in Nigeria and Ghana.\n\n    Args:\n        otp: One time password\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n    payload = {\"otp\": otp}\n    url = self._full_url(\"/transfer/disable_otp_finalize\")\n    return await self._handle_request(\n        HTTPMethod.POST,\n        url,\n        payload,  # type: ignore\n        response_data_model_class=alternate_model_class,\n    )\n</code></pre>"},{"location":"reference/transfers_control/#pypaystack2.sub_clients.async_clients.transfers_control.AsyncTransferControlClient.get_balance_ledger","title":"<code>get_balance_ledger(alternate_model_class=None)</code>  <code>async</code>","text":"<p>Fetch all pay-ins and pay-outs that occured on your integration</p> <p>Parameters:</p> Name Type Description Default <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[list[BalanceLedgerItem]] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/transfers_control.py</code> <pre><code>async def get_balance_ledger(\n    self,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[list[BalanceLedgerItem]] | Response[PaystackDataModel]:\n    \"\"\"Fetch all pay-ins and pay-outs that occured on your integration\n\n    Args:\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._full_url(\"balance/ledger\")\n    return await self._handle_request(\n        HTTPMethod.GET,\n        url,  # type: ignore\n        response_data_model_class=alternate_model_class or BalanceLedgerItem,\n    )\n</code></pre>"},{"location":"reference/transfers_control/#pypaystack2.sub_clients.async_clients.transfers_control.AsyncTransferControlClient.resend_otp","title":"<code>resend_otp(transfer_code, reason, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Generates a new OTP and sends to customer in the event they are having trouble receiving one.</p> Note <p>Feature Availability     This feature is only available to businesses in Nigeria and Ghana.</p> <p>Parameters:</p> Name Type Description Default <code>transfer_code</code> <code>str</code> <p>Transfer code</p> required <code>reason</code> <code>Reason</code> <p>Any value from the <code>Reason</code> enum</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[None] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/transfers_control.py</code> <pre><code>async def resend_otp(\n    self,\n    transfer_code: str,\n    reason: Reason,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[None] | Response[PaystackDataModel]:\n    \"\"\"\n    Generates a new OTP and sends to customer in the event they are having trouble receiving one.\n\n    Note:\n        Feature Availability\n            This feature is only available to businesses in Nigeria and Ghana.\n\n    Args:\n        transfer_code: Transfer code\n        reason: Any value from the ``Reason`` enum\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n    payload = {\"transfer_code\": transfer_code, \"reason\": reason}\n    url = self._full_url(\"/transfer/resend_otp\")\n    return await self._handle_request(\n        HTTPMethod.POST,\n        url,\n        payload,  # type: ignore\n        response_data_model_class=alternate_model_class,\n    )\n</code></pre>"},{"location":"reference/verification/","title":"Verification","text":""},{"location":"reference/verification/#pypaystack2.sub_clients.sync_clients.verification.VerificationClient","title":"<code>VerificationClient</code>","text":"<p>               Bases: <code>BaseAPIClient</code></p> <p>Provides a wrapper for paystack Verification API</p> <p>The Verification API allows you to perform KYC processes. https://paystack.com/docs/api/verification/</p> Note <p>This feature is only available to businesses in Nigeria.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/verification.py</code> <pre><code>class VerificationClient(BaseAPIClient):\n    \"\"\"Provides a wrapper for paystack Verification API\n\n    The Verification API allows you to perform KYC processes.\n    https://paystack.com/docs/api/verification/\n\n    Note:\n        This feature is only available to businesses in Nigeria.\n    \"\"\"\n\n    def resolve_account_number(\n        self,\n        account_number: str,\n        bank_code: str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[BankAccountInfo] | Response[PaystackDataModel]:\n        \"\"\"Confirm an account belongs to the right customer\n\n        Note:\n            Feature Availability\n                This feature is only available to businesses in Nigeria.\n\n        Args:\n            account_number: Account Number\n            bank_code: You can get the list of bank codes by calling\n                `PaystackClient.miscellaneous.get_banks` method.\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._full_url(\n            f\"/bank/resolve?account_number={account_number}&amp;bank_code={bank_code}\"\n        )\n        return self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or BankAccountInfo,\n        )\n\n    def validate_account(\n        self,\n        account_name: str,\n        account_number: str,\n        account_type: AccountType,\n        bank_code: str,\n        country_code: Country,\n        document_type: Document,\n        document_number: str | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[AccountVerificationInfo] | Response[PaystackDataModel]:\n        \"\"\"Confirm the authenticity of a customer's account number before sending money\n\n        Args:\n            account_name: Customer's first and last name registered with their bank\n            account_number: Customer's account number\n            account_type: bank_code: The bank code of the customer\u2019s bank. You can fetch the bank codes by\n                using `PaystackClient.miscellaneous.get_banks` method.\n            bank_code: The bank code of the customer\u2019s bank\n            country_code: Any value from the ``Country`` enum\n            document_type: Customer\u2019s mode of identity. any value from the\n                `Document` enum.\n            document_number: Customer\u2019s mode of identity number\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        payload = {\n            \"account_name\": account_name,\n            \"account_number\": account_number,\n            \"account_type\": account_type,\n            \"bank_code\": bank_code,\n            \"country_code\": country_code,\n            \"document_type\": document_type,\n            \"document_number\": document_number,\n        }\n        url = self._full_url(\"/bank/validate\")\n\n        return self._handle_request(  # type: ignore\n            HTTPMethod.POST,\n            url,\n            payload,\n            response_data_model_class=alternate_model_class or AccountVerificationInfo,\n        )\n\n    def resolve_card_bin(\n        self,\n        bin_: str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[CardBin] | Response[PaystackDataModel]:\n        \"\"\"Get more information about a customer's card\n\n        Args:\n            bin_: First 6 characters of card\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/decision/bin/{bin_}\")\n        return self._handle_request(  # type: ignore\n            HTTPMethod.GET,\n            url,\n            response_data_model_class=alternate_model_class or CardBin,\n        )\n</code></pre>"},{"location":"reference/verification/#pypaystack2.sub_clients.sync_clients.verification.VerificationClient.resolve_account_number","title":"<code>resolve_account_number(account_number, bank_code, alternate_model_class=None)</code>","text":"<p>Confirm an account belongs to the right customer</p> Note <p>Feature Availability     This feature is only available to businesses in Nigeria.</p> <p>Parameters:</p> Name Type Description Default <code>account_number</code> <code>str</code> <p>Account Number</p> required <code>bank_code</code> <code>str</code> <p>You can get the list of bank codes by calling <code>PaystackClient.miscellaneous.get_banks</code> method.</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[BankAccountInfo] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/verification.py</code> <pre><code>def resolve_account_number(\n    self,\n    account_number: str,\n    bank_code: str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[BankAccountInfo] | Response[PaystackDataModel]:\n    \"\"\"Confirm an account belongs to the right customer\n\n    Note:\n        Feature Availability\n            This feature is only available to businesses in Nigeria.\n\n    Args:\n        account_number: Account Number\n        bank_code: You can get the list of bank codes by calling\n            `PaystackClient.miscellaneous.get_banks` method.\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._full_url(\n        f\"/bank/resolve?account_number={account_number}&amp;bank_code={bank_code}\"\n    )\n    return self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or BankAccountInfo,\n    )\n</code></pre>"},{"location":"reference/verification/#pypaystack2.sub_clients.sync_clients.verification.VerificationClient.resolve_card_bin","title":"<code>resolve_card_bin(bin_, alternate_model_class=None)</code>","text":"<p>Get more information about a customer's card</p> <p>Parameters:</p> Name Type Description Default <code>bin_</code> <code>str</code> <p>First 6 characters of card</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[CardBin] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/verification.py</code> <pre><code>def resolve_card_bin(\n    self,\n    bin_: str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[CardBin] | Response[PaystackDataModel]:\n    \"\"\"Get more information about a customer's card\n\n    Args:\n        bin_: First 6 characters of card\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/decision/bin/{bin_}\")\n    return self._handle_request(  # type: ignore\n        HTTPMethod.GET,\n        url,\n        response_data_model_class=alternate_model_class or CardBin,\n    )\n</code></pre>"},{"location":"reference/verification/#pypaystack2.sub_clients.sync_clients.verification.VerificationClient.validate_account","title":"<code>validate_account(account_name, account_number, account_type, bank_code, country_code, document_type, document_number=None, alternate_model_class=None)</code>","text":"<p>Confirm the authenticity of a customer's account number before sending money</p> <p>Parameters:</p> Name Type Description Default <code>account_name</code> <code>str</code> <p>Customer's first and last name registered with their bank</p> required <code>account_number</code> <code>str</code> <p>Customer's account number</p> required <code>account_type</code> <code>AccountType</code> <p>bank_code: The bank code of the customer\u2019s bank. You can fetch the bank codes by using <code>PaystackClient.miscellaneous.get_banks</code> method.</p> required <code>bank_code</code> <code>str</code> <p>The bank code of the customer\u2019s bank</p> required <code>country_code</code> <code>Country</code> <p>Any value from the <code>Country</code> enum</p> required <code>document_type</code> <code>Document</code> <p>Customer\u2019s mode of identity. any value from the <code>Document</code> enum.</p> required <code>document_number</code> <code>str | None</code> <p>Customer\u2019s mode of identity number</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[AccountVerificationInfo] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/sync_clients/verification.py</code> <pre><code>def validate_account(\n    self,\n    account_name: str,\n    account_number: str,\n    account_type: AccountType,\n    bank_code: str,\n    country_code: Country,\n    document_type: Document,\n    document_number: str | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[AccountVerificationInfo] | Response[PaystackDataModel]:\n    \"\"\"Confirm the authenticity of a customer's account number before sending money\n\n    Args:\n        account_name: Customer's first and last name registered with their bank\n        account_number: Customer's account number\n        account_type: bank_code: The bank code of the customer\u2019s bank. You can fetch the bank codes by\n            using `PaystackClient.miscellaneous.get_banks` method.\n        bank_code: The bank code of the customer\u2019s bank\n        country_code: Any value from the ``Country`` enum\n        document_type: Customer\u2019s mode of identity. any value from the\n            `Document` enum.\n        document_number: Customer\u2019s mode of identity number\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    payload = {\n        \"account_name\": account_name,\n        \"account_number\": account_number,\n        \"account_type\": account_type,\n        \"bank_code\": bank_code,\n        \"country_code\": country_code,\n        \"document_type\": document_type,\n        \"document_number\": document_number,\n    }\n    url = self._full_url(\"/bank/validate\")\n\n    return self._handle_request(  # type: ignore\n        HTTPMethod.POST,\n        url,\n        payload,\n        response_data_model_class=alternate_model_class or AccountVerificationInfo,\n    )\n</code></pre>"},{"location":"reference/verification/#pypaystack2.sub_clients.async_clients.verification.AsyncVerificationClient","title":"<code>AsyncVerificationClient</code>","text":"<p>               Bases: <code>BaseAsyncAPIClient</code></p> <p>Provides a wrapper for paystack Verification API</p> <p>The Verification API allows you to perform KYC processes. https://paystack.com/docs/api/verification/</p> Note <p>This feature is only available to businesses in Nigeria.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/verification.py</code> <pre><code>class AsyncVerificationClient(BaseAsyncAPIClient):\n    \"\"\"Provides a wrapper for paystack Verification API\n\n    The Verification API allows you to perform KYC processes.\n    https://paystack.com/docs/api/verification/\n\n    Note:\n        This feature is only available to businesses in Nigeria.\n    \"\"\"\n\n    async def resolve_account_number(\n        self,\n        account_number: str,\n        bank_code: str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[BankAccountInfo] | Response[PaystackDataModel]:\n        \"\"\"Confirm an account belongs to the right customer\n\n        Note:\n            Feature Availability\n                This feature is only available to businesses in Nigeria.\n\n        Args:\n            account_number: Account Number\n            bank_code: You can get the list of bank codes by calling\n                `PaystackClient.miscellaneous.get_banks` method.\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n        url = self._full_url(\n            f\"/bank/resolve?account_number={account_number}&amp;bank_code={bank_code}\"\n        )\n        return await self._handle_request(\n            HTTPMethod.GET,\n            url,  # type: ignore\n            response_data_model_class=alternate_model_class or BankAccountInfo,\n        )\n\n    async def validate_account(\n        self,\n        account_name: str,\n        account_number: str,\n        account_type: AccountType,\n        bank_code: str,\n        country_code: Country,\n        document_type: Document,\n        document_number: str | None = None,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[AccountVerificationInfo] | Response[PaystackDataModel]:\n        \"\"\"Confirm the authenticity of a customer's account number before sending money\n\n        Args:\n            account_name: Customer's first and last name registered with their bank\n            account_number: Customer's account number\n            account_type: bank_code: The bank code of the customer\u2019s bank. You can fetch the bank codes by\n                using `PaystackClient.miscellaneous.get_banks` method.\n            bank_code: The bank code of the customer\u2019s bank\n            country_code: Any value from the ``Country`` enum\n            document_type: Customer\u2019s mode of identity. any value from the\n                ``Document`` enum.\n            document_number: Customer\u2019s mode of identity number\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        payload = {\n            \"account_name\": account_name,\n            \"account_number\": account_number,\n            \"account_type\": account_type,\n            \"bank_code\": bank_code,\n            \"country_code\": country_code,\n            \"document_type\": document_type,\n            \"document_number\": document_number,\n        }\n        url = self._full_url(\"/bank/validate\")\n\n        return await self._handle_request(\n            HTTPMethod.POST,\n            url,\n            payload,  # type: ignore\n            response_data_model_class=alternate_model_class or AccountVerificationInfo,\n        )\n\n    async def resolve_card_bin(\n        self,\n        bin_: str,\n        alternate_model_class: type[PaystackDataModel] | None = None,\n    ) -&gt; Response[CardBin] | Response[PaystackDataModel]:\n        \"\"\"Get more information about a customer's card\n\n        Args:\n            bin_: First 6 characters of card\n            alternate_model_class: A pydantic model class to use instead of the\n                default pydantic model used by the library to present the data in\n                the `Response.data`. The default behaviour of the library is to\n                set  `Response.data` to `None` if it fails to serialize the data\n                returned from paystack with the model provided in the library.\n                Providing a pydantic model class via this parameter overrides\n                the library default model with the model class you provide.\n                This can come in handy when the models in the library do not\n                accurately represent the data returned, and you prefer working with the\n                data as a pydantic model instead of as a dict of the response returned\n                by  paystack before it is serialized with pydantic models, The original\n                data can be accessed via `Response.raw`.\n\n\n        Returns:\n            A pydantic model containing the response gotten from paystack's server.\n        \"\"\"\n\n        url = self._full_url(f\"/decision/bin/{bin_}\")\n        return await self._handle_request(\n            HTTPMethod.GET,\n            url,  # type: ignore\n            response_data_model_class=alternate_model_class or CardBin,\n        )\n</code></pre>"},{"location":"reference/verification/#pypaystack2.sub_clients.async_clients.verification.AsyncVerificationClient.resolve_account_number","title":"<code>resolve_account_number(account_number, bank_code, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Confirm an account belongs to the right customer</p> Note <p>Feature Availability     This feature is only available to businesses in Nigeria.</p> <p>Parameters:</p> Name Type Description Default <code>account_number</code> <code>str</code> <p>Account Number</p> required <code>bank_code</code> <code>str</code> <p>You can get the list of bank codes by calling <code>PaystackClient.miscellaneous.get_banks</code> method.</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[BankAccountInfo] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/verification.py</code> <pre><code>async def resolve_account_number(\n    self,\n    account_number: str,\n    bank_code: str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[BankAccountInfo] | Response[PaystackDataModel]:\n    \"\"\"Confirm an account belongs to the right customer\n\n    Note:\n        Feature Availability\n            This feature is only available to businesses in Nigeria.\n\n    Args:\n        account_number: Account Number\n        bank_code: You can get the list of bank codes by calling\n            `PaystackClient.miscellaneous.get_banks` method.\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n    url = self._full_url(\n        f\"/bank/resolve?account_number={account_number}&amp;bank_code={bank_code}\"\n    )\n    return await self._handle_request(\n        HTTPMethod.GET,\n        url,  # type: ignore\n        response_data_model_class=alternate_model_class or BankAccountInfo,\n    )\n</code></pre>"},{"location":"reference/verification/#pypaystack2.sub_clients.async_clients.verification.AsyncVerificationClient.resolve_card_bin","title":"<code>resolve_card_bin(bin_, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Get more information about a customer's card</p> <p>Parameters:</p> Name Type Description Default <code>bin_</code> <code>str</code> <p>First 6 characters of card</p> required <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[CardBin] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/verification.py</code> <pre><code>async def resolve_card_bin(\n    self,\n    bin_: str,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[CardBin] | Response[PaystackDataModel]:\n    \"\"\"Get more information about a customer's card\n\n    Args:\n        bin_: First 6 characters of card\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    url = self._full_url(f\"/decision/bin/{bin_}\")\n    return await self._handle_request(\n        HTTPMethod.GET,\n        url,  # type: ignore\n        response_data_model_class=alternate_model_class or CardBin,\n    )\n</code></pre>"},{"location":"reference/verification/#pypaystack2.sub_clients.async_clients.verification.AsyncVerificationClient.validate_account","title":"<code>validate_account(account_name, account_number, account_type, bank_code, country_code, document_type, document_number=None, alternate_model_class=None)</code>  <code>async</code>","text":"<p>Confirm the authenticity of a customer's account number before sending money</p> <p>Parameters:</p> Name Type Description Default <code>account_name</code> <code>str</code> <p>Customer's first and last name registered with their bank</p> required <code>account_number</code> <code>str</code> <p>Customer's account number</p> required <code>account_type</code> <code>AccountType</code> <p>bank_code: The bank code of the customer\u2019s bank. You can fetch the bank codes by using <code>PaystackClient.miscellaneous.get_banks</code> method.</p> required <code>bank_code</code> <code>str</code> <p>The bank code of the customer\u2019s bank</p> required <code>country_code</code> <code>Country</code> <p>Any value from the <code>Country</code> enum</p> required <code>document_type</code> <code>Document</code> <p>Customer\u2019s mode of identity. any value from the <code>Document</code> enum.</p> required <code>document_number</code> <code>str | None</code> <p>Customer\u2019s mode of identity number</p> <code>None</code> <code>alternate_model_class</code> <code>type[PaystackDataModel] | None</code> <p>A pydantic model class to use instead of the default pydantic model used by the library to present the data in the <code>Response.data</code>. The default behaviour of the library is to set  <code>Response.data</code> to <code>None</code> if it fails to serialize the data returned from paystack with the model provided in the library. Providing a pydantic model class via this parameter overrides the library default model with the model class you provide. This can come in handy when the models in the library do not accurately represent the data returned, and you prefer working with the data as a pydantic model instead of as a dict of the response returned by  paystack before it is serialized with pydantic models, The original data can be accessed via <code>Response.raw</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[AccountVerificationInfo] | Response[PaystackDataModel]</code> <p>A pydantic model containing the response gotten from paystack's server.</p> Source code in <code>src/pypaystack2/sub_clients/async_clients/verification.py</code> <pre><code>async def validate_account(\n    self,\n    account_name: str,\n    account_number: str,\n    account_type: AccountType,\n    bank_code: str,\n    country_code: Country,\n    document_type: Document,\n    document_number: str | None = None,\n    alternate_model_class: type[PaystackDataModel] | None = None,\n) -&gt; Response[AccountVerificationInfo] | Response[PaystackDataModel]:\n    \"\"\"Confirm the authenticity of a customer's account number before sending money\n\n    Args:\n        account_name: Customer's first and last name registered with their bank\n        account_number: Customer's account number\n        account_type: bank_code: The bank code of the customer\u2019s bank. You can fetch the bank codes by\n            using `PaystackClient.miscellaneous.get_banks` method.\n        bank_code: The bank code of the customer\u2019s bank\n        country_code: Any value from the ``Country`` enum\n        document_type: Customer\u2019s mode of identity. any value from the\n            ``Document`` enum.\n        document_number: Customer\u2019s mode of identity number\n        alternate_model_class: A pydantic model class to use instead of the\n            default pydantic model used by the library to present the data in\n            the `Response.data`. The default behaviour of the library is to\n            set  `Response.data` to `None` if it fails to serialize the data\n            returned from paystack with the model provided in the library.\n            Providing a pydantic model class via this parameter overrides\n            the library default model with the model class you provide.\n            This can come in handy when the models in the library do not\n            accurately represent the data returned, and you prefer working with the\n            data as a pydantic model instead of as a dict of the response returned\n            by  paystack before it is serialized with pydantic models, The original\n            data can be accessed via `Response.raw`.\n\n    Returns:\n        A pydantic model containing the response gotten from paystack's server.\n    \"\"\"\n\n    payload = {\n        \"account_name\": account_name,\n        \"account_number\": account_number,\n        \"account_type\": account_type,\n        \"bank_code\": bank_code,\n        \"country_code\": country_code,\n        \"document_type\": document_type,\n        \"document_number\": document_number,\n    }\n    url = self._full_url(\"/bank/validate\")\n\n    return await self._handle_request(\n        HTTPMethod.POST,\n        url,\n        payload,  # type: ignore\n        response_data_model_class=alternate_model_class or AccountVerificationInfo,\n    )\n</code></pre>"},{"location":"tutorials/tutorial-00/","title":"Paystack Command line Client","text":""},{"location":"tutorials/tutorial-00/#paystack-command-line-client","title":"Paystack Command line Client","text":"<p>This tutorial aims to expose you to how to use <code>pypaystack2</code> in your python projects for paystack integrations. We'll be building a simple command line application that integrates with paystack's services.</p>"},{"location":"tutorials/tutorial-00/#project-setup","title":"Project Setup","text":"<p>We'll start by setting up our project. We'll be using uv for managing this project's dependencies and environment. you're free to use your preferred choice like <code>virtualenv</code>, <code>hatch</code> or <code>poetry</code>. if you don't have <code>uv</code> installed yet, you can install it with the installation script in its documentation here or with <code>pip install uv</code>. Preferably you use the installation script, but if you use pip to install it, it's important to note that <code>uv</code> should be installed globally and not within a virtual environment. You're good to proceed if this prerequisite is met.</p> <ul> <li>Initialize our project with uv.</li> </ul> <pre><code>uv init paystack-cli-client &amp;&amp; cd paystack-cli-client\n</code></pre> <p>Your directory structure should look similar to this</p> <pre><code>paystack-cli-client\n\u251c\u2500\u2500 main.py\n\u251c\u2500\u2500 pyproject.toml\n\u2514\u2500\u2500 README.md\n\n1 directory, 3 files\n</code></pre> <p>This is the default you get from initializing your project with <code>uv</code> as a bin project. The <code>main.py</code> contains a sample code which we won't be needing, an empty <code>README.md</code> file and a <code>pyproject.toml</code> file that contains your project's metadata such as the project's name, version, dependencies e.t.c. Some hidden files and directory are not listed here such as a <code>.git</code> folder as <code>uv</code> initializes an empty git repository in the newly instantiated project. The use of git is not covered in this tutorial, please commit your code as you see fit. There is also a <code>.python-version</code> file which is used by <code>uv</code> to determine the python to use for initializing the virtual environment. A <code>.venv</code> directory will eventually be added when a virtual environment is created by <code>uv</code> as a result of installing the projects dependency or running <code>uv sync</code></p> <ul> <li>Install the projects dependencies. We'll be needing <code>pypaystack2</code>, <code>python-dotenv</code>, and <code>typer</code>.   <code>pypaystack2</code> is our client library for integrating with paystack. <code>python-dotenv</code> helps us manage our   environmental variables and typer makes building command line apps in python super   simple.</li> </ul> <pre><code>uv add pypaystack2 python-dotenv typer\n</code></pre> <ul> <li>Activate your virtual environment accordingly (for mac and linux <code>source .venv/bin/activate</code>)</li> </ul> <p>If all work's fine, you're good to proceed.</p>"},{"location":"tutorials/tutorial-00/#environmental-variables","title":"Environmental Variables","text":"<p><code>pypaystack2</code> depends on your paystack secret key that you get from signing up to paystack. Paystack provides you with two pairs. A pair of public and secret keys for live mode and another set for test mode. You can find them in your account settings. Since this is just a tutorial, we'll be using only the test secret key. Create a new file named <code>.env</code> within your project's root directory. Now put in your test secret key in the <code>.env</code> file like so.</p> <pre><code>PAYSTACK_SECRET_KEY = \"YOUR_PAYSTACK_SECRET_KEY\"\n</code></pre> <p>Warning</p> <p>Because this is just a tutorial, no extra measure is made to protect this environmental. In a more serious project or production code, extra care should be taken to protect it and also avoid pushing it to a remote source control like GitHub.</p>"},{"location":"tutorials/tutorial-00/#let-the-games-begin","title":"Let the games begin","text":"<p>It's time to start building! replace the boilerplate code in the <code>main.py</code> file in your root directory with the snippet below</p> <pre><code># paystack-cli-client/main.py\nfrom dotenv import load_dotenv\n\nload_dotenv()\n</code></pre> <p>What we have just done is loaded our secret test key within the <code>.env</code> file. You may be wondering why do we need that, here's why <code>pypaystack2</code> needs this key to authorize its communication with paystack's REST API. It is the bearer token used in the requests. You can pass your secret key directly into the clients i.e. <code>PaystackClient</code> or <code>AsyncPaystackClient</code>. Passing your secret key directly to the clients, overrides the secret key set in the environmental variables if any.</p> <p>Note</p> <p>You don't have to provide your secret key on the instantiation of any of the clients as long as you have it set in your environmental variables like this tutorial does.</p>"},{"location":"tutorials/tutorial-00/#on-your-marks","title":"On your marks!","text":"<p>The first feature we'll be implementing for our Paystack Command line Client is the ability to create new customers on our paystack integration. so now update your <code>main.py</code> file with the code below.</p> <pre><code># paystack-cli-client/main.py\nfrom dotenv import load_dotenv\nfrom typer import Typer\n\nload_dotenv()\n\napp = Typer()\n\n\n@app.command()\ndef new_customer():\n    print(\"new customer successfully created!\")\n\n\nif __name__ == \"__main__\":\n    app()\n</code></pre> <p>This is a minimum setup to building cli apps with <code>Typer</code>. Now try this in your project's root directory.</p> <pre><code>python main.py --help\n</code></pre> <p>You should see.</p> <pre><code>$ python  main.py --help\n\n Usage: main.py [OPTIONS]\n\n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --install-completion          Install completion for the current shell.                     \u2502\n\u2502 --show-completion             Show completion for the current shell, to copy it or          \u2502\n\u2502                               customize the installation.                                   \u2502\n\u2502 --help                        Show this message and exit.                                   \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>You can see that we now have a command line app that's responding to our command in this case <code>--help</code>. Let's try out the custom command we just added.</p> <pre><code>python main.py\n</code></pre> <p>You should see</p> <pre><code>new customer successfully created!\n</code></pre> <p>At the moment, no new customer is actually getting created on your paystack integration. let's bring in <code>pypaystack2</code> to help us get the job done. For this to work, <code>pypaystack2</code> provides clients which serves as an abstraction over the REST APIs provided by Paystack. The two main clients you'll ever need are <code>PaystackClient</code> and <code>AsyncPaystackClient</code>. These two clients are mirror of each other but the <code>AsyncPaystackClient</code> is useful in asynchronous contexts such as asynchronous FastAPI endpoints. These two main clients are just binding to other specialized clients called sub clients. For example <code>PaystackClient.customers</code> is just a binding to an instance of <code>CustomerClient</code> which is a sub client with methods for interacting with only paystack's customers API. As a result, <code>CustomerClient</code> may be used directly by importing it from <code>pypaystack2.sub_clients</code> but this is discouraged, just use <code>PaystackClient</code> or <code>AsyncPaystackClient</code> as your needs require. The sub clients are named to closely match the API they abstract and methods on these clients correspond to endpoints on the Paystack services you're interested in so in this case, for us to create a customer on our integration, we need to use the <code>CustomerClient</code> sub client which connects to Paystack's Customer Services API. This is available on the <code>PaystackClient</code> via the <code>customers</code> binding. More info of Paystack's Customer Services API. See also CustomerClient</p> <pre><code># paystack-cli-client/main.py\nfrom dotenv import load_dotenv\nfrom pypaystack2 import PaystackClient\nfrom typer import Typer\n\nload_dotenv()\n\napp = Typer()\nclient = PaystackClient()\n\n\n@app.command()\ndef new_customer(\n        email: str,\n        first_name: str | None = None,\n        last_name: str | None = None,\n        phone: str | None = None,\n):\n    print(\"Connecting to paystack...\\n\")\n    response = client.customers.create(\n        email=email, first_name=first_name, last_name=last_name, phone=phone\n    )\n    print(repr(response))\n    print(\"\\nNew customer successfully created!\")\n\n\nif __name__ == \"__main__\":\n    app()\n</code></pre> <p>Note</p> <p>All API wrappers are available on <code>pypaystack</code>. as attributes e.g. <code>paystack.transactions</code> for the Transactions API</p> <p>Now if you run the script again.</p> <pre><code>python main.py\n</code></pre> <p>You get error saying you have a missing argument 'EMAIL'</p> <pre><code>$ python main.py\nUsage: main.py [OPTIONS] EMAIL\nTry 'main.py --help' for help.\n\u256d\u2500 Error \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 Missing argument 'EMAIL'.                                                                   \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>Now let's try out our script with the email of the customer we want to create.</p> <pre><code>python main.py johndoe@example.com\n</code></pre> <p>Now if all goes fine. \"An Internet connection is required\", you should get something similar to this</p> <pre><code>$ python main.py johndoe@example.com\nConnecting to paystack...\n\nResponse(status_code=&lt;HTTPStatus.OK: 200&gt;, status=True, message='Customer created', data=Customer(integration=630606, id=87934333, first_name='john', last_name='doe', email='johndoe@example.com', customer_code='CUS_8x2byd6x3dk5hp0', phone=None, metadata=None, risk_action=&lt;RiskAction.DEFAULT: 'default'&gt;, international_phone_format=None, identified=False, identifications=None, transactions=[], subscriptions=[], authorizations=[], created_at=datetime.datetime(2022, 7, 25, 3, 46, 1, tzinfo=TzInfo(UTC)), updated_at=datetime.datetime(2022, 7, 25, 3, 46, 1, tzinfo=TzInfo(UTC)), total_transactions=None, total_transaction_value=None, dedicated_account=None, dedicated_accounts=None), meta=None, type=None, code=None, raw={'status': True, 'message': 'Customer created', 'data': {'transactions': [], 'subscriptions': [], 'authorizations': [], 'first_name': 'john', 'last_name': 'doe', 'email': 'johndoe@example.com', 'phone': None, 'metadata': None, 'domain': 'test', 'customer_code': 'CUS_8x2byd6x3dk5hp0', 'risk_action': 'default', 'id': 87934333, 'integration': 630606, 'createdAt': '2022-07-25T03:46:01.000Z', 'updatedAt': '2022-07-25T03:46:01.000Z', 'identified': False, 'identifications': None}})\n\nNew customer successfully created!\n</code></pre> <p>Yay! You've just created a new customer on your integration You can check out the customer's tab in your Paystack account dashboard to confirm this.</p> <p>Tip</p> <p>You can also create new customers with a first name and last name like so.</p> <pre><code>python main.py johndoe@example.com --first-name John --last-name Doe\n</code></pre>"},{"location":"tutorials/tutorial-00/#what-just-happened","title":"What just happened?","text":"<p>You have just created a new customer on your integration with the CLI app you just built. But how? If you've followed this tutorial to this point, you already know what clients are, or you can quickly skim through the previous sections to get a refresher. The right question should be what is the <code>create</code> method on the <code>CustomerClient</code> sub client provided as a binding on <code>PaystackClient</code> as <code>customers</code> for. You guess right if what's on your mind is that it creates a new customer on your integration. So as it was said earlier, all sub clients provided as bindings on the <code>PaystackClient</code>and <code>AsycPaystackClient</code> main clients have methods on them that correspond to an endpoint on paystack and all of these methods will return a <code>Response</code> object based on the response it gets from Paystack. This <code>Response</code> is a pydantic model that has <code>status</code>,<code>status_code</code>,<code>message</code>, <code>data</code>, e.t.c see more. The signature of the return type on the methods determine the content of <code>Response.data</code>. E.g. <code>Response[Customer]</code> implies that <code>Response.data</code> contains a single <code>Customer</code> instance, a pydantic model representing paystack's customer resource, <code>Response[list[Customer]]</code> implies <code>Response.data</code> contains a list of instances of <code>Customer</code> and <code>Response[None]</code> implies <code>Response.data</code> is <code>None</code></p> <p>Note</p> <p><code>Response.data</code> may still be <code>None</code> even when there's a concrete signature like <code>Response[Customer]</code> This only happens when pypaystack2 is unable to serialize the data in the response returned by paystack with the pydantic model in the signature. You'll get a warning in the logs about this issue and how to resolve it even though the serialization fails silently, As long as it is guaranteed that the model can serialize the response data, the type of <code>Response.data</code> is guaranteed to be an instance of that model. You may need to explicitly pass an alterate model class to the methods to overrided the model provided by pypaystack2 when you get this warning.</p> <p>Hovering over <code>response</code> in your IDE or code editor may show the type of response as <code>Response[Customer] | Response</code> which can be misleading, what is the extra  <code>| Response</code> about.</p> <p></p> <p>If you hover on the create method, you get a method signature similar to this</p> <p></p> <p>The signature says <code>client.customers.create</code> returns <code>Response[Customer] | Response[PaystackDataModel]</code> and there is also an additional optional <code>alternate_model_class</code> parameter in the methods parameter. What the signature is trying to say is that <code>client.customers.create</code> will return <code>Response[Customer]</code> but if you provide an  <code>alterate_model_class</code>, <code>client.customers.create</code> will return <code>Response[PaystackDataModel]</code> <code>PaystactDataModel</code> is just a generic that serves a placeholder for any pydantic model that represents a data returned by paystack. i.e. if I implement a custom customer model like so</p> <p></p><pre><code>from pydantic import BaseModel\nfrom pypaystack2 import PaystackClient\nfrom pypaystac2.models import Customer\n\nclass MyCustomCustomer(BaseModel):\n  ... # All attributes are skipped for simplicity\n\nclass MyImprovedCustomer(Customer):\n  ... # Overrides of incorrect attributes or addition of new attributes\n\nclient = PaystackClient()\nresponse = client.customers.create(email=\"johndoe@example.com\", alterate_model_class=MyCustomCusomer)\n# or\nresponse = client.customers.create(email=\"johndoe@example.com\", alterate_model_class=MyImprovedCustomer)\n</code></pre> It means that <code>response</code> in  the first case is of type <code>Response[MyCustomCustomer]</code> and it is <code>Responnse[MyImprovedCustomer]</code> in the second case and <code>Response.data</code> is guaranteed  to be an instance of <code>MyCustomCustomer</code> and  <code>MyImprovedCustomer</code> respectively provided that the two models that serialize the data retured by paystack else <code>Response.data</code> is None and you get a warning of the failed serialization and  how to  fix it at a log level of WARNING. the raw json data returned from paystack that has been serialized to native python types is available in <code>Response.raw</code><p></p> <pre><code>response = client.customers.create(email=email, first_name=first_name, last_name=last_name, phone=phone)\n</code></pre> <p>You can access the attributes of the <code>Response</code> model instance like <code>response.status</code>, <code>response.status_code</code>, <code>response.message</code>, <code>response.data</code> and more</p>"},{"location":"tutorials/tutorial-00/#more-commands","title":"More Commands!","text":"<p>Let's add a few more commands to our Paystack Command line Client</p> <pre><code># root-dir/main.py\nfrom dotenv import load_dotenv\nfrom pypaystack2 import PaystackClient\nfrom typer import Typer\n\nload_dotenv()\n\napp = Typer()\nclient = PaystackClient()\n\n\n@app.command()\ndef new_customer(\n        email: str,\n        first_name: str | None = None,\n        last_name: str | None = None,\n        phone: str | None = None,\n):\n    response = client.customers.create(\n        email=email, first_name=first_name, last_name=last_name, phone=phone\n    )\n    print(\"Connecting to paystack...\\n\")\n    print(repr(response))\n    print(\"\\nNew customer successfully created!\")\n\n\n@app.command()\ndef list_customers(count: int = 2):\n    response = client.customers.get_customers(pagination=count)\n    print(\"Connecting to paystack...\\n\")\n    print(repr(response))\n    print(\"\\nCustomers retrieved!\")\n\n\n@app.command()\ndef get_customer(ec: str):\n    response = client.customers.get_customer(email_or_code=ec)\n    print(\"Connecting to paystack...\\n\")\n    print(repr(response))\n    print(\"\\nCustomer retrieved!\")\n\n\n@app.command()\ndef update_customer(code: str, last_name: str, first_name: str):\n    response = client.customers.update(\n        code=code, last_name=last_name, first_name=first_name\n    )\n    print(\"Connecting to paystack...\\n\")\n    print(repr(response))\n    print(\"\\nCustomer updated!\")\n\n\nif __name__ == \"__main__\":\n    app()\n</code></pre> <p>We now have 3 new commands for our cli app. you can check them out with</p> <pre><code>python main.py --help\n</code></pre> <p>Now under the available command you should see <code>get-customer</code>, <code>list-customers</code>, <code>new-customer</code>, update-customer</p> <pre><code>$ python  main.py --help\n\n Usage: main.py [OPTIONS] COMMAND [ARGS]...\n\n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --install-completion          Install completion for the current shell.                     \u2502\n\u2502 --show-completion             Show completion for the current shell, to copy it or          \u2502\n\u2502                               customize the installation.                                   \u2502\n\u2502 --help                        Show this message and exit.                                   \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 Commands \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 new-customer                                                                                \u2502\n\u2502 list-customers                                                                              \u2502\n\u2502 get-customer                                                                                \u2502\n\u2502 update-customer                                                                             \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>You can try out the new command with the following commands</p> <pre><code>$ python main.py list-customers\n</code></pre> <pre><code>$ python main.py get-customer johndoe@example.com\n</code></pre> <p>Wow, that's amazing! We can make it better. With it be better if the cli return json data instead of dumping python types to the console? Sure! We can leverage pydantic for that because every model in <code>pypaystack2</code> is a pydantic model</p> <pre><code># Replace all\n-- print(\"Connecting to paystack...\")\n-- print(repr(response))\n-- print(\"THE_SUCCESS_MESSAGE\")\n# with\n++ print(response.model_dump_json())\n</code></pre> <p>Neat! Now we may run the CLI like so to get the result of the request written into a file.</p> <pre><code>$ python main.py get-customer johndoe@example.com &gt; dump.json\n</code></pre> <p>Note</p> <p>There's one more edge case we're not handling in our current CLI implementation. Exceptions! all client methods that make a API call to paystack can raise <code>ValueError</code> and <code>ClientNetworkError</code>. <code>ValueError</code> is raised when there's an issue with the parameter combination passed or there's a missing parameter. This may not require any special handling as it is just an indicator of a misuse of the client methods and no requests are made yet. <code>ClientNetworkError</code> may  require handling as it's an indication of network related issues such as a poor connection or a timeout. for example the snippet below will raise a <code>ClientNetworkError</code> when run without an internet connection. <code>ClientNetworkError</code> is just a wrapper over the underlying <code>httpx</code> exception that  was raised.</p> <pre><code>from pypaystack2 import PaystackClient\nfrom pypaystack2.exceptions import ClientNetworkError\n\ntry:\n  response = client.customers.create(email=\"johndoe@example.com\")\nexcept ClientNetworkError as error:\n  print(f'ClientNetworkError was indeed raised: {error}')\n</code></pre>"},{"location":"tutorials/tutorial-00/#where-to-go-from-here","title":"Where to go from here","text":"<p>It's all in your hands now. We now have a working CLI app, but it does not have all the features to make it a fully fledged Paystack command line client you can implement more commands. This tutorial has served its purpose giving you the confidence to use <code>pypaystack2</code> for your desired integration with Paystack. You can check out the fully built paystack-cli which can be quite useful for developmental purposes. Not sure how something works,check the doc strings, check the API reference, you can always search the documentation too. Good luck on your next project!</p>"}]}
